{"files":[{"patch":"@@ -41,0 +41,78 @@\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  u1 cg_type_flags = INVALID_CGROUPS_GENERIC;\n+  const char* proc_cgroups = \"\/proc\/cgroups\";\n+  const char* proc_self_cgroup = \"\/proc\/self\/cgroup\";\n+  const char* proc_self_mountinfo = \"\/proc\/self\/mountinfo\";\n+\n+  bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &cg_type_flags);\n+\n+  if (!valid_cgroup) {\n+    \/\/ Could not detect cgroup type\n+    return NULL;\n+  }\n+  assert(is_valid_cgroup(&cg_type_flags), \"Expected valid cgroup type\");\n+\n+  if (is_cgroup_v2(&cg_type_flags)) {\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    if(PrintContainerInfo)\n+      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n+    cleanup(cg_infos);\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/*\n+   * Cgroup v1 case:\n+   *\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  assert(is_cgroup_v1(&cg_type_flags), \"Cgroup v1 expected\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  cleanup(cg_infos);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,\n+                                            const char* proc_cgroups,\n+                                            const char* proc_self_cgroup,\n+                                            const char* proc_self_mountinfo,\n+                                            u1* flags) {\n@@ -45,2 +123,0 @@\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n@@ -53,6 +129,0 @@\n-  CgroupInfo cg_infos[CG_INFO_LENGTH];\n-  int cpuset_idx  = 0;\n-  int cpu_idx     = 1;\n-  int cpuacct_idx = 2;\n-  int memory_idx  = 3;\n-\n@@ -62,2 +132,4 @@\n-   * For cgroups v1 unified hierarchy, cpu, cpuacct, cpuset, memory controllers\n-   * must have non-zero for the hierarchy ID field.\n+   * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field and relevant controllers mounted.\n+   * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory\n+   * controllers must have hierarchy ID 0 and the unified controller mounted.\n@@ -65,1 +137,1 @@\n-  cgroups = fopen(\"\/proc\/cgroups\", \"r\");\n+  cgroups = fopen(proc_cgroups, \"r\");\n@@ -68,2 +140,2 @@\n-        tty->print_cr(\"Can't open \/proc\/cgroups, %s\",\n-                                 strerror(errno));\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_cgroups, strerror(errno));\n@@ -71,1 +143,2 @@\n-      return NULL;\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n@@ -84,3 +157,3 @@\n-      cg_infos[memory_idx]._name = os::strdup(name);\n-      cg_infos[memory_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[memory_idx]._enabled = (enabled == 1);\n+      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n+      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n@@ -88,3 +161,3 @@\n-      cg_infos[cpuset_idx]._name = os::strdup(name);\n-      cg_infos[cpuset_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpuset_idx]._enabled = (enabled == 1);\n+      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n+      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n@@ -92,3 +165,3 @@\n-      cg_infos[cpu_idx]._name = os::strdup(name);\n-      cg_infos[cpu_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpu_idx]._enabled = (enabled == 1);\n+      cg_infos[CPU_IDX]._name = os::strdup(name);\n+      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n@@ -96,3 +169,3 @@\n-      cg_infos[cpuacct_idx]._name = os::strdup(name);\n-      cg_infos[cpuacct_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpuacct_idx]._enabled = (enabled == 1);\n+      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n+      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n@@ -115,1 +188,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -124,1 +199,1 @@\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n+  cgroup = fopen(proc_self_cgroup, \"r\");\n@@ -127,2 +202,2 @@\n-      tty->print_cr(\"Can't open \/proc\/self\/cgroup, %s\",\n-                               strerror(errno));\n+      tty->print_cr(\"Can't open %s, %s\",\n+                    proc_self_cgroup, strerror(errno));\n@@ -130,1 +205,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -152,2 +229,2 @@\n-        assert(hierarchy_id == cg_infos[memory_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[memory_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -155,2 +232,2 @@\n-        assert(hierarchy_id == cg_infos[cpuset_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpuset_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -158,2 +235,2 @@\n-        assert(hierarchy_id == cg_infos[cpu_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpu_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -161,2 +238,2 @@\n-        assert(hierarchy_id == cg_infos[cpuacct_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpuacct_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -173,7 +250,36 @@\n-  if (is_cgroupsV2) {\n-    \/\/ Find the cgroup2 mount point by reading \/proc\/self\/mountinfo\n-    mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-    if (mntinfo == NULL) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                                   strerror(errno));\n+  \/\/ Find various mount points by reading \/proc\/self\/mountinfo\n+  \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+  mntinfo = fopen(proc_self_mountinfo, \"r\");\n+  if (mntinfo == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_self_mountinfo, strerror(errno));\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  bool cgroupv2_mount_point_found = false;\n+  bool any_cgroup_mounts_found = false;\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmp_mount_point[MAXPATHLEN+1];\n+    char tmp_fs_type[MAXPATHLEN+1];\n+    char tmproot[MAXPATHLEN+1];\n+    char tmpmount[MAXPATHLEN+1];\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+    \/\/ block in the hybrid case.\n+    \/\/\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+      \/\/ we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype\n+      if (!cgroupv2_mount_point_found && strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+        cgroupv2_mount_point_found = true;\n+        any_cgroup_mounts_found = true;\n+        for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+          assert(cg_infos[i]._mount_path == NULL, \"_mount_path memory stomping\");\n+          cg_infos[i]._mount_path = os::strdup(tmp_mount_point);\n@@ -181,1 +287,1 @@\n-        return NULL;\n+      }\n@@ -184,13 +290,37 @@\n-    char cgroupv2_mount[MAXPATHLEN+1];\n-    char fstype[MAXPATHLEN+1];\n-    bool mount_point_found = false;\n-    while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-      char *tmp_mount_point = cgroupv2_mount;\n-      char *tmp_fs_type = fstype;\n-\n-      \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-      if (sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n-        \/\/ we likely have an early match return, be sure we have cgroup2 as fstype\n-        if (strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n-          mount_point_found = true;\n-          break;\n+    \/* Cgroup v1 relevant info\n+     *\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     *\n+     * Example for docker:\n+     * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+     *\n+     * Example for host:\n+     * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+     *\/\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s cgroup %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+      if (strcmp(\"cgroup\", tmp_fs_type) != 0) {\n+        \/\/ Skip cgroup2 fs lines on hybrid or unified hierarchy.\n+        continue;\n+      }\n+      any_cgroup_mounts_found = true;\n+      while ((token = strsep(&cptr, \",\")) != NULL) {\n+        if (strcmp(token, \"memory\") == 0) {\n+          assert(cg_infos[MEMORY_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[MEMORY_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuset\") == 0) {\n+          assert(cg_infos[CPUSET_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUSET_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpu\") == 0) {\n+          assert(cg_infos[CPU_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPU_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuacct\") == 0) {\n+          assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUACCT_IDX]._data_complete = true;\n@@ -200,2 +330,16 @@\n-    fclose(mntinfo);\n-    if (!mount_point_found) {\n+  }\n+  fclose(mntinfo);\n+\n+  \/\/ Neither cgroup2 nor cgroup filesystems mounted via \/proc\/self\/mountinfo\n+  \/\/ No point in continuing.\n+  if (!any_cgroup_mounts_found) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"No cgroup controllers mounted.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_NO_MOUNT;\n+    return false;\n+  }\n+\n+  if (is_cgroupsV2) {\n+    if (!cgroupv2_mount_point_found) {\n@@ -205,1 +349,3 @@\n-      return NULL;\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_V2;\n+      return false;\n@@ -208,12 +354,2 @@\n-    \/\/ Construct the subsystem, free resources and return\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cgroupv2_mount, cg_infos[memory_idx]._cgroup_path);\n-    for (int i = 0; i < CG_INFO_LENGTH; i++) {\n-      os::free(cg_infos[i]._name);\n-      os::free(cg_infos[i]._cgroup_path);\n-    }\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n-    }\n-    return new CgroupV2Subsystem(unified);\n+    *flags = CGROUPS_V2;\n+    return true;\n@@ -227,44 +363,1 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      if (PrintContainerInfo) {\n-        tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                                 strerror(errno));\n-      }\n-      return NULL;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupV1MemoryController(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupV1Controller(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupV1Controller(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupV1Controller(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n+  if (!cg_infos[MEMORY_IDX]._data_complete) {\n@@ -274,1 +367,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -276,1 +371,1 @@\n-  if (cpuset == NULL) {\n+  if (!cg_infos[CPUSET_IDX]._data_complete) {\n@@ -280,1 +375,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -282,1 +379,1 @@\n-  if (cpu == NULL) {\n+  if (!cg_infos[CPU_IDX]._data_complete) {\n@@ -286,1 +383,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -288,1 +387,1 @@\n-  if (cpuacct == NULL) {\n+  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n@@ -292,1 +391,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -294,0 +395,3 @@\n+  \/\/ Cgroups v1 case, we have all the info we need.\n+  *flags = CGROUPS_V1;\n+  return true;\n@@ -295,24 +399,4 @@\n-  \/*\n-   * Use info gathered previously from \/proc\/self\/cgroup\n-   * and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n+};\n+\n+void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n+  assert(cg_infos != NULL, \"Invariant\");\n@@ -320,10 +404,4 @@\n-    CgroupInfo info = cg_infos[i];\n-    if (strcmp(info._name, \"memory\") == 0) {\n-      memory->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuset\") == 0) {\n-      cpuset->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpu\") == 0) {\n-      cpu->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-      cpuacct->set_subsystem_path(info._cgroup_path);\n-    }\n+    os::free(cg_infos[i]._name);\n+    os::free(cg_infos[i]._cgroup_path);\n+    os::free(cg_infos[i]._root_mount_path);\n+    os::free(cg_infos[i]._mount_path);\n@@ -331,1 +409,0 @@\n-  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.cpp","additions":238,"deletions":161,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -56,0 +56,14 @@\n+#define CGROUPS_V1               1\n+#define CGROUPS_V2               2\n+#define INVALID_CGROUPS_V2       3\n+#define INVALID_CGROUPS_V1       4\n+#define INVALID_CGROUPS_NO_MOUNT 5\n+#define INVALID_CGROUPS_GENERIC  6\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+#define CPUSET_IDX     0\n+#define CPU_IDX        1\n+#define CPUACCT_IDX    2\n+#define MEMORY_IDX     3\n+\n@@ -202,2 +216,0 @@\n-\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n-#define CG_INFO_LENGTH 4\n@@ -264,7 +276,3 @@\n-class CgroupSubsystemFactory: AllStatic {\n-  public:\n-    static CgroupSubsystem* create();\n-};\n-\n-\/\/ Class representing info in \/proc\/self\/cgroup.\n-\/\/ See man 7 cgroups\n+\/\/ Utility class for storing info retrieved from \/proc\/cgroups,\n+\/\/ \/proc\/self\/cgroup and \/proc\/self\/mountinfo\n+\/\/ For reference see man 7 cgroups and CgroupSubsystemFactory\n@@ -273,0 +281,1 @@\n+  friend class WhiteBox;\n@@ -275,4 +284,18 @@\n-  char* _name;\n-  int _hierarchy_id;\n-  bool _enabled;\n-  char* _cgroup_path;\n+    char* _name;\n+    int _hierarchy_id;\n+    bool _enabled;\n+    bool _data_complete;    \/\/ indicating cgroup v1 data is complete for this controller\n+    char* _cgroup_path;     \/\/ cgroup controller path from \/proc\/self\/cgroup\n+    char* _root_mount_path; \/\/ root mount path from \/proc\/self\/mountinfo. Unused for cgroup v2\n+    char* _mount_path;      \/\/ mount path from \/proc\/self\/mountinfo.\n+\n+  public:\n+    CgroupInfo() {\n+      _name = NULL;\n+      _hierarchy_id = -1;\n+      _enabled = false;\n+      _data_complete = false;\n+      _cgroup_path = NULL;\n+      _root_mount_path = NULL;\n+      _mount_path = NULL;\n+    }\n@@ -282,0 +305,28 @@\n+class CgroupSubsystemFactory: AllStatic {\n+  friend class WhiteBox;\n+\n+  public:\n+    static CgroupSubsystem* create();\n+  private:\n+    static inline bool is_cgroup_v2(u1* flags) {\n+       return *flags == CGROUPS_V2;\n+    }\n+\n+#ifdef ASSERT\n+    static inline bool is_valid_cgroup(u1* flags) {\n+       return *flags == CGROUPS_V1 || *flags == CGROUPS_V2;\n+    }\n+    static inline bool is_cgroup_v1(u1* flags) {\n+       return *flags == CGROUPS_V1;\n+    }\n+#endif\n+\n+    \/\/ Determine the cgroup type (version 1 or version 2), given\n+    \/\/ relevant paths to files. Sets 'flags' accordingly.\n+    static bool determine_type(CgroupInfo* cg_infos,\n+                               const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* flags);\n+    static void cleanup(CgroupInfo* cg_infos);\n+};\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp","additions":64,"deletions":13,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#endif\n+\n@@ -165,1 +170,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -587,0 +591,12 @@\n+#ifdef LINUX\n+bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* cg_flags) {\n+  CgroupInfo cg_infos[4];\n+  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+                                                    proc_self_cgroup,\n+                                                    proc_self_mountinfo, cg_flags);\n+}\n+#endif\n+\n@@ -1205,0 +1221,25 @@\n+WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,\n+                                    jobject o,\n+                                    jstring proc_cgroups,\n+                                    jstring proc_self_cgroup,\n+                                    jstring proc_self_mountinfo))\n+  jint ret = 0;\n+#ifdef LINUX\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  u1 cg_type_flags = 0;\n+  \/\/ This sets cg_type_flags\n+  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  ret = (jint)cg_type_flags;\n+  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);\n+  env->ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);\n+#endif\n+  return ret;\n+WB_END\n+\n@@ -1335,0 +1376,3 @@\n+  {CC\"validateCgroup\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_ValidateCgroup },\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+#ifdef LINUX\n+  static bool validate_cgroup(const char* proc_cgroups, const char* proc_self_cgroup, const char* proc_self_mountinfo, u1* cg_flags);\n+#endif\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CgroupSubsystemFactory\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build CgroupSubsystemFactory\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import com.oracle.java.testlibrary.Asserts;\n+import com.oracle.java.testlibrary.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * Verify hotspot's detection heuristics of CgroupSubsystemFactory::create()\n+ *\/\n+public class CgroupSubsystemFactory {\n+\n+    \/\/ Mirrored from hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp\n+    private static final int CGROUPS_V1 = 1;\n+    private static final int CGROUPS_V2 = 2;\n+    private static final int INVALID_CGROUPS_V2 = 3;\n+    private static final int INVALID_CGROUPS_V1 = 4;\n+    private static final int INVALID_CGROUPS_NO_MOUNT = 5;\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private Path cgroupV1SelfCgroup;\n+    private Path cgroupV2SelfCgroup;\n+    private Path cgroupV2MntInfoMissingCgroupv2;\n+    private Path cgroupv1MntInfoMissingMemoryController;\n+    private String procSelfCgroupHybridContent = \"11:hugetlb:\/\\n\" +\n+            \"10:devices:\/user.slice\\n\" +\n+            \"9:pids:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"8:cpu,cpuacct:\/\\n\" +\n+            \"7:perf_event:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/\\n\" +\n+            \"4:net_cls,net_prio:\/\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:memory:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\\n\" +\n+            \"0::\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\";\n+    private String procSelfCgroupV2UnifiedContent = \"0::\/user.slice\/user-1000.slice\/session-3.scope\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\";\n+    private String mntInfoHybridStub =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;\n+    private String mntInfoHybridMissingMemory = mntInfoHybridStub;\n+    private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;\n+    private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  3   1   1\\n\" +\n+            \"cpu 8   1   1\\n\" +\n+            \"cpuacct 8   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    private void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero_cgroupv2_last\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder.getBytes());\n+\n+            cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_hybrid\");\n+            Files.write(cgroupV1SelfCgroup, procSelfCgroupHybridContent.getBytes());\n+\n+            cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_v2\");\n+            Files.write(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent.getBytes());\n+\n+            cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), \"mnt_info_missing_memory\");\n+            Files.write(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory.getBytes());\n+\n+            cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), \"mnt_info_missing_cgroup2\");\n+            Files.write(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void teardown() {\n+        try {\n+            deleteFileTree(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    private static void deleteFileTree(Path dir) throws IOException {\n+        java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private boolean isValidCgroup(int value) {\n+        return value == CGROUPS_V1 || value == CGROUPS_V2;\n+    }\n+\n+    public void testCgroupv1NoMounts(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"No cgroups mounted in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1NoMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V2, retval, \"No cgroup2 filesystem in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2NoCgroup2Fs PASSED!\");\n+    }\n+\n+    public void testCgroupv1MissingMemoryController(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V1, retval, \"Required memory controller path missing in mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MissingMemoryController PASSED!\");\n+    }\n+\n+    public void testCgroupv2(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"Expected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2 PASSED!\");\n+    }\n+\n+    public void testCgroupV1Hybrid(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1Hybrid PASSED!\");\n+    }\n+\n+    public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1HybridMntInfoOrder PASSED!\");\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        CgroupSubsystemFactory test = new CgroupSubsystemFactory();\n+        test.setup();\n+        try {\n+            test.testCgroupv1NoMounts(wb);\n+            test.testCgroupv2(wb);\n+            test.testCgroupV1Hybrid(wb);\n+            test.testCgroupV1HybridMntInfoOrder(wb);\n+            test.testCgroupv1MissingMemoryController(wb);\n+            test.testCgroupv2NoCgroup2Fs(wb);\n+        } finally {\n+            test.teardown();\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -35,0 +35,4 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n@@ -373,0 +377,21 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n+\n","filename":"hotspot\/test\/testlibrary\/com\/oracle\/java\/testlibrary\/Utils.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -259,0 +259,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"hotspot\/test\/testlibrary\/whitebox\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}