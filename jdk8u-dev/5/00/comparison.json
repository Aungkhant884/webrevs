{"files":[{"patch":"@@ -84,8 +84,0 @@\n-  \/** @return class file object for given Java class.\n-   *\/\n-  public static ClassPath.ClassFile lookupClassFile(String class_name) {\n-    try {\n-      return ClassPath.SYSTEM_CLASS_PATH.getClassFile(class_name);\n-    } catch(IOException e) { return null; }\n-  }\n-\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/bcel\/internal\/Repository.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,383 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-package com.sun.org.apache.bcel.internal.util;\n-\n-\/* ====================================================================\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 2001 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and\/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution,\n- *    if any, must include the following acknowledgment:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http:\/\/www.apache.org\/).\"\n- *    Alternately, this acknowledgment may appear in the software itself,\n- *    if and wherever such third-party acknowledgments normally appear.\n- *\n- * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n- *    \"Apache BCEL\" must not be used to endorse or promote products\n- *    derived from this software without prior written permission. For\n- *    written permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\",\n- *    \"Apache BCEL\", nor may \"Apache\" appear in their name, without\n- *    prior written permission of the Apache Software Foundation.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http:\/\/www.apache.org\/>.\n- *\/\n-\n-import java.util.*;\n-import java.util.zip.*;\n-import java.io.*;\n-\n-\/**\n- * Responsible for loading (class) files from the CLASSPATH. Inspired by\n- * sun.tools.ClassPath.\n- *\n- * @author  <A HREF=\"mailto:markus.dahm@berlin.de\">M. Dahm<\/A>\n- *\/\n-public class ClassPath implements Serializable {\n-  public static final ClassPath SYSTEM_CLASS_PATH = new ClassPath();\n-\n-  private PathEntry[] paths;\n-  private String      class_path;\n-\n-  \/**\n-   * Search for classes in given path.\n-   *\/\n-  public ClassPath(String class_path) {\n-    this.class_path = class_path;\n-\n-    ArrayList vec = new ArrayList();\n-\n-    for(StringTokenizer tok=new StringTokenizer(class_path,\n-                            SecuritySupport.getSystemProperty(\"path.separator\"));\n-        tok.hasMoreTokens();)\n-    {\n-      String path = tok.nextToken();\n-\n-      if(!path.equals(\"\")) {\n-        File file = new File(path);\n-\n-        try {\n-          if(SecuritySupport.getFileExists(file)) {\n-            if(file.isDirectory())\n-              vec.add(new Dir(path));\n-            else\n-              vec.add(new Zip(new ZipFile(file)));\n-          }\n-        } catch(IOException e) {\n-          System.err.println(\"CLASSPATH component \" + file + \": \" + e);\n-        }\n-      }\n-    }\n-\n-    paths = new PathEntry[vec.size()];\n-    vec.toArray(paths);\n-  }\n-\n-  \/**\n-   * Search for classes in CLASSPATH.\n-   * @deprecated Use SYSTEM_CLASS_PATH constant\n-   *\/\n-  public ClassPath() {\n-    \/\/ this(getClassPath());\n-    this(\"\");\n-  }\n-\n-  \/** @return used class path string\n-   *\/\n-  public String toString() {\n-    return class_path;\n-  }\n-\n-  public int hashCode() {\n-    return class_path.hashCode();\n-  }\n-\n-  public boolean equals(Object o) {\n-    if(o instanceof ClassPath) {\n-      return class_path.equals(((ClassPath)o).class_path);\n-    }\n-\n-    return false;\n-  }\n-\n-  private static final void getPathComponents(String path, ArrayList list) {\n-    if(path != null) {\n-      StringTokenizer tok = new StringTokenizer(path, File.pathSeparator);\n-\n-      while(tok.hasMoreTokens()) {\n-        String name = tok.nextToken();\n-        File   file = new File(name);\n-\n-        if(SecuritySupport.getFileExists(file)) {\n-          list.add(name);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/** Checks for class path components in the following properties:\n-   * \"java.class.path\", \"sun.boot.class.path\", \"java.ext.dirs\"\n-   *\n-   * @return class path as used by default by BCEL\n-   *\/\n-  public static final String getClassPath() {\n-\n-    String class_path, boot_path, ext_path;\n-\n-    try {\n-      class_path = SecuritySupport.getSystemProperty(\"java.class.path\");\n-      boot_path  = SecuritySupport.getSystemProperty(\"sun.boot.class.path\");\n-      ext_path   = SecuritySupport.getSystemProperty(\"java.ext.dirs\");\n-    }\n-    catch (SecurityException e) {\n-        return \"\";\n-    }\n-\n-    ArrayList list = new ArrayList();\n-\n-    getPathComponents(class_path, list);\n-    getPathComponents(boot_path, list);\n-\n-    ArrayList dirs = new ArrayList();\n-    getPathComponents(ext_path, dirs);\n-\n-    for(Iterator e = dirs.iterator(); e.hasNext(); ) {\n-      File ext_dir = new File((String)e.next());\n-      String[] extensions = SecuritySupport.getFileList(ext_dir, new FilenameFilter() {\n-        public boolean accept(File dir, String name) {\n-          name = name.toLowerCase();\n-          return name.endsWith(\".zip\") || name.endsWith(\".jar\");\n-        }\n-      });\n-\n-      if(extensions != null)\n-        for(int i=0; i < extensions.length; i++)\n-          list.add(ext_path + File.separatorChar + extensions[i]);\n-    }\n-\n-    StringBuffer buf = new StringBuffer();\n-\n-    for(Iterator e = list.iterator(); e.hasNext(); ) {\n-      buf.append((String)e.next());\n-\n-      if(e.hasNext())\n-        buf.append(File.pathSeparatorChar);\n-    }\n-\n-    return buf.toString().intern();\n-  }\n-\n-  \/**\n-   * @param name fully qualified class name, e.g. java.lang.String\n-   * @return input stream for class\n-   *\/\n-  public InputStream getInputStream(String name) throws IOException {\n-    return getInputStream(name, \".class\");\n-  }\n-\n-  \/**\n-   * Return stream for class or resource on CLASSPATH.\n-   *\n-   * @param name fully qualified file name, e.g. java\/lang\/String\n-   * @param suffix file name ends with suff, e.g. .java\n-   * @return input stream for file on class path\n-   *\/\n-  public InputStream getInputStream(String name, String suffix) throws IOException {\n-    InputStream is = null;\n-\n-    try {\n-      is = getClass().getClassLoader().getResourceAsStream(name + suffix);\n-    } catch(Exception e) { }\n-\n-    if(is != null)\n-      return is;\n-\n-    return getClassFile(name, suffix).getInputStream();\n-  }\n-\n-  \/**\n-   * @param name fully qualified file name, e.g. java\/lang\/String\n-   * @param suffix file name ends with suff, e.g. .java\n-   * @return class file for the java class\n-   *\/\n-  public ClassFile getClassFile(String name, String suffix) throws IOException {\n-    for(int i=0; i < paths.length; i++) {\n-      ClassFile cf;\n-\n-      if((cf = paths[i].getClassFile(name, suffix)) != null)\n-        return cf;\n-    }\n-\n-    throw new IOException(\"Couldn't find: \" + name + suffix);\n-  }\n-\n-  \/**\n-   * @param name fully qualified class name, e.g. java.lang.String\n-   * @return input stream for class\n-   *\/\n-  public ClassFile getClassFile(String name) throws IOException {\n-    return getClassFile(name, \".class\");\n-  }\n-\n-  \/**\n-   * @param name fully qualified file name, e.g. java\/lang\/String\n-   * @param suffix file name ends with suffix, e.g. .java\n-   * @return byte array for file on class path\n-   *\/\n-  public byte[] getBytes(String name, String suffix) throws IOException {\n-    InputStream is = getInputStream(name, suffix);\n-\n-    if(is == null)\n-      throw new IOException(\"Couldn't find: \" + name + suffix);\n-\n-    DataInputStream dis   = new DataInputStream(is);\n-    byte[]          bytes = new byte[is.available()];\n-    dis.readFully(bytes);\n-    dis.close(); is.close();\n-\n-    return bytes;\n-  }\n-\n-  \/**\n-   * @return byte array for class\n-   *\/\n-  public byte[] getBytes(String name) throws IOException {\n-    return getBytes(name, \".class\");\n-  }\n-\n-  \/**\n-   * @param name name of file to search for, e.g. java\/lang\/String.java\n-   * @return full (canonical) path for file\n-   *\/\n-  public String getPath(String name) throws IOException {\n-    int    index  = name.lastIndexOf('.');\n-    String suffix = \"\";\n-\n-    if(index > 0) {\n-      suffix = name.substring(index);\n-      name   = name.substring(0, index);\n-    }\n-\n-    return getPath(name, suffix);\n-  }\n-\n-  \/**\n-   * @param name name of file to search for, e.g. java\/lang\/String\n-   * @param suffix file name suffix, e.g. .java\n-   * @return full (canonical) path for file, if it exists\n-   *\/\n-  public String getPath(String name, String suffix) throws IOException {\n-    return getClassFile(name, suffix).getPath();\n-  }\n-\n-  private static abstract class PathEntry implements Serializable {\n-    abstract ClassFile getClassFile(String name, String suffix) throws IOException;\n-  }\n-\n-  \/** Contains information about file\/ZIP entry of the Java class.\n-   *\/\n-  public interface ClassFile {\n-    \/** @return input stream for class file.\n-     *\/\n-    public abstract InputStream getInputStream() throws IOException;\n-\n-    \/** @return canonical path to class file.\n-     *\/\n-    public abstract String getPath();\n-\n-    \/** @return base path of found class, i.e. class is contained relative\n-     * to that path, which may either denote a directory, or zip file\n-     *\/\n-    public abstract String getBase();\n-\n-    \/** @return modification time of class file.\n-     *\/\n-    public abstract long getTime();\n-\n-    \/** @return size of class file.\n-     *\/\n-    public abstract long getSize();\n-  }\n-\n-  private static class Dir extends PathEntry {\n-    private String dir;\n-\n-    Dir(String d) { dir = d; }\n-\n-    ClassFile getClassFile(String name, String suffix) throws IOException {\n-      final File file = new File(dir + File.separatorChar +\n-                                 name.replace('.', File.separatorChar) + suffix);\n-\n-      return SecuritySupport.getFileExists(file)? new ClassFile() {\n-        public InputStream getInputStream() throws IOException { return new FileInputStream(file); }\n-\n-        public String      getPath()        { try {\n-          return file.getCanonicalPath();\n-        } catch(IOException e) { return null; }\n-\n-        }\n-        public long        getTime()        { return file.lastModified(); }\n-        public long        getSize()        { return file.length(); }\n-        public String getBase() {  return dir;  }\n-\n-      } : null;\n-    }\n-\n-    public String toString() { return dir; }\n-  }\n-\n-  private static class Zip extends PathEntry {\n-    private ZipFile zip;\n-\n-    Zip(ZipFile z) { zip = z; }\n-\n-    ClassFile getClassFile(String name, String suffix) throws IOException {\n-      final ZipEntry entry = zip.getEntry(name.replace('.', '\/') + suffix);\n-\n-      return (entry != null)? new ClassFile() {\n-        public InputStream getInputStream() throws IOException { return zip.getInputStream(entry); }\n-        public String      getPath()        { return entry.toString(); }\n-        public long        getTime()        { return entry.getTime(); }\n-        public long        getSize()       { return entry.getSize(); }\n-        public String getBase() {\n-          return zip.getName();\n-        }\n-      } : null;\n-    }\n-  }\n-}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassPath.java","additions":0,"deletions":383,"binary":false,"changes":383,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Map;\n@@ -53,1 +52,0 @@\n-  private static final String DEFAULT_PATH = ClassPath.getClassPath();\n@@ -57,1 +55,0 @@\n-  private ClassPath _path = null;\n@@ -60,14 +57,1 @@\n-  private SyntheticRepository(ClassPath path) {\n-    _path = path;\n-  }\n-\n-  public static SyntheticRepository getInstance() {\n-    return getInstance(ClassPath.SYSTEM_CLASS_PATH);\n-  }\n-\n-  public static SyntheticRepository getInstance(ClassPath classPath) {\n-    SyntheticRepository rep = (SyntheticRepository)_instances.get(classPath);\n-\n-    if(rep == null) {\n-      rep = new SyntheticRepository(classPath);\n-      _instances.put(classPath, rep);\n+    private SyntheticRepository() {\n@@ -76,1 +60,2 @@\n-    return rep;\n+  public static SyntheticRepository getInstance() {\n+      return new SyntheticRepository();\n@@ -114,4 +99,2 @@\n-    try {\n-      return loadClass(_path.getInputStream(className), className);\n-    } catch(IOException e) {\n-      throw new ClassNotFoundException(\"Exception while looking for class \" +\n+    IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n+    throw new ClassNotFoundException(\"Exception while looking for class \" +\n@@ -119,1 +102,0 @@\n-    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/bcel\/internal\/util\/SyntheticRepository.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"}]}