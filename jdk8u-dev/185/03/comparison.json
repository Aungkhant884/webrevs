{"files":[{"patch":"@@ -41,0 +41,78 @@\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  u1 cg_type_flags = INVALID_CGROUPS_GENERIC;\n+  const char* proc_cgroups = \"\/proc\/cgroups\";\n+  const char* proc_self_cgroup = \"\/proc\/self\/cgroup\";\n+  const char* proc_self_mountinfo = \"\/proc\/self\/mountinfo\";\n+\n+  bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &cg_type_flags);\n+\n+  if (!valid_cgroup) {\n+    \/\/ Could not detect cgroup type\n+    return NULL;\n+  }\n+  assert(is_valid_cgroup(&cg_type_flags), \"Expected valid cgroup type\");\n+\n+  if (is_cgroup_v2(&cg_type_flags)) {\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    if(PrintContainerInfo)\n+      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n+    cleanup(cg_infos);\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/*\n+   * Cgroup v1 case:\n+   *\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  assert(is_cgroup_v1(&cg_type_flags), \"Cgroup v1 expected\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  cleanup(cg_infos);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,\n+                                            const char* proc_cgroups,\n+                                            const char* proc_self_cgroup,\n+                                            const char* proc_self_mountinfo,\n+                                            u1* flags) {\n@@ -45,2 +123,0 @@\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n@@ -53,6 +129,0 @@\n-  CgroupInfo cg_infos[CG_INFO_LENGTH];\n-  int cpuset_idx  = 0;\n-  int cpu_idx     = 1;\n-  int cpuacct_idx = 2;\n-  int memory_idx  = 3;\n-\n@@ -62,2 +132,4 @@\n-   * For cgroups v1 unified hierarchy, cpu, cpuacct, cpuset, memory controllers\n-   * must have non-zero for the hierarchy ID field.\n+   * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field and relevant controllers mounted.\n+   * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory\n+   * controllers must have hierarchy ID 0 and the unified controller mounted.\n@@ -65,1 +137,1 @@\n-  cgroups = fopen(\"\/proc\/cgroups\", \"r\");\n+  cgroups = fopen(proc_cgroups, \"r\");\n@@ -68,2 +140,2 @@\n-        tty->print_cr(\"Can't open \/proc\/cgroups, %s\",\n-                                 strerror(errno));\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_cgroups, strerror(errno));\n@@ -71,1 +143,2 @@\n-      return NULL;\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n@@ -84,3 +157,3 @@\n-      cg_infos[memory_idx]._name = os::strdup(name);\n-      cg_infos[memory_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[memory_idx]._enabled = (enabled == 1);\n+      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n+      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n@@ -88,3 +161,3 @@\n-      cg_infos[cpuset_idx]._name = os::strdup(name);\n-      cg_infos[cpuset_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpuset_idx]._enabled = (enabled == 1);\n+      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n+      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n@@ -92,3 +165,3 @@\n-      cg_infos[cpu_idx]._name = os::strdup(name);\n-      cg_infos[cpu_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpu_idx]._enabled = (enabled == 1);\n+      cg_infos[CPU_IDX]._name = os::strdup(name);\n+      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n@@ -96,3 +169,3 @@\n-      cg_infos[cpuacct_idx]._name = os::strdup(name);\n-      cg_infos[cpuacct_idx]._hierarchy_id = hierarchy_id;\n-      cg_infos[cpuacct_idx]._enabled = (enabled == 1);\n+      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n+      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n@@ -115,1 +188,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -124,1 +199,1 @@\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n+  cgroup = fopen(proc_self_cgroup, \"r\");\n@@ -127,2 +202,2 @@\n-      tty->print_cr(\"Can't open \/proc\/self\/cgroup, %s\",\n-                               strerror(errno));\n+      tty->print_cr(\"Can't open %s, %s\",\n+                    proc_self_cgroup, strerror(errno));\n@@ -130,1 +205,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -152,2 +229,2 @@\n-        assert(hierarchy_id == cg_infos[memory_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[memory_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -155,2 +232,2 @@\n-        assert(hierarchy_id == cg_infos[cpuset_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpuset_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -158,2 +235,2 @@\n-        assert(hierarchy_id == cg_infos[cpu_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpu_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -161,2 +238,2 @@\n-        assert(hierarchy_id == cg_infos[cpuacct_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n-        cg_infos[cpuacct_idx]._cgroup_path = os::strdup(cgroup_path);\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -173,7 +250,36 @@\n-  if (is_cgroupsV2) {\n-    \/\/ Find the cgroup2 mount point by reading \/proc\/self\/mountinfo\n-    mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-    if (mntinfo == NULL) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                                   strerror(errno));\n+  \/\/ Find various mount points by reading \/proc\/self\/mountinfo\n+  \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+  mntinfo = fopen(proc_self_mountinfo, \"r\");\n+  if (mntinfo == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_self_mountinfo, strerror(errno));\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  bool cgroupv2_mount_point_found = false;\n+  bool any_cgroup_mounts_found = false;\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmp_mount_point[MAXPATHLEN+1];\n+    char tmp_fs_type[MAXPATHLEN+1];\n+    char tmproot[MAXPATHLEN+1];\n+    char tmpmount[MAXPATHLEN+1];\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+    \/\/ block in the hybrid case.\n+    \/\/\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s %*s %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+      \/\/ we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype\n+      if (!cgroupv2_mount_point_found && strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+        cgroupv2_mount_point_found = true;\n+        any_cgroup_mounts_found = true;\n+        for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+          assert(cg_infos[i]._mount_path == NULL, \"_mount_path memory stomping\");\n+          cg_infos[i]._mount_path = os::strdup(tmp_mount_point);\n@@ -181,1 +287,1 @@\n-        return NULL;\n+      }\n@@ -184,13 +290,58 @@\n-    char cgroupv2_mount[MAXPATHLEN+1];\n-    char fstype[MAXPATHLEN+1];\n-    bool mount_point_found = false;\n-    while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-      char *tmp_mount_point = cgroupv2_mount;\n-      char *tmp_fs_type = fstype;\n-\n-      \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-      if (sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n-        \/\/ we likely have an early match return, be sure we have cgroup2 as fstype\n-        if (strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n-          mount_point_found = true;\n-          break;\n+    \/* Cgroup v1 relevant info\n+     *\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     *\n+     * Example for docker:\n+     * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+     *\n+     * Example for host:\n+     * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+     *\/\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+      if (strcmp(\"cgroup\", tmp_fs_type) != 0) {\n+        \/\/ Skip cgroup2 fs lines on hybrid or unified hierarchy.\n+        continue;\n+      }\n+      while ((token = strsep(&cptr, \",\")) != NULL) {\n+        if (strcmp(token, \"memory\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[MEMORY_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[MEMORY_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuset\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          if (cg_infos[CPUSET_IDX]._mount_path != NULL) {\n+            \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+            \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+            \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+            if (strstr(cg_infos[CPUSET_IDX]._mount_path, \"\/sys\/fs\/cgroup\") != cg_infos[CPUSET_IDX]._mount_path) {\n+              if (PrintContainerInfo) {\n+                tty->print_cr(\"Duplicate cpuset controllers detected. Picking %s, skipping %s.\",\n+                              tmpmount, cg_infos[CPUSET_IDX]._mount_path);\n+              }\n+              os::free(cg_infos[CPUSET_IDX]._mount_path);\n+              cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+            } else {\n+              if (PrintContainerInfo) {\n+                tty->print_cr(\"Duplicate cpuset controllers detected. Picking %s, skipping %s.\",\n+                              cg_infos[CPUSET_IDX]._mount_path, tmpmount);\n+              }\n+            }\n+          } else {\n+            cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+          }\n+          cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUSET_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpu\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[CPU_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPU_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuacct\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUACCT_IDX]._data_complete = true;\n@@ -200,2 +351,16 @@\n-    fclose(mntinfo);\n-    if (!mount_point_found) {\n+  }\n+  fclose(mntinfo);\n+\n+  \/\/ Neither cgroup2 nor cgroup filesystems mounted via \/proc\/self\/mountinfo\n+  \/\/ No point in continuing.\n+  if (!any_cgroup_mounts_found) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"No relevant cgroup controllers mounted.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_NO_MOUNT;\n+    return false;\n+  }\n+\n+  if (is_cgroupsV2) {\n+    if (!cgroupv2_mount_point_found) {\n@@ -205,1 +370,3 @@\n-      return NULL;\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_V2;\n+      return false;\n@@ -208,12 +375,2 @@\n-    \/\/ Construct the subsystem, free resources and return\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cgroupv2_mount, cg_infos[memory_idx]._cgroup_path);\n-    for (int i = 0; i < CG_INFO_LENGTH; i++) {\n-      os::free(cg_infos[i]._name);\n-      os::free(cg_infos[i]._cgroup_path);\n-    }\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n-    }\n-    return new CgroupV2Subsystem(unified);\n+    *flags = CGROUPS_V2;\n+    return true;\n@@ -227,44 +384,1 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      if (PrintContainerInfo) {\n-        tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                                 strerror(errno));\n-      }\n-      return NULL;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupV1MemoryController(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupV1Controller(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupV1Controller(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupV1Controller(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n+  if (!cg_infos[MEMORY_IDX]._data_complete) {\n@@ -274,1 +388,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -276,1 +392,1 @@\n-  if (cpuset == NULL) {\n+  if (!cg_infos[CPUSET_IDX]._data_complete) {\n@@ -280,1 +396,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -282,1 +400,1 @@\n-  if (cpu == NULL) {\n+  if (!cg_infos[CPU_IDX]._data_complete) {\n@@ -286,1 +404,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -288,1 +408,1 @@\n-  if (cpuacct == NULL) {\n+  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n@@ -292,1 +412,3 @@\n-    return NULL;\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n@@ -294,0 +416,3 @@\n+  \/\/ Cgroups v1 case, we have all the info we need.\n+  *flags = CGROUPS_V1;\n+  return true;\n@@ -295,24 +420,4 @@\n-  \/*\n-   * Use info gathered previously from \/proc\/self\/cgroup\n-   * and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n+};\n+\n+void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n+  assert(cg_infos != NULL, \"Invariant\");\n@@ -320,10 +425,4 @@\n-    CgroupInfo info = cg_infos[i];\n-    if (strcmp(info._name, \"memory\") == 0) {\n-      memory->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuset\") == 0) {\n-      cpuset->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpu\") == 0) {\n-      cpu->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-      cpuacct->set_subsystem_path(info._cgroup_path);\n-    }\n+    os::free(cg_infos[i]._name);\n+    os::free(cg_infos[i]._cgroup_path);\n+    os::free(cg_infos[i]._root_mount_path);\n+    os::free(cg_infos[i]._mount_path);\n@@ -331,1 +430,0 @@\n-  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.cpp","additions":259,"deletions":161,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -56,0 +56,14 @@\n+#define CGROUPS_V1               1\n+#define CGROUPS_V2               2\n+#define INVALID_CGROUPS_V2       3\n+#define INVALID_CGROUPS_V1       4\n+#define INVALID_CGROUPS_NO_MOUNT 5\n+#define INVALID_CGROUPS_GENERIC  6\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+#define CPUSET_IDX     0\n+#define CPU_IDX        1\n+#define CPUACCT_IDX    2\n+#define MEMORY_IDX     3\n+\n@@ -158,1 +172,4 @@\n-  if (err != 0)                                                           \\\n+  if (err != 0) {                                                         \\\n+    if (PrintContainerInfo) {                                             \\\n+      tty->print_cr(logstring, (return_type) OSCONTAINER_ERROR);          \\\n+    }                                                                     \\\n@@ -160,0 +177,1 @@\n+  }                                                                       \\\n@@ -202,2 +220,0 @@\n-\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n-#define CG_INFO_LENGTH 4\n@@ -264,7 +280,3 @@\n-class CgroupSubsystemFactory: AllStatic {\n-  public:\n-    static CgroupSubsystem* create();\n-};\n-\n-\/\/ Class representing info in \/proc\/self\/cgroup.\n-\/\/ See man 7 cgroups\n+\/\/ Utility class for storing info retrieved from \/proc\/cgroups,\n+\/\/ \/proc\/self\/cgroup and \/proc\/self\/mountinfo\n+\/\/ For reference see man 7 cgroups and CgroupSubsystemFactory\n@@ -273,0 +285,1 @@\n+  friend class WhiteBox;\n@@ -275,4 +288,18 @@\n-  char* _name;\n-  int _hierarchy_id;\n-  bool _enabled;\n-  char* _cgroup_path;\n+    char* _name;\n+    int _hierarchy_id;\n+    bool _enabled;\n+    bool _data_complete;    \/\/ indicating cgroup v1 data is complete for this controller\n+    char* _cgroup_path;     \/\/ cgroup controller path from \/proc\/self\/cgroup\n+    char* _root_mount_path; \/\/ root mount path from \/proc\/self\/mountinfo. Unused for cgroup v2\n+    char* _mount_path;      \/\/ mount path from \/proc\/self\/mountinfo.\n+\n+  public:\n+    CgroupInfo() {\n+      _name = NULL;\n+      _hierarchy_id = -1;\n+      _enabled = false;\n+      _data_complete = false;\n+      _cgroup_path = NULL;\n+      _root_mount_path = NULL;\n+      _mount_path = NULL;\n+    }\n@@ -282,0 +309,28 @@\n+class CgroupSubsystemFactory: AllStatic {\n+  friend class WhiteBox;\n+\n+  public:\n+    static CgroupSubsystem* create();\n+  private:\n+    static inline bool is_cgroup_v2(u1* flags) {\n+       return *flags == CGROUPS_V2;\n+    }\n+\n+#ifdef ASSERT\n+    static inline bool is_valid_cgroup(u1* flags) {\n+       return *flags == CGROUPS_V1 || *flags == CGROUPS_V2;\n+    }\n+    static inline bool is_cgroup_v1(u1* flags) {\n+       return *flags == CGROUPS_V1;\n+    }\n+#endif\n+\n+    \/\/ Determine the cgroup type (version 1 or version 2), given\n+    \/\/ relevant paths to files. Sets 'flags' accordingly.\n+    static bool determine_type(CgroupInfo* cg_infos,\n+                               const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* flags);\n+    static void cleanup(CgroupInfo* cg_infos);\n+};\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp","additions":69,"deletions":14,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n@@ -39,1 +39,1 @@\n-                     \"Raw value for CPU shares is: %d\", \"%d\", shares);\n+                     \"Raw value for CPU Shares is: %d\", \"%d\", shares);\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2287,1 +2287,1 @@\n-if (!OSContainer::is_containerized()) {\n+  if (!OSContainer::is_containerized()) {\n","filename":"hotspot\/src\/os\/linux\/vm\/os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#endif\n+\n@@ -165,1 +170,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -587,0 +591,12 @@\n+#ifdef LINUX\n+bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* cg_flags) {\n+  CgroupInfo cg_infos[4];\n+  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+                                                    proc_self_cgroup,\n+                                                    proc_self_mountinfo, cg_flags);\n+}\n+#endif\n+\n@@ -1205,0 +1221,25 @@\n+WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,\n+                                    jobject o,\n+                                    jstring proc_cgroups,\n+                                    jstring proc_self_cgroup,\n+                                    jstring proc_self_mountinfo))\n+  jint ret = 0;\n+#ifdef LINUX\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  u1 cg_type_flags = 0;\n+  \/\/ This sets cg_type_flags\n+  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  ret = (jint)cg_type_flags;\n+  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);\n+  env->ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);\n+#endif\n+  return ret;\n+WB_END\n+\n@@ -1335,0 +1376,3 @@\n+  {CC\"validateCgroup\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_ValidateCgroup },\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+#ifdef LINUX\n+  static bool validate_cgroup(const char* proc_cgroups, const char* proc_self_cgroup, const char* proc_self_mountinfo, u1* cg_flags);\n+#endif\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CgroupSubsystemFactory\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build CgroupSubsystemFactory\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import com.oracle.java.testlibrary.Asserts;\n+import com.oracle.java.testlibrary.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * Verify hotspot's detection heuristics of CgroupSubsystemFactory::create()\n+ *\/\n+public class CgroupSubsystemFactory {\n+\n+    \/\/ Mirrored from hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp\n+    private static final int CGROUPS_V1 = 1;\n+    private static final int CGROUPS_V2 = 2;\n+    private static final int INVALID_CGROUPS_V2 = 3;\n+    private static final int INVALID_CGROUPS_V1 = 4;\n+    private static final int INVALID_CGROUPS_NO_MOUNT = 5;\n+    private Path existingDirectory;\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1SelfCgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoDoubleCpuset;\n+    private Path cgroupv1MntInfoDoubleCpuset2;\n+    private Path cgroupv1MntInfoSystemdOnly;\n+    private String mntInfoEmpty = \"\";\n+    private Path cgroupV1SelfCgroup;\n+    private Path cgroupV2SelfCgroup;\n+    private Path cgroupV2MntInfoMissingCgroupv2;\n+    private Path cgroupv1MntInfoMissingMemoryController;\n+    private String procSelfCgroupHybridContent = \"11:hugetlb:\/\\n\" +\n+            \"10:devices:\/user.slice\\n\" +\n+            \"9:pids:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"8:cpu,cpuacct:\/\\n\" +\n+            \"7:perf_event:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/\\n\" +\n+            \"4:net_cls,net_prio:\/\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:memory:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\\n\" +\n+            \"0::\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\";\n+    private String procSelfCgroupV2UnifiedContent = \"0::\/user.slice\/user-1000.slice\/session-3.scope\";\n+    private String procSelfCgroupV1JoinControllers =\n+            \"9:freezer:\/\\n\" +\n+            \"8:rdma:\/\\n\" +\n+            \"7:blkio:\/user.slice\\n\" +\n+            \"6:devices:\/user.slice\\n\" +\n+            \"5:pids:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"4:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:perf_event:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-2.scope\\n\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\";\n+    private String mntInfoHybridStub =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+    private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;\n+    private String mntInfoHybridMissingMemory = mntInfoHybridStub;\n+    private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;\n+    private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpusets rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupv1DoubleCpuset = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n+    private String mntInfoCgroupv1DoubleCpuset2 =  mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  3   1   1\\n\" +\n+            \"cpu 8   1   1\\n\" +\n+            \"cpuacct 8   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n+\n+    private void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero_cgroupv2_last\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder.getBytes());\n+\n+            cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_hybrid\");\n+            Files.write(cgroupV1SelfCgroup, procSelfCgroupHybridContent.getBytes());\n+\n+            cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_v2\");\n+            Files.write(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent.getBytes());\n+\n+            cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), \"mnt_info_missing_memory\");\n+            Files.write(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory.getBytes());\n+\n+            cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), \"mnt_info_missing_cgroup2\");\n+            Files.write(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpuset = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_double_cpuset\");\n+            Files.write(cgroupv1MntInfoDoubleCpuset, mntInfoCgroupv1DoubleCpuset.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpuset2 = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_double_cpuset2\");\n+            Files.write(cgroupv1MntInfoDoubleCpuset2, mntInfoCgroupv1DoubleCpuset2.getBytes());\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_systemd_only\");\n+            Files.write(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly.getBytes());\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.write(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers.getBytes());\n+\n+            cgroupv1SelfCgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.write(cgroupv1SelfCgroupsJoinControllers, procSelfCgroupV1JoinControllers.getBytes());\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.write(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void teardown() {\n+        try {\n+            deleteFileTree(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    private static void deleteFileTree(Path dir) throws IOException {\n+        java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private boolean isValidCgroup(int value) {\n+        return value == CGROUPS_V1 || value == CGROUPS_V2;\n+    }\n+\n+    public void testCgroupv1JoinControllerCombo(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String procSelfCgroup = cgroupv1SelfCgroupsJoinControllers.toString();\n+        String procSelfMountinfo = cgroupv1MountInfoJoinControllers.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Join controllers should be properly detected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1JoinControllerMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv1MultipleCpusetMounts(WhiteBox wb, Path mountInfo) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = mountInfo.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Multiple cpuset controllers, but only one in \/sys\/fs\/cgroup\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MultipleCpusetMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv1SystemdOnly(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoSystemdOnly.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"Only systemd mounted. Invalid\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1SystemdOnly PASSED!\");\n+    }\n+\n+    public void testCgroupv1NoMounts(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"No cgroups mounted in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1NoMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V2, retval, \"No cgroup2 filesystem in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2NoCgroup2Fs PASSED!\");\n+    }\n+\n+    public void testCgroupv1MissingMemoryController(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V1, retval, \"Required memory controller path missing in mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MissingMemoryController PASSED!\");\n+    }\n+\n+    public void testCgroupv2(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"Expected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2 PASSED!\");\n+    }\n+\n+    public void testCgroupV1Hybrid(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1Hybrid PASSED!\");\n+    }\n+\n+    public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1HybridMntInfoOrder PASSED!\");\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        CgroupSubsystemFactory test = new CgroupSubsystemFactory();\n+        test.setup();\n+        try {\n+            test.testCgroupv1SystemdOnly(wb);\n+            test.testCgroupv1NoMounts(wb);\n+            test.testCgroupv2(wb);\n+            test.testCgroupV1Hybrid(wb);\n+            test.testCgroupV1HybridMntInfoOrder(wb);\n+            test.testCgroupv1MissingMemoryController(wb);\n+            test.testCgroupv2NoCgroup2Fs(wb);\n+            test.testCgroupv1MultipleCpusetMounts(wb, test.cgroupv1MntInfoDoubleCpuset);\n+            test.testCgroupv1MultipleCpusetMounts(wb, test.cgroupv1MntInfoDoubleCpuset2);\n+            test.testCgroupv1JoinControllerCombo(wb);\n+        } finally {\n+            test.teardown();\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test PlainRead\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build PlainRead\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n+ *\/\n+\n+import com.oracle.java.testlibrary.ProcessTools;\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n+import com.oracle.java.testlibrary.Platform;\n+import sun.hotspot.WhiteBox;\n+\n+public class PlainRead {\n+\n+    static public void match(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static final String good_value = \"(\\\\d+|-1|Unlimited)\";\n+    static final String bad_value = \"(failed)\";\n+\n+    static final String[] variables = {\"Memory Limit is:\", \"CPU Shares is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n+\n+    static public void isContainer(OutputAnalyzer oa) {\n+        for (String v: variables) {\n+            match(oa, v, good_value);\n+        }\n+        for (String v: variables) {\n+            noMatch(oa, v, bad_value);\n+        }\n+    }\n+\n+    static public void isNotContainer(OutputAnalyzer oa) {\n+       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintContainerInfo\", \"-version\");\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        if (wb.isContainerized()) {\n+            System.out.println(\"Inside a cgroup, testing...\");\n+            isContainer(output);\n+        } else {\n+            System.out.println(\"Not in a cgroup, testing...\");\n+            isNotContainer(output);\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/PlainRead.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -32,0 +33,8 @@\n+        Metrics metrics = jdk.internal.platform.Container.metrics();\n+        System.out.println(\"Metrics instance: \" + (metrics == null ? \"null\" : \"non-null\"));\n+        if (metrics != null) {\n+            System.out.println(\"Metrics.getMemoryAndSwapLimit() == \" + metrics.getMemoryAndSwapLimit());\n+            System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n+            System.out.println(\"Metrics.getMemoryAndSwapUsage() == \" + metrics.getMemoryAndSwapUsage());\n+            System.out.println(\"Metrics.getMemoryUsage() == \" + metrics.getMemoryUsage());\n+        }\n","filename":"hotspot\/test\/runtime\/containers\/docker\/CheckOperatingSystemMXBean.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n@@ -373,0 +377,21 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n+\n","filename":"hotspot\/test\/testlibrary\/com\/oracle\/java\/testlibrary\/Utils.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -259,0 +259,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"hotspot\/test\/testlibrary\/whitebox\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n@@ -37,1 +41,1 @@\n-class CgroupSubsystemFactory {\n+public class CgroupSubsystemFactory {\n@@ -45,0 +49,25 @@\n+    \/*\n+     * From https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+     *\n+     *  36 35 98:0 \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+     *  (1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)\n+     *\n+     *  (1) mount ID:  unique identifier of the mount (may be reused after umount)\n+     *  (2) parent ID:  ID of parent (or of self for the top of the mount tree)\n+     *  (3) major:minor:  value of st_dev for files on filesystem\n+     *  (4) root:  root of the mount within the filesystem\n+     *  (5) mount point:  mount point relative to the process's root\n+     *  (6) mount options:  per mount options\n+     *  (7) optional fields:  zero or more fields of the form \"tag[:value]\"\n+     *  (8) separator:  marks the end of the optional fields\n+     *  (9) filesystem type:  name of filesystem of the form \"type[.subtype]\"\n+     *  (10) mount source:  filesystem specific information or \"none\"\n+     *  (11) super options:  per super block options\n+     *\/\n+    private static final Pattern MOUNTINFO_PATTERN = Pattern.compile(\n+        \"^[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+\" + \/\/ (1), (2), (3)\n+        \"[^\\\\s]+\\\\s+([^\\\\s]+)\\\\s+\" +           \/\/ (4), (5)     - group 1: mount point\n+        \"[^-]+-\\\\s+\" +                         \/\/ (6), (7), (8)\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 2: filesystem type\n+        \".*$\");                                \/\/ (10), (11)\n+\n@@ -46,1 +75,1 @@\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+        Optional<CgroupTypeResult> optResult = null;\n@@ -48,14 +77,1 @@\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n-            for (String line : lines) {\n-                if (line.startsWith(\"#\")) {\n-                    continue;\n-                }\n-                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n-                switch (info.getName()) {\n-                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n-                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n-                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n-                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n-                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n-                }\n-            }\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n@@ -66,10 +82,2 @@\n-        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n-        boolean isCgroupsV2 = true;\n-        boolean anyControllersEnabled = false;\n-        boolean anyCgroupsV2Controller = false;\n-        boolean anyCgroupsV1Controller = false;\n-        for (CgroupInfo info: infos.values()) {\n-            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n-            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n-            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n-            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        if (optResult.equals(Optional.empty())) {\n+            return null;\n@@ -77,0 +85,1 @@\n+        CgroupTypeResult result = optResult.get();\n@@ -79,1 +88,1 @@\n-        if (!anyControllersEnabled) {\n+        if (!result.isAnyControllersEnabled()) {\n@@ -85,1 +94,1 @@\n-        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+        if (result.isAnyCgroupV1Controllers() && result.isAnyCgroupV2Controllers()) {\n@@ -89,1 +98,1 @@\n-        if (isCgroupsV2) {\n+        if (result.isCgroupV2()) {\n@@ -97,0 +106,105 @@\n+\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        for (String line : lines) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+            switch (info.getName()) {\n+            case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+            case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+            case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+            case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+            case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+            }\n+        }\n+\n+        \/\/ For cgroups v2 all controllers need to have zero hierarchy id\n+        \/\/ and \/proc\/self\/mountinfo needs to have at least one cgroup filesystem\n+        \/\/ mounted. Note that hybrid hierarchy has controllers mounted via\n+        \/\/ cgroup v1. In that case hierarchy id's will be non-zero.\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If there are no mounted, relevant cgroup controllers in mountinfo and only\n+        \/\/ 0 hierarchy IDs in \/proc\/cgroups have been seen, we are on a cgroups v1 system.\n+        \/\/ However, continuing in that case does not make sense as we'd need\n+        \/\/ information from mountinfo for the mounted controller paths which we wouldn't\n+        \/\/ find anyway in that case.\n+        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n+            boolean anyCgroupMounted = mntInfo.anyMatch(CgroupSubsystemFactory::isRelevantControllerMount);\n+            if (!anyCgroupMounted && isCgroupsV2) {\n+                return Optional.empty();\n+            }\n+        }\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+        return Optional.of(result);\n+    }\n+\n+    private static boolean isRelevantControllerMount(String line) {\n+         Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(line.trim());\n+         if (lineMatcher.matches()) {\n+             String mountPoint = lineMatcher.group(1);\n+             String fsType = lineMatcher.group(2);\n+             if (fsType.equals(\"cgroup\")) {\n+                 String filename = Paths.get(mountPoint).getFileName().toString();\n+                 for (String fn: filename.split(\",\")) {\n+                     switch (fn) {\n+                         case MEMORY_CTRL: \/\/ fall through\n+                         case CPU_CTRL:\n+                         case CPUSET_CTRL:\n+                         case CPUACCT_CTRL:\n+                         case BLKIO_CTRL:\n+                             return true;\n+                         default: break; \/\/ ignore not recognized controllers\n+                     }\n+                 }\n+             } else if (fsType.equals(\"cgroup2\")) {\n+                 return true;\n+             }\n+         }\n+         return false;\n+    }\n+\n+    public static final class CgroupTypeResult {\n+        private final boolean isCgroupV2;\n+        private final boolean anyControllersEnabled;\n+        private final boolean anyCgroupV2Controllers;\n+        private final boolean anyCgroupV1Controllers;\n+\n+        private CgroupTypeResult(boolean isCgroupV2,\n+                                 boolean anyControllersEnabled,\n+                                 boolean anyCgroupV2Controllers,\n+                                 boolean anyCgroupV1Controllers) {\n+            this.isCgroupV2 = isCgroupV2;\n+            this.anyControllersEnabled = anyControllersEnabled;\n+            this.anyCgroupV1Controllers = anyCgroupV1Controllers;\n+            this.anyCgroupV2Controllers = anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isCgroupV2() {\n+            return isCgroupV2;\n+        }\n+\n+        public boolean isAnyControllersEnabled() {\n+            return anyControllersEnabled;\n+        }\n+\n+        public boolean isAnyCgroupV2Controllers() {\n+            return anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isAnyCgroupV1Controllers() {\n+            return anyCgroupV1Controllers;\n+        }\n+    }\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":143,"deletions":29,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    private static final long NO_SWAP = 0;\n@@ -56,1 +57,1 @@\n-    private long getLongVal(String file) {\n+    private long getLongVal(String file, long defaultValue) {\n@@ -60,1 +61,5 @@\n-                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+                                                      defaultValue);\n+    }\n+\n+    private long getLongVal(String file) {\n+        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n@@ -292,0 +297,5 @@\n+        \/\/ We only get a null string when file memory.swap.max doesn't exist.\n+        \/\/ In that case we return the memory limit without any swap.\n+        if (strVal == null) {\n+            return getMemoryLimit();\n+        }\n@@ -310,1 +320,0 @@\n-        long swapUsage = getLongVal(\"memory.swap.current\");\n@@ -312,1 +321,7 @@\n-        return memoryUsage + swapUsage;\n+        if (memoryUsage >= 0) {\n+            \/\/ If file memory.swap.current doesn't exist, only return the regular\n+            \/\/ memory usage (without swap). Thus, use default value of NO_SWAP.\n+            long swapUsage = getLongVal(\"memory.swap.current\", NO_SWAP);\n+            return memoryUsage + swapUsage;\n+        }\n+        return memoryUsage; \/\/ case of no memory limits\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemFactory;\n+import jdk.internal.platform.CgroupSubsystemFactory.CgroupTypeResult;\n+import jdk.testlibrary.Utils;\n+import jdk.testlibrary.FileUtils;\n+\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/lib\/testlibrary\n+ * @run junit\/othervm TestCgroupSubsystemFactory\n+ *\/\n+public class TestCgroupSubsystemFactory {\n+\n+    private Path existingDirectory;\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoSystemdOnly;\n+    private Path cgroupv1MntInfoDoubleCpusets;\n+    private Path cgroupv1MntInfoDoubleCpusets2;\n+    private String mntInfoEmpty = \"\";\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String mntInfoHybrid =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  9   1   1\\n\" +\n+            \"cpu 7   1   1\\n\" +\n+            \"cpuacct 7   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpuset rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupsV1DoubleCpuset = mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String mntInfoCgroupsV1DoubleCpuset2 = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_systemd_only\");\n+            Files.write(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpusets = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset\");\n+            Files.write(cgroupv1MntInfoDoubleCpusets, mntInfoCgroupsV1DoubleCpuset.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpusets2 = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset2\");\n+            Files.write(cgroupv1MntInfoDoubleCpusets2, mntInfoCgroupsV1DoubleCpuset2.getBytes());\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.write(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers.getBytes());\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.write(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testCgroupv1JoinControllerCombo() throws IOException {\n+        String cgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String mountInfo = cgroupv1MountInfoJoinControllers.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Join controller combination expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testCgroupv1SystemdOnly() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoSystemdOnly.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"zero hierarchy ids with no *relevant* controllers mounted\", Optional.empty().equals(result));\n+    }\n+\n+    @Test\n+    public void testCgroupv1MultipleCpusetMounts() throws IOException {\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets);\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets2);\n+    }\n+\n+    private void doMultipleCpusetMountsTest(Path info) throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = info.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Duplicate cpusets should not influence detection heuristic\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testHybridCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"hybrid hierarchy expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"zero hierarchy ids with no mounted controllers => empty result\", Optional.empty().equals(result));\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV2() throws IOException {\n+        String cgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"zero hierarchy ids with mounted controllers expected cgroups v2\", res.isCgroupV2());\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void mountInfoFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = Paths.get(existingDirectory.toString(), \"not-existing-mountinfo\").toString();\n+\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void cgroupsFileNotFound() throws IOException {\n+        String cgroups = Paths.get(existingDirectory.toString(), \"not-existing-cgroups\").toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -99,1 +100,1 @@\n-        if (effectiveCpus.length != 0) {\n+        if (effectiveCpus != null) {\n@@ -134,1 +135,1 @@\n-        if (effectiveMems.length != 0) {\n+        if (effectiveMems != null) {\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n+            throw new RuntimeException(\"kernel memory limit test not supported for cgroups v2\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -44,3 +45,3 @@\n-    public static long convertStringToLong(String strval, long overflowRetval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n+    public static long convertStringToLong(String strval, long initialVal, long overflowRetval) {\n+        long retval = initialVal;\n+        if (strval == null) return retval;\n@@ -96,1 +97,1 @@\n-            return new Integer[0];\n+            return null;\n@@ -111,0 +112,15 @@\n+    public static Integer[] boxedArrayOrNull(int[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return Arrays.stream(primitiveArray).boxed().toArray(Integer[]::new);\n+    }\n+\n+    public static Integer[] sortAllowNull(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.internal.platform.Metrics;\n+import jdk.internal.platform.CgroupSubsystem;\n@@ -43,0 +43,2 @@\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Asserts;\n@@ -46,0 +48,2 @@\n+    \/\/ Aliased for readability\n+    private static final long RETVAL_UNAVAILABLE = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -130,3 +134,0 @@\n-        if (startPerCpu == null) {\n-            startPerCpu = new long[0];\n-        }\n@@ -162,1 +163,1 @@\n-        return (data == null || data.isEmpty()) ? 0L : convertStringToLong(data);\n+        return (data == null || data.isEmpty()) ? RETVAL_UNAVAILABLE : convertStringToLong(data);\n@@ -166,1 +167,1 @@\n-        return CgroupMetricsTester.convertStringToLong(strval, Long.MAX_VALUE);\n+        return CgroupMetricsTester.convertStringToLong(strval, RETVAL_UNAVAILABLE, Long.MAX_VALUE);\n@@ -178,1 +179,1 @@\n-        return 0L;\n+        return RETVAL_UNAVAILABLE;\n@@ -183,1 +184,1 @@\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n+        return data == null || data.isEmpty() ? RETVAL_UNAVAILABLE : Double.parseDouble(data);\n@@ -206,0 +207,7 @@\n+    private Long[] boxedArrayOrNull(long[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return LongStream.of(primitiveArray).boxed().toArray(Long[]::new);\n+    }\n+\n@@ -218,1 +226,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -244,1 +252,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -270,1 +278,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED: newVal;\n@@ -298,1 +306,1 @@\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n+            newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -321,1 +329,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -346,1 +354,1 @@\n-        Long[] newVals = new Long[0];\n+        Long[] newVals = null;\n@@ -353,6 +361,6 @@\n-        long[] oldValsPrim = metrics.getPerCpuUsage();\n-        Long[] oldVals = LongStream.of(oldValsPrim == null ? new long[0] : oldValsPrim)\n-                                    .boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+        Long[] oldVals = boxedArrayOrNull(metrics.getPerCpuUsage());\n+        if (oldVals != null) {\n+            for (int i = 0; i < oldVals.length; i++) {\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                    warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+                }\n@@ -360,0 +368,2 @@\n+        } else {\n+            Asserts.assertNull(newVals, Controller.CPUACCT.value() + \"cpuacct.usage_percpu not both null\");\n@@ -417,2 +427,2 @@\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -423,1 +433,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -431,11 +441,8 @@\n-        \/\/ Skip this test if this metric is not supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSets);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n@@ -444,2 +451,2 @@\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -448,1 +455,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -456,11 +463,8 @@\n-        \/\/ Skip this test if this metric is not supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n-            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSetMems);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n@@ -507,3 +511,0 @@\n-        if (newPerCpu == null) {\n-            newPerCpu = new long[0];\n-        }\n@@ -527,5 +528,11 @@\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n+        if (startPerCpu != null) {\n+            boolean success = false;\n+            for (int i = 0; i < startPerCpu.length; i++) {\n+                if (newPerCpu[i] > startPerCpu[i]) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+            if (!success) {\n+                fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                                                       Arrays.toString(startPerCpu));\n@@ -533,0 +540,2 @@\n+        } else {\n+            Asserts.assertNull(newPerCpu, Controller.CPU.value() + \" getPerCpuUsage not both null\");\n@@ -535,2 +544,0 @@\n-        if(!success) fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":65,"deletions":58,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.platform.CgroupSubsystem;\n@@ -41,0 +40,1 @@\n+    private static final long NOT_AVAILABLE = -1;\n@@ -128,1 +128,1 @@\n-            return 0;\n+            return NOT_AVAILABLE;\n@@ -155,1 +155,1 @@\n-        if (rawVal == 0 || rawVal == 100) {\n+        if (rawVal == NOT_AVAILABLE || rawVal == 100) {\n@@ -203,1 +203,8 @@\n-        return CgroupMetricsTester.convertStringToLong(val, UNLIMITED);\n+        return CgroupMetricsTester.convertStringToLong(val, NOT_AVAILABLE, UNLIMITED);\n+    }\n+\n+    private long nanosOrUnlimited(long micros) {\n+        if (micros < 0) {\n+            return UNLIMITED;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n@@ -235,5 +242,6 @@\n-        oldVal = metrics.getMemoryAndSwapLimit();\n-        long valSwap = getLongLimitValueFromFile(\"memory.swap.max\");\n-        long valMemory = getLongLimitValueFromFile(\"memory.max\");\n-        if (valSwap == UNLIMITED) {\n-            newVal = valSwap;\n+        long memAndSwapLimit = metrics.getMemoryAndSwapLimit();\n+        long memLimit = metrics.getMemoryLimit();\n+        \/\/ Only test swap memory limits if we can. On systems with swapaccount=0\n+        \/\/ we cannot, as swap limits are disabled.\n+        if (memAndSwapLimit <= memLimit) {\n+            System.out.println(\"No swap memory limits, test case(s) skipped\");\n@@ -241,6 +249,12 @@\n-            assert valMemory >= 0;\n-            newVal = valSwap + valMemory;\n-        }\n-        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n-            fail(\"memory.swap.max\", oldVal, newVal);\n-        }\n+            oldVal = memAndSwapLimit;\n+            long valSwap = getLongLimitValueFromFile(\"memory.swap.max\");\n+            long valMemory = getLongLimitValueFromFile(\"memory.max\");\n+            if (valSwap == UNLIMITED) {\n+                newVal = valSwap;\n+            } else {\n+                assert valMemory >= 0;\n+                newVal = valSwap + valMemory;\n+            }\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(\"memory.swap.max\", oldVal, newVal);\n+            }\n@@ -248,6 +262,7 @@\n-        oldVal = metrics.getMemoryAndSwapUsage();\n-        long swapUsage = getLongValueFromFile(\"memory.swap.current\");\n-        long memUsage = getLongValueFromFile(\"memory.current\");\n-        newVal = swapUsage + memUsage;\n-        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n-            fail(\"memory.swap.current\", oldVal, newVal);\n+            oldVal = metrics.getMemoryAndSwapUsage();\n+            long swapUsage = getLongValueFromFile(\"memory.swap.current\");\n+            long memUsage = getLongValueFromFile(\"memory.current\");\n+            newVal = swapUsage + memUsage;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(\"memory.swap.current\", oldVal, newVal);\n+            }\n@@ -268,1 +283,1 @@\n-        long newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+        long newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n@@ -275,1 +290,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n@@ -281,1 +296,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n@@ -321,1 +336,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n@@ -330,3 +345,2 @@\n-        int[] cpus = mapNullToEmpty(metrics.getCpuSetCpus());\n-        Integer[] oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -337,1 +351,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -343,3 +357,2 @@\n-        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetCpus());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -348,1 +361,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -354,3 +367,2 @@\n-        cpus = mapNullToEmpty(metrics.getCpuSetMems());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -359,1 +371,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -365,3 +377,2 @@\n-        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetMems());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -370,1 +381,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -377,9 +388,0 @@\n-    private int[] mapNullToEmpty(int[] cpus) {\n-        if (cpus == null) {\n-            \/\/ Not available. For sake of testing continue with an\n-            \/\/ empty array.\n-            cpus = new int[0];\n-        }\n-        return cpus;\n-    }\n-\n@@ -474,1 +476,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return NOT_AVAILABLE;\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":53,"deletions":51,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,0 +44,2 @@\n+import java.nio.file.attribute.FileAttribute;\n+\n@@ -443,0 +447,20 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n","filename":"jdk\/test\/lib\/testlibrary\/jdk\/testlibrary\/Utils.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}