{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,4 +200,1 @@\n-            return String.format(\"%s\/%s:%d\",\n-                                event.getValue(\"host\"),\n-                                event.getValue(\"address\"),\n-                                event.getValue(\"port\"));\n+            return event.getValue(\"address\") + \":\"  + event.getValue(\"port\");\n@@ -208,1 +205,1 @@\n-        return s.getInetAddress().toString() + \":\" + s.getPort();\n+        return s.getInetAddress().getHostAddress() + \":\" + s.getPort();\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/IOEvent.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.Collections;\n+import java.util.Comparator;\n@@ -44,0 +46,1 @@\n+        Collections.sort(events, Comparator.comparing(RecordedEvent::getStartTime));\n@@ -51,0 +54,3 @@\n+            for (RecordedEvent e: events) {\n+                System.out.println(e);\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/IOHelper.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,4 +60,4 @@\n-        Recording recording = new Recording();\n-        recording.disable(IOEvent.EVENT_FILE_READ);\n-        recording.disable(IOEvent.EVENT_FILE_WRITE);\n-        recording.start();\n+        try (Recording recording = new Recording()) {\n+            recording.disable(IOEvent.EVENT_FILE_READ);\n+            recording.disable(IOEvent.EVENT_FILE_WRITE);\n+            recording.start();\n@@ -65,3 +65,3 @@\n-        useRandomAccessFile(tmp);\n-        useFileStreams(tmp);\n-        useFileChannel(tmp);\n+            useRandomAccessFile(tmp);\n+            useFileStreams(tmp);\n+            useFileChannel(tmp);\n@@ -69,6 +69,7 @@\n-        recording.stop();\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            final String eventName = event.getEventType().getName();\n-            System.out.println(\"Got eventName:\" + eventName);\n-            assertNotEquals(eventName, IOEvent.EVENT_FILE_READ, \"Got disabled read event\");\n-            assertNotEquals(eventName, IOEvent.EVENT_FILE_WRITE, \"Got disabled write event\");\n+            recording.stop();\n+            for (RecordedEvent event : Events.fromRecording(recording)) {\n+                final String eventName = event.getEventType().getName();\n+                System.out.println(\"Got eventName:\" + eventName);\n+                assertNotEquals(eventName, IOEvent.EVENT_FILE_READ, \"Got disabled read event\");\n+                assertNotEquals(eventName, IOEvent.EVENT_FILE_WRITE, \"Got disabled write event\");\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestDisabledEvents.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,68 +53,68 @@\n-        Recording recording = new Recording();\n-        List<IOEvent> expectedEvents = new ArrayList<>();\n-\n-        try (RandomAccessFile rf = new RandomAccessFile(tmp, \"rw\"); FileChannel ch = rf.getChannel();) {\n-            recording.enable(IOEvent.EVENT_FILE_FORCE).withThreshold(Duration.ofMillis(0));\n-            recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n-            recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n-            recording.start();\n-\n-            ByteBuffer bufA = ByteBuffer.allocateDirect(10);\n-            ByteBuffer bufB = ByteBuffer.allocateDirect(20);\n-            bufA.put(\"1234567890\".getBytes());\n-            bufB.put(\"1234567890\".getBytes());\n-\n-            \/\/ test write(ByteBuffer)\n-            bufA.flip();\n-            long size = ch.write(bufA);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n-\n-            \/\/ test write(ByteBuffer, long)\n-            bufA.flip();\n-            size = ch.write(bufA, bufA.capacity() \/ 2);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n-\n-            \/\/ test write(ByteBuffer[])\n-            bufA.flip();\n-            bufA.limit(5);\n-            bufB.flip();\n-            bufB.limit(5);\n-            size = ch.write(new ByteBuffer[] { bufA, bufB });\n-            expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n-\n-            \/\/ test force(boolean)\n-            ch.force(true);\n-            expectedEvents.add(IOEvent.createFileForceEvent(tmp));\n-\n-            \/\/ reset file\n-            ch.position(0);\n-\n-            \/\/ test read(ByteBuffer)\n-            bufA.clear();\n-            size = ch.read(bufA);\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-            \/\/ test read(ByteBuffer, long)\n-            bufA.clear();\n-            size = ch.read(bufA, bufA.capacity() \/ 2);\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-            \/\/ test read(ByteBuffer[])\n-            bufA.clear();\n-            bufA.limit(5);\n-            bufB.clear();\n-            bufB.limit(5);\n-            size = ch.read(new ByteBuffer[] { bufA, bufB });\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-            \/\/ Read at EOF. Should get size -1 in event.\n-            ch.position(ch.size());\n-            bufA.clear();\n-            size = ch.read(bufA);\n-            assertEquals(size, -1L, \"Expected size -1 when read at EOF\");\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-            ch.close();\n-            recording.stop();\n-            List<RecordedEvent> events = Events.fromRecording(recording);\n-            IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+        try (Recording recording = new Recording()) {\n+            List<IOEvent> expectedEvents = new ArrayList<>();\n+            try (RandomAccessFile rf = new RandomAccessFile(tmp, \"rw\"); FileChannel ch = rf.getChannel();) {\n+                recording.enable(IOEvent.EVENT_FILE_FORCE).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n+\n+                ByteBuffer bufA = ByteBuffer.allocateDirect(10);\n+                ByteBuffer bufB = ByteBuffer.allocateDirect(20);\n+                bufA.put(\"1234567890\".getBytes());\n+                bufB.put(\"1234567890\".getBytes());\n+\n+                \/\/ test write(ByteBuffer)\n+                bufA.flip();\n+                long size = ch.write(bufA);\n+                expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n+\n+                \/\/ test write(ByteBuffer, long)\n+                bufA.flip();\n+                size = ch.write(bufA, bufA.capacity() \/ 2);\n+                expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n+\n+                \/\/ test write(ByteBuffer[])\n+                bufA.flip();\n+                bufA.limit(5);\n+                bufB.flip();\n+                bufB.limit(5);\n+                size = ch.write(new ByteBuffer[] { bufA, bufB });\n+                expectedEvents.add(IOEvent.createFileWriteEvent(size, tmp));\n+\n+                \/\/ test force(boolean)\n+                ch.force(true);\n+                expectedEvents.add(IOEvent.createFileForceEvent(tmp));\n+\n+                \/\/ reset file\n+                ch.position(0);\n+\n+                \/\/ test read(ByteBuffer)\n+                bufA.clear();\n+                size = ch.read(bufA);\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+\n+                \/\/ test read(ByteBuffer, long)\n+                bufA.clear();\n+                size = ch.read(bufA, bufA.capacity() \/ 2);\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+\n+                \/\/ test read(ByteBuffer[])\n+                bufA.clear();\n+                bufA.limit(5);\n+                bufB.clear();\n+                bufB.limit(5);\n+                size = ch.read(new ByteBuffer[] { bufA, bufB });\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+\n+                \/\/ Read at EOF. Should get size -1 in event.\n+                ch.position(ch.size());\n+                bufA.clear();\n+                size = ch.read(bufA);\n+                assertEquals(size, -1L, \"Expected size -1 when read at EOF\");\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+\n+                ch.close();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestFileChannelEvents.java","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-        Recording recording = new Recording();\n-        List<IOEvent> expectedEvents = new ArrayList<>();\n+        try (Recording recording = new Recording()) {\n+            List<IOEvent> expectedEvents = new ArrayList<>();\n@@ -58,3 +58,3 @@\n-        recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n-        recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n-        recording.start();\n+            recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n+            recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n+            recording.start();\n@@ -62,1 +62,1 @@\n-        final byte[] buf = { 1, 2, 3 };\n+            final byte[] buf = { 1, 2, 3 };\n@@ -64,10 +64,2 @@\n-        \/\/ Create the file.\n-        try (RandomAccessFile f = new RandomAccessFile(tmp, \"rw\")) {\n-            f.write(buf);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(buf.length, tmp));\n-        }\n-\n-        \/\/ Reopen the file as ReadOnly and try to write to it.\n-        \/\/ Should generate an event with bytesWritten = -1.\n-        try (RandomAccessFile f = new RandomAccessFile(tmp, \"r\")) {\n-            try {\n+            \/\/ Create the file.\n+            try (RandomAccessFile f = new RandomAccessFile(tmp, \"rw\")) {\n@@ -75,4 +67,1 @@\n-                fail(\"No exception for ReadOnly File\");\n-            } catch (IOException e) {\n-                \/\/ Expected exception\n-                expectedEvents.add(IOEvent.createFileWriteEvent(-1, tmp));\n+                expectedEvents.add(IOEvent.createFileWriteEvent(buf.length, tmp));\n@@ -80,1 +69,0 @@\n-        }\n@@ -82,12 +70,10 @@\n-        \/\/ Try to write to read-only FileChannel.\n-        try (RandomAccessFile f = new RandomAccessFile(tmp, \"r\"); FileChannel ch = f.getChannel()) {\n-            ByteBuffer writeBuf = ByteBuffer.allocateDirect(buf.length);\n-            writeBuf.put(buf);\n-            writeBuf.flip();\n-            ch.position(0);\n-            try {\n-                ch.write(writeBuf);\n-                fail(\"No exception for ReadOnly FileChannel\");\n-            } catch (java.nio.channels.NonWritableChannelException e) {\n-                \/\/ Expected exception\n-                expectedEvents.add(IOEvent.createFileWriteEvent(-1, tmp));\n+            \/\/ Reopen the file as ReadOnly and try to write to it.\n+            \/\/ Should generate an event with bytesWritten = -1.\n+            try (RandomAccessFile f = new RandomAccessFile(tmp, \"r\")) {\n+                try {\n+                    f.write(buf);\n+                    fail(\"No exception for ReadOnly File\");\n+                } catch (IOException e) {\n+                    \/\/ Expected exception\n+                    expectedEvents.add(IOEvent.createFileWriteEvent(-1, tmp));\n+                }\n@@ -95,1 +81,0 @@\n-        }\n@@ -97,3 +82,19 @@\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-        IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+            \/\/ Try to write to read-only FileChannel.\n+            try (RandomAccessFile f = new RandomAccessFile(tmp, \"r\"); FileChannel ch = f.getChannel()) {\n+                ByteBuffer writeBuf = ByteBuffer.allocateDirect(buf.length);\n+                writeBuf.put(buf);\n+                writeBuf.flip();\n+                ch.position(0);\n+                try {\n+                    ch.write(writeBuf);\n+                    fail(\"No exception for ReadOnly FileChannel\");\n+                } catch (java.nio.channels.NonWritableChannelException e) {\n+                    \/\/ Expected exception\n+                    expectedEvents.add(IOEvent.createFileWriteEvent(-1, tmp));\n+                }\n+            }\n+\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+        }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestFileReadOnly.java","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,6 @@\n-        Recording recording = new Recording();\n-        List<IOEvent> expectedEvents = new ArrayList<>();\n+        try (Recording recording = new Recording()) {\n+            List<IOEvent> expectedEvents = new ArrayList<>();\n+            try(FileOutputStream fos = new FileOutputStream(tmp); FileInputStream fis = new FileInputStream(tmp);) {\n+                recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n@@ -56,4 +60,2 @@\n-        try(FileOutputStream fos = new FileOutputStream(tmp); FileInputStream fis = new FileInputStream(tmp);) {\n-            recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n-            recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n-            recording.start();\n+                int writeByte = 47;\n+                byte[] writeBuf = {11, 12, 13, 14};\n@@ -61,2 +63,7 @@\n-            int writeByte = 47;\n-            byte[] writeBuf = {11, 12, 13, 14};\n+                \/\/ Write\n+                fos.write(writeByte);\n+                expectedEvents.add(IOEvent.createFileWriteEvent(1, tmp));\n+                fos.write(writeBuf);\n+                expectedEvents.add(IOEvent.createFileWriteEvent(writeBuf.length, tmp));\n+                fos.write(writeBuf, 0, 2);\n+                expectedEvents.add(IOEvent.createFileWriteEvent(2, tmp));\n@@ -64,7 +71,4 @@\n-            \/\/ Write\n-            fos.write(writeByte);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(1, tmp));\n-            fos.write(writeBuf);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(writeBuf.length, tmp));\n-            fos.write(writeBuf, 0, 2);\n-            expectedEvents.add(IOEvent.createFileWriteEvent(2, tmp));\n+                \/\/ Read\n+                int readByte = fis.read();\n+                assertEquals(readByte, writeByte, \"Wrong byte read\");\n+                expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n@@ -72,4 +76,4 @@\n-            \/\/ Read\n-            int readByte = fis.read();\n-            assertEquals(readByte, writeByte, \"Wrong byte read\");\n-            expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n+                byte[] readBuf = new byte[writeBuf.length];\n+                long size = fis.read(readBuf);\n+                assertEquals(size, (long)writeBuf.length, \"Wrong size when reading byte[]\");\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n@@ -77,4 +81,3 @@\n-            byte[] readBuf = new byte[writeBuf.length];\n-            long size = fis.read(readBuf);\n-            assertEquals(size, (long)writeBuf.length, \"Wrong size when reading byte[]\");\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+                size = fis.read(readBuf, 0, 2);\n+                assertEquals(size, 2L, \"Wrong size when reading 2 bytes\");\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n@@ -82,3 +85,4 @@\n-            size = fis.read(readBuf, 0, 2);\n-            assertEquals(size, 2L, \"Wrong size when reading 2 bytes\");\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+                \/\/ We are at EOF. Read more and verify we get size -1.\n+                size = fis.read(readBuf);\n+                assertEquals(size, -1L, \"Size should be -1 at EOF\");\n+                expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n@@ -86,8 +90,4 @@\n-            \/\/ We are at EOF. Read more and verify we get size -1.\n-            size = fis.read(readBuf);\n-            assertEquals(size, -1L, \"Size should be -1 at EOF\");\n-            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-            recording.stop();\n-            List<RecordedEvent> events = Events.fromRecording(recording);\n-            IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestFileStreamEvents.java","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,0 @@\n-        \"java\/net\/SocketInputStream::read::([B)I\",\n@@ -111,1 +110,0 @@\n-        \"java\/net\/SocketOutputStream::write::([B)V\",\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,56 +52,57 @@\n-        Recording recording = new Recording();\n-        List<IOEvent> expectedEvents = new ArrayList<>();\n-\n-        recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n-        recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n-        recording.start();\n-\n-        RandomAccessFile ras = new RandomAccessFile(tmp, \"rw\");\n-        int writeInt = 47;\n-        byte[] writeBuffer = {10,11,12,13};\n-\n-        \/\/ Write an int and a buffer.\n-        ras.write(writeInt);\n-        expectedEvents.add(IOEvent.createFileWriteEvent(1, tmp));\n-        ras.write(writeBuffer);\n-        expectedEvents.add(IOEvent.createFileWriteEvent(writeBuffer.length, tmp));\n-\n-        ras.seek(0);\n-\n-        \/\/ Read int and buffer\n-        int readInt = ras.read();\n-        assertEquals(readInt, writeInt, \"wrong int read\");\n-        expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n-        byte[] readBuffer = new byte [writeBuffer.length];\n-        int size = ras.read(readBuffer);\n-        verifyBufferEquals(readBuffer, writeBuffer);\n-        expectedEvents.add(IOEvent.createFileReadEvent(readBuffer.length, tmp));\n-\n-        \/\/ Read beyond EOF\n-        readInt = ras.read();\n-        assertEquals(-1, readInt, \"wrong read after EOF\");\n-        expectedEvents.add(IOEvent.createFileReadEvent(-1, tmp));\n-\n-        \/\/ Seek to beginning and verify we can read after EOF.\n-        ras.seek(0);\n-        readInt = ras.read();\n-        assertEquals(readInt, writeInt, \"wrong int read after seek(0)\");\n-        expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n-\n-        \/\/ seek beyond EOF and verify we get EOF when reading.\n-        ras.seek(10);\n-        readInt = ras.read();\n-        assertEquals(-1, readInt, \"wrong read after seek beyond EOF\");\n-        expectedEvents.add(IOEvent.createFileReadEvent(-1, tmp));\n-\n-        \/\/ Read partial buffer.\n-        int partialSize = writeBuffer.length - 2;\n-        ras.seek(ras.length()-partialSize);\n-        size = ras.read(readBuffer);\n-        assertEquals(size, partialSize, \"Wrong size partial buffer read\");\n-        expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n-\n-        ras.close();\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-        IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+        try (Recording recording = new Recording()) {\n+            List<IOEvent> expectedEvents = new ArrayList<>();\n+\n+            recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n+            recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n+            recording.start();\n+\n+            RandomAccessFile ras = new RandomAccessFile(tmp, \"rw\");\n+            int writeInt = 47;\n+            byte[] writeBuffer = {10,11,12,13};\n+\n+            \/\/ Write an int and a buffer.\n+            ras.write(writeInt);\n+            expectedEvents.add(IOEvent.createFileWriteEvent(1, tmp));\n+            ras.write(writeBuffer);\n+            expectedEvents.add(IOEvent.createFileWriteEvent(writeBuffer.length, tmp));\n+\n+            ras.seek(0);\n+\n+            \/\/ Read int and buffer\n+            int readInt = ras.read();\n+            assertEquals(readInt, writeInt, \"wrong int read\");\n+            expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n+            byte[] readBuffer = new byte [writeBuffer.length];\n+            int size = ras.read(readBuffer);\n+            verifyBufferEquals(readBuffer, writeBuffer);\n+            expectedEvents.add(IOEvent.createFileReadEvent(readBuffer.length, tmp));\n+\n+            \/\/ Read beyond EOF\n+            readInt = ras.read();\n+            assertEquals(-1, readInt, \"wrong read after EOF\");\n+            expectedEvents.add(IOEvent.createFileReadEvent(-1, tmp));\n+\n+            \/\/ Seek to beginning and verify we can read after EOF.\n+            ras.seek(0);\n+            readInt = ras.read();\n+            assertEquals(readInt, writeInt, \"wrong int read after seek(0)\");\n+            expectedEvents.add(IOEvent.createFileReadEvent(1, tmp));\n+\n+            \/\/ seek beyond EOF and verify we get EOF when reading.\n+            ras.seek(10);\n+            readInt = ras.read();\n+            assertEquals(-1, readInt, \"wrong read after seek beyond EOF\");\n+            expectedEvents.add(IOEvent.createFileReadEvent(-1, tmp));\n+\n+            \/\/ Read partial buffer.\n+            int partialSize = writeBuffer.length - 2;\n+            ras.seek(ras.length()-partialSize);\n+            size = ras.read(readBuffer);\n+            assertEquals(size, partialSize, \"Wrong size partial buffer read\");\n+            expectedEvents.add(IOEvent.createFileReadEvent(size, tmp));\n+\n+            ras.close();\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            IOHelper.verifyEqualsInOrder(events, expectedEvents);\n+        }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestRandomAccessFileEvents.java","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,17 +67,11 @@\n-\n-        Recording recording = new Recording();\n-        recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n-        recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n-        recording.start();\n-\n-        TestThread writerThread = new TestThread(new XRun() {\n-            @Override\n-            public void xrun() throws IOException {\n-                final byte[] buf = new byte[OP_COUNT];\n-                for (int i = 0; i < buf.length; ++i) {\n-                    buf[i] = (byte)((i + 'a') % 255);\n-                }\n-                try (RandomAccessFile raf = new RandomAccessFile(tmp, \"rwd\")) {\n-                    for(int i = 0; i < OP_COUNT; ++i) {\n-                        raf.write(buf, 0, i + 1);\n-                        writeCount++;\n+        try (Recording recording = new Recording()) {\n+            recording.enable(IOEvent.EVENT_FILE_READ).withThreshold(Duration.ofMillis(0));\n+            recording.enable(IOEvent.EVENT_FILE_WRITE).withThreshold(Duration.ofMillis(0));\n+            recording.start();\n+\n+            TestThread writerThread = new TestThread(new XRun() {\n+                @Override\n+                public void xrun() throws IOException {\n+                    final byte[] buf = new byte[OP_COUNT];\n+                    for (int i = 0; i < buf.length; ++i) {\n+                        buf[i] = (byte)((i + 'a') % 255);\n@@ -85,2 +79,7 @@\n-                }\n-            }}, \"TestWriterThread\");\n+                    try (RandomAccessFile raf = new RandomAccessFile(tmp, \"rwd\")) {\n+                        for(int i = 0; i < OP_COUNT; ++i) {\n+                            raf.write(buf, 0, i + 1);\n+                            writeCount++;\n+                        }\n+                    }\n+                }}, \"TestWriterThread\");\n@@ -121,1 +120,1 @@\n-                if (Events.isEventType(event,IOEvent.EVENT_FILE_READ)) {\n+                if (Events.isEventType(event, IOEvent.EVENT_FILE_READ)) {\n@@ -139,0 +138,1 @@\n+    }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestRandomAccessFileThread.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+\n@@ -65,32 +66,33 @@\n-        Recording recording = new Recording();\n-\n-        try (ServerSocketChannel ss = ServerSocketChannel.open()) {\n-            recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n-            recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n-            recording.start();\n-\n-            ss.socket().setReuseAddress(true);\n-            ss.socket().bind(null);\n-\n-            TestThread readerThread = new TestThread(new XRun() {\n-                @Override\n-                public void xrun() throws IOException {\n-                    ByteBuffer bufA = ByteBuffer.allocate(bufSizeA);\n-                    ByteBuffer bufB = ByteBuffer.allocate(bufSizeB);\n-                    try (SocketChannel sc = ss.accept()) {\n-                        int readSize = sc.read(bufA);\n-                        assertEquals(readSize, bufSizeA, \"Wrong readSize bufA\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(bufSizeA, sc.socket()));\n-\n-                        bufA.clear();\n-                        bufA.limit(1);\n-                        readSize = (int)sc.read(new ByteBuffer[] { bufA, bufB });\n-                        assertEquals(readSize, 1 + bufSizeB, \"Wrong readSize 1+bufB\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(readSize, sc.socket()));\n-\n-                        \/\/ We try to read, but client have closed. Should get EOF.\n-                        bufA.clear();\n-                        bufA.limit(1);\n-                        readSize = sc.read(bufA);\n-                        assertEquals(readSize, -1, \"Wrong readSize at EOF\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(-1, sc.socket()));\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocketChannel ss = ServerSocketChannel.open()) {\n+                recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n+\n+                ss.socket().setReuseAddress(true);\n+                ss.socket().bind(null);\n+\n+                TestThread readerThread = new TestThread(new XRun() {\n+                    @Override\n+                    public void xrun() throws IOException {\n+                        ByteBuffer bufA = ByteBuffer.allocate(bufSizeA);\n+                        ByteBuffer bufB = ByteBuffer.allocate(bufSizeB);\n+                        try (SocketChannel sc = ss.accept()) {\n+                            int readSize = sc.read(bufA);\n+                            assertEquals(readSize, bufSizeA, \"Wrong readSize bufA\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bufSizeA, sc.socket()));\n+\n+                            bufA.clear();\n+                            bufA.limit(1);\n+                            readSize = (int) sc.read(new ByteBuffer[] { bufA, bufB });\n+                            assertEquals(readSize, 1 + bufSizeB, \"Wrong readSize 1+bufB\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(readSize, sc.socket()));\n+\n+                            \/\/ We try to read, but client have closed. Should\n+                            \/\/ get EOF.\n+                            bufA.clear();\n+                            bufA.limit(1);\n+                            readSize = sc.read(bufA);\n+                            assertEquals(readSize, -1, \"Wrong readSize at EOF\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(-1, sc.socket()));\n+                        }\n@@ -98,15 +100,14 @@\n-                }\n-            });\n-            readerThread.start();\n-\n-            try (SocketChannel sc = SocketChannel.open(ss.socket().getLocalSocketAddress())) {\n-                ByteBuffer bufA = ByteBuffer.allocateDirect(bufSizeA);\n-                ByteBuffer bufB = ByteBuffer.allocateDirect(bufSizeB);\n-                for (int i = 0; i < bufSizeA; ++i) {\n-                    bufA.put((byte)('a' + (i % 20)));\n-                }\n-                for (int i = 0; i < bufSizeB; ++i) {\n-                    bufB.put((byte)('A' + (i % 20)));\n-                }\n-                bufA.flip();\n-                bufB.flip();\n+                });\n+                readerThread.start();\n+\n+                try (SocketChannel sc = SocketChannel.open(ss.socket().getLocalSocketAddress())) {\n+                    ByteBuffer bufA = ByteBuffer.allocateDirect(bufSizeA);\n+                    ByteBuffer bufB = ByteBuffer.allocateDirect(bufSizeB);\n+                    for (int i = 0; i < bufSizeA; ++i) {\n+                        bufA.put((byte) ('a' + (i % 20)));\n+                    }\n+                    for (int i = 0; i < bufSizeB; ++i) {\n+                        bufB.put((byte) ('A' + (i % 20)));\n+                    }\n+                    bufA.flip();\n+                    bufB.flip();\n@@ -114,2 +115,2 @@\n-                sc.write(bufA);\n-                addExpectedEvent(IOEvent.createSocketWriteEvent(bufSizeA, sc.socket()));\n+                    sc.write(bufA);\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(bufSizeA, sc.socket()));\n@@ -117,6 +118,6 @@\n-                bufA.clear();\n-                bufA.limit(1);\n-                int bytesWritten = (int)sc.write(new ByteBuffer[] { bufA, bufB });\n-                assertEquals(bytesWritten, 1 + bufSizeB, \"Wrong bytesWritten 1+bufB\");\n-                addExpectedEvent(IOEvent.createSocketWriteEvent(bytesWritten, sc.socket()));\n-            }\n+                    bufA.clear();\n+                    bufA.limit(1);\n+                    int bytesWritten = (int) sc.write(new ByteBuffer[] { bufA, bufB });\n+                    assertEquals(bytesWritten, 1 + bufSizeB, \"Wrong bytesWritten 1+bufB\");\n+                    addExpectedEvent(IOEvent.createSocketWriteEvent(bytesWritten, sc.socket()));\n+                }\n@@ -124,4 +125,5 @@\n-            readerThread.joinAndThrow();\n-            recording.stop();\n-            List<RecordedEvent> events= Events.fromRecording(recording);\n-            IOHelper.verifyEquals(events, expectedEvents);\n+                readerThread.joinAndThrow();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEquals(events, expectedEvents);\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestSocketChannelEvents.java","additions":62,"deletions":60,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+\n@@ -67,45 +68,46 @@\n-        Recording recording = new Recording();\n-\n-        try (ServerSocket ss = new ServerSocket()) {\n-            recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n-            recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n-            recording.start();\n-\n-            ss.setReuseAddress(true);\n-            ss.bind(null);\n-\n-            TestThread readerThread = new TestThread(new XRun() {\n-                @Override\n-                public void xrun() throws IOException {\n-                    byte[] bs = new byte[4];\n-                    try (Socket s = ss.accept(); InputStream is = s.getInputStream()) {\n-                        int readInt = is.read();\n-                        assertEquals(readInt, writeInt, \"Wrong readInt\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(1, s));\n-\n-                        int bytesRead = is.read(bs, 0, 3);\n-                        assertEquals(bytesRead, 3, \"Wrong bytesRead partial buffer\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n-\n-                        bytesRead = is.read(bs);\n-                        assertEquals(bytesRead, writeBuf.length, \"Wrong bytesRead full buffer\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n-\n-                        \/\/ Try to read more, but writer have closed. Should get EOF.\n-                        readInt = is.read();\n-                        assertEquals(readInt, -1, \"Wrong readInt at EOF\");\n-                        addExpectedEvent(IOEvent.createSocketReadEvent(-1, s));\n-                   }\n-                }\n-            });\n-            readerThread.start();\n-\n-            try (Socket s = new Socket()) {\n-                s.connect(ss.getLocalSocketAddress());\n-                try (OutputStream os = s.getOutputStream()) {\n-                    os.write(writeInt);\n-                    addExpectedEvent(IOEvent.createSocketWriteEvent(1, s));\n-                    os.write(writeBuf, 0, 3);\n-                    addExpectedEvent(IOEvent.createSocketWriteEvent(3, s));\n-                    os.write(writeBuf);\n-                    addExpectedEvent(IOEvent.createSocketWriteEvent(writeBuf.length, s));\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocket ss = new ServerSocket()) {\n+                recording.enable(IOEvent.EVENT_SOCKET_READ).withThreshold(Duration.ofMillis(0));\n+                recording.enable(IOEvent.EVENT_SOCKET_WRITE).withThreshold(Duration.ofMillis(0));\n+                recording.start();\n+\n+                ss.setReuseAddress(true);\n+                ss.bind(null);\n+\n+                TestThread readerThread = new TestThread(new XRun() {\n+                    @Override\n+                    public void xrun() throws IOException {\n+                        byte[] bs = new byte[4];\n+                        try (Socket s = ss.accept(); InputStream is = s.getInputStream()) {\n+                            int readInt = is.read();\n+                            assertEquals(readInt, writeInt, \"Wrong readInt\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(1, s));\n+\n+                            int bytesRead = is.read(bs, 0, 3);\n+                            assertEquals(bytesRead, 3, \"Wrong bytesRead partial buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            bytesRead = is.read(bs);\n+                            assertEquals(bytesRead, writeBuf.length, \"Wrong bytesRead full buffer\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(bytesRead, s));\n+\n+                            \/\/ Try to read more, but writer have closed. Should\n+                            \/\/ get EOF.\n+                            readInt = is.read();\n+                            assertEquals(readInt, -1, \"Wrong readInt at EOF\");\n+                            addExpectedEvent(IOEvent.createSocketReadEvent(-1, s));\n+                        }\n+                    }\n+                });\n+                readerThread.start();\n+\n+                try (Socket s = new Socket()) {\n+                    s.connect(ss.getLocalSocketAddress());\n+                    try (OutputStream os = s.getOutputStream()) {\n+                        os.write(writeInt);\n+                        addExpectedEvent(IOEvent.createSocketWriteEvent(1, s));\n+                        os.write(writeBuf, 0, 3);\n+                        addExpectedEvent(IOEvent.createSocketWriteEvent(3, s));\n+                        os.write(writeBuf);\n+                        addExpectedEvent(IOEvent.createSocketWriteEvent(writeBuf.length, s));\n+                    }\n@@ -113,1 +115,0 @@\n-            }\n@@ -115,4 +116,5 @@\n-            readerThread.joinAndThrow();\n-            recording.stop();\n-            List<RecordedEvent> events = Events.fromRecording(recording);\n-            IOHelper.verifyEquals(events, expectedEvents);\n+                readerThread.joinAndThrow();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                IOHelper.verifyEquals(events, expectedEvents);\n+            }\n","filename":"jdk\/test\/jdk\/jfr\/event\/io\/TestSocketEvents.java","additions":53,"deletions":51,"binary":false,"changes":104,"status":"modified"}]}