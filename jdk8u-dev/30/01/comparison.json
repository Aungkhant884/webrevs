{"files":[{"patch":"@@ -2,3 +2,2 @@\n-\/\/ Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2014, 2019, Red Hat Inc.\n-\/\/ All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2014, 2022, Red Hat, Inc. All rights reserved.\n@@ -2239,0 +2238,40 @@\n+  static void loadStore(MacroAssembler masm, mem_insn insn,\n+                         Register reg, int opcode,\n+                         Register base, int index, int size, int disp,\n+                         int size_in_memory)\n+  {\n+    Address::extend scale;\n+\n+    \/\/ Hooboy, this is fugly.  We need a way to communicate to the\n+    \/\/ encoder that the index needs to be sign extended, so we have to\n+    \/\/ enumerate all the cases.\n+    switch (opcode) {\n+    case INDINDEXSCALEDOFFSETI2L:\n+    case INDINDEXSCALEDI2L:\n+    case INDINDEXSCALEDOFFSETI2LN:\n+    case INDINDEXSCALEDI2LN:\n+    case INDINDEXOFFSETI2L:\n+    case INDINDEXOFFSETI2LN:\n+      scale = Address::sxtw(size);\n+      break;\n+    default:\n+      scale = Address::lsl(size);\n+    }\n+\n+    if (index == -1) {\n+      Address addr(base, disp);\n+      \/* Fix up any out-of-range offsets. *\/\n+      assert_different_registers(rscratch1, base);\n+      assert_different_registers(rscratch1, reg);\n+      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n+      (masm.*insn)(reg, addr);\n+    } else {\n+      if (disp == 0) {\n+        (masm.*insn)(reg, Address(base, as_Register(index), scale));\n+      } else {\n+        masm.lea(rscratch1, Address(base, disp));\n+        (masm.*insn)(reg, Address(rscratch1, as_Register(index), scale));\n+      }\n+    }\n+  }\n+\n@@ -2327,0 +2366,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2333,0 +2374,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2339,0 +2382,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2345,0 +2390,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2351,0 +2398,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2357,0 +2406,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2363,0 +2414,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2369,0 +2422,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2375,0 +2430,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2381,0 +2438,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2387,0 +2446,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2393,0 +2454,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2399,0 +2462,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2405,0 +2470,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2411,0 +2478,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2417,0 +2486,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2423,0 +2494,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2429,0 +2502,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2435,0 +2510,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2441,0 +2518,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2448,0 +2527,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2451,1 +2532,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2454,0 +2535,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2457,1 +2540,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2460,0 +2543,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2463,1 +2548,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2466,0 +2551,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2469,1 +2556,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2472,0 +2559,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2483,1 +2572,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n@@ -2486,0 +2575,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2489,1 +2580,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n@@ -2492,0 +2583,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2498,0 +2591,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2504,0 +2599,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2510,0 +2607,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2516,0 +2615,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2521,1 +2622,1 @@\n-\n+ \n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/aarch64.ad","additions":111,"deletions":10,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1,3 +1,45 @@\n-define(choose, `loadStore($1, &MacroAssembler::$3, $2, $4,\n-               $5, $6, $7, $8);dnl\n-\n+dnl Copyright (c) 2014, 2022 Red Hat Inc. All rights reserved.\n+dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+dnl\n+dnl This code is free software; you can redistribute it and\/or modify it\n+dnl under the terms of the GNU General Public License version 2 only, as\n+dnl published by the Free Software Foundation.\n+dnl\n+dnl This code is distributed in the hope that it will be useful, but WITHOUT\n+dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+dnl version 2 for more details (a copy is included in the LICENSE file that\n+dnl accompanied this code).\n+dnl\n+dnl You should have received a copy of the GNU General Public License version\n+dnl 2 along with this work; if not, write to the Free Software Foundation,\n+dnl Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+dnl\n+dnl Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+dnl or visit www.oracle.com if you need additional information or have any\n+dnl questions.\n+dnl\n+dnl \n+dnl Process this file with m4 ad_encode.m4 to generate the load\/store\n+dnl patterns used in aarch64.ad.\n+dnl\n+dnl\n+dnl\n+define(LOAD,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    $3Register dst_reg = as_$3Register($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, dst_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(LOADV,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::$3,\n+       $mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -5,21 +47,3 @@\n-define(access, `\n-    $3Register $1_reg = as_$3Register($$1$$reg);\n-    $4choose(MacroAssembler(&cbuf), $1_reg,$2,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)')dnl\n-define(load,`\n-  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n-access(dst,$2,$3)')dnl\n-load(iRegI,ldrsbw)\n-load(iRegI,ldrsb)\n-load(iRegI,ldrb)\n-load(iRegL,ldrb)\n-load(iRegI,ldrshw)\n-load(iRegI,ldrsh)\n-load(iRegI,ldrh)\n-load(iRegL,ldrh)\n-load(iRegI,ldrw)\n-load(iRegL,ldrw)\n-load(iRegL,ldrsw)\n-load(iRegL,ldr)\n-load(vRegF,ldrs,Float)\n-load(vRegD,ldrd,Float)\n+dnl\n+dnl\n+dnl\n@@ -27,2 +51,10 @@\n-  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n-access(src,$2,$3,$4)')dnl\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    $3Register src_reg = as_$3Register($src$$reg);\n+    $4loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, src_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n@@ -30,0 +62,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -32,2 +66,56 @@\n-    choose(_masm,zr,$2,$mem->opcode(),\n-        as_$3Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)')dnl\n+    $4loadStore(_masm, &MacroAssembler::$2, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREL,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    $3Register src_reg = as_$3Register($src$$reg);\n+    $4loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, src_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $5);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREL0,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n+    MacroAssembler _masm(&cbuf);\n+    $4loadStore(_masm, &MacroAssembler::$2, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $5);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREV,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::$3,\n+       $mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+LOAD(iRegI,ldrsbw)\n+LOAD(iRegI,ldrsb)\n+LOAD(iRegI,ldrb)\n+LOAD(iRegL,ldrb)\n+LOAD(iRegI,ldrshw)\n+LOAD(iRegI,ldrsh)\n+LOAD(iRegI,ldrh)\n+LOAD(iRegL,ldrh)\n+LOAD(iRegI,ldrw)\n+LOAD(iRegL,ldrw)\n+LOAD(iRegL,ldrsw)\n+LOAD(iRegL,ldr)\n+LOAD(vRegF,ldrs,Float)\n+LOAD(vRegD,ldrd,Float)\n+LOADV(vecD,ldrvS,S)\n+LOADV(vecD,ldrvD,D)\n+LOADV(vecX,ldrvQ,Q)\n@@ -36,5 +124,15 @@\n-STORE(iRegI,strh)\n-STORE0(iRegI,strh)\n-STORE(iRegI,strw)\n-STORE0(iRegI,strw)\n-STORE(iRegL,str,,\n+\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n+    MacroAssembler _masm(&cbuf);\n+    __ membar(Assembler::StoreStore);\n+    loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}dnl\n+\n+STOREL(iRegI,strh,,,2)\n+STOREL0(iRegI,strh,,,2)\n+STOREL(iRegI,strw,,,4)\n+STOREL0(iRegI,strw,,,4)\n+STOREL(iRegL,str,,\n@@ -49,2 +147,2 @@\n-    ')\n-STORE0(iRegL,str)\n+    ',8)\n+STOREL0(iRegL,str,,,8)\n@@ -53,21 +151,3 @@\n-\n-  enc_class aarch64_enc_strw_immn(immN src, memory mem) %{\n-    MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    if (con) __ encode_heap_oop_not_null(rscratch2);\n-    choose(_masm,rscratch2,strw,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)\n-\n-  enc_class aarch64_enc_strw_immnk(immN src, memory mem) %{\n-    MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    __ encode_klass_not_null(rscratch2);\n-    choose(_masm,rscratch2,strw,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)\n-\n+STOREV(vecD,strvS,S)\n+STOREV(vecD,strvD,D)\n+STOREV(vecX,strvQ,Q)\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/ad_encode.m4","additions":136,"deletions":56,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import sun.misc.Unsafe;\n+import java.util.Random;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import static java.lang.Math.abs;\n+import static java.lang.Math.pow;\n+import static java.lang.Math.round;\n+import static java.math.BigInteger.TEN;\n+import java.lang.reflect.Field;\n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n+import static java.lang.String.format;\n+import static java.lang.System.arraycopy;\n+\n+\/* @test\n+ * @bug 8235385\n+ * @summary Verifies non-volatile memory access with long offset\n+ * @requires os.arch == \"aarch64\"\n+ *\/\n+public class NonVolatileMemoryAccessWithLongOffset {\n+    private static final Unsafe unsafe;\n+    static Random random = new Random();\n+\n+    static {\n+        Field f = null;\n+        try {\n+            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            unsafe = (Unsafe) f.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new Error(e);\n+        }\n+    }\n+    private static final int MAX_LENGTH = 10000;\n+\n+    private static byte[] input0 = new byte[MAX_LENGTH];\n+    private static byte[] input1 = new byte[MAX_LENGTH];\n+    private static final int MAX_VALUE_LENGTH = random.nextInt(200) + 20;\n+    private static final byte[] maxValue = new byte[MAX_VALUE_LENGTH];\n+    private static final byte[] minValue = new byte[MAX_VALUE_LENGTH];\n+    private static final int DECIMAL_MAX_VALUE_LENGTH = MAX_VALUE_LENGTH - 15;\n+    private static byte[] byteArray;\n+\n+    private static final    int valueType = random.nextInt(100);\n+    private static final    int numNulls = random.nextInt(100);\n+    private static final    int numRows = random.nextInt(100);\n+    private static final    int countDistinct = random.nextInt(100);\n+    private static final    long rawDataSize = (long)random.nextInt(100);\n+    private static final    long sum = (long)random.nextInt(1000);\n+    private static final    int version = random.nextInt(100);\n+\n+\n+    private static final    int dictOffset = random.nextInt(100);\n+    private static final    int dictLength = random.nextInt(100);\n+    private static final    int histOffset = random.nextInt(100);\n+    private static final    int histLength = random.nextInt(100);\n+    private static final    int dpnOffset = random.nextInt(100);\n+    private static final    int dpnCount = random.nextInt(100);\n+\n+    private static final    long maxRowCount = (long)random.nextInt(1000);\n+    private static final    long minRowCount = (long)random.nextInt(1000);\n+    private static final    long totalRowCount = (long)random.nextInt(100);\n+    private static final    long maxMemSize = (long)random.nextInt(1000);\n+    private static final    long minMemSize = (long)random.nextInt(100);\n+    private static final    long totalMemSize = (long)random.nextInt(1000);\n+\n+    private static final    long toastOffset = (long)random.nextInt(1000);\n+    private static final    boolean hasToast = random.nextInt(100) > 50;\n+\n+\n+    private static final int MAX_STRING_LENGTH = random.nextInt(300) + 20;\n+    private static final byte[] maxString = new byte[MAX_STRING_LENGTH];\n+    private static final byte[] minString = new byte[MAX_STRING_LENGTH];\n+    private static int maxStringLength = random.nextInt(100);\n+    private static int minStringLength = random.nextInt(100);\n+    private static final boolean maxStringIsNull = random.nextInt(100) > 20;\n+    private static final boolean minStringIsNull = random.nextInt(100) > 60;\n+\n+    private static final short precision = (short)random.nextInt(100);\n+    private static final short scale = (short)random.nextInt(100);\n+    private static final boolean    useShortCompressFloat = random.nextInt(100) > 60;\n+    private static final int SHORT_SIZE = 2;\n+    private static final int CHAR_SIZE = 2;\n+    private static final int INT_SIZE = 4;\n+    private static final int LONG_SIZE = 8;\n+    private static final int FLOAT_SIZE = 4;\n+    private static final int DOUBLE_SIZE = 8;\n+    private static final int    BOOLEAN_SIZE = 1;\n+\n+    private static void premitiveAssert(boolean flag) {\n+        if (flag == false) {\n+            throw new RuntimeException(\"overflow!\");\n+        }\n+    }\n+\n+    private static long BYTE_ARRAY_OFFSET = unsafe.ARRAY_BYTE_BASE_OFFSET;\n+\n+\n+    public static final void toBytes(short obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         SHORT_SIZE));\n+        unsafe.putShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(int obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n+        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(long obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n+        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(float obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         FLOAT_SIZE));\n+        unsafe.putFloat(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(double obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         DOUBLE_SIZE));\n+        unsafe.putDouble(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(char obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         CHAR_SIZE));\n+        unsafe.putChar(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         1));\n+        unsafe.putBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static int bytesSize() {\n+        return MAX_LENGTH;\n+    }\n+    static byte[] toBytesDup() {\n+        byte[] rawBytes = input1;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+\n+    static byte[] toBytes() {\n+        byte[] rawBytes = input0;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        \/\/if (version.getVersion() < DetailColumn.VERSION_EIGHT) {\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        long s = 0, s1 = 0;\n+        for (int i = 0; i < input0.length; i++) {\n+            input0[i] = 0;\n+            input1[i] = 0;\n+        }\n+        for (int i = 0; i < 100000; i++) {\n+            s += toBytes()[0];\n+            s1 += toBytesDup()[0];\n+            for (int j = 0; j < input0.length; j++) {\n+                if (input0[j] != input1[j]) {\n+                    throw new RuntimeException(\"not match!\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n","filename":"hotspot\/test\/compiler\/8235385\/NonVolatileMemoryAccessWithLongOffset.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"}]}