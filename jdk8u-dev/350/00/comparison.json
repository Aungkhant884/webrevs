{"files":[{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4422141 4695338\n+ * @summary TTY: .length field for arrays in print statements in jdb not recognized\n+ *          TTY: dump <ArrayReference> command not implemented.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/ArrayLengthDumpTest.sh\n+ *\n+ * @library \/lib\n+ * @build ArrayLengthDumpTest\n+ * @run main\/othervm ArrayLengthDumpTest\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\n+class ArrayLengthDumpTarg {\n+    static final int [] i = {0,1,2,3,4,5,6};\n+    String [] s = {\"zero\", \"one\", \"two\", \"three\", \"four\"};\n+    String [][] t = {s, s, s, s, s, s, s, s, s, s, s};\n+    int length = 5;\n+\n+    private void bar() {\n+    }\n+\n+    private void foo() {\n+        ArrayLengthDumpTarg u[] = { new ArrayLengthDumpTarg(),\n+                                    new ArrayLengthDumpTarg(),\n+                                    new ArrayLengthDumpTarg(),\n+                                    new ArrayLengthDumpTarg(),\n+                                    new ArrayLengthDumpTarg(),\n+                                    new ArrayLengthDumpTarg() };\n+        int k = u.length;\n+        System.out.println(\"        u.length is: \" + k);\n+        k = this.s.length;\n+        System.out.println(\"   this.s.length is: \" + k);\n+        k = this.t.length;\n+        System.out.println(\"   this.t.length is: \" + k);\n+        k = this.t[1].length;\n+        System.out.println(\"this.t[1].length is: \" + k);\n+        k = i.length;\n+        System.out.println(\"        i.length is: \" + k);\n+        bar();                      \/\/ @1 breakpoint\n+    }\n+\n+    public static void main(String[] args) {\n+        ArrayLengthDumpTarg my = new ArrayLengthDumpTarg();\n+        my.foo();\n+    }\n+}\n+\n+public class ArrayLengthDumpTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new ArrayLengthDumpTest().run();\n+    }\n+\n+    public ArrayLengthDumpTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = ArrayLengthDumpTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"ArrayLengthDumpTest.java\", 1);\n+\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        List<String> reply = new LinkedList<>();\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this.s.length\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this.s\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this.t.length\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this.t[1].length\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"ArrayLengthDumpTarg.i.length\")));\n+        reply.addAll(jdb.command(JdbCommand.dump(\"this.length\")));\n+\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                \/\/ Test the fix for 4690242:\n+                .shouldNotContain(\"No instance field or method with the name length in\")\n+                .shouldNotContain(\"No static field or method with the name length\")\n+                \/\/ Test the fix for 4695338:\n+                .shouldContain(\"\\\"zero\\\", \\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\"\");\n+\n+        jdb.contToExit(1);\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/ArrayLengthDumpTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -1,121 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4422141 4695338\n-#  @summary TTY: .length field for arrays in print statements in jdb not recognized\n-#           TTY: dump <ArrayReference> command not implemented.\n-#  @author Tim Bell\n-#\n-#  @run shell ArrayLengthDumpTest.sh\n-#\n-classname=ArrayLengthDumpTarg\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-class $classname {\n-    static final int [] i = {0,1,2,3,4,5,6};\n-    String [] s = {\"zero\", \"one\", \"two\", \"three\", \"four\"};\n-    String [][] t = {s, s, s, s, s, s, s, s, s, s, s};\n-    int length = 5;\n-\n-    public void bar() {\n-    }\n-\n-    public void foo() {\n-        ArrayLengthDumpTarg u[] = { new ArrayLengthDumpTarg(),\n-                                    new ArrayLengthDumpTarg(),\n-                                    new ArrayLengthDumpTarg(),\n-                                    new ArrayLengthDumpTarg(),\n-                                    new ArrayLengthDumpTarg(),\n-                                    new ArrayLengthDumpTarg() };\n-        int k = u.length;\n-        System.out.println(\"        u.length is: \" + k);\n-        k = this.s.length;\n-        System.out.println(\"   this.s.length is: \" + k);\n-        k = this.t.length;\n-        System.out.println(\"   this.t.length is: \" + k);\n-        k = this.t[1].length;\n-        System.out.println(\"this.t[1].length is: \" + k);\n-        k = i.length;\n-        System.out.println(\"        i.length is: \" + k);\n-        bar();                      \/\/ @1 breakpoint\n-    }\n-\n-    public static void main(String[] args) {\n-        ArrayLengthDumpTarg my = new ArrayLengthDumpTarg();\n-        my.foo();\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   setBkpts @1\n-   runToBkpt @1\n-   cmd dump this\n-   cmd dump this.s.length\n-   cmd dump this.s\n-   cmd dump this.t.length\n-   cmd dump this.t[1].length\n-   cmd dump ArrayLengthDumpTarg.i.length\n-   cmd dump this.length\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-#\n-# Test the fix for 4690242:\n-#\n-jdbFailIfPresent \"No instance field or method with the name length in\" 50\n-jdbFailIfPresent \"No static field or method with the name length\" 50\n-#\n-# Test the fix for 4695338:\n-#\n-jdbFailIfNotPresent \"\\\"zero\\\", \\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\"\" 50\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/ArrayLengthDumpTest.sh","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6862295\n+ * @summary Verify breakpoints still work after a full GC.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/BreakpointWithFullGC.sh\n+ *\n+ * @library \/lib\n+ * @compile -g BreakpointWithFullGC.java\n+ * @run main\/othervm BreakpointWithFullGC\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.Jdb;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class BreakpointWithFullGCTarg {\n+    public static List<Object> objList = new ArrayList<>();\n+\n+    private static void init(int numObjs) {\n+        for (int i = 0; i < numObjs; i++) {\n+            objList.add(new Object());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10; i++) {\n+            System.out.println(\"top of loop\");     \/\/ @1 breakpoint\n+            init(500000);\n+            objList.clear();\n+            System.gc();\n+            System.out.println(\"bottom of loop\");  \/\/ @1 breakpoint\n+        }\n+        System.out.println(\"end of test\");         \/\/ @1 breakpoint\n+    }\n+}\n+\n+public class BreakpointWithFullGC extends JdbTest {\n+    public static void main(String argv[]) {\n+        new BreakpointWithFullGC().run();\n+    }\n+\n+    private BreakpointWithFullGC() {\n+        super(new LaunchOptions(DEBUGGEE_CLASS)\n+                     .addDebuggeeOptions(DEBUGGEE_OPTIONS));\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = BreakpointWithFullGCTarg.class.getName();\n+    \/\/ We don't specify \"-Xmx\" for debuggee as we have full GCs with any value.\n+    private static final String[] DEBUGGEE_OPTIONS = {\"-verbose:gc\"};\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"BreakpointWithFullGC.java\", 1);\n+\n+        \/\/ get to the first loop breakpoint\n+        jdb.command(JdbCommand.run());\n+        \/\/ 19 \"cont\" commands gets us through all the loop breakpoints.\n+        for (int i = 1; i <= 19; i++) {\n+            jdb.command(JdbCommand.cont());\n+        }\n+        \/\/ get to the last breakpoint\n+        jdb.command(JdbCommand.cont());\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                \/\/ make sure we hit the first breakpoint at least once\n+                .stdoutShouldMatch(\"System\\\\..*top of loop\")\n+                \/\/ make sure we hit the second breakpoint at least once\n+                .stdoutShouldMatch(\"System\\\\..*bottom of loop\")\n+                \/\/ make sure we hit the last breakpoint\n+                .stdoutShouldMatch(\"System\\\\..*end of test\");\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                \/\/ check for error message due to thread ID change\n+                .stderrShouldNotContain(\"Exception in thread \\\"event-handler\\\" java.lang.NullPointerException\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/BreakpointWithFullGC.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -1,129 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2009, 2013 Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 6862295\n-#  @summary Verify breakpoints still work after a full GC.\n-#  @author dcubed (based on the test program posted to the following\n-#  Eclipse thread https:\/\/bugs.eclipse.org\/bugs\/show_bug.cgi?id=279137)\n-#\n-#  @run shell BreakpointWithFullGC.sh\n-\n-compileOptions=-g\n-# Hijacking the mode parameter to make sure we use a small amount\n-# of memory and can see what GC is doing.\n-mode=\"-Xmx32m -verbose:gc\"\n-# Force use of a GC framework collector to see the original failure.\n-#mode=\"$mode -XX:+UseSerialGC\"\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class $1 {\n-    public static List<Object> objList = new ArrayList<Object>();\n-\n-    private static void init(int numObjs) {\n-        for (int i = 0; i < numObjs; i++) {\n-            objList.add(new Object());\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 10; i++) {\n-            System.out.println(\"top of loop\");     \/\/ @1 breakpoint\n-            init(500000);\n-            objList.clear();\n-            System.gc();\n-            System.out.println(\"bottom of loop\");  \/\/ @1 breakpoint\n-        }\n-        System.out.println(\"end of test\");         \/\/ @1 breakpoint\n-    }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-\n-    # get to the first loop breakpoint\n-    runToBkpt\n-    # 19 \"cont\" commands gets us through all the loop breakpoints.\n-    # Use for-loop instead of while-loop to avoid creating processes\n-    # for '[' and 'expr'.\n-    for ii in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19; do\n-        contToBkpt\n-    done\n-    # get to the last breakpoint\n-    contToBkpt\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh\n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-# make sure we hit the first breakpoint at least once\n-jdbFailIfNotPresent 'System\\..*top of loop'\n-\n-# make sure we hit the second breakpoint at least once\n-jdbFailIfNotPresent 'System\\..*bottom of loop'\n-\n-# make sure we hit the last breakpoint\n-jdbFailIfNotPresent 'System\\..*end of test'\n-\n-# make sure we had at least one full GC\n-debuggeeFailIfNotPresent 'Full GC'\n-\n-# check for error message due to thread ID change\n-debuggeeFailIfPresent \\\n-    'Exception in thread \"event-handler\" java.lang.NullPointerException'\n-\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/BreakpointWithFullGC.sh","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4749692\n+ * @summary REGRESSION: jdb rejects the syntax catch java.lang.IndexOutOfBoundsException\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/CatchAllTest.sh\n+ *\n+ * @library \/lib\n+ * @build CatchAllTest\n+ * @run main\/othervm CatchAllTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class CatchAllTestTarg {\n+    public void bar() {\n+        System.out.println(\"bar\");        \/\/ @1 breakpoint\n+    }\n+\n+    public static void main(String[] args) {\n+        CatchAllTestTarg my = new CatchAllTestTarg();\n+        my.bar();\n+    }\n+}\n+\n+public class CatchAllTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new CatchAllTest().run();\n+    }\n+\n+    private CatchAllTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = CatchAllTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"CatchAllTest.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        final String IOOB = \"java.lang.IndexOutOfBoundsException\";\n+        jdb.command(JdbCommand.catch_(IOOB));\n+        jdb.command(JdbCommand.catch_(\"\"));\n+        jdb.command(JdbCommand.ignore(\"\"));\n+        jdb.command(JdbCommand.ignore(IOOB));\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.all, IOOB));\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.all, IOOB));\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.caught, IOOB));\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.caught, IOOB));\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.uncaught, IOOB));\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.uncaught, IOOB));\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"Usage: catch\")\n+                .shouldNotContain(\"Usage: ignore\");\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchAllTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,94 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4749692\n-#  @summary REGRESSION: jdb rejects the syntax catch java.lang.IndexOutOfBoundsException\n-#  @author Tim Bell\n-#\n-#  @run shell CatchAllTest.sh\n-#\n-classname=CatchAllTestTarg\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-class $classname {\n-    public void bar() {\n-        System.out.println(\"bar\");        \/\/ @1 breakpoint\n-    }\n-\n-    public static void main(String[] args) {\n-        CatchAllTestTarg my = new CatchAllTestTarg();\n-        my.bar();\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   setBkpts @1\n-   runToBkpt @1\n-   cmd catch           java.lang.IndexOutOfBoundsException\n-   cmd catch\n-   cmd ignore\n-   cmd ignore          java.lang.IndexOutOfBoundsException\n-   cmd catch  all      java.lang.IndexOutOfBoundsException\n-   cmd ignore all      java.lang.IndexOutOfBoundsException\n-   cmd catch  caught   java.lang.IndexOutOfBoundsException\n-   cmd ignore caught   java.lang.IndexOutOfBoundsException\n-   cmd catch  uncaught java.lang.IndexOutOfBoundsException\n-   cmd ignore uncaught java.lang.IndexOutOfBoundsException\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-#\n-jdbFailIfPresent \"Usage: catch\"\n-jdbFailIfPresent \"Usage: ignore\"\n-#\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchAllTest.sh","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4788864\n+ * @summary TTY: 'catch caught' with no class pattern throws NullPointerException\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/CatchCaughtTest.sh\n+ *\n+ * @library \/lib\n+ * @build CatchCaughtTest\n+ * @run main\/othervm CatchCaughtTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class CatchCaughtTestTarg {\n+    public void bar() {\n+        System.out.println(\"bar\");        \/\/ @1 breakpoint\n+    }\n+\n+    public static void main(String[] args) {\n+        CatchCaughtTestTarg my = new CatchCaughtTestTarg();\n+        my.bar();\n+    }\n+}\n+\n+public class CatchCaughtTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new CatchCaughtTest().run();\n+    }\n+\n+    private CatchCaughtTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = CatchCaughtTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"CatchCaughtTest.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.caught, \"\"));\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"Internal exception\")\n+                .shouldContain(\"Usage: catch\");\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchCaughtTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4788864\n-#  @summary TTY: 'catch caught' with no class pattern throws NullPointerException\n-#  @author Tim Bell\n-#\n-#  @run shell CatchCaughtTest.sh\n-#\n-classname=CatchCaughtTestTarg\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-class $classname {\n-    public void bar() {\n-        System.out.println(\"bar\");        \/\/ @1 breakpoint\n-    }\n-\n-    public static void main(String[] args) {\n-        CatchCaughtTestTarg my = new CatchCaughtTestTarg();\n-        my.bar();\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   setBkpts @1\n-   runToBkpt @1\n-   cmd catch caught\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-#\n-jdbFailIfPresent \"Internal exception\"\n-jdbFailIfNotPresent \"Usage: catch\"\n-#\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchCaughtTest.sh","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4671838\n+ * @summary TTY: surprising ExceptionSpec.resolveEventRequest() wildcard results\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/CatchPatternTest.sh\n+ *\n+ * @library \/lib\n+ * @build CatchPatternTest\n+ * @run main\/othervm CatchPatternTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class CatchPatternTestTarg {\n+    public void bark(int i) {\n+        System.out.println(\" bark: \" + i);\n+        switch (i) {\n+        case 0:\n+            throw new IllegalArgumentException(\"IllegalArgumentException\");\n+        case 1:\n+            throw new ArithmeticException(\"ArithmeticException\");\n+        case 2:\n+            throw new IllegalMonitorStateException(\"IllegalMonitorStateException\");\n+        case 3:\n+            throw new IndexOutOfBoundsException(\"IndexOutOfBoundsException\");\n+        default:\n+            throw new Error(\"should not happen\");\n+        }\n+    }\n+    public void loop(int max) {\n+        for (int i = 0; i <= max; i++) {\n+            try {\n+                bark(i);\n+            } catch(RuntimeException re) {\n+                System.out.println(\" loop: \" + re.getMessage() +\n+                       \" caught and ignored.\");\n+            }\n+        }\n+    }\n+    public void partOne() {\n+        loop(2);\n+        System.out.println(\"partOne completed\");\n+    }\n+    public void partTwo() {\n+        loop(3);\n+        System.out.println(\"partTwo completed\");\n+    }\n+    public static void main(String[] args) {\n+        System.out.println(\"Howdy!\");\n+        CatchPatternTestTarg my = new CatchPatternTestTarg();\n+        my.partOne();\n+        my.partTwo();\n+        System.out.println(\"Goodbye from CatchPatternTestTarg!\");\n+    }\n+}\n+\n+public class CatchPatternTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new CatchPatternTest().run();\n+    }\n+\n+    private CatchPatternTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = CatchPatternTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"main\"));\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"partTwo\"));\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.uncaught, \"java.lang.Throwable\"));\n+        \/\/ Instead of matching java.lang.I* we use two more specific\n+        \/\/ patterns here. The reason is to avoid matching IncompatibleClassChangeError\n+        \/\/ (or the subclass NoSuchMethodError) thrown by the\n+        \/\/ java.lang.invoke infrastructure.\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.all, \"java.lang.Il*\"));\n+        jdb.command(JdbCommand.catch_(JdbCommand.ExType.all, \"java.lang.Ind*\"));\n+        jdb.command(JdbCommand.cont());\n+        jdb.command(JdbCommand.cont());\n+        jdb.command(JdbCommand.cont());\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.all, \"java.lang.Ind*\"));\n+        jdb.command(JdbCommand.ignore(JdbCommand.ExType.all, \"java.lang.Il*\"));\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldContain(\"Exception occurred: java.lang.IllegalArgumentException\")\n+                .shouldContain(\"Exception occurred: java.lang.IllegalMonitorStateException\")\n+                .shouldNotContain(\"Exception occurred: ArithmeticException\")\n+                .shouldNotContain(\"Exception occurred: IndexOutOfBoundsException\")\n+                .shouldNotContain(\"Exception occurred: IllegalStateException\")\n+                .shouldNotContain(\"should not happen\");\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldContain(\"partOne completed\")\n+                .shouldContain(\"partTwo completed\");\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchPatternTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4671838\n-#  @summary TTY: surprising ExceptionSpec.resolveEventRequest() wildcard results\n-#  @author Tim Bell\n-#\n-#  @run shell CatchPatternTest.sh\n-classname=CatchPatternTestTarg\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-    public void bark(int i) {\n-        System.out.println(\" bark: \" + i);\n-        switch (i) {\n-        case 0:\n-            throw new IllegalArgumentException(\"IllegalArgumentException\");\n-        case 1:\n-            throw new ArithmeticException(\"ArithmeticException\");\n-        case 2:\n-            throw new IllegalMonitorStateException(\"IllegalMonitorStateException\");\n-        case 3:\n-            throw new IndexOutOfBoundsException(\"IndexOutOfBoundsException\");\n-        default:\n-            throw new Error(\"should not happen\");\n-        }\n-    }\n-    public void loop(int max) {\n-        for (int i = 0; i <= max; i++) {\n-            try {\n-                bark(i);\n-            } catch(RuntimeException re) {\n-                System.out.println(\" loop: \" + re.getMessage() +\n-                       \" caught and ignored.\");\n-            }\n-        }\n-    }\n-    public void partOne() {\n-        loop(2);\n-        System.out.println(\"partOne completed\");\n-    }\n-    public void partTwo() {\n-        loop(3);\n-        System.out.println(\"partTwo completed\");\n-    }\n-    public static void main(String[] args) {\n-        System.out.println(\"Howdy!\");\n-        $classname my = new $classname();\n-        my.partOne();\n-        my.partTwo();\n-        System.out.println(\"Goodbye from $classname!\");\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   #set -x\n-   cmd stop in ${classname}.main\n-   cmd stop in ${classname}.partTwo\n-   runToBkpt\n-   cmd ignore uncaught java.lang.Throwable\n-   cmd catch all java.lang.I*\n-   cmd cont\n-   cmd cont\n-   cmd cont\n-   cmd ignore all java.lang.I*\n-   cmd cont\n-   cmd quit\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-#\n-jdbFailIfNotPresent \"Exception occurred: java.lang.IllegalArgumentException\"\n-jdbFailIfNotPresent \"Exception occurred: java.lang.IllegalMonitorStateException\"\n-jdbFailIfPresent \"Exception occurred: ArithmeticException\"\n-jdbFailIfPresent \"Exception occurred: IndexOutOfBoundsException\"\n-jdbFailIfPresent \"Exception occurred: IllegalStateException\"\n-jdbFailIfPresent \"should not happen\"\n-debuggeeFailIfNotPresent \"partOne completed\"\n-debuggeeFailIfNotPresent \"partTwo completed\"\n-#\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/CatchPatternTest.sh","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4507088\n+ * @summary TTY: Add a comment delimiter to the jdb command set\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/CommandCommentDelimiter.sh\n+ *\n+ * @library \/lib\n+ * @build CommandCommentDelimiter\n+ * @run main\/othervm CommandCommentDelimiter\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class CommandCommentDelimiterTarg {\n+    public static void main(String args[]) {\n+        System.out.print  (\"Hello\");\n+        System.out.print  (\", \");\n+        System.out.print  (\"world\");\n+        System.out.println(\"!\");\n+    }\n+}\n+\n+\n+public class CommandCommentDelimiter extends JdbTest {\n+    public static void main(String argv[]) {\n+        new CommandCommentDelimiter().run();\n+    }\n+\n+    private CommandCommentDelimiter() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = CommandCommentDelimiterTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"main\"));\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.step());\n+        jdb.command(\"#\");\n+        jdb.command(\"#foo\");\n+        jdb.command(\"3 #blah\");\n+        jdb.command(\"# connectors\");\n+        jdb.command(JdbCommand.step());\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"Unrecognized command: '#'.  Try help...\")\n+                .shouldNotContain(\"Available connectors are\");\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/CommandCommentDelimiter.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4507088\n-#  @summary TTY: Add a comment delimiter to the jdb command set\n-#  @author Tim Bell\n-#  @run shell CommandCommentDelimiter.sh\n-#\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-    public static void main(String args[]) {\n-        System.out.print  (\"Hello\");\n-        System.out.print  (\", \");\n-        System.out.print  (\"world\");\n-        System.out.println(\"!\");\n-    }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   #set -x\n-   cmd stop in $classname.main\n-   runToBkpt\n-   cmd step\n-   cmd \\#\n-   cmd \\#foo\n-   cmd 3 \\#blah\n-   cmd \\# connectors\n-   cmd step\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfPresent \"Unrecognized command: '#'.  Try help...\" 50\n-jdbFailIfPresent \"Available connectors are\" 50\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/CommandCommentDelimiter.sh","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4525714\n+ * @summary jtreg test PopAsynchronousTest fails in build 85 with -Xcomp\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/DeoptimizeWalk.sh\n+ *\n+ * @library \/lib\n+ * @compile -g DeoptimizeWalk.java\n+ * @run main\/othervm DeoptimizeWalk\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\/*\n+ * The bug (JDK-4525714) is about failing PopAsynchronousTest test.\n+ * This is another test of the same issue. The bug occurs when trying\n+ * to walk the stack of a deoptimized thread. We can do this\n+ * by running in -Xcomp mode and by doing a step which causes deopt,\n+ * and then a 'where'. This will cause not all the frames to be shown.\n+ *\/\n+\n+class DeoptimizeWalkTarg {\n+    static public void main(String[] args) {\n+        DeoptimizeWalkTarg mine = new DeoptimizeWalkTarg();\n+        mine.a1(89);\n+    }\n+\n+    public void a1(int p1) {\n+        int v1 = 89;\n+        System.out.println(\"a1\" + v1);\n+        a2(89);\n+    }\n+\n+    public void a2(int pp) {\n+        int v2 = 89;\n+        System.out.println(\"a2\" + v2);\n+        a3(89);\n+    }\n+\n+    public void a3(int pp) {\n+        int v3 = 89;\n+        System.out.println(\"a3\");  \/\/@ 1 breakpoint\n+        a4(22);                  \/\/ it passes if this line is commented out\n+        System.out.println(\"jj\");\n+    }\n+\n+    public void a4(int pp) {\n+        int v4 = 90;\n+        System.out.println(\"a4: @1 breakpoint here\");\n+    }\n+}\n+\n+\n+public class DeoptimizeWalk extends JdbTest {\n+    public static void main(String argv[]) {\n+        new DeoptimizeWalk().run();\n+    }\n+\n+    private DeoptimizeWalk() {\n+        super(new LaunchOptions(DEBUGGEE_CLASS)\n+                .addDebuggeeOptions(DEBUGGEE_OPTIONS));\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = DeoptimizeWalkTarg.class.getName();\n+    private static final String[] DEBUGGEE_OPTIONS = {\"-Xcomp\"};\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"DeoptimizeWalk.java\", 1);\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.command(JdbCommand.step());\n+        jdb.command(JdbCommand.where(\"\"));\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldContain(DEBUGGEE_CLASS + \".main\");\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\");\n+    }\n+}\n+\n","filename":"jdk\/test\/com\/sun\/jdi\/DeoptimizeWalk.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -1,112 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4525714\n-#  @summary jtreg test PopAsynchronousTest fails in build 85 with -Xcomp\n-#  @author Jim Holmlund\/Swamy Venkataramanappa\n-#  @run shell DeoptimizeWalk.sh\n-\n-#  This is another test of the same bug.  The bug occurs when trying\n-#  to walk the stack of a deoptimized thread.  We can do this\n-#  by running in -Xcomp mode and by doing a step which causes deopt,\n-#  and then a 'where'.  This will cause not all the frames to be shown.\n-\n-compileOptions=-g\n-\n-echo \"*********** This test only fails with -Xcomp ***************\"\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-    static public void main(String[] args) {\n-       $1 mine = new $1();\n-       mine.a1(89);\n-    }\n-\n-    public void a1(int p1) {\n-      int v1 = 89;\n-      System.out.println(\"a1\" + v1);\n-      a2(89);\n-    }\n-\n-\n-    public void a2(int pp) {\n-      int v2 = 89;\n-      System.out.println(\"a2\" + v2);\n-      a3(89);\n-    }\n-\n-    public void a3(int pp) {\n-      int v3 = 89;\n-      System.out.println(\"a3\");  \/\/@ 1 breakpoint\n-      a4(22);                  \/\/ it passes if this line is commented out\n-      System.out.println(\"jj\");\n-    }\n-    \n-    public void a4(int pp) {\n-      int v4 = 90;\n-      System.out.println(\"a4: @1 breakpoint here\");\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    cmd where\n-    #cmd next\n-    cmd step\n-    cmd where\n-    cmd quit\n-    jdbFailIfNotPresent \"shtest\\.main\" 3\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/DeoptimizeWalk.sh","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4663146\n+ * @summary Arguments match no method error\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/EvalArgs.sh\n+ *\n+ * @library \/lib\n+ * @build EvalArgs\n+ * @run main\/othervm EvalArgs\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\/*\n+ * The bug is that, for example, if a String is passed\n+ * as an arg to a func where an Object is expected,\n+ * \"Arguments match no method\" error occurs. jdb doesn't notice that this is\n+ * legal because String is an instance of Object.\n+ *\/\n+\n+class EvalArgsTarg {\n+\n+    static jj1 myjj1;\n+    static jj2 myjj2;\n+    static oranges myoranges;\n+    static boolean jjboolean = true;\n+    static byte    jjbyte = 1;\n+    static char    jjchar = 'a';\n+    static double  jjdouble = 2.2;\n+    static float   jjfloat = 3.1f;\n+    static int     jjint = 4;\n+    static long    jjlong = 5;\n+    static short   jjshort = 6;\n+    static int[]   jjintArray = {7, 8};\n+    static float[] jjfloatArray = {9.1f, 10.2f};\n+\n+\n+    public static void main(String args[]) {\n+        myjj1 = new jj1();\n+        myjj2 = new jj2();\n+        myoranges = new oranges();\n+\n+        \/\/ prove that these work\n+        System.out.println( ffjj1(myjj1));\n+        System.out.println( ffjj1(myjj2));\n+\n+        System.out.println(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjboolean) = \" +\n+                            EvalArgsTarg.ffoverload(EvalArgsTarg.jjboolean));\n+        System.out.println(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjbyte) = \" +\n+                            EvalArgsTarg.ffoverload(EvalArgsTarg.jjbyte));\n+        System.out.println(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjchar) = \" +\n+                            EvalArgsTarg.ffoverload(EvalArgsTarg.jjchar));\n+        System.out.println(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjdouble) = \" +\n+                            EvalArgsTarg.ffoverload(EvalArgsTarg.jjdouble));\n+\n+        \/\/This doesn't even compile\n+        \/\/System.out.println( \"ffintArray(jjfloatArray) = \" + ffintArray(jjfloatArray));\n+        gus();\n+    }\n+\n+    static void gus() {\n+        int x = 0;             \/\/ @1 breakpoint\n+    }\n+\n+    public static String ffjj1(jj1 arg) {\n+        return arg.me;\n+    }\n+\n+    public static String ffjj2(jj2 arg) {\n+        return arg.me;\n+    }\n+\n+    static String ffboolean(boolean p1) {\n+        return \"ffbool: p1 = \" + p1;\n+    }\n+\n+    static String ffbyte(byte p1) {\n+        return \"ffbyte: p1 = \" + p1;\n+    }\n+\n+    static String ffchar(char p1) {\n+        return \"ffchar: p1 = \" + p1;\n+    }\n+\n+    static String ffdouble(double p1) {\n+        return \"ffdouble: p1 = \" + p1;\n+    }\n+\n+    static String fffloat(float p1) {\n+        return \"fffloat: p1 = \" + p1;\n+    }\n+\n+    static String ffint(int p1) {\n+        return \"ffint: p1 = \" + p1;\n+    }\n+\n+    static String fflong(long p1) {\n+        return \"fflong: p1 = \" + p1;\n+    }\n+\n+    static String ffshort(short p1) {\n+        return \"ffshort: p1 = \" + p1;\n+    }\n+\n+    static String ffintArray(int[] p1) {\n+        return \"ffintArray: p1 = \" + p1;\n+    }\n+\n+    \/\/ Overloaded funcs\n+    public static String ffoverload(jj1 arg) {\n+        return arg.me;\n+    }\n+\n+    static String ffoverload(boolean p1) {\n+        return \"ffoverload: boolean p1 = \" + p1;\n+    }\n+\/***\n+    static String ffoverload(byte p1) {\n+        return \"ffoverload: byte p1 = \" + p1;\n+    }\n+***\/\n+    static String ffoverload(char p1) {\n+        return \"ffoverload: char p1 = \" + p1;\n+    }\n+\n+    static String ffoverload(double p1) {\n+        return \"ffoverload: double p1 = \" + p1;\n+    }\n+\n+    static String ffoverload(float p1) {\n+        return \"ffoverload: float p1 = \" + p1;\n+    }\n+\/***\n+    static String ffoverload(int p1) {\n+        return \"ffoverload: int p1 = \" + p1;\n+    }\n+***\/\n+    static String ffoverload(long p1) {\n+        return \"ffoverload: long p1 = \" + p1;\n+    }\n+\n+    static String ffoverload(short p1) {\n+        return \"ffoverload: short p1 = \" + p1;\n+    }\n+\n+    static String ffoverload(int[] p1) {\n+        return \"ffoverload: int array p1 = \" + p1;\n+    }\n+\n+    static class jj1 {\n+        String me;\n+        jj1() {\n+            me = \"jj1name\";\n+        }\n+        public String toString() {\n+            return me;\n+        }\n+\n+    }\n+\n+    static class jj2 extends jj1 {\n+        jj2() {\n+            super();\n+            me = \"jj2name\";\n+        }\n+    }\n+\n+    static class oranges {\n+        oranges() {\n+        }\n+    }\n+}\n+\n+public class EvalArgs extends JdbTest {\n+    public static void main(String argv[]) {\n+        new EvalArgs().run();\n+    }\n+\n+    private EvalArgs() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = EvalArgsTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"EvalArgs.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        final String argsMatchNoMethod = \"Arguments match no method\";\n+        \/\/ verify that it works ok when arg types are the same as\n+        \/\/ the param types\n+        evalShouldNotContain(\"EvalArgsTarg.ffboolean(EvalArgsTarg.jjboolean)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffbyte(EvalArgsTarg.jjbyte)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffchar(EvalArgsTarg.jjchar)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffdouble(EvalArgsTarg.jjdouble)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.fffloat(EvalArgsTarg.jjfloat)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffint(EvalArgsTarg.jjint)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.fflong(EvalArgsTarg.jjlong)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffshort(EvalArgsTarg.jjshort)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffintArray(EvalArgsTarg.jjintArray)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffjj1(EvalArgsTarg.myjj1)\", argsMatchNoMethod);\n+\n+        \/\/ Provide a visual break in the output\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ Verify mixing primitive types works ok\n+        \/\/ These should work even though the arg types are\n+        \/\/ not the same because there is only one\n+        \/\/ method with each name.\n+        evalShouldNotContain(\"EvalArgsTarg.ffbyte(EvalArgsTarg.jjint)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffchar(EvalArgsTarg.jjdouble)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffdouble(EvalArgsTarg.jjfloat)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.fffloat(EvalArgsTarg.jjshort)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffint(EvalArgsTarg.jjlong)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.fflong(EvalArgsTarg.jjchar)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffshort(EvalArgsTarg.jjbyte)\", argsMatchNoMethod);\n+\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/  Verify that passing a subclass object works\n+        evalShouldNotContain(\"EvalArgsTarg.ffjj1(EvalArgsTarg.myjj2)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.myjj1.toString().equals(\\\"jj1name\\\")\", argsMatchNoMethod);\n+\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ Overloaded methods.  These should pass\n+        \/\/ because there is an exact  match.\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjboolean)\", argsMatchNoMethod);\n+\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjchar)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjdouble)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjfloat)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjlong)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjshort)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjintArray)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.myjj1)\", argsMatchNoMethod);\n+        evalShouldNotContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.myjj2)\", argsMatchNoMethod);\n+\n+        jdb.command(JdbCommand.print(\"1\"));\n+        jdb.command(JdbCommand.print(\"\\\"These should fail with msg Arguments match multiple methods\\\"\"));\n+\n+        \/\/ These overload calls should fail because there\n+        \/\/ isn't an exact match and jdb isn't smart  enough\n+        \/\/ to figure out which of several possibilities\n+        \/\/ should be called\n+        final String argsMatchMultipleMethods = \"Arguments match multiple methods\";\n+        evalShouldContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjbyte)\", argsMatchMultipleMethods);\n+\n+        evalShouldContain(\"EvalArgsTarg.ffoverload(EvalArgsTarg.jjint)\", argsMatchMultipleMethods);\n+\n+        jdb.command(JdbCommand.print(\"1\"));\n+        jdb.command(JdbCommand.print(\"\\\"These should fail with InvalidTypeExceptions\\\"\"));\n+\n+        final String invalidTypeException = \"InvalidTypeException\";\n+        evalShouldContain(\"EvalArgsTarg.ffboolean(EvalArgsTarg.jjbyte)\", invalidTypeException);\n+        evalShouldContain(\"EvalArgsTarg.ffintArray(EvalArgsTarg.jjint)\", invalidTypeException);\n+        evalShouldContain(\"EvalArgsTarg.ffintArray(EvalArgsTarg.jjfloatArray)\", invalidTypeException);\n+        evalShouldContain(\"EvalArgsTarg.ffjj2(EvalArgsTarg.myjj1)\", invalidTypeException);\n+        evalShouldContain(\"EvalArgsTarg.ffjj2(EvalArgsTarg.myoranges)\", invalidTypeException);\n+\n+        jdb.contToExit(1);\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalArgs.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -1,318 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4663146\n-#  @summary Arguments match no method error \n-#  @author Jim Holmlund\/Suvasis\n-#\n-#  @run shell\/timeout=300 EvalArgs.sh\n-\n-#  The bug is that, for example, if a String is passed\n-#  as an arg to a func where an Object is expected,\n-#  the above error occurs.  jdb doesnt notice that this is\n-#  legal because String is an instance of Object.\n-\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-classname=EvalArgs\n-#compileOptions=-g\n-#java=\"java_g\"\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-\n-    static jj1 myjj1;\n-    static jj2 myjj2;\n-    static oranges myoranges;\n-    static boolean jjboolean = true;\n-    static byte    jjbyte = 1;\n-    static char    jjchar = 'a';\n-    static double  jjdouble = 2.2;\n-    static float   jjfloat = 3.1f;\n-    static int     jjint = 4;\n-    static long    jjlong = 5;\n-    static short   jjshort = 6;\n-    static int[]   jjintArray = {7, 8};\n-    static float[] jjfloatArray = {9.1f, 10.2f};\n-\n-\n-    public static void main(String args[]) {\n-        myjj1 = new jj1();\n-        myjj2 = new jj2();\n-        myoranges = new oranges();\n-\n-        \/\/ prove that these work\n-        System.out.println( ffjj1(myjj1));\n-        System.out.println( ffjj1(myjj2));\n-\n-        System.out.println(\"$classname.ffoverload($classname.jjboolean) = \" + \n-                            $classname.ffoverload($classname.jjboolean));\n-        System.out.println(\"$classname.ffoverload($classname.jjbyte) = \" + \n-                            $classname.ffoverload($classname.jjbyte));\n-        System.out.println(\"$classname.ffoverload($classname.jjchar) = \" + \n-                            $classname.ffoverload($classname.jjchar));\n-        System.out.println(\"$classname.ffoverload($classname.jjdouble) = \" + \n-                            $classname.ffoverload($classname.jjdouble));\n-\n-\n-        \/\/This doesn't even compile\n-        \/\/System.out.println( \"ffintArray(jjfloatArray) = \" + ffintArray(jjfloatArray));\n-        gus();\n-    }\n-\n-    static void gus() {\n-        int x = 0;             \/\/ @1 breakpoint\n-    }\n-\n-    public static String ffjj1(jj1 arg) {\n-        return arg.me;\n-    }\n-    \n-    public static String ffjj2(jj2 arg) {\n-        return arg.me;\n-    }\n-    \n-    static String ffboolean(boolean p1) {\n-        return \"ffbool: p1 = \" + p1;\n-    }\n-\n-    static String ffbyte(byte p1) {\n-        return \"ffbyte: p1 = \" + p1;\n-    }\n-        \n-    static String ffchar(char p1) {\n-        return \"ffchar: p1 = \" + p1;\n-    }\n-        \n-    static String ffdouble(double p1) {\n-        return \"ffdouble: p1 = \" + p1;\n-    }\n-        \n-    static String fffloat(float p1) {\n-        return \"fffloat: p1 = \" + p1;\n-    }\n-        \n-    static String ffint(int p1) {\n-        return \"ffint: p1 = \" + p1;\n-    }\n-        \n-    static String fflong(long p1) {\n-        return \"fflong: p1 = \" + p1;\n-    }\n-        \n-    static String ffshort(short p1) {\n-        return \"ffshort: p1 = \" + p1;\n-    }\n-        \n-    static String ffintArray(int[] p1) {\n-        return \"ffintArray: p1 = \" + p1;\n-    }\n-\n-    \/\/ Overloaded funcs\n-    public static String ffoverload(jj1 arg) {\n-        return arg.me;\n-    }\n-    \n-    static String ffoverload(boolean p1) {\n-        return \"ffoverload: boolean p1 = \" + p1;\n-    }\n-\/***        \n-    static String ffoverload(byte p1) {\n-        return \"ffoverload: byte p1 = \" + p1;\n-    }\n-***\/        \n-    static String ffoverload(char p1) {\n-        return \"ffoverload: char p1 = \" + p1;\n-    }\n-\n-    static String ffoverload(double p1) {\n-        return \"ffoverload: double p1 = \" + p1;\n-    }\n-\n-    static String ffoverload(float p1) {\n-        return \"ffoverload: float p1 = \" + p1;\n-    }\n-\/***        \n-    static String ffoverload(int p1) {\n-        return \"ffoverload: int p1 = \" + p1;\n-    }\n-***\/        \n-    static String ffoverload(long p1) {\n-        return \"ffoverload: long p1 = \" + p1;\n-    }\n-\n-    static String ffoverload(short p1) {\n-        return \"ffoverload: short p1 = \" + p1;\n-    }\n-      \n-    static String ffoverload(int[] p1) {\n-        return \"ffoverload: int array p1 = \" + p1;\n-    }\n-\n-  static class jj1 {\n-    String me;\n-    jj1() {\n-        me = \"jj1name\";\n-    }\n-    public String toString() {\n-        return me;\n-    }\n-    \n-  }\n-\n-  static class jj2 extends jj1 {\n-    jj2() {\n-        super();\n-        me = \"jj2name\";\n-    }\n-  }\n-\n-  static class oranges {\n-    oranges() {\n-    }\n-  }\n-}\n-\n-\n-\n-EOF\n-}\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-\n-    # verify that it works ok when arg types are the same as\n-    # the param types\n-    cmd eval \"$classname.ffboolean($classname.jjboolean)\"\n-    cmd eval \"$classname.ffbyte($classname.jjbyte)\"\n-    cmd eval \"$classname.ffchar($classname.jjchar)\"\n-    cmd eval \"$classname.ffdouble($classname.jjdouble)\"\n-    cmd eval \"$classname.fffloat($classname.jjfloat)\"\n-    cmd eval \"$classname.ffint($classname.jjint)\"\n-    cmd eval \"$classname.fflong($classname.jjlong)\"\n-    cmd eval \"$classname.ffshort($classname.jjshort)\"\n-    cmd eval \"$classname.ffintArray($classname.jjintArray)\"\n-    cmd eval \"$classname.ffjj1($classname.myjj1)\"\n-\n-    # Provide a visual break in the output\n-    cmd print 1\n-\n-    # Verify mixing primitive types works ok \n-    # These should work even though the arg types are\n-    # not the same because there is only one\n-    # method with each name.\n-    cmd eval \"$classname.ffbyte($classname.jjint)\"\n-    cmd eval \"$classname.ffchar($classname.jjdouble)\"\n-    cmd eval \"$classname.ffdouble($classname.jjfloat)\"\n-    cmd eval \"$classname.fffloat($classname.jjshort)\"\n-    cmd eval \"$classname.ffint($classname.jjlong)\"\n-    cmd eval \"$classname.fflong($classname.jjchar)\"\n-    cmd eval \"$classname.ffshort($classname.jjbyte)\"\n-\n-    cmd print 1\n-\n-    # Verify that passing a subclass object works\n-    cmd eval \"$classname.ffjj1($classname.myjj2)\"\n-    cmd eval \"$classname.myjj1.toString().equals(\"jj1name\")\"\n-\n-    cmd print 1\n-\n-    # Overloaded methods.  These should pass\n-    # because there is an exact  match.\n-    cmd eval \"$classname.ffoverload($classname.jjboolean)\"\n-\n-    cmd eval \"$classname.ffoverload($classname.jjchar)\"\n-    cmd eval \"$classname.ffoverload($classname.jjdouble)\"\n-    cmd eval \"$classname.ffoverload($classname.jjfloat)\"\n-    cmd eval \"$classname.ffoverload($classname.jjlong)\"\n-    cmd eval \"$classname.ffoverload($classname.jjshort)\"\n-    cmd eval \"$classname.ffoverload($classname.jjintArray)\"\n-    cmd eval \"$classname.ffoverload($classname.myjj1)\"\n-    cmd eval \"$classname.ffoverload($classname.myjj2)\"\n-    jdbFailIfPresent \"Arguments match no method\"\n-\n-    cmd print 1\n-    cmd print '\"These should fail with msg Arguments match multiple methods\"'\n-\n-    # These overload calls should fail because ther\n-    # isn't an exact match and jdb isn't smart  enough\n-    # to figure out which of several possibilities\n-    # should be called\n-    cmd eval \"$classname.ffoverload($classname.jjbyte)\"\n-    jdbFailIfNotPresent \"Arguments match multiple methods\" 3\n-\n-    cmd eval \"$classname.ffoverload($classname.jjint)\"\n-    jdbFailIfNotPresent \"Arguments match multiple methods\" 3\n-\n-    cmd print 1\n-    cmd print '\"These should fail with InvalidTypeExceptions\"'\n-\n-    cmd eval \"$classname.ffboolean($classname.jjbyte)\"\n-    jdbFailIfNotPresent \"InvalidTypeException\" 3\n-\n-    cmd eval \"$classname.ffintArray($classname.jjint)\"\n-    jdbFailIfNotPresent \"InvalidTypeException\" 3\n-\n-    cmd eval \"$classname.ffintArray($classname.jjfloatArray)\"\n-    jdbFailIfNotPresent \"InvalidTypeException\" 3\n-\n-    cmd eval \"$classname.ffjj2($classname.myjj1)\"\n-    jdbFailIfNotPresent \"InvalidTypeException\" 3\n-\n-    cmd eval \"$classname.ffjj2($classname.myoranges)\"\n-    jdbFailIfNotPresent \"InvalidTypeException\" 3\n-\n-    cmd quit \n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalArgs.sh","additions":0,"deletions":318,"binary":false,"changes":318,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8160024\n+ * @summary jdb returns invalid argument count if first parameter to Arrays.asList is null\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/EvalArraysAsList.sh\n+ *\n+ * @library \/lib\n+ * @build EvalArraysAsList\n+ * @run main\/othervm EvalArraysAsList\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\/*\n+ * The test checks if evaluation of the expression java.util.Arrays.asList(null, \"a\")\n+ * works normally and does not throw an IllegalArgumentException.\n+ *\/\n+class EvalArraysAsListTarg {\n+    public static void main(String[] args) {\n+        java.util.List<Object> l = java.util.Arrays.asList(null, \"a\");\n+        System.out.println(\"java.util.Arrays.asList(null, \\\"a\\\") returns: \" + l);\n+        return;    \/\/ @1 breakpoint\n+    }\n+}\n+\n+\n+public class EvalArraysAsList extends JdbTest {\n+    public static void main(String argv[]) {\n+        new EvalArraysAsList().run();\n+    }\n+\n+    private EvalArraysAsList() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = EvalArraysAsListTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"EvalArraysAsList.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        final String illegalArgumentException = \"IllegalArgumentException\";\n+\n+        evalShouldNotContain(\"java.util.Arrays.asList(null, null)\", illegalArgumentException);\n+\n+        evalShouldNotContain(\"java.util.Arrays.asList(null, \\\"a\\\")\", illegalArgumentException);\n+\n+        evalShouldNotContain(\"java.util.Arrays.asList(\\\"a\\\", null)\", illegalArgumentException);\n+\n+        jdb.contToExit(1);\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalArraysAsList.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-#!\/bin\/sh\n-#\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 8160024\n-#  @summary jdb returns invalid argument count if first parameter to Arrays.asList is null\n-#\n-#  @run shell\/timeout=300 EvalArraysAsList.sh\n-#\n-#  The test checks if evaluation of the expression java.util.Arrays.asList(null, \"a\")\n-#  works normally and does not throw an IllegalArgumentException.\n-\n-classname=EvalArraysAsList\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-    public static void main(String[] args) {\n-        java.util.List<Object> l = java.util.Arrays.asList(null, \"a\");\n-        System.out.println(\"java.util.Arrays.asList(null, \\\\\"a\\\\\") returns: \" + l);\n-        return;    \/\/ @1 breakpoint\n-    }\n-}\n-EOF\n-}\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-\n-    cmd eval \"java.util.Arrays.asList(null, null)\"\n-    jdbFailIfPresent \"IllegalArgumentException\" 3\n-\n-    cmd eval \"java.util.Arrays.asList(null, \\\"a\\\")\"\n-    jdbFailIfPresent \"IllegalArgumentException\" 3\n-\n-    cmd eval \"java.util.Arrays.asList(\\\"a\\\", null)\"\n-    jdbFailIfPresent \"IllegalArgumentException\" 3\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh\n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalArraysAsList.sh","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8031195\n+ * @summary JDB allows evaluation of calls to static interface methods\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/EvalInterfaceStatic.sh\n+ *\n+ * @library \/lib\n+ * @build EvalInterfaceStatic\n+ * @run main\/othervm EvalInterfaceStatic\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\/*\n+ * The test exercises the ability to invoke static methods on interfaces.\n+ * Static interface methods are a new feature added in JDK8.\n+ *\n+ * The test makes sure that it is possible to invoke an interface\n+ * static method and that the static methods are not inherited by extending\n+ * interfaces.\n+ *\/\n+interface EvalStaticInterfaces {\n+    static String staticMethod1() {\n+        return \"base:staticMethod1\";\n+    }\n+\n+    static String staticMethod2() {\n+        return \"base:staticMethod2\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ prove that these work\n+        System.out.println(\"base staticMethod1(): \" + EvalStaticInterfaces.staticMethod1());\n+        System.out.println(\"base staticMethod2(): \" + EvalStaticInterfaces.staticMethod2());\n+        System.out.println(\"overridden staticMethod2(): \" + ExtendedEvalStaticInterfaces.staticMethod2());\n+        System.out.println(\"base staticMethod3(): \" + ExtendedEvalStaticInterfaces.staticMethod3());\n+\n+        gus();\n+    }\n+\n+    static void gus() {\n+        int x = 0;             \/\/ @1 breakpoint\n+    }\n+}\n+\n+interface ExtendedEvalStaticInterfaces extends EvalStaticInterfaces {\n+    static String staticMethod2() {\n+        return \"extended:staticMethod2\";\n+    }\n+\n+    static String staticMethod3() {\n+        return \"extended:staticMethod3\";\n+    }\n+}\n+\n+\n+public class EvalInterfaceStatic extends JdbTest {\n+    public static void main(String argv[]) {\n+        new EvalInterfaceStatic().run();\n+    }\n+\n+    private EvalInterfaceStatic() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = EvalStaticInterfaces.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"EvalInterfaceStatic.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        evalShouldContain(\"EvalStaticInterfaces.staticMethod1()\", \"base:staticMethod1\");\n+\n+        evalShouldContain(\"EvalStaticInterfaces.staticMethod2()\", \"base:staticMethod2\");\n+\n+        evalShouldNotContain(\"ExtendedEvalStaticInterfaces.staticMethod1()\", \"base:staticMethod1\");\n+\n+        evalShouldContain(\"ExtendedEvalStaticInterfaces.staticMethod2()\", \"extended:staticMethod2\");\n+\n+        evalShouldContain(\"ExtendedEvalStaticInterfaces.staticMethod3()\", \"extended:staticMethod3\");\n+\n+        jdb.contToExit(1);\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalInterfaceStatic.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -1,126 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 8031195\n-#  @summary JDB allows evaluation of calls to static interface methods\n-#  @author Jaroslav Bachorik\n-#\n-#  @run shell\/timeout=300 EvalInterfaceStatic.sh\n-\n-#  The test exercises the ability to invoke static methods on interfaces.\n-#  Static interface methods are a new feature added in JDK8.\n-#\n-#  The test makes sure that it is, at all, possible to invoke an interface\n-#  static method and that the static methods are not inherited by extending\n-#  interfaces.\n-\n-classname=EvalStaticInterfaces\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public interface $classname {\n-    static String staticMethod1() {\n-        return \"base:staticMethod1\";\n-    }\n-\n-    static String staticMethod2() {\n-        return \"base:staticMethod2\";\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ prove that these work\n-        System.out.println(\"base staticMethod1(): \" + $classname.staticMethod1());\n-        System.out.println(\"base staticMethod2(): \" + $classname.staticMethod2());\n-        System.out.println(\"overridden staticMethod2(): \" + Extended$classname.staticMethod2());\n-        System.out.println(\"base staticMethod3(): \" + Extended$classname.staticMethod3());\n-\n-        gus();\n-    }\n-\n-    static void gus() {\n-        int x = 0;             \/\/ @1 breakpoint\n-    }\n-}\n-\n-interface Extended$classname extends $classname {\n-    static String staticMethod2() {\n-        return \"extended:staticMethod2\";\n-    }\n-\n-    static String staticMethod3() {\n-        return \"extended:staticMethod3\";\n-    }\n-}\n-\n-\n-\n-EOF\n-}\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-\n-    cmd eval \"$classname.staticMethod1()\"\n-    jdbFailIfNotPresent \"base:staticMethod1\" 2\n-\n-    cmd eval \"$classname.staticMethod2()\"\n-    jdbFailIfNotPresent \"base:staticMethod2\" 2\n-\n-    cmd eval \"Extended$classname.staticMethod1()\"\n-    jdbFailIfPresent \"base:staticMethod1\" 2\n-\n-    cmd eval \"Extended$classname.staticMethod2()\"\n-    jdbFailIfNotPresent \"extended:staticMethod2\" 2\n-\n-    cmd eval \"Extended$classname.staticMethod3()\"\n-    jdbFailIfNotPresent \"extended:staticMethod3\" 2\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh\n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/EvalInterfaceStatic.sh","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4448658\n+ * @summary javac produces the inconsistent variable debug in while loops.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/GetLocalVariables3Test.sh\n+ *\n+ * @library \/lib\n+ * @compile -g GetLocalVariables3Test.java\n+ * @run main\/othervm GetLocalVariables3Test\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\n+class GetLocalVariables3Targ {\n+    public static void main(String[] args) {\n+        System.out.println(\"Howdy!\");\n+        int i = 1, j, k;\n+        while ((j = i) > 0) {\n+            k = j; i = k - 1;    \/\/ @1 breakpoint\n+        }\n+        System.out.println(\"Goodbye from GetLocalVariables3Targ!\");\n+    }\n+}\n+\n+\n+public class GetLocalVariables3Test extends JdbTest {\n+    public static void main(String argv[]) {\n+        new GetLocalVariables3Test().run();\n+    }\n+\n+    private GetLocalVariables3Test() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = GetLocalVariables3Targ.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"GetLocalVariables3Test.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.locals());\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldContain(\"j = 1\");\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldContain(\"Howdy\")\n+                .shouldContain(\"Goodbye from GetLocalVariables3Targ\");\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/GetLocalVariables3Test.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4448658\n-#  @summary javac produces the inconsistent variable debug in while loops.\n-#  @author Tim Bell\n-#\n-#  @run shell GetLocalVariables3Test.sh\n-#\n-classname=GetLocalVariables3Targ\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class GetLocalVariables3Targ {\n-    public static void main(String[] args) {\n-        System.out.println(\"Howdy!\");\n-        int i = 1, j, k;\n-        while ((j = i) > 0) {\n-            k = j; i = k - 1;    \/\/ @1 breakpoint\n-        }\n-        System.out.println(\"Goodbye from GetLocalVariables3Targ!\");\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   setBkpts @1\n-   runToBkpt @1\n-   cmd locals\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    compileOptions=\"-g\"\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-mysetup\n-\n-runit\n-jdbFailIfNotPresent \"j = 1\"\n-debuggeeFailIfNotPresent \"Howdy\"\n-debuggeeFailIfNotPresent \"Goodbye from GetLocalVariables3Targ\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/GetLocalVariables3Test.sh","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4847812\n+ * @summary TTY: jdb lock command displays incorrect data\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/JdbLockTest.sh\n+ *\n+ * @library \/lib\n+ * @compile -g JdbLockTest.java\n+ * @run main\/othervm JdbLockTest\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class JdbLockTestTarg {\n+    static String jj = \"jj\";\n+    public static void main(String args[]) {\n+        synchronized(jj) {\n+            sleeper xx = new sleeper();\n+            xx.start();\n+            \/\/ Give the sleeper a chance to run and get to\n+            \/\/ the synchronized statement.\n+            while(sleeper.started == 0) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch(InterruptedException ee) {\n+                }\n+            }\n+            \/\/ At this bkpt, sleeper should be waiting on $classname.jj\n+            System.out.println(\"Hello sailor\");    \/\/ @1 breakpoint\n+        }\n+    }\n+}\n+\n+class sleeper extends Thread {\n+    public static int started = 0;\n+    public void run() {\n+        started = 1;\n+        System.out.println(\"     sleeper starts sleeping\");\n+        synchronized(JdbLockTestTarg.jj) {\n+            System.out.println(\"     sleeper got the lock\");\n+        }\n+        System.out.println(\"     sleeper awakes\");\n+    }\n+}\n+\n+public class JdbLockTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new JdbLockTest().run();\n+    }\n+\n+    private JdbLockTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = JdbLockTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"JdbLockTest.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        \/\/ This should say that main owns the lock\n+        \/\/ and the sleeper thread is waiting for it.\n+        execCommand(JdbCommand.lock(\"JdbLockTestTarg.jj\"))\n+                .shouldNotContain(\"Waiting thread: main\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbLockTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -1,110 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4847812\n-#  @summary TTY: jdb lock command displays incorrect data\n-#  @author Jim Holmlund\n-#  @run shell JdbLockTest.sh\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-classname=JdbLockTest\n-compileOptions=-g\n-#java=\"java_g\"\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-    static String jj = \"jj\";\n-    public static void main(String args[]) {\n-        synchronized(jj) {\n-            sleeper xx = new sleeper();\n-            xx.start();\n-            \/\/ Give the sleeper a chance to run and get to\n-            \/\/ the synchronized statement.\n-            while(sleeper.started == 0) {\n-                try {\n-                    Thread.sleep(100);\n-                } catch(InterruptedException ee) {\n-                }\n-            }\n-            \/\/ At this bkpt, sleeper should be waiting on $classname.jj\n-            System.out.println(\"Hello sailor\");    \/\/ @1 breakpoint\n-        }\n-    }\n-}\n-\n-class sleeper extends Thread {\n-    public static int started = 0;\n-    public void run() {\n-        started = 1;\n-        System.out.println(\"     sleeper starts sleeping\");\n-        synchronized($classname.jj) {\n-            System.out.println(\"     sleeper got the lock\");\n-        }\n-        System.out.println(\"     sleeper awakes\");\n-    }\n-}\n-\n-EOF\n-}\n-\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    # This should say that main owns the lock\n-    # and the sleeper thread is waiting for it.\n-    cmd lock $classname.jj\n-    cmd quit \n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfPresent \"Waiting thread: main\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbLockTest.sh","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6202891\n+ * @summary TTY: Add support for method exit event return values to jdb\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/JdbMethodExitTest.sh\n+ *\n+ * @library \/lib\n+ * @compile -g JdbMethodExitTest.java\n+ * @run main\/othervm JdbMethodExitTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.util.*;\n+import java.net.URLClassLoader;\n+import java.net.URL;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * This tests the jdb trace command\n+ *\/\n+\n+class JdbMethodExitTestTarg {\n+    \/\/ These are the values that will be returned by the methods\n+    static URL[] urls = new URL[1];\n+    public static byte      byteValue = 89;\n+    public static char      charValue = 'x';\n+    public static double    doubleValue = 2.2;\n+    public static float     floatValue = 3.3f;\n+    public static int       intValue = 1;\n+    public static short     shortValue = 8;\n+    public static boolean   booleanValue = false;\n+\n+    public static Class       classValue = Object.class;\n+    public static ClassLoader classLoaderValue;\n+    {\n+        try {\n+            urls[0] = new URL(\"file:\/foo\");\n+        } catch (java.net.MalformedURLException ee) {\n+        }\n+        classLoaderValue = new URLClassLoader(urls);\n+    }\n+\n+    public static Thread      threadValue;\n+    public static ThreadGroup threadGroupValue;\n+    public static String      stringValue = \"abc\";\n+    public static int[]       intArrayValue = new int[] {1, 2, 3};\n+\n+    public static JdbMethodExitTestTarg  objectValue =\n+        new JdbMethodExitTestTarg();\n+    public String ivar = stringValue;\n+\n+    \/\/ These are the instance methods\n+    public byte i_bytef()            { return byteValue; }\n+    public char i_charf()            { return charValue; }\n+    public double i_doublef()        { return doubleValue; }\n+    public float i_floatf()          { return floatValue; }\n+    public int i_intf()              { return intValue; }\n+    public short i_shortf()          { return shortValue; }\n+    public boolean i_booleanf()      { return booleanValue; }\n+    public String i_stringf()        { return stringValue; }\n+    public Class i_classf()          { return classValue; }\n+    public ClassLoader i_classLoaderf()\n+                                     { return classLoaderValue; }\n+    public Thread i_threadf()        { return threadValue = Thread.currentThread(); }\n+    public ThreadGroup i_threadGroupf()\n+                                     { return threadGroupValue = threadValue.getThreadGroup(); }\n+    public int[] i_intArrayf()       { return intArrayValue; }\n+    public Object i_nullObjectf()    { return null; }\n+    public Object i_objectf()        { return objectValue; }\n+    public void i_voidf()            {}\n+\n+    static void doit(JdbMethodExitTestTarg xx) {\n+\n+        xx.i_bytef();\n+        xx.i_charf();\n+        xx.i_doublef();\n+        xx.i_floatf();\n+        xx.i_intf();\n+        xx.i_shortf();\n+        xx.i_booleanf();\n+        xx.i_stringf();\n+        xx.i_intArrayf();\n+        xx.i_classf();\n+        xx.i_classLoaderf();\n+        xx.i_threadf();\n+        xx.i_threadGroupf();\n+        xx.i_nullObjectf();\n+        xx.i_objectf();\n+        xx.i_voidf();\n+\n+        \/\/ Prove it works for native methods too\n+        StrictMath.sin(doubleValue);\n+        stringValue.intern();\n+    }\n+\n+    public static void bkpt() {\n+       int i = 0;     \/\/@1 breakpoint\n+    }\n+\n+    public static String traceMethods() {\n+        return \"traceMethods\";\n+    }\n+\n+    public static String traceMethods1() {\n+        return \"traceMethods1\";\n+    }\n+\n+    public static String traceExits() {\n+        return \"traceExits\";\n+    }\n+\n+    public static String traceExits1() {\n+        return \"traceExits1\";\n+    }\n+\n+    public static String traceExit() {\n+        return \"traceExit\";\n+    }\n+\n+    public static String traceExit1() {\n+        return \"traceExit1\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ The debugger will stop at the start of main,\n+        \/\/ enable method exit events, and then do\n+        \/\/ a resume.\n+\n+        JdbMethodExitTestTarg xx = new JdbMethodExitTestTarg();\n+        System.out.println(\"threadid=\"+Thread.currentThread().getId());\n+        bkpt();\n+\n+        \/\/ test all possible return types\n+        doit(xx);\n+        bkpt();\n+\n+       \/\/ test trace methods\n+       traceMethods();\n+\n+       \/\/ test trace go methods\n+       traceMethods1();\n+       bkpt();\n+\n+       \/\/ test trace method exits\n+       traceExits();\n+\n+       \/\/ test trace method exits\n+       traceExits1();\n+       bkpt();\n+\n+       \/\/ test trace method exit\n+       traceExit();\n+\n+       \/\/ test trace method exit\n+       traceExit1();\n+       bkpt();\n+\n+    }\n+}\n+\n+public class JdbMethodExitTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new JdbMethodExitTest().run();\n+    }\n+\n+    private JdbMethodExitTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = JdbMethodExitTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"JdbMethodExitTest.java\", 1);\n+\n+        \/\/ test all possible return types\n+        execCommand(JdbCommand.run())\n+                .shouldContain(\"Breakpoint hit\");\n+        Integer threadId = Integer.parseInt(\n+                new OutputAnalyzer(getDebuggeeOutput())\n+                        .firstMatch(\"^threadid=(.*)$\", 1));\n+        jdb.command(JdbCommand.untrace());\n+\n+        jdb.command(JdbCommand.traceMethods(false, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace methods in effect\");\n+\n+        jdb.command(JdbCommand.traceMethods(true, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace go methods in effect\");\n+\n+        jdb.command(JdbCommand.traceMethodExits(false, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace method exits in effect\");\n+\n+        jdb.command(JdbCommand.traceMethodExits(true, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace go method exits in effect\");\n+\n+        jdb.command(JdbCommand.traceMethodExit(false, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace method exit in effect for JdbMethodExitTestTarg.bkpt\");\n+\n+        jdb.command(JdbCommand.traceMethodExit(true, null));\n+        execCommand(JdbCommand.trace())\n+                .shouldContain(\"trace go method exit in effect for JdbMethodExitTestTarg.bkpt\");\n+\n+\n+        \/\/ trace exit of methods with all the return values\n+        \/\/ (but just check a couple of them)\n+        jdb.command(JdbCommand.traceMethodExits(true, threadId));\n+        execCommand(JdbCommand.cont())\n+                .shouldContain(\"instance of JdbMethodExitTestTarg\")\n+                .shouldContain(\"return value = 8\");\n+\n+        \/\/ Get out of bkpt back to the call to traceMethods\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        jdb.command(JdbCommand.traceMethods(false, threadId));\n+        execCommand(JdbCommand.cont())\n+                .shouldContain(\"Method entered:\");\n+        execCommand(JdbCommand.cont())\n+                .shouldContain(\"Method exited: return value = \\\"traceMethods\\\"\");\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        List<String> reply = new LinkedList<>();\n+        reply.addAll(jdb.command(JdbCommand.traceMethods(true, threadId)));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                .shouldContain(\"Method entered: \\\"thread=main\\\", JdbMethodExitTestTarg.traceMethods1\")\n+                .shouldMatch(\"Method exited: .* JdbMethodExitTestTarg.traceMethods1\");\n+        jdb.command(JdbCommand.untrace());\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        reply.clear();\n+        reply.addAll(jdb.command(JdbCommand.traceMethodExits(false, threadId)));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                .shouldContain(\"Method exited: return value = \\\"traceExits\\\"\");\n+        jdb.command(JdbCommand.untrace());\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        reply.clear();\n+        reply.addAll(jdb.command(JdbCommand.traceMethodExits(true, threadId)));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                .shouldMatch(\"Method exited: .* JdbMethodExitTestTarg.traceExits1\");\n+        jdb.command(JdbCommand.untrace());\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        reply.clear();\n+        reply.addAll(jdb.command(JdbCommand.step()));   \/\/ step into traceExit()\n+        reply.addAll(jdb.command(JdbCommand.traceMethodExit(false, threadId)));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                .shouldContain(\"Method exited: return value = \\\"traceExit\\\"\");\n+        jdb.command(JdbCommand.untrace());\n+        jdb.command(JdbCommand.stepUp());\n+\n+\n+        reply.clear();\n+        reply.addAll(jdb.command(JdbCommand.step()));\n+        reply.addAll(jdb.command(JdbCommand.step()));   \/\/ skip over setting return value in caller :-(\n+        reply.addAll(jdb.command(JdbCommand.traceMethodExit(true, threadId)));\n+        reply.addAll(jdb.command(JdbCommand.cont()));\n+        new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)))\n+                .shouldMatch(\"Method exited: .*JdbMethodExitTestTarg.traceExit1\");\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldContain(\"Breakpoint hit\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbMethodExitTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -1,309 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2004, 2005, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 6202891\n-#  @summary TTY: Add support for method exit event return values to jdb\n-#  @author Jim Holmlund\n-#  @run shell JdbMethodExitTest.sh\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-classname=JdbMethodExitTest\n-compileOptions=-g\n-#java=\"java_g\"\n-#set -x\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-import java.util.*;\n-import java.net.URLClassLoader;\n-import java.net.URL;\n-\n-\/*\n- * This tests the jdb trace command\n- *\/\n-\n-class $classname {\n-    \/\/ These are the values that will be returned by the methods\n-    static URL[] urls = new URL[1];\n-    public static byte      byteValue = 89;\n-    public static char      charValue = 'x';\n-    public static double    doubleValue = 2.2;\n-    public static float     floatValue = 3.3f;\n-    public static int       intValue = 1;\n-    public static short     shortValue = 8;\n-    public static boolean   booleanValue = false;\n-\n-    public static Class       classValue = Object.class;\n-    public static ClassLoader classLoaderValue;\n-    {\n-        try {\n-            urls[0] = new URL(\"hi there\");\n-        } catch (java.net.MalformedURLException ee) {\n-        }\n-        classLoaderValue = new URLClassLoader(urls);\n-    }\n-\n-    public static Thread      threadValue;\n-    public static ThreadGroup threadGroupValue;\n-    public static String      stringValue = \"abc\";\n-    public static int[]       intArrayValue = new int[] {1, 2, 3};\n-\n-    public static $classname  objectValue = \n-        new $classname();\n-    public String ivar = stringValue;\n-\n-    \/\/ These are the instance methods\n-    public byte i_bytef()            { return byteValue; }\n-    public char i_charf()            { return charValue; }\n-    public double i_doublef()        { return doubleValue; }\n-    public float i_floatf()          { return floatValue; }\n-    public int i_intf()              { return intValue; }\n-    public short i_shortf()          { return shortValue; }\n-    public boolean i_booleanf()      { return booleanValue; }\n-    public String i_stringf()        { return stringValue; }\n-    public Class i_classf()          { return classValue; }\n-    public ClassLoader i_classLoaderf()\n-                                     { return classLoaderValue; }\n-    public Thread i_threadf()        { return threadValue = Thread.currentThread(); }\n-    public ThreadGroup i_threadGroupf()  \n-                                     { return threadGroupValue = threadValue.getThreadGroup(); }\n-    public int[] i_intArrayf()       { return intArrayValue; }\n-    public Object i_nullObjectf()    { return null; }\n-    public Object i_objectf()        { return objectValue; }\n-    public void i_voidf()            {}\n-\n-    static void doit($classname xx) {\n-\n-        xx.i_bytef();\n-        xx.i_charf();\n-        xx.i_doublef();\n-        xx.i_floatf();\n-        xx.i_intf();\n-        xx.i_shortf();\n-        xx.i_booleanf();\n-        xx.i_stringf();\n-        xx.i_intArrayf();\n-        xx.i_classf();\n-        xx.i_classLoaderf();\n-        xx.i_threadf();\n-        xx.i_threadGroupf();\n-        xx.i_nullObjectf();\n-        xx.i_objectf();\n-        xx.i_voidf();\n-\n-        \/\/ Prove it works for native methods too\n-        StrictMath.sin(doubleValue);\n-        stringValue.intern();\n-    }\n-\n-    public static void bkpt() {\n-       int i = 0;     \/\/@1 breakpoint\n-    }\n-\n-    public static String traceMethods() {\n-        return \"traceMethods\";\n-    }\n-\n-    public static String traceMethods1() {\n-        return \"traceMethods1\";\n-    }\n-\n-    public static String traceExits() {\n-        return \"traceExits\";\n-    }\n-\n-    public static String traceExits1() {\n-        return \"traceExits1\";\n-    }\n-\n-    public static String traceExit() {\n-        return \"traceExit\";\n-    }\n-\n-    public static String traceExit1() {\n-        return \"traceExit1\";\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ The debugger will stop at the start of main,\n-        \/\/ enable method exit events, and then do\n-        \/\/ a resume.\n-\n-        $classname xx = new $classname();\n-        System.out.println(\"threadid=\"+Thread.currentThread().getId());\n-        bkpt();\n-\n-        \/\/ test all possible return types\n-        doit(xx);\n-        bkpt();\n-        \n-       \/\/ test trace methods\n-       traceMethods();\n-\n-       \/\/ test trace go methods\n-       traceMethods1();\n-       bkpt();\n-\n-       \/\/ test trace method exits\n-       traceExits();\n-\n-       \/\/ test trace method exits\n-       traceExits1();\n-       bkpt();\n-       \n-       \/\/ test trace method exit\n-       traceExit();\n-\n-       \/\/ test trace method exit\n-       traceExit1();\n-       bkpt();\n-       \n-    }\n-}\n-EOF\n-}\n-\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-\n-    # test all possible return types\n-    runToBkpt @1\n-    debuggeeMatchRegexp \"s\/threadid=\\(.*\\)\/\\1\/g\"\n-    threadid=$?\n-    cmd untrace\n-\n-    cmd trace methods\n-    cmd trace\n-    jdbFailIfNotPresent \"trace methods in effect\"\n-\n-    cmd trace go methods\n-    cmd trace\n-    jdbFailIfNotPresent \"trace go methods in effect\"\n-\n-    cmd trace method exits\n-    cmd trace\n-    jdbFailIfNotPresent \"trace method exits in effect\"\n-\n-    cmd trace go method exits\n-    cmd trace\n-    jdbFailIfNotPresent \"trace go method exits in effect\"\n-\n-    cmd trace method exit\n-    cmd trace\n-    jdbFailIfNotPresent \"trace method exit in effect for JdbMethodExitTest.bkpt\"\n-\n-    cmd trace go method exit\n-    cmd trace\n-    jdbFailIfNotPresent \"trace go method exit in effect for JdbMethodExitTest.bkpt\"\n-\n-\n-    # trace exit of methods with all the return values\n-    # (but just check a couple of them)\n-    cmd trace go method exits $threadid\n-    cmd cont\n-    jdbFailIfNotPresent \"instance of JdbMethodExitTest\"\n-    jdbFailIfNotPresent \"return value = 8\"\n-    \n-    # Get out of bkpt back to the call to traceMethods\n-    cmd step up\n-\n-\n-    cmd trace methods $threadid\n-    cmd cont\n-    jdbFailIfNotPresent \"Method entered:\"\n-    cmd cont\n-    jdbFailIfNotPresent \"Method exited: return value = \\\"traceMethods\\\"\"\n-    cmd step up\n-\n-\n-    cmd trace go methods $threadid\n-    cmd cont\n-    cmd cont\n-    cmd cont\n-    jdbFailIfNotPresent \"Method entered: \\\"thread=main\\\", JdbMethodExitTest.traceMethods1\"\n-    jdbFailIfNotPresent 'Method exited: .* JdbMethodExitTest.traceMethods1'\n-    cmd untrace\n-    cmd step up\n-    \n-\n-    cmd trace method exits $threadid\n-    cmd cont\n-    jdbFailIfNotPresent \"Method exited: return value = \\\"traceExits\\\"\"\n-    cmd untrace\n-    cmd step up\n-\n-\n-    cmd trace go method exits $threadid\n-    cmd cont\n-    jdbFailIfNotPresent 'Method exited: .* JdbMethodExitTest.traceExits1'\n-    cmd untrace\n-    cmd step up\n-\n-\n-    cmd step            # step into traceExit()\n-    cmd trace method exit $threadid\n-    cmd cont\n-    jdbFailIfNotPresent \"Method exited: return value = \\\"traceExit\\\"\"\n-    cmd untrace\n-    cmd step up\n-\n-\n-    cmd step\n-    cmd step           # skip over setting return value in caller :-(\n-    cmd trace go method exit $threadid\n-    cmd cont\n-    jdbFailIfNotPresent 'Method exited: .*JdbMethodExitTest.traceExit1'\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfNotPresent \"Breakpoint hit\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbMethodExitTest.sh","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4762765\n+ * @summary REGRESSION: jdb \/ jdi not stopping at some breakpoints and steps in j2sdk1.4.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/JdbMissStep.sh\n+ *\n+ * @library \/lib\n+ * @compile -g JdbMissStep.java\n+ * @run main\/othervm JdbMissStep\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class JdbMissStepTarg {\n+\n+    public static void main(String args[]) {\n+        JdbMissStepTarg dbb = new JdbMissStepTarg();\n+        System.out.println(\"ANSWER IS: \" + dbb.getIntVal());\n+        jj2 gus = new jj2();\n+        System.out.println(\"ANSWER2 IS: \" + gus.getIntVal());\n+    }\n+\n+    static int statVal;\n+    int intVal = 89;\n+    public int getIntVal() {\n+        return intVal;  \/\/@ 1 breakpoint\n+    }\n+\n+    static class jj2 {\n+        static int statVal;\n+        int intVal = 89;\n+        public int getIntVal() {\n+            return intVal;  \/\/@1 breakpoint  line 20\n+        }\n+    }\n+}\n+\n+public class JdbMissStep extends JdbTest {\n+    public static void main(String argv[]) {\n+        new JdbMissStep().run();\n+    }\n+\n+    private JdbMissStep() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = JdbMissStepTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(jdb, DEBUGGEE_CLASS + \"$jj2\", System.getProperty(\"test.src\") + \"\/JdbMissStep.java\", 1);\n+\n+        jdb.command(JdbCommand.run());\n+        jdb.command(JdbCommand.step());\n+\n+        new OutputAnalyzer(jdb.getJdbOutput())\n+                .shouldContain(\"Breakpoint hit\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbMissStep.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -1,101 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4762765\n-#  @summary REGRESSION: jdb \/ jdi not stopping at some breakpoints and steps in j2sdk1.4.\n-#  @author Jim Holmlund\n-#\n-#  @run shell JdbMissStep.sh\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-classname=JdbMissStep\n-compileOptions=-g\n-#java=\"java_g\"\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-   \n-    public static void main(String args[]) {\n-        $classname dbb = new $classname();\n-        System.out.println(\"ANSWER IS: \" + dbb.getIntVal());\n-        jj2 gus = new jj2();\n-        System.out.println(\"ANSWER2 IS: \" + gus.getIntVal());\n-    }\n-\n-    static int statVal;\n-    int intVal = 89;\n-    public int getIntVal() {\n-        return intVal;  \/\/@ 1 breakpoint\n-    }\n-\n-  static class jj2 {\n-    static int statVal;\n-    int intVal = 89;\n-    public int getIntVal() {\n-        return intVal;  \/\/@1 breakpoint  line 20\n-    }\n-  }\n-}\n-\n-EOF\n-}\n-\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    cmd stop at $classname'$jj2:20'\n-    runToBkpt\n-    cmd step\n-    cmd quit \n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfNotPresent \"Breakpoint hit\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbMissStep.sh","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4870984\n+ * @summary JPDA: Add support for RFE 4856541 - varargs\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/JdbVarargsTest.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm JdbVarargsTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class JdbVarargsTestTarg {\n+\n+    public static void main(String args[]) {\n+        int ii = 0; \/\/ @1 breakpoint\n+\n+        \/\/ Call the varargs method so the bkpt will be hit\n+        varString(new String[] {\"a\", \"b\"});\n+    }\n+\n+    static String varString(String... ss) {\n+        if (ss == null) {\n+            return \"-null-\";\n+        }\n+        if (ss.length == 0) {\n+            return \"NONE\";\n+        }\n+        String retVal = \"\";\n+        for (int ii = 0; ii < ss.length; ii++) {\n+            retVal += ss[ii];\n+        }\n+        return retVal;\n+    }\n+\n+}\n+\n+public class JdbVarargsTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new JdbVarargsTest().run();\n+    }\n+\n+    private JdbVarargsTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = JdbVarargsTestTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"JdbVarargsTest.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        \/\/ check that 'methods' shows the ...\n+        jdb.command(JdbCommand.methods(DEBUGGEE_CLASS));\n+\n+        \/\/ check that we can call with no args\n+        jdb.command(JdbCommand.eval(DEBUGGEE_CLASS + \".varString();\"));\n+\n+        \/\/ check that we can call with var args\n+        jdb.command(JdbCommand.eval(DEBUGGEE_CLASS + \".varString(\\\"aa\\\", \\\"bb\\\");\"));\n+\n+        \/\/ check that we can stop in ...\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"varString(java.lang.String...)\"));\n+\n+        jdb.command(JdbCommand.cont());\n+\n+        new OutputAnalyzer(jdb.getJdbOutput())\n+                .shouldContain(\"NONE\")\n+                .shouldContain(\"aabb\")\n+                .shouldContain(DEBUGGEE_CLASS + \" varString(java.lang.String...)\")\n+                .shouldMatch(\"Breakpoint hit:.*varString\\\\(\\\\)\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbVarargsTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -1,110 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4870984\n-#  @summary  JPDA: Add support for RFE 4856541 - varargs\n-#\n-#  @author jjh\n-#\n-#  @run shell JdbVarargsTest.sh\n-\n-classname=JdbVarargsTest\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-   \n-    public static void main(String args[]) {\n-        int ii = 0; \/\/ @1 breakpoint\n-\n-        \/\/ Call the varargs method so the bkpt will be hit\n-        varString(new String[] {\"a\", \"b\"});\n-    }\n-\n-    static String varString(String... ss) {\n-        if (ss == null) {\n-            return \"-null-\";\n-        }\n-        if (ss.length == 0) {\n-            return \"NONE\";\n-        }\n-        String retVal = \"\";\n-        for (int ii = 0; ii < ss.length; ii++) {\n-            retVal += ss[ii];\n-        }\n-        return retVal;\n-    }\n-\n-}\n-EOF\n-}\n-\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-\n-    # check that 'methods' shows the ...\n-    cmd methods \"$classname\"\n-\n-    # check that we can call with no args\n-    cmd eval  \"$classname.varString();\"\n-\n-    # check that we can call with var args\n-    cmd eval \"$classname.varString(\\\"aa\\\", \\\"bb\\\");\"\n-    \n-    # check that we can stop in ...\n-    cmd stop in \"$classname.varString(java.lang.String...)\"\n-    contToBkpt\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfNotPresent \"NONE\"\n-jdbFailIfNotPresent \"aabb\"\n-jdbFailIfNotPresent \"$classname varString\\(java\\.lang\\.String\\.\\.\\.\\)\"\n-jdbFailIfNotPresent 'Breakpoint hit:.*varString\\(\\)'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/JdbVarargsTest.sh","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6224859\n+ * @summary JDWP: Mixing application suspends and debugger suspends can cause hangs\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/MixedSuspendTest.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm MixedSuspendTest\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class MixedSuspendTarg extends Thread {\n+\n+    static volatile boolean started = true;\n+    static String lock = \"startLock\";\n+\n+    public static void main(String[] args){\n+        System.out.println(\"Howdy from MixedSuspendTarg\");\n+\n+        MixedSuspendTarg mytarg = new MixedSuspendTarg();\n+\n+        synchronized(lock) {\n+            mytarg.start();\n+            try {\n+                lock.wait();\n+            } catch(InterruptedException ee) {\n+            }\n+        }\n+        mytarg.suspend();\n+        bkpt();\n+        System.out.println(\"Debuggee: resuming thread\");\n+\n+        \/\/ If the bug occurs, this resume hangs in the back-end\n+        mytarg.resume();\n+        System.out.println(\"Debuggee: resumed thread\");\n+        synchronized(lock) {\n+            started = false;\n+        }\n+        System.out.println(\"Debuggee: exitting, started = \" + started);\n+    }\n+\n+    public void run() {\n+        synchronized(lock) {\n+            lock.notifyAll();\n+        }\n+        while (true) {\n+            synchronized(lock) {\n+                if (!started) {\n+                    break;\n+                }\n+                int i = 0;\n+            }\n+        }\n+\n+        System.out.println(\"Debuggee: end of thread\");\n+    }\n+\n+    static void bkpt() {\n+        \/\/System.out.println(\"bkpt reached, thread = \" + this.getName());\n+        int i = 0;   \/\/ @1 breakpoint\n+    }\n+}\n+\n+public class MixedSuspendTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new MixedSuspendTest().run();\n+    }\n+\n+    private MixedSuspendTest() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = MixedSuspendTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"MixedSuspendTest.java\", 1);\n+        jdb.command(JdbCommand.run());\n+        jdb.command(JdbCommand.cont().allowExit());\n+\n+        \/\/ This test fails by timing out.\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/MixedSuspendTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 6224859\n-#  @summary JDWP: Mixing application suspends and debugger suspends can cause hangs\n-# \n-#  @author Jim Holmlund\n-# \n-#  @run build TestScaffold VMConnection TargetListener TargetAdapter\n-#  @run shell MixedSuspendTest.sh\n-\n-classname=MixedSuspendTarg\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-\n-import java.util.*;\n-\n-public class $classname extends Thread {\n-\n-    static volatile boolean started = true;\n-    static String lock = \"startLock\";\n-\n-    public static void main(String[] args){\n-        System.out.println(\"Howdy from MixedSuspendTarg\");\n-\n-        MixedSuspendTarg mytarg = new MixedSuspendTarg();\n-\n-        synchronized(lock) {\n-            mytarg.start();\n-            try {\n-                lock.wait();\n-            } catch(InterruptedException ee) {\n-            }\n-        }\n-        mytarg.suspend();\n-        bkpt();\n-        System.out.println(\"Debuggee: resuming thread\");\n-\n-        \/\/ If the bug occurs, this resume hangs in the back-end\n-        mytarg.resume();\n-        System.out.println(\"Debuggee: resumed thread\");\n-        synchronized(lock) {\n-            started = false;\n-        }\n-        System.out.println(\"Debuggee: exitting, started = \" + started);\n-    }\n-\n-    public void run() {\n-        synchronized(lock) {\n-            lock.notifyAll();\n-        }\n-        while (true) {\n-            synchronized(lock) {\n-                if (!started) {\n-                    break;\n-                }\n-                int i = 0;\n-            }\n-        }\n-            \n-        System.out.println(\"Debuggee: end of thread\");\n-    }\n-\n-    static void bkpt() {\n-        \/\/System.out.println(\"bkpt reached, thread = \" + this.getName());\n-        int i = 0;   \/\/ @1 breakpoint\n-    }\n-}\n-\n-EOF\n-}\n-\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-## This test fails by timing out.\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/MixedSuspendTest.sh","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4467887 4913748\n+ * @summary TTY: NullPointerException at com.sun.tools.jdi.MirrorImpl.validateMirrors\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/NotAField.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm NotAField\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class NotAFieldTarg {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello, world!\");\n+    }\n+}\n+\n+public class NotAField extends JdbTest {\n+    public static void main(String argv[]) {\n+        new NotAField().run();\n+    }\n+\n+    private NotAField() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = NotAFieldTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"main\"));\n+        jdb.command(JdbCommand.run());\n+\n+        \/\/ This works:\n+        jdb.command(JdbCommand.print(\"java.lang.Class.reflectionFactory.hashCode()\"));\n+        \/\/ This should result in a ParseException: (\"No such field in ...\"):\n+        jdb.command(JdbCommand.print(\"java.lang.Class.reflectionFactory.hashCode\"));\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(jdb.getJdbOutput())\n+                .shouldContain(\"com.sun.tools.example.debug.expr.ParseException\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/NotAField.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,97 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2004, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4467887 4913748\n-#  @summary TTY: NullPointerException at\n-#           com.sun.tools.jdi.MirrorImpl.validateMirrors\n-#  @author Tim Bell\n-#  @run shell NotAField.sh\n-#\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class $classname {\n-    public static void main(String args[]) {\n-        System.out.println(\"Hello, world!\");\n-    }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   #set -x\n-   cmd stop in $classname.main\n-   runToBkpt\n-   #This works:\n-   cmd print \"java.lang.Class.reflectionFactory.hashCode()\"\n-   #This should result in a ParseException: (\"No such field in ...\"):\n-   cmd print \"java.lang.Class.reflectionFactory.hashCode\"\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-   if [ -z \"${TESTJAVA}\" ] ; then\n-      # TESTJAVA is not set, so the test is running stand-alone.\n-      # TESTJAVA holds the path to the root directory of the build of the JDK\n-      # to be tested.  That is, any java files run explicitly in this shell\n-      # should use TESTJAVA in the path to the java interpreter.\n-      # So, we'll set this to the JDK spec'd on the command line.  If none\n-      # is given on the command line, tell the user that and use a default.\n-      # THIS IS THE JDK BEING TESTED.\n-      if [ -n \"$1\" ] ; then\n-             TESTJAVA=$1\n-         else\n-             TESTJAVA=$JAVA_HOME\n-      fi\n-      TESTSRC=.\n-      TESTCLASSES=.\n-   fi\n-   echo \"JDK under test is: $TESTJAVA\"\n-\n-   if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-   fi\n-\n-   if [ -r $TESTSRC\/ShellScaffold.sh ] ; then\n-        . $TESTSRC\/ShellScaffold.sh \n-   elif [ -r $TESTSRC\/..\/ShellScaffold.sh ] ; then\n-        . $TESTSRC\/..\/ShellScaffold.sh\n-   fi\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfNotPresent \"com.sun.tools.example.debug.expr.ParseException\" 50\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/NotAField.sh","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4690242 4695338\n+ * @summary TTY: jdb throws NullPointerException when printing local variables\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/NullLocalVariable.sh\n+ *\n+ * @library \/lib\n+ * @compile -g NullLocalVariable.java\n+ * @run main\/othervm NullLocalVariable\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class NullLocalVariableTarg {\n+    public static final void main(String args[]) {\n+        try {\n+            System.out.println(\"hi!\");               \/\/ @1 breakpoint\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            System.out.println(\"done\");\n+        }\n+    }\n+}\n+\n+public class NullLocalVariable extends JdbTest {\n+    public static void main(String argv[]) {\n+        new NullLocalVariable().run();\n+    }\n+\n+    private NullLocalVariable() {\n+        super(DEBUGGEE_CLASS);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = NullLocalVariableTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpointsFromTestSource(\"NullLocalVariable.java\", 1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.locals());\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/NullLocalVariable.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#  @test\n-#  @bug 4690242 4695338\n-#  @summary TTY: jdb throws NullPointerException when printing local variables\n-#  @author Tim Bell\n-#\n-#  @run shell NullLocalVariable.sh\n-#\n-classname=badscope\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $classname.java.1\n-public class badscope {\n-    public static final void main(String args[]) {\n-        try {\n-            System.out.println(\"hi!\");               \/\/ @1 breakpoint\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        } finally {\n-            System.out.println(\"done\");\n-        }\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-   #set -x\n-   cmd stop at badscope:4   ; $sleepcmd\n-   runToBkpt                ; $sleepcmd\n-   cmd next                 ; $sleepcmd\n-   cmd next                 ; $sleepcmd\n-   cmd locals               ; $sleepcmd\n-   cmd cont\n-}\n-\n-mysetup()\n-{\n-    compileOptions=-g\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh\n-            break\n-        fi\n-    done\n-}\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfPresent \"Internal exception\" 50\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/NullLocalVariable.sh","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4777868\n-#  @summary Compile with java -g, do a RedefineClasses, and you don't get local vars\n-#  @author Jim Holmlund\n-#\n-#  @run shell Redefine-g.sh\n-#pkg=untitled7\n-\n-# Compile the first version without -g and the 2nd version with -g.\n-compileOptions=\n-compileOptions2=-g\n-#java=java_g\n-\n-# Uncomment this to see the JDI trace\n-# jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-  public $1() {\n-  }\n-  public static void main(String[] args) {\n-    int gus = 22;\n-    $1 kk = new $1();\n-    kk.m1(\"ab\");\n-  }\n-\n-  void m1(String p1) {\n-    int m1l1 = 1;\n-    System.out.println(\"m1(String) called\");\n-    m1(p1, \"2nd\");\n-    \/\/ @1 uncomment System.out.println(\"Hello Milpitas!\");\n-  }\n-\n-  void m1(String p1, String p2) {\n-    int m1l2 = 2;\n-    System.out.println(\"m2\" + p1 + p2);  \/\/ @1 breakpoint\n-  }\n-\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    cmd where\n-    cmd locals\n-\n-    redefineClass @1\n-    cmd where\n-    cmd locals\n-\n-    cmd pop\n-    cmd where\n-    cmd locals\n-\n-    cmd pop\n-    cmd where\n-    cmd locals\n-\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-jdbFailIfNotPresent 'p1 = \"ab\"'\n-jdbFailIfNotPresent 'p2 = \"2nd\"'\n-jdbFailIfNotPresent 'm1l2 = 2'\n-jdbFailIfPresent    'm1l1'\n-\n-jdbFailIfNotPresent 'args = instance of java.lang.String'\n-jdbFailIfNotPresent 'gus = 22'\n-jdbFailIfNotPresent 'kk = instance of shtest'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/Redefine-g.sh","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6805864\n+ * @summary Redefine an abstract class that is called via a concrete\n+ * class and via two interface objects and verify that the right\n+ * methods are called.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineAbstractClass.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineAbstractClass.java\n+ * @run main\/othervm RedefineAbstractClass\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.ClassTransformer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefineAbstractClassTarg {\n+    public static void main(String[] args) {\n+        System.out.println(\"This is RedefineAbstractClass\");\n+\n+        MyConcreteClass foo = new MyConcreteClass();\n+        \/\/ do the work once before redefine\n+        foo.doWork();\n+\n+        System.out.println(\"stop here for redefine\");  \/\/ @1 breakpoint\n+\n+        \/\/ do the work again after redefine\n+        foo.doWork();\n+\n+        System.out.println(\"stop here to check results\");  \/\/ @2 breakpoint\n+    }\n+}\n+\n+interface MyInterface1 {\n+    public boolean checkFunc();\n+    public boolean isMyInterface1();\n+}\n+\n+interface MyInterface2 {\n+    public boolean checkFunc();\n+    public boolean isMyInterface2();\n+}\n+\n+abstract class MyAbstractClass implements MyInterface1, MyInterface2 {\n+    static int counter = 0;\n+    public boolean checkFunc() {\n+        counter++;\n+        System.out.println(\"MyAbstractClass.checkFunc() called.\");\n+        \/\/ @1 uncomment System.out.println(\"This is call \" + counter + \" to checkFunc\");\n+        return true;\n+    }\n+    public boolean isMyInterface1() {\n+        System.out.println(\"MyAbstractClass.isMyInterface1() called.\");\n+        return true;\n+    }\n+    public boolean isMyInterface2() {\n+        System.out.println(\"MyAbstractClass.isMyInterface2() called.\");\n+        return true;\n+    }\n+}\n+\n+class MyConcreteClass extends MyAbstractClass {\n+    public void doWork() {\n+        \/\/ checkFunc() is called via invokevirtual here; MyConcreteClass\n+        \/\/ inherits via MyAbstractClass\n+        System.out.println(\"In doWork() calling checkFunc(): \" + checkFunc());\n+\n+        MyInterface1 if1 = (MyInterface1) this;\n+        \/\/ checkFunc() is called via invokeinterface here; this call will\n+        \/\/ use the first itable entry\n+        System.out.println(\"In doWork() calling if1.checkFunc(): \" + if1.checkFunc());\n+\n+        MyInterface2 if2 = (MyInterface2) this;\n+        \/\/ checkFunc() is called via invokeinterface here; this call will\n+        \/\/ use the second itable entry\n+        System.out.println(\"In doWork() calling if2.checkFunc(): \" + if2.checkFunc());\n+    }\n+}\n+\n+\n+public class RedefineAbstractClass extends JdbTest {\n+    public static void main(String argv[]) {\n+        new RedefineAbstractClass().run();\n+    }\n+\n+    private RedefineAbstractClass() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineAbstractClassTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineAbstractClass.java\";\n+    private static final String ABSTRACT_CLASS = \"MyAbstractClass\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        setBreakpoints(2);\n+        jdb.command(JdbCommand.run());\n+\n+        \/\/ modified version of redefineClass function\n+        String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                .transform(1, ABSTRACT_CLASS, \"-g\");\n+        jdb.command(JdbCommand.redefine(ABSTRACT_CLASS, transformedClassFile));\n+        \/\/ end modified version of redefineClass function\n+\n+        \/\/ this will continue to the second breakpoint\n+        jdb.command(JdbCommand.cont());\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldContain(\"This is call 4 to checkFunc\")\n+                .shouldContain(\"This is call 5 to checkFunc\")\n+                .shouldContain(\"This is call 6 to checkFunc\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAbstractClass.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -1,153 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-\n-# @test\n-# @bug 6805864\n-# @summary Redefine an abstract class that is called via a concrete\n-#   class and via two interface objects and verify that the right\n-#   methods are called.\n-# @author Daniel D. Daugherty\n-#\n-# @run shell RedefineAbstractClass.sh\n-\n-compileOptions=-g\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-  public static void main(String[] args) {\n-    System.out.println(\"This is RedefineAbstractClass\");\n-\n-    MyConcreteClass foo = new MyConcreteClass();\n-    \/\/ do the work once before redefine\n-    foo.doWork();\n-\n-    System.out.println(\"stop here for redefine\");  \/\/ @1 breakpoint\n-\n-    \/\/ do the work again after redefine\n-    foo.doWork();\n-\n-    System.out.println(\"stop here to check results\");  \/\/ @2 breakpoint\n-  }\n-}\n-\n-interface MyInterface1 {\n-  public boolean checkFunc();\n-  public boolean isMyInterface1();\n-}\n-\n-interface MyInterface2 {\n-  public boolean checkFunc();\n-  public boolean isMyInterface2();\n-}\n-\n-abstract class MyAbstractClass implements MyInterface1, MyInterface2 {\n-  static int counter = 0;\n-  public boolean checkFunc() {\n-    counter++;\n-    System.out.println(\"MyAbstractClass.checkFunc() called.\");\n-    \/\/ @1 uncomment System.out.println(\"This is call \" + counter + \" to checkFunc\");\n-    return true;\n-  }\n-  public boolean isMyInterface1() {\n-    System.out.println(\"MyAbstractClass.isMyInterface1() called.\");\n-    return true;\n-  }\n-  public boolean isMyInterface2() {\n-    System.out.println(\"MyAbstractClass.isMyInterface2() called.\");\n-    return true;\n-  }\n-}\n-\n-class MyConcreteClass extends MyAbstractClass {\n-  public void doWork() {\n-    \/\/ checkFunc() is called via invokevirtual here; MyConcreteClass\n-    \/\/ inherits via MyAbstractClass\n-    System.out.println(\"In doWork() calling checkFunc(): \" + checkFunc());\n-\n-    MyInterface1 if1 = (MyInterface1) this;\n-    \/\/ checkFunc() is called via invokeinterface here; this call will\n-    \/\/ use the first itable entry\n-    System.out.println(\"In doWork() calling if1.checkFunc(): \" + if1.checkFunc());\n-\n-    MyInterface2 if2 = (MyInterface2) this;\n-    \/\/ checkFunc() is called via invokeinterface here; this call will\n-    \/\/ use the second itable entry\n-    System.out.println(\"In doWork() calling if2.checkFunc(): \" + if2.checkFunc());\n-  }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    setBkpts @2\n-    runToBkpt @1\n-    # modified version of redefineClass function\n-    vers=2\n-    abs_class=MyAbstractClass\n-    cmd redefine $pkgDot$abs_class $tmpFileDir\/vers$vers\/$abs_class.class\n-    cp $tmpFileDir\/$classname.java.$vers \\\n-        $tmpFileDir\/$classname.java\n-    # end modified version of redefineClass function\n-\n-    # this will continue to the second breakpoint\n-    cmd cont\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-debuggeeFailIfNotPresent 'This is call 4 to checkFunc'\n-debuggeeFailIfNotPresent 'This is call 5 to checkFunc'\n-debuggeeFailIfNotPresent 'This is call 6 to checkFunc'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAbstractClass.sh","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8149743\n+ * @summary crash when adding a breakpoint after redefining to add a private static method\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineAddPrivateMethod.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineAddPrivateMethod.java\n+ * @run main\/othervm RedefineAddPrivateMethod\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefineAddPrivateMethodTarg {\n+    static public void main(String[] args) {\n+        System.out.println(\"@1 breakpoint\");\n+        System.out.println(\"@2 breakpoint\");\n+    }\n+\n+    \/\/ @1 uncomment private static void test() {}\n+}\n+\n+public class RedefineAddPrivateMethod extends JdbTest {\n+    public static void main(String argv[]) {\n+        new RedefineAddPrivateMethod().run();\n+    }\n+\n+    private RedefineAddPrivateMethod() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineAddPrivateMethodTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineAddPrivateMethod.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+\n+        redefineClass(1, \"-g\");\n+        \/\/ ensure \"test()\" method has been added successfully\n+        execCommand(JdbCommand.eval(DEBUGGEE_CLASS + \".test()\"))\n+                .shouldNotContain(\"ParseException\");\n+\n+        setBreakpoints(2);\n+        jdb.command(JdbCommand.run());\n+\n+        jdb.quit();\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAddPrivateMethod.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 8149743\n-#  @summary crash when adding a breakpoint after redefining to add a private static method\n-#  @run shell RedefineAddPrivateMethod.sh\n-\n-compileOptions=-g\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-public class $1 {\n-    static public void main(String[] args) {\n-        System.out.println(\"@1 breakpoint\");\n-        System.out.println(\"@2 breakpoint\");\n-    }\n-\n-    \/\/ @1 uncomment private static void test() {}\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    setBkpts @2\n-    runToBkpt @2\n-    cmd exitJdb\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAddPrivateMethod.sh","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5002251 6407335 6412391\n+ * @summary Redefine a class that has an annotation and verify that the\n+ * new annotation is returned.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineAnnotation.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineAnnotation.java\n+ * @run main\/othervm RedefineAnnotation\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+@Foo(Constants.class_annotation)  \/\/ @1 commentout\n+\/\/ @1 uncomment @Foo(Constants.new_class_annotation)\n+class RedefineAnnotationTarg {\n+    @Foo(Constants.field_annotation)  \/\/ @1 commentout\n+    \/\/ @1 uncomment @Foo(Constants.new_field_annotation)\n+    public int dummy_field;\n+\n+    public static void main(String[] args) {\n+        MySubClass sub = new MySubClass();\n+        MySubSubClass subsub = new MySubSubClass();\n+        new RedefineAnnotationTarg().hi(false);\n+        new RedefineAnnotationTarg().hi(true);  \/\/ @1 breakpoint\n+        sub.hi(true);\n+        subsub.hi(true);\n+    }\n+\n+    @Foo(Constants.method_annotation)  \/\/ @1 commentout\n+    \/\/ @1 uncomment @Foo(Constants.new_method_annotation)\n+    public void hi(\n+    @Foo(Constants.method_parameter_annotation)  \/\/ @1 commentout\n+    \/\/ @1 uncomment @Foo(Constants.new_method_parameter_annotation)\n+                   boolean isNewVersion) {\n+\n+        if (isNewVersion) {\n+            System.out.println(\"Checking for NEW versions of annotations in \"\n+                + getClass());\n+        }\n+\n+        \/\/ class annotations check:\n+        Foo foo = getClass().getAnnotation(Foo.class);\n+        if (foo == null) {\n+          throw new Error(\"FAIL: cannot get class_annotation from \"\n+                        + getClass());\n+        }\n+\n+        String class_annotation = foo.value();\n+        System.out.println(\"class annotation is: \" + class_annotation);\n+        if (isNewVersion) {\n+            if (class_annotation.equals(Constants.new_class_annotation)) {\n+                System.out.println(\"PASS: class_annotation was changed.\");\n+            } else {\n+                System.out.println(\"FAIL: class_annotation was NOT changed.\");\n+            }\n+        }\n+\n+        \/\/ field annotations check:\n+        try {\n+            Field my_field = getClass().getField(\"dummy_field\");\n+            foo = my_field.getAnnotation(Foo.class);\n+            if (foo == null) {\n+              throw new Error(\"FAIL: cannot get field_annotation from \"\n+                            + getClass() + \".dummy_field\");\n+            }\n+            String field_annotation = foo.value();\n+            System.out.println(\"field annotation is: \" + field_annotation);\n+            if (isNewVersion) {\n+                if (field_annotation.equals(Constants.new_field_annotation)) {\n+                    System.out.println(\"PASS: field_annotation was changed.\");\n+                } else {\n+                    System.out.println(\n+                        \"FAIL: field_annotation was NOT changed.\");\n+                }\n+        }\n+        } catch (NoSuchFieldException nsfe) {\n+            throw new Error(\"FAIL: cannot find field 'dummy_field' in \"\n+                          + getClass());\n+        }\n+\n+        \/\/ method annotations check:\n+        try {\n+            Class params[] = new Class[1];\n+            params[0] = Boolean.TYPE;\n+            Method my_method = getClass().getMethod(\"hi\", params);\n+            foo = my_method.getAnnotation(Foo.class);\n+            if (foo == null) {\n+              throw new Error(\"FAIL: cannot get field_annotation from \"\n+                            + getClass() + \".hi()\");\n+            }\n+            String method_annotation = foo.value();\n+            System.out.println(\"method annotation is: \" + method_annotation);\n+            if (isNewVersion) {\n+                if (method_annotation.equals(Constants.new_method_annotation)) {\n+                    System.out.println(\"PASS: method_annotation was changed.\");\n+                } else {\n+                    System.out.println(\n+                        \"FAIL: method_annotation was NOT changed.\");\n+                }\n+            }\n+        } catch (NoSuchMethodException nsme) {\n+            throw new Error(\"FAIL: cannot find method 'hi' in \" + getClass());\n+        }\n+\n+        \/\/ method parameter annotations check:\n+        try {\n+            Class params[] = new Class[1];\n+            params[0] = Boolean.TYPE;\n+            Method my_method = getClass().getMethod(\"hi\", params);\n+            Annotation my_annotations[][] = my_method.getParameterAnnotations();\n+            if (my_annotations.length != 1) {\n+                throw new Error(\"FAIL: unexpected my_annotations.length (\"\n+                              + my_annotations.length);\n+            }\n+            Annotation my_annotation[] = my_annotations[0];\n+            if (my_annotation.length != 1) {\n+                throw new Error(\"FAIL: unexpected my_annotation.length (\"\n+                              + my_annotation.length);\n+            }\n+            foo = (Foo)my_annotation[0];\n+            String method_parameter_annotation = foo.value();\n+            System.out.println(\"method parameter annotation is: \"\n+                + method_parameter_annotation);\n+            if (isNewVersion) {\n+                if (method_parameter_annotation.equals(\n+                    Constants.new_method_parameter_annotation)) {\n+                    System.out.println(\n+                        \"PASS: method_parameter_annotation was changed.\");\n+                } else {\n+                    System.out.println(\n+                        \"FAIL: method_parameter_annotation was NOT changed.\");\n+                }\n+            }\n+        } catch (NoSuchMethodException nsme) {\n+            throw new Error(\"FAIL: cannot find method 'hi' in \" + getClass());\n+        }\n+    }\n+}\n+\n+\/\/ this subclass exists just to make the RedefineClasses() code do a\n+\/\/ subclass walk to update the counter\n+class MySubClass extends RedefineAnnotationTarg {\n+    int my_int_field_makes_me_different;\n+}\n+\n+\/\/ this subclass exists just to make the RedefineClasses() code do a\n+\/\/ sub-subclass walk to update the counter\n+class MySubSubClass extends MySubClass {\n+    float my_float_field_makes_me_different;\n+}\n+\n+class Constants {\n+    static final String class_annotation     = \"Patrick's class comment\";\n+    static final String new_class_annotation = \"*NEW* Patrick's class comment\";\n+\n+    static final String field_annotation     = \"dummy_field comment\";\n+    static final String new_field_annotation = \"*NEW* dummy_field comment\";\n+\n+    static final String method_annotation     = \"method hi() comment\";\n+    static final String new_method_annotation = \"*NEW* method hi() comment\";\n+\n+    static final String method_parameter_annotation     =\n+        \"param isNewVersion comment\";\n+    static final String new_method_parameter_annotation =\n+        \"*NEW* param isNewVersion comment\";\n+}\n+\n+\n+\/**\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Inherited\n+@interface Foo {\n+    String value();\n+}\n+\n+public class RedefineAnnotation extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineAnnotation().run();\n+    }\n+\n+    private RedefineAnnotation() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineAnnotationTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineAnnotation.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+\n+        redefineClass(1, \"-g\");\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"FAIL:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAnnotation.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -1,245 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2006, 2007, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 5002251 6407335 6412391\n-#  @summary Redefine a class that has an annotation and verify that the\n-#    new annotation is returned.\n-#\n-#  @run shell RedefineAnnotation.sh\n-\n-compileOptions=-g\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-import java.lang.annotation.*;\n-import java.lang.reflect.*;\n-\n-\/**\n- *\/\n-@Foo(Constants.class_annotation)  \/\/ @1 commentout\n-\/\/ @1 uncomment @Foo(Constants.new_class_annotation)\n-public class $1 {\n-@Foo(Constants.field_annotation)  \/\/ @1 commentout\n-\/\/ @1 uncomment @Foo(Constants.new_field_annotation)\n-    public int dummy_field;\n-\n-    public static void main(String[] args) {\n-        MySubClass sub = new MySubClass();\n-        MySubSubClass subsub = new MySubSubClass();\n-        new $1().hi(false);\n-        new $1().hi(true);  \/\/ @1 breakpoint\n-        sub.hi(true);\n-        subsub.hi(true);\n-    }\n-\n-@Foo(Constants.method_annotation)  \/\/ @1 commentout\n-\/\/ @1 uncomment @Foo(Constants.new_method_annotation)\n-    public void hi(\n-@Foo(Constants.method_parameter_annotation)  \/\/ @1 commentout\n-\/\/ @1 uncomment @Foo(Constants.new_method_parameter_annotation)\n-                   boolean isNewVersion) {\n-\n-        if (isNewVersion) {\n-            System.out.println(\"Checking for NEW versions of annotations in \"\n-                + getClass());\n-        }\n-\n-        \/\/ class annotations check:\n-        Foo foo = getClass().getAnnotation(Foo.class);\n-        if (foo == null) {\n-          throw new Error(\"FAIL: cannot get class_annotation from \"\n-                        + getClass());\n-        }\n-\n-        String class_annotation = foo.value();\n-        System.out.println(\"class annotation is: \" + class_annotation);\n-        if (isNewVersion) {\n-            if (class_annotation.equals(Constants.new_class_annotation)) {\n-                System.out.println(\"PASS: class_annotation was changed.\");\n-            } else {\n-                System.out.println(\"FAIL: class_annotation was NOT changed.\");\n-            }\n-        }\n-    \n-        \/\/ field annotations check:\n-        try {\n-            Field my_field = getClass().getField(\"dummy_field\");\n-            foo = my_field.getAnnotation(Foo.class);\n-            if (foo == null) {\n-              throw new Error(\"FAIL: cannot get field_annotation from \"\n-                            + getClass() + \".dummy_field\");\n-            }\n-            String field_annotation = foo.value();\n-            System.out.println(\"field annotation is: \" + field_annotation);\n-            if (isNewVersion) {\n-                if (field_annotation.equals(Constants.new_field_annotation)) {\n-                    System.out.println(\"PASS: field_annotation was changed.\");\n-                } else {\n-                    System.out.println(\n-                        \"FAIL: field_annotation was NOT changed.\");\n-                }\n-        }\n-        } catch (NoSuchFieldException nsfe) {\n-            throw new Error(\"FAIL: cannot find field 'dummy_field' in \"\n-                          + getClass());\n-        }\n-    \n-        \/\/ method annotations check:\n-        try {\n-            Class params[] = new Class[1];\n-            params[0] = Boolean.TYPE;\n-            Method my_method = getClass().getMethod(\"hi\", params);\n-            foo = my_method.getAnnotation(Foo.class);\n-            if (foo == null) {\n-              throw new Error(\"FAIL: cannot get field_annotation from \"\n-                            + getClass() + \".hi()\");\n-            }\n-            String method_annotation = foo.value();\n-            System.out.println(\"method annotation is: \" + method_annotation);\n-            if (isNewVersion) {\n-                if (method_annotation.equals(Constants.new_method_annotation)) {\n-                    System.out.println(\"PASS: method_annotation was changed.\");\n-                } else {\n-                    System.out.println(\n-                        \"FAIL: method_annotation was NOT changed.\");\n-                }\n-            }\n-        } catch (NoSuchMethodException nsme) {\n-            throw new Error(\"FAIL: cannot find method 'hi' in \" + getClass());\n-        }\n-    \n-        \/\/ method parameter annotations check:\n-        try {\n-            Class params[] = new Class[1];\n-            params[0] = Boolean.TYPE;\n-            Method my_method = getClass().getMethod(\"hi\", params);\n-            Annotation my_annotations[][] = my_method.getParameterAnnotations();\n-            if (my_annotations.length != 1) {\n-                throw new Error(\"FAIL: unexpected my_annotations.length (\"\n-                              + my_annotations.length);\n-            }\n-            Annotation my_annotation[] = my_annotations[0];\n-            if (my_annotation.length != 1) {\n-                throw new Error(\"FAIL: unexpected my_annotation.length (\"\n-                              + my_annotation.length);\n-            }\n-            foo = (Foo)my_annotation[0];\n-            String method_parameter_annotation = foo.value();\n-            System.out.println(\"method parameter annotation is: \"\n-                + method_parameter_annotation);\n-            if (isNewVersion) {\n-                if (method_parameter_annotation.equals(\n-                    Constants.new_method_parameter_annotation)) {\n-                    System.out.println(\n-                        \"PASS: method_parameter_annotation was changed.\");\n-                } else {\n-                    System.out.println(\n-                        \"FAIL: method_parameter_annotation was NOT changed.\");\n-                }\n-            }\n-        } catch (NoSuchMethodException nsme) {\n-            throw new Error(\"FAIL: cannot find method 'hi' in \" + getClass());\n-        }\n-    }\n-}\n-\n-\/\/ this subclass exists just to make the RedefineClasses() code do a\n-\/\/ subclass walk to update the counter\n-class MySubClass extends $1 {\n-  int my_int_field_makes_me_different;\n-}\n-\n-\/\/ this subclass exists just to make the RedefineClasses() code do a\n-\/\/ sub-subclass walk to update the counter\n-class MySubSubClass extends MySubClass {\n-  float my_float_field_makes_me_different;\n-}\n-\n-class Constants {\n-    static final String class_annotation     = \"Patrick's class comment\";\n-    static final String new_class_annotation = \"*NEW* Patrick's class comment\";\n-\n-    static final String field_annotation     = \"dummy_field comment\";\n-    static final String new_field_annotation = \"*NEW* dummy_field comment\";\n-\n-    static final String method_annotation     = \"method hi() comment\";\n-    static final String new_method_annotation = \"*NEW* method hi() comment\";\n-\n-    static final String method_parameter_annotation     =\n-        \"param isNewVersion comment\";\n-    static final String new_method_parameter_annotation =\n-        \"*NEW* param isNewVersion comment\";\n-}\n-\n-\n-\/**\n- *\/\n-@Retention(RetentionPolicy.RUNTIME)\n-@Inherited\n-@interface Foo {\n-    String value();\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    cmd cont\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-debuggeeFailIfPresent 'FAIL:'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineAnnotation.sh","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6270982\n+ * @summary Redefine a class so that the order of external classes in\n+ *          the constant pool are changed.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineChangeClassOrder.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineChangeClassOrder.java\n+ * @run main\/othervm RedefineChangeClassOrder\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+class RedefineChangeClassOrderTarg {\n+    public static void main(String[] args) {\n+        new RedefineChangeClassOrderTarg().hi(false);\n+        new RedefineChangeClassOrderTarg().hi(true);  \/\/ @1 breakpoint\n+    }\n+\n+    public void hi(boolean expected) {\n+        boolean isNewVersion = false; \/\/ @1 commentout\n+        \/\/ @1 uncomment boolean isNewVersion = true;\n+\n+        if (expected == isNewVersion) {\n+            System.out.println(\"PASS: expected and isNewVersion match.\");\n+        } else {\n+            System.out.println(\"FAIL: expected and isNewVersion do not match.\");\n+            System.out.println(\"expected=\" + expected\n+              + \"  isNewVersion=\" + isNewVersion);\n+        }\n+\n+        Foo1 foo1 = new Foo1();  \/\/ @1 commentout\n+        foo1.hi();  \/\/ @1 commentout\n+\n+        \/\/ This Hack code block exists to force some verification_type_info\n+        \/\/ objects of subtype Object_variable_info into the StackMapTable.\n+        \/\/\n+        \/\/ In the redefined code, the above Foo1 code is effectively\n+        \/\/ moved after the Foo2 code below which causes things to be\n+        \/\/ layed out in a different order in the constant pool. The\n+        \/\/ cpool_index in the Object_variable_info has to be updated\n+        \/\/ in the redefined code's StackMapTable to refer to right\n+        \/\/\/ constant pool index in the merged constant pool.\n+        Hack hack = getClass().getAnnotation(Hack.class);\n+        if (hack != null) {\n+            String class_annotation = hack.value();\n+            System.out.println(\"class annotation is: \" + class_annotation);\n+            if (isNewVersion) {\n+                if (class_annotation.equals(\"JUNK\")) {\n+                    System.out.println(\"class_annotation is JUNK.\");\n+                } else {\n+                    System.out.println(\"class_annotation is NOT JUNK.\");\n+                }\n+            }\n+        }\n+\n+        Foo2 foo2 = new Foo2();\n+        foo2.hi();\n+\n+        \/\/ @1 uncomment Foo1 foo1 = new Foo1();\n+        \/\/ @1 uncomment foo1.hi();\n+    }\n+}\n+\n+class Foo1 {\n+    public void hi() {\n+        System.out.println(\"Hello from \" + getClass());\n+    }\n+}\n+\n+class Foo2 {\n+    public void hi() {\n+        System.out.println(\"Hello from \" + getClass());\n+    }\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface Hack {\n+    String value();\n+}\n+\n+\n+public class RedefineChangeClassOrder extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineChangeClassOrder().run();\n+    }\n+\n+    private RedefineChangeClassOrder() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineChangeClassOrderTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineChangeClassOrder.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"FAIL:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineChangeClassOrder.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -1,151 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 6270982\n-#  @summary Redefine a class so that the order of external classes in\n-#  the constant pool are changed.\n-#  @author dcubed\n-#\n-#  @run shell RedefineChangeClassOrder.sh\n-\n-compileOptions=-g\n-\n-# Would like to run this test with this option:\n-# -XX:-FailOverToOldVerifier\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-\n-public class $1 {\n-    public static void main(String[] args) {\n-        new $1().hi(false);\n-        new $1().hi(true);  \/\/ @1 breakpoint\n-    }\n-\n-    public void hi(boolean expected) {\n-        boolean isNewVersion = false; \/\/ @1 commentout\n-        \/\/ @1 uncomment boolean isNewVersion = true;\n-\n-        if (expected == isNewVersion) {\n-            System.out.println(\"PASS: expected and isNewVersion match.\");\n-        } else {\n-            System.out.println(\"FAIL: expected and isNewVersion do not match.\");\n-            System.out.println(\"expected=\" + expected\n-              + \"  isNewVersion=\" + isNewVersion);\n-        }\n-\n-        Foo1 foo1 = new Foo1();  \/\/ @1 commentout\n-        foo1.hi();  \/\/ @1 commentout\n-\n-        \/\/ This Hack code block exists to force some verification_type_info\n-        \/\/ objects of subtype Object_variable_info into the StackMapTable.\n-        \/\/\n-        \/\/ In the redefined code, the above Foo1 code is effectively\n-        \/\/ moved after the Foo2 code below which causes things to be\n-        \/\/ layed out in a different order in the constant pool. The\n-        \/\/ cpool_index in the Object_variable_info has to be updated\n-        \/\/ in the redefined code's StackMapTable to refer to right\n-        \/\/\/ constant pool index in the merged constant pool.\n-        Hack hack = getClass().getAnnotation(Hack.class);\n-        if (hack != null) {\n-            String class_annotation = hack.value();\n-            System.out.println(\"class annotation is: \" + class_annotation);\n-            if (isNewVersion) {\n-                if (class_annotation.equals(\"JUNK\")) {\n-                    System.out.println(\"class_annotation is JUNK.\");\n-                } else {\n-                    System.out.println(\"class_annotation is NOT JUNK.\");\n-                }\n-            }\n-        }\n-\n-        Foo2 foo2 = new Foo2();\n-        foo2.hi();\n-\n-        \/\/ @1 uncomment Foo1 foo1 = new Foo1();\n-        \/\/ @1 uncomment foo1.hi();\n-    }\n-}\n-\n-class Foo1 {\n-    public void hi() {\n-        System.out.println(\"Hello from \" + getClass());\n-    }\n-}\n-\n-class Foo2 {\n-    public void hi() {\n-        System.out.println(\"Hello from \" + getClass());\n-    }\n-}\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface Hack {\n-    String value();\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    cmd cont\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-debuggeeFailIfPresent 'FAIL:'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineChangeClassOrder.sh","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4628760\n+ * @summary RedefineClasses gets assertion: \"Should be a method entry in cpcache!\"\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineClasses.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm RedefineClasses\n+ *\/\n+\n+\/* On windows, with b90, this gets this:\n+ * assert(u2_at_bcp >= 0 && u2_at_bcp < old_cache->length(), \"Bad cpcache index!\")\n+ *\n+ * Error happened during: VM_RedefineClasses\n+ *\n+ * Error ID: D:\/jdk1.4\/hotspot\\src\\share\\vm\\prims\\jvmdi_hotswap.cpp, 331\n+\n+ * On solaris, and on windows with 4559100 fixed, this test fails with:\n+ *\n+ * HotSpot Virtual Machine Error, assertion failure\n+ * Please report this error at\n+ * http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n+ *\n+ * Java VM: Java HotSpot(TM) Client VM (1.4-internal-debug mixed mode)\n+ *\n+ * assert(old_cache->entry_at(u2_at_bcp)->is_method_entry(), \"Should be a method entry in cpcache!\")\n+ *\n+ * Error happened during: VM_RedefineClasses\n+ *\n+ * Error ID: M:\\ws\\m\\b2\\service_hs_baseline\\src\\share\\vm\\prims\\jvmdi_hotswap.cpp, 335\n+ *\/\n+\n+\/*\n+ * With -Xcomp on solaris this passes, but takes 2 minutes.\n+ *\/\n+\n+import lib.jdb.ClassTransformer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.lang.Thread;\n+import java.util.HashMap;\n+import javax.swing.*;\n+import java.util.*;\n+\n+class RedefineClassesTarg {\n+    int xxx = 20;\n+    \/\/ThreadGroup k = new ThreadGroup(\"group\");\n+    int i;\n+\n+    public RedefineClassesTarg() {\n+    }\n+\n+    public void a1() {\n+    a2();\n+    }\n+\n+    public void a2() {\n+    a3();\n+    }\n+\n+    public void a3() {\n+        System.out.println(\"out from a3\");   \/\/ @1 breakpoint\n+        \/\/System.out.println(\"hello world\"); \/\/ @ 1 delete this isn't even necesary\n+    }\n+    public void a4() {\n+        System.out.println(\"in a4\");\n+        int i = 2;\n+        int j = 3333;\n+        System.out.println(\"i + j = \" + (i + j));\n+        System.out.println(\"out from a4\");\n+        System.out.println(\"def\");\n+        a1();\n+    }\n+\n+    public void aa() {\n+        a4();\n+        System.out.println(\"out from aa\");\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        byte xyz[] = new byte[] { 'a', 'b', 'c' };\n+\n+        int x1 = 100;\n+        x1 = 101;\n+        x1 = 102;\n+        x1 = 103;\n+        String m1 = \"def\";\n+        String m2 = \"abc\";\n+        String m3 = \"def\";\n+\n+        int[] m = new int[] { 100, 200, 300 };\n+\n+        RedefineClassesTarg untitled31 = new RedefineClassesTarg();\n+        untitled31.aa();\n+    }\n+}\n+\n+public class RedefineClasses extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineClasses().run();\n+    }\n+\n+    private RedefineClasses() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineClassesTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineClasses.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                .transform(1, DEBUGGEE_CLASS);\n+        jdb.command(JdbCommand.redefine(DEBUGGEE_CLASS, transformedClassFile));\n+        jdb.command(JdbCommand.redefine(DEBUGGEE_CLASS, transformedClassFile));\n+        jdb.command(JdbCommand.redefine(DEBUGGEE_CLASS, transformedClassFile));\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineClasses.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -1,160 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2007, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4628760\n-#  @summary RedefineClasses gets assertion: \"Should be a method entry in cpcache!\"\n-#  @author jjh\n-#\n-#  @run shell\/timeout=180 RedefineClasses.sh\n-\n-# On windows, with b90, this gets this:\n-# assert(u2_at_bcp >= 0 && u2_at_bcp < old_cache->length(), \"Bad cpcache index!\")\n-#\n-# Error happened during: VM_RedefineClasses\n-#\n-# Error ID: D:\/jdk1.4\/hotspot\\src\\share\\vm\\prims\\jvmdi_hotswap.cpp, 331\n-\n-# On solaris, and on windows with 4559100 fixed, this test fails with:\n-#\n-# HotSpot Virtual Machine Error, assertion failure\n-# Please report this error at\n-# http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n-#\n-# Java VM: Java HotSpot(TM) Client VM (1.4-internal-debug mixed mode)\n-#\n-# assert(old_cache->entry_at(u2_at_bcp)->is_method_entry(), \"Should be a method entry in cpcache!\")\n-#\n-# Error happened during: VM_RedefineClasses\n-#\n-# Error ID: M:\\ws\\m\\b2\\service_hs_baseline\\src\\share\\vm\\prims\\jvmdi_hotswap.cpp, 335\n-\n-\n-# With -Xcomp on solaris this passes, but takes 2 minutes, thus the \/timeout above.\n-\n-# These are variables that can be set to control execution\n-\n-java=java\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-\n-import java.lang.Thread;\n-import java.util.HashMap;\n-import javax.swing.*;\n-import java.util.*;\n-\n-\n-public class $1 {\n-  int xxx = 20;\n-  \/\/ThreadGroup k = new ThreadGroup(\"group\");\n-  int i;\n-\n-  public $1() {\n-  }\n-\n-  public void a1() {\n-      a2();\n-  }\n-\n-  public void a2() {\n-    a3();\n-  }\n-\n-  public void a3() {\n-     System.out.println(\"out from a3\");   \/\/ @1 breakpoint\n-     \/\/System.out.println(\"hello world\"); \/\/ @ 1 delete this isn't even necesary\n-  }\n-  public void a4() {\n-    System.out.println(\"in a4\");\n-    int i = 2;\n-    int j = 3333;\n-    System.out.println(\"i + j = \" + (i + j));\n-    System.out.println(\"out from a4\");\n-    System.out.println(\"def\");\n-    a1();\n-  }\n-\n-  public void aa() {\n-    a4();\n-    System.out.println(\"out from aa\");\n-  }\n-\n-\n-  public static void main(String[] args) {\n-    byte xyz[] = new byte[] { 'a', 'b', 'c' };\n-\n-    int x1 = 100;\n-    x1 = 101;\n-    x1 = 102;\n-    x1 = 103;\n-    String m1 = \"def\";\n-    String m2 = \"abc\";\n-    String m3 = \"def\";\n-\n-    int[] m = new int[] { 100, 200, 300 };\n-\n-    $1 untitled31 = new $1();\n-    untitled31.aa();\n-  }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt\n-    cmd redefine $classname $tmpFileDir\/$classname.class\n-    cmd redefine $classname $tmpFileDir\/$classname.class\n-    cmd redefine $classname $tmpFileDir\/$classname.class\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineClasses.sh","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4705330\n+ * @summary Netbeans Fix and Continue crashes JVM\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineClearBreakpoint.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineClearBreakpoint.java\n+ * @run main\/othervm RedefineClearBreakpoint\n+ *\/\n+\n+\/*\n+ * The failure occurs after a breakpoint is set and then cleared\n+ * after a class redefinition, in a method that was EMCP.\n+ * This sequence creates a state in which subsequent operations\n+ * such as accessing local vars via JVMDI, can cause a hotspot crash.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.util.List;\n+\n+class RedefineClearBreakpointTarg {\n+\n+    public RedefineClearBreakpointTarg() {\n+        int a=23;\n+        a=m(a);\n+    }\n+    public int m(int b){\n+        int bb=89;\n+        System.out.println(\"RedefineClearBreakpointTarg -  constructor\" + b); \/\/@1 breakpoint\n+        return b*b;\n+    }\n+\n+    public static void main(java.lang.String[] args) {\n+        new RedefineClearBreakpointTarg();\n+        int jj = 0;   \/\/@1 delete\n+    }\n+\n+}\n+\n+\n+public class RedefineClearBreakpoint extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineClearBreakpoint().run();\n+    }\n+\n+    private RedefineClearBreakpoint() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineClearBreakpointTarg.class.getName();\n+    private static final String SOURCE_FILE = \"RedefineClearBreakpoint.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        List<Integer> bps = parseBreakpoints(getTestSourcePath(SOURCE_FILE), 1);\n+        Asserts.assertEquals(bps.size(), 1, \"unexpected breakpoint count\");\n+        jdb.command(JdbCommand.stopAt(DEBUGGEE_CLASS, bps.get(0)));\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+\n+        jdb.command(JdbCommand.stopAt(DEBUGGEE_CLASS, bps.get(0)));\n+        jdb.command(JdbCommand.next());     \/\/ This is needed to make the crash happen at the 'locals' cmd\n+\n+        jdb.command(JdbCommand.clear(DEBUGGEE_CLASS, bps.get(0)));\n+        jdb.command(JdbCommand.locals());   \/\/ The crash happens here\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineClearBreakpoint.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -1,101 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4705330\n-#  @summary Netbeans Fix and Continue crashes JVM\n-#  @author Jim Holmlund\/Swamy Venkataramanappa\n-#  @run shell RedefineClearBreakpoint.sh\n-\n-#  The failure occurs after a bkpt is set and then cleared\n-#  after a class redefinition, in a method that was EMCP.\n-#  This sequence creates a state in which subsequent operations\n-#  such as accessing local vars via JVMDI, can cause a hotspot crash.\n-\n-# These are variables that can be set to control execution\n-\n-compileOptions=-g\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-        \n-        public $1() {\n-            int a=23;\n-            a=m(a);\n-            \n-        }\n-        public int m(int b){\n-            int bb=89;\n-            System.out.println(\"$1 -  constructor\" + b); \/\/@1 breakpoint\n-            return b*b;\n-        }\n-        \n-        public static void main(java.lang.String[] args) {\n-            new $1();        \n-            int jj = 0;   \/\/@1 delete\n-        }\n-            \n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    #cmd clear    NOTE this shows that jdb thinks the bpt is still set :-(\n-    setBkpts @1\n-    cmd next     # This is needed to make the crash happen at the 'locals' cmd\n-    cmd clear shtest:11\n-    cmd locals   # The crash happens here.\n-    #where\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineClearBreakpoint.sh","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4559100\n+ * @summary The VM crashes when a method in a redefined class throws an exception.\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineException.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm RedefineException\n+ *\/\n+\n+\/* This is another symptomm of 4559100\n+ * This causes a bus error on solsparc:\n+ *  ---- called from signal handler with signal 10 (SIGBUS) ------\n+ *    [11] constantPoolOopDesc::klass_at_if_loaded(0xffbed4d8, 0x16, 0xffbed5cc, 0x0, 0x1, 0xfa40b330), at 0xfe11568c\n+ *    [12] methodOopDesc::fast_exception_handler_bci_for(0x6, 0x1, 0xfe400a0c, 0x0, 0x2d1f0, 0x0), at 0xfe12e620\n+ *    [13] jvmdi::post_exception_throw_event(0x2d1f0, 0xf61036f8, 0xf6103752, 0xf20414a8, 0x2e2928, 0xfe12e190), at 0xfe2a4fa4\n+ *\/\n+\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefineExceptionTarg {\n+    String str;\n+    int ii;\n+    static public void main(String[] args) {\n+        System.out.println(\"In Main\");\n+        RedefineExceptionTarg mine = new RedefineExceptionTarg();\n+        mine.a1();\n+    }\n+\n+    public void a1() {\n+        int a1local = 1;\n+        String a1string = \"a1\";\n+\n+        ii = 89;                                 \/\/ @1 delete this line\n+        str = \"foo\";\n+        System.out.println(\"a1: Calling the original a2\/a3.  'The @@@ deleted lines should appear\");\n+        System.out.println(\"ii = \" + ii);        \/\/ @1 delete this line\n+        a2();\n+    }\n+\n+    public void a2() {\n+        int a2local = 2;\n+        String a2string = \"a2\";\n+        \/\/System.out.println(\"a2: @ @@delete this line\");\n+        try {\n+            a3();\n+        } catch (Exception ee) {\n+            System.out.println(\"a2: Exception caught\");\n+        }\n+        System.out.println(\"a2: done\");\n+    }\n+\n+    public void a3() throws Exception {\n+        int a3local = 3;\n+        String a3string = \"a3\";\n+        System.out.println(\"a3: @@ delete this line\");   \/\/ If this line is deleted, the test passes!\n+        System.out.println(\"a3: @1 breakpoint here a3\");\n+        throw new Exception(\"This is the exception\");\n+    }\n+}\n+\n+public class RedefineException extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineException().run();\n+    }\n+\n+    private RedefineException() {\n+        super(RedefineExceptionTarg.class.getName(), \"RedefineException.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1);\n+        jdb.command(JdbCommand.pop());\n+        jdb.contToExit(1);\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineException.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -1,119 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4559100\n-#  @summary The VM crashes when a method in a redefined class throws an exception.\n-#  @author Jim Holmlund\n-#\n-#  @run shell RedefineException.sh\n-\n-# This is another symptomm of 4559100\n-# This causes a bus error on solsparc:\n-#  ---- called from signal handler with signal 10 (SIGBUS) ------\n-#  [11] constantPoolOopDesc::klass_at_if_loaded(0xffbed4d8, 0x16, 0xffbed5cc, 0x0, 0x1, 0xfa40b330), at 0xfe11568c\n-#  [12] methodOopDesc::fast_exception_handler_bci_for(0x6, 0x1, 0xfe400a0c, 0x0, 0x2d1f0, 0x0), at 0xfe12e620\n-#  [13] jvmdi::post_exception_throw_event(0x2d1f0, 0xf61036f8, 0xf6103752, 0xf20414a8, 0x2e2928, 0xfe12e190), at 0xfe2a4fa4\n-\n-# These are variables that can be set to control execution\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-    String str;\n-    int ii;\n-    static public void main(String[] args) {\n-       System.out.println(\"In Main\");\n-       $1 mine = new $1();\n-       mine.a1();\n-    }\n-\n-    public void a1() {\n-      int a1local = 1;\n-      String a1string = \"a1\";\n-\n-      ii = 89;                                 \/\/ @1 delete this line\n-      str = \"foo\";\n-      System.out.println(\"a1: Calling the original a2\/a3.  'The @@@ deleted lines should appear\");\n-      System.out.println(\"ii = \" + ii);        \/\/ @1 delete this line\n-      a2();\n-    }\n-\n-    public void a2() {\n-      int a2local = 2;\n-      String a2string = \"a2\";\n-      \/\/System.out.println(\"a2: @ @@delete this line\");\n-      try {\n-        a3();\n-      } catch (Exception ee) {\n-        System.out.println(\"a2: Exception caught\");\n-      }\n-      System.out.println(\"a2: done\");\n-    }\n-  \n-    public void a3() throws Exception {\n-      int a3local = 3;\n-      String a3string = \"a3\";\n-      System.out.println(\"a3: @@ delete this line\");   \/\/ If this line is deleted, the test passes!\n-      System.out.println(\"a3: @1 breakpoint here a3\");\n-      throw new Exception(\"This is the exception\");\n-    }\n-}\n-EOF\n-}\n-\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt\n-    redefineClass @1\n-    cmd pop\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineException.sh","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4788344\n+ * @summary RedefineClasses is an apparent no-op if instance method is final\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineFinal.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineFinal.java\n+ * @run main\/othervm RedefineFinal\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+final class RedefineFinalTarg {\n+\n+    public int m1(int i) {\n+        \/\/ @1 uncomment System.out.println(\"I'm here\");\n+        return m2(i, 1000);\n+    }\n+\n+    public int m2(int i, int j) {\n+        if (i < 0 || j < 0) {   \/\/ @1 breakpoint\n+            throw new IllegalArgumentException();\n+        }\n+        return i+j;\n+    }\n+\n+    RedefineFinalTarg() {\n+        m1(0);\n+        m1(0);\n+    }\n+\n+    public static void main(String args[]) {\n+        new RedefineFinalTarg();\n+    }\n+}\n+\n+public class RedefineFinal extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineFinal().run();\n+    }\n+\n+    private RedefineFinal() {\n+        super(RedefineFinalTarg.class.getName(), \"RedefineFinal.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.cont());\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"obsolete\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineFinal.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,103 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4788344\n-#  @summary RedefineClasses is an apparent no-op if instance method is final\n-#\n-#  @run shell RedefineFinal.sh\n-\n-compileOptions=-g\n-compileOptions2=-g\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public final class $1 {\n-\n-    public int m1(int i) {\n-        \/\/ @1 uncomment System.out.println(\"I'm here\");\n-        return m2(i, 1000);\n-    }\n-\n-    public int m2(int i, int j) {\n-        if (i < 0 || j < 0) {   \/\/ @1 breakpoint\n-            throw new IllegalArgumentException();\n-        }\n-        return i+j;\n-    }\n-\n-    $1() {\n-        m1(0);\n-        m1(0);\n-    }\n-\n-    public static void main(String args[]) {\n-        new $1();\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    setBkpts @1\n-    contToBkpt\n-    cmd where\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-jdbFailIfPresent 'obsolete'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineFinal.sh","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4777868\n+ * @summary Compile with java -g, do a RedefineClasses, and you don't get local vars\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/Redefine-g.sh\n+ *\n+ * @library \/lib\n+ * @compile RedefineG.java\n+ * @run main\/othervm RedefineG\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+\n+\/\/ Compile the first version without -g and the 2nd version with -g.\n+class RedefineGTarg {\n+    public RedefineGTarg() {\n+    }\n+    public static void main(String[] args){\n+        int gus=22;\n+        RedefineGTarg kk=new RedefineGTarg();\n+        kk.m1(\"ab\");\n+      }\n+\n+    void m1(String p1) {\n+        int m1l1 = 1;\n+        System.out.println(\"m1(String) called\");\n+        m1(p1, \"2nd\");\n+        \/\/ @1 uncomment System.out.println(\"Hello Milpitas!\");\n+    }\n+\n+    void m1(String p1, String p2) {\n+        int m1l2 = 2;\n+        System.out.println(\"m2\" + p1 + p2);  \/\/ @1 breakpoint\n+    }\n+\n+}\n+\n+public class RedefineG extends JdbTest {\n+    public static void main(String argv[]) {\n+        new RedefineG().run();\n+    }\n+\n+    private RedefineG() {\n+        super(DEBUGGEE_CLASS,\n+                \"RedefineG.java\");\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = RedefineGTarg.class.getName();\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.command(JdbCommand.locals());\n+\n+        redefineClass(1, \"-g\");\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.command(JdbCommand.locals());\n+\n+        jdb.command(JdbCommand.pop());\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.command(JdbCommand.locals());\n+\n+        jdb.command(JdbCommand.pop());\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.command(JdbCommand.locals());\n+\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldContain(\"p1 = \\\"ab\\\"\")\n+                .shouldContain(\"p2 = \\\"2nd\\\"\")\n+                .shouldContain(\"m1l2 = 2\")\n+                .shouldNotContain(\"m1l1\")\n+                .shouldContain(\"args = instance of java.lang.String\")\n+                .shouldContain(\"gus = 22\")\n+                .shouldContain(\"kk = instance of \" + DEBUGGEE_CLASS);\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineG.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6394084\n+ * @summary Redefine class can't handle addition of 64 bit constants in JDK1.5.0_05\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineIntConstantToLong.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineIntConstantToLong.java\n+ * @run main\/othervm RedefineIntConstantToLong\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+final class RedefineIntConstantToLongTarg {\n+\n+    public long m1(int i) {\n+        long r=0;\n+        r = m2(i * 2); \/\/ @1 commentout\n+        \/\/ @1 uncomment      r =m2(i * 2L);\n+        return r;\n+    }\n+\n+    public long m2(int j) {\n+        System.out.println(System.getProperty(\"line.separator\") +\n+                           \"**** public long m2(int j) with value: \" + j);\n+        return j;\n+    }\n+\n+    public long m2(long j) {\n+        System.out.println(System.getProperty(\"line.separator\") +\n+                           \"**** public long m2(long j) with value: \" + j);\n+        return j;\n+    }\n+\n+    public void doit() throws Exception {\n+        long r1 = 0;\n+        long r2;\n+        r1 = m1(1000);\n+        r2 = 0;         \/\/ @1 breakpoint\n+        r2 = m1(1000);\n+        if (r1 != r2) { \/\/ @1 breakpoint\n+             throw new Exception(\"FAILURE: Expected value: \" + r1 + \" Actual value: \" + r2);\n+        } else {\n+             System.out.println(\"SUCCESS: Expected value: \" + r1 + \" Actual value: \" + r2);\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new RedefineIntConstantToLongTarg().doit();\n+    }\n+}\n+\n+public class RedefineIntConstantToLong extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineIntConstantToLong().run();\n+    }\n+\n+    private RedefineIntConstantToLong() {\n+        super(RedefineIntConstantToLongTarg.class.getName(), \"RedefineIntConstantToLong.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.cont());\n+        jdb.command(JdbCommand.where(\"\"));\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"FAILURE:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineIntConstantToLong.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -1,118 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 6394084\n-#  @summary Redefine class can't handle addition of 64 bit constants in JDK1.5.0_05\n-#\n-#  @run shell RedefineIntConstantToLong.sh\n-\n-compileOptions=-g\n-compileOptions2=-g\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public final class $1 {\n-\n-    public long m1(int i) {\n-        long r=0;\n-        r = m2(i * 2); \/\/ @1 commentout\n-        \/\/ @1 uncomment      r =m2(i * 2L);\n-        return r;\n-    }\n-\n-    public long m2(int j) {\n-        System.out.println(System.getProperty(\"line.separator\") + \n-                           \"**** public long m2(int j) with value: \" + j);\n-        return j;\n-    }\n-\n-    public long m2(long j) {\n-        System.out.println(System.getProperty(\"line.separator\") + \n-                           \"**** public long m2(long j) with value: \" + j);\n-        return j;\n-    }\n-\n-    public void doit() throws Exception {\n-        long r1 = 0;\n-        long r2;\n-        r1 = m1(1000);\n-        r2 = 0;         \/\/ @1 breakpoint\n-        r2 = m1(1000);\n-        if (r1 != r2) { \/\/ @1 breakpoint\n-             throw new Exception(\"FAILURE: Expected value: \" + r1 + \" Actual value: \" + r2);\n-        } else {\n-             System.out.println(\"SUCCESS: Expected value: \" + r1 + \" Actual value: \" + r2);\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        new $1().doit();\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    setBkpts @1\n-    contToBkpt\n-    cmd where\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-jdbFailIfPresent 'FAILURE:'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineIntConstantToLong.sh","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4724076\n+ * @summary Redefine does not work in for\/while loop\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineMulti.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineMulti.java\n+ * @run main\/othervm RedefineMulti\n+ *\/\n+\n+\/*\n+ * The failure occurs when a method is active and\n+ * a method that it calls multiple times is redefined\n+ * more than once.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefineMultiTarg {\n+\n+    String field1;\n+    String field2;\n+\n+    \/\/ The first time thru the loop in start,\n+    \/\/ \"Before update...\" should be printed.\n+    \/\/ After the first redefine, \"After update...\" should be printed\n+    \/\/ After the 2nd redefine, \"abcde...\" should be printed.\n+    \/\/ The bug is that \"After update...\" is printed instead because\n+    \/\/ stat() calls version 2 of doSomething() instead of\n+    \/\/ version 3.\n+    private void doSomething()  {\n+        System.out.println(\"Before update...\");  \/\/ @1 commentout\n+        \/\/ @1 uncomment System.out.println(\"After update...\");  \/\/ @2 commentout\n+        \/\/ @2 uncomment System.out.println(\"abcde...\");\n+    }\n+\n+    public void start() {\n+        for (int i=0; i < 3; i++)   {\n+            doSomething();      \/\/ @1 breakpoint here  line 16\n+            System.out.println(\"field1 = \" + field1);\n+            System.out.println(\"field2 = \" + field2);\n+        }\n+        \/\/ Redefinex myx = new Redefinex();\n+        \/\/  for (int i = 0; i < 5; i++) {\n+        \/\/    myx.methodx1();                     \/\/ line 22\n+        \/\/    System.out.println(\"fieldx1 = \" + myx.fieldx1);\n+        \/\/    System.out.println(\"fieldx2 = \" + myx.fieldx2);\n+        \/\/  }\n+    }\n+\n+    public static void main(String[] args) {\n+        RedefineMultiTarg xxx = new RedefineMultiTarg();\n+        xxx.field1 = \"field1\";\n+        xxx.field2 = \"field2\";\n+        xxx.start();\n+    }\n+}\n+\n+class Redefinex {\n+    public String fieldx1;\n+    public String fieldx2;\n+\n+    Redefinex() {\n+        fieldx1 = \"fieldx1\";\n+        fieldx2 = \"fieldx2\";\n+    }\n+\n+    public void methodx1() {\n+        System.out.println(\"redefinex 1\");\n+        \/\/System.out.println(\"redefinex 2\");\n+        \/\/System.out.println(\"redefinex 3\");\n+    }\n+}\n+\n+\/*********\n+Steps to reproduce this problem:\n+   a. add line breakpoint  in start()\n+   b. debug\n+   c. when breakpoint is hit, type continue. You should see output \"Before update...\"\n+   d. change \"Before update\" to  \"After update\"\n+   e. redefine,  and set line breakpoint (see step a)\n+   f. type continue. You should see output \"After update\"\n+   g. change \"After update\" to \"abcde\"\n+   h. redefine, and set line breakpoint (see step a)\n+   i.  type continue. The output is shown as \"After update\"\n+   j. to see \"abcde\" output,  users will have to pop the stack, and re-execute method start().\n+************\/\n+\n+public class RedefineMulti extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineMulti().run();\n+    }\n+\n+    private RedefineMulti() {\n+        super(RedefineMultiTarg.class.getName(), \"RedefineMulti.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        jdb.command(JdbCommand.cont());\n+        redefineClass(1, \"-g\");\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.cont());\n+        redefineClass(2, \"-g\");\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\")\n+                .shouldContain(\"abcde\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineMulti.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -1,155 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4724076\n-#  @summary Redefine does not work in for\/while loop\n-#  @author Jim Holmlund\/Swamy Venkataramanappa\n-#\n-#  The failure occurs when a method is active and\n-#  a method that it calls multiple times is redefined\n-#  more than once.\n-#  @run shell\/timeout=240 RedefineMulti.sh\n-\n-compileOptions=-g\n-#java=java_g\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-\n-    String field1;\n-    String field2;\n-\n-    \/\/ The first time thru the loop in start,\n-    \/\/ \"Before update...\" should be printed.\n-    \/\/ After the first redefine, \"After update...\" should be printed\n-    \/\/ After the 2nd redefine, \"abcde...\" should be printed.\n-    \/\/ The bug is that \"After update...\" is printed instead because\n-    \/\/ stat() calls version 2 of doSomething() instead of\n-    \/\/ version 3.\n-    private void doSomething()  {\n-        System.out.println(\"Before update...\");  \/\/ @1 commentout\n-        \/\/ @1 uncomment System.out.println(\"After update...\");  \/\/ @2 commentout\n-        \/\/ @2 uncomment System.out.println(\"abcde...\");\n-    }\n-\n-    public void start() {\n-        for (int i=0; i < 3; i++)   {\n-            doSomething();      \/\/ @1 breakpoint here  line 16\n-            System.out.println(\"field1 = \" + field1);\n-            System.out.println(\"field2 = \" + field2);\n-        }\n-        \/\/ Redefinex myx = new Redefinex();\n-        \/\/  for (int i = 0; i < 5; i++) {\n-        \/\/    myx.methodx1();                     \/\/ line 22\n-        \/\/    System.out.println(\"fieldx1 = \" + myx.fieldx1);\n-        \/\/    System.out.println(\"fieldx2 = \" + myx.fieldx2);\n-        \/\/  }\n-    }\n-\n-    public static void main(String[] args) {\n-        $1 xxx = new $1();\n-        xxx.field1 = \"field1\";\n-        xxx.field2 = \"field2\";\n-        xxx.start();\n-    }\n-}\n-\n-class Redefinex {\n-    public String fieldx1;\n-    public String fieldx2;\n-\n-    Redefinex() {\n-        fieldx1 = \"fieldx1\";\n-        fieldx2 = \"fieldx2\";\n-    }\n-\n-    public void methodx1() {\n-        System.out.println(\"redefinex 1\");\n-        \/\/System.out.println(\"redefinex 2\");\n-        \/\/System.out.println(\"redefinex 3\");\n-    }\n-     \n-}\n-\n-    \/*********\n-Steps to reproduce this problem:\n-   a. add line breakpoint  in start()\n-   b. debug\n-   c. when breakpoint is hit, type continue. You should see output\n-\"Before update...\"\n-   d. change \"Before update\" to  \"After update\"\n-   e. redefine,  and set line breakpoint (see step a)\n-   f. type continue. You should see output \"After update\"\n-   g. change \"After update\" to \"abcde\"\n-   h. redefine, and set line breakpoint (see step a)\n-   i.  type continue. The output is shown as \"After update\"\n-\n-   j. to see \"abcde\" output,  users will have to pop the stack, and\n-re-execute method start().\n-    ************\/\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    contToBkpt\n-    redefineClass @1\n-    setBkpts @1\n-    contToBkpt\n-    redefineClass @2\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-debuggeeFailIfNotPresent \"abcde\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineMulti.sh","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4622663\n+ * @summary redefine and pop top frame from jdb gets assertion failure\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefinePop.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefinePop.java\n+ * @run main\/othervm RedefinePop\n+ *\/\n+\n+\/*\n+ * The failure occurs with debug java when the pop deletes the\n+ * line that called the method which is being popped.\n+ *\/\n+\n+\/*\n+ * assert(index<len, \"should have found method\")\n+ * [8] report_assertion_failure(0xfe2a54d9, 0xfe2a54e3, 0x2cc, 0xfe2a5527, 0xfffffff8, 0x3f2b8), at 0xfda1e5e8\n+ * [9] methodOopDesc::jni_id(0xf590a2f0, 0x3e868, 0x8, 0xffbed760, 0xf590a3ac, 0xffbed664), at 0xfdcd7a2c\n+ * [10] JvmdiThreadState::compare_and_set_current_location(0x3f450, 0xf590a2f0, 0xf590a33f, 0x1, 0x1, 0x3e868), at 0xfdc0f670\n+ * [11] jvmdi::at_single_stepping_point(0x3e868, 0xf590a2f0, 0xf590a33f, 0x5, 0x0, 0x0), at 0xfdc29184\n+ * [12] InterpreterRuntime::at_safepoint(0x3e868, 0xb6, 0x2, 0xf9c28744, 0xf590a038, 0xffbed880), at 0xfdb0d590\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefinePopTarg {\n+    static public void main(String[] args) {\n+        RedefinePopTarg mine = new RedefinePopTarg();\n+        mine.a1(44);   \/\/ @1 delete the call that we are in when the pop occurs\n+        mine.a4();\n+    }\n+\n+    public void a1(int p1) {\n+        System.out.println(\"a1: @1 breakpoint here\");\n+    }\n+\n+    public void a4() {\n+        System.out.println(\"a4: The next line should not say Ni!\");\n+        System.out.println(\"a4: Ni!\");   \/\/ @1 delete\n+    }\n+}\n+\n+public class RedefinePop extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefinePop().run();\n+    }\n+\n+    private RedefinePop() {\n+        super(RedefinePopTarg.class.getName(), \"RedefinePop.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+        jdb.command(JdbCommand.pop());\n+        jdb.contToExit(1);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefinePop.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -1,102 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2005, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4622663\n-#  @summary redefine and pop top frame from jdb gets assertion failure\n-#  @author Jim Holmlund\/Swamy Venkataramanappa\n-#\n-#  The failure occurs with debug java when the pop deletes the\n-#  line that called the method which is being popped.\n-#  @run shell RedefinePop.sh\n-\n-\n-# assert(index<len, \"should have found method\")\n-#  [8] report_assertion_failure(0xfe2a54d9, 0xfe2a54e3, 0x2cc, 0xfe2a5527, 0xfffffff8, 0x3f2b8), at 0xfda1e5e8\n-# [9] methodOopDesc::jni_id(0xf590a2f0, 0x3e868, 0x8, 0xffbed760, 0xf590a3ac, 0xffbed664), at 0xfdcd7a2c\n- # [10] JvmdiThreadState::compare_and_set_current_location(0x3f450, 0xf590a2f0, 0xf590a33f, 0x1, 0x1, 0x3e868), at 0xfdc0f670\n-#  [11] jvmdi::at_single_stepping_point(0x3e868, 0xf590a2f0, 0xf590a33f, 0x5, 0x0, 0x0), at 0xfdc29184\n-#  [12] InterpreterRuntime::at_safepoint(0x3e868, 0xb6, 0x2, 0xf9c28744, 0xf590a038, 0xffbed880), at 0xfdb0d590\n-\n-# These are variables that can be set to control execution\n-\n-compileOptions=-g\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-    static public void main(String[] args) {\n-       $1 mine = new $1();\n-       mine.a1(44);   \/\/ @1 delete the call that we are in when the pop occurs\n-       mine.a4();\n-    }\n-\n-    public void a1(int p1) {\n-      System.out.println(\"a1: @1 breakpoint here\");\n-    }\n-\n-    public void a4() {\n-      System.out.println(\"a4: The next line should not say Ni!\");\n-      System.out.println(\"a4: Ni!\");   \/\/ @1 delete\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-    cmd pop\n-    cmd cont\n-    cmd quit\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefinePop.sh","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4689395\n+ * @summary \"step over\" after a class is redefined acts like \"step out\"\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineStep.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineStep.java\n+ * @run main\/othervm RedefineStep\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class RedefineStepTarg {\n+    static int counter;\n+    static public void main(String[] args) {\n+        RedefineStepTarg mine = new RedefineStepTarg();\n+        mine.a1(10);\n+        System.out.println(\"done\");  \/\/ should not see this\n+    }\n+\n+    public void a1(int p1) {\n+        System.out.println(\"jj0\");   \/\/ @1 breakpoint   line 10\n+        a2();\n+        System.out.println(\"jj3\");    \/\/ @1 delete\n+    }\n+    public void a2() {\n+        System.out.println(\"a2\");\n+    }\n+}\n+\n+public class RedefineStep extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineStep().run();\n+    }\n+\n+    private RedefineStep() {\n+        super(RedefineStepTarg.class.getName(), \"RedefineStep.java\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        redefineClass(1, \"-g\");\n+\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.next());\n+        jdb.command(JdbCommand.next());\n+\n+        new OutputAnalyzer(getJdbOutput())\n+                .shouldNotContain(\"should not see this\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineStep.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -1,101 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4689395\n-#  @summary \"step over\" after a class is redefined acts like \"step out\"\n-#  @author Jim Holmlund\n-#  @run shell RedefineStep.sh\n-#\n-\n-#pkg=untitled7\n-classname=gus1\n-compileOptions=-g\n-#java=java_g\n-\n-# Uncomment this to see the JDI trace\n-#jdbOptions=-dbgtrace\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-    static int counter;\n-    static public void main(String[] args) {\n-       $1 mine = new $1();\n-       mine.a1(10);\n-       System.out.println(\"done\");  \/\/ should not see this\n-    }\n-\n-    public void a1(int p1) {\n-        System.out.println(\"jj0\");   \/\/ @1 breakpoint   line 10\n-        a2();\n-        System.out.println(\"jj3\");    \/\/ @1 delete\n-    }\n-    public void a2() {\n-        System.out.println(\"a2\");\n-    }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    redefineClass @1\n-\n-    cmd next\n-    cmd next\n-    cmd next\n-    cmd next\n-    cmd next\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-\n-jdbFailIfPresent 'should not see this'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineStep.sh","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4660756\n+ * @summary TTY: Need to clear source cache after doing a redefine class\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/RedefineTTYLineNumber.sh\n+ *\n+ * @library \/lib\n+ * @compile -g RedefineTTYLineNumber.java\n+ * @run main\/othervm RedefineTTYLineNumber\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class RedefineTTYLineNumberTarg {\n+\n+    public void B() {\n+        System.out.println(\"in B: @1 delete\"); \/\/ delete 1 line before A method\n+    }\n+\n+    public void A() {\n+        System.out.println(\"expected statement printed by jdb\");\n+    }\n+\n+    public static void main(String[] args) {\n+        RedefineTTYLineNumberTarg untitled41 = new RedefineTTYLineNumberTarg();\n+        untitled41.A();\n+        System.out.println(\"done\");\n+    }\n+}\n+\n+public class RedefineTTYLineNumber extends JdbTest {\n+\n+    public static void main(String argv[]) {\n+        new RedefineTTYLineNumber().run();\n+    }\n+\n+    private RedefineTTYLineNumber() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private final static String DEBUGGEE_CLASS = RedefineTTYLineNumberTarg.class.getName();\n+    private final static String SOURCE_FILE = \"RedefineTTYLineNumber.java\";\n+\n+    \/\/ parses line number from the jdb \"Breakpoint hit\" message\n+    private static int parseLineNum(String s) {\n+        \/\/ Breakpoint hit: \"thread=main\", RedefineTTYLineNumberTarg.A(), line=49 bci=0\n+        \/\/ 49            System.out.println(\"expected statement printed by jdb\");\n+        Matcher m = Pattern.compile(\"\\\\bline=(\\\\d+)\\\\b\").matcher(s);\n+        if (!m.find()) {\n+            throw new RuntimeException(\"could not parse line number\");\n+        }\n+        return Integer.parseInt(m.group(1));\n+    }\n+\n+    private void verifyBPSource(int n, String reply) {\n+        if (!reply.contains(\"expected statement printed by jdb\")) {\n+            throw new RuntimeException(\"Breakpoint source (\" + n + \") is not correct\");\n+        }\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"A\"));\n+        String bp1Reply = execCommand(JdbCommand.run()).getStdout();\n+        int bp1Line = parseLineNum(bp1Reply);\n+        redefineClass(1, \"-g\");\n+        jdb.command(JdbCommand.pop());\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"A\"));\n+        String bp2Reply = execCommand(JdbCommand.cont()).getStdout();\n+        int bp2Line = parseLineNum(bp2Reply);\n+\n+        new OutputAnalyzer(getDebuggeeOutput())\n+                .shouldNotContain(\"Internal exception:\");\n+        \/\/ 1 line is deleted before RedefineTTYLineNumberTarg.A(),\n+        \/\/ so bp2Line should be equals bp1Line-1\n+        Asserts.assertEquals(bp2Line, bp1Line - 1, \"BP line numbers\");\n+        verifyBPSource(1, bp1Reply);\n+        \/\/ uncomment the following line to reproduce JDK-8210927\n+        \/\/verifyBPSource(2, bp2Reply);\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineTTYLineNumber.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -1,101 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4660756\n-#  @summary TTY: Need to clear source cache after doing a redefine class\n-#  @author Jim Holmlund\n-#  @run shell\/timeout=240 RedefineTTYLineNumber.sh\n-\n-#set -x\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-#classname=Untitled3\n-compileOptions=-g\n-#java=java_g\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-\n-  public void B() {\n-    System.out.println(\"in B\");\n-    System.out.println(\"in B: @1 delete\");\n-  }\n-\n-  \/\/ line number sensitive!!! Next line must be line 10.\n-  public void A() {\n-    System.out.println(\"in A, about to call B\");  \/\/ 11 before, 10 afterward\n-    System.out.println(\"out from B\");\n-  }\n-\n-  public static void main(String[] args) {\n-    $1 untitled41 = new $1();\n-    untitled41.A();\n-    System.out.println(\"done\");\n-  }\n-}\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    cmd stop in shtest.A\n-    runToBkpt\n-    #jdbFailIfNotPresent \"System\\.out\\.println\" 3\n-    redefineClass @1\n-    cmd pop\n-    cmd stop in shtest.A\n-    contToBkpt\n-    #jdbFailIfNotPresent \"System\\.out\\.println\" 3\n-    cmd quit\n-    \n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    if [ -r $TESTSRC\/ShellScaffold.sh ] ; then\n-        . $TESTSRC\/ShellScaffold.sh \n-    elif [ -r $TESTSRC\/..\/ShellScaffold.sh ] ; then\n-        . $TESTSRC\/..\/ShellScaffold.sh\n-    fi\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-debuggeeFailIfPresent \"Internal exception:\"\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/RedefineTTYLineNumber.sh","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4511950 4843082\n+ * @summary 1. jdb's expression evaluation doesn't perform string conversion properly\n+ *          2. TTY: run on expression evaluation\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/StringConvertTest.sh\n+ *\n+ * @library \/lib\n+ * @compile -g StringConvertTest.java\n+ * @run main\/othervm StringConvertTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class StringConvertTarg {\n+    String me;\n+    static JJ1 x1;\n+    static JJ2 x2;\n+    static JJ2[] x3 = new JJ2[2];\n+    static String x4 = \"abc\";\n+    static int ii = 89;\n+    static String grower = \"grower\";\n+    static StringBuffer sbGrower = new StringBuffer(\"sbGrower\");\n+    int ivar = 89;\n+    StringConvertTarg(String xx) {\n+        me = xx;\n+    }\n+\n+    static String fred() {\n+        return \"a static method\";\n+    }\n+\n+    void  gus() {\n+        int gusLoc = 1;\n+        StringBuffer sbTim = new StringBuffer(\"tim\");\n+        int kk = 1;                          \/\/@1 breakpoint\n+    }\n+\n+    static String growit(String extra) {\n+        grower += extra;\n+        return grower;\n+    }\n+\n+    static String sbGrowit(String extra) {\n+        sbGrower.append(extra);\n+        return sbGrower.toString();\n+    }\n+\n+    public static void main(String[] args) {\n+        x1 = new JJ1(\"first JJ1\");\n+        x2 = new JJ2(\"first JJ2\");\n+        x3[0] = new JJ2(\"array0\");\n+        x3[1] = new JJ2(\"array1\");\n+        StringConvertTarg loc1 = new StringConvertTarg(\"first me\");\n+\n+        \/\/ These just show what output should look like\n+        System.out.println(\"x1 = \" + x1);\n+        System.out.println(\"x2 = \" + x2);\n+        System.out.println(\"x3.toString = \" + x3.toString());\n+        System.out.println(\"x4.toString = \" + x4.toString());\n+\n+        \/\/ Dont want to call growit since it would change\n+        \/\/ the value.\n+\n+        System.out.println(\"loc1 = \" + loc1);\n+        System.out.println(\"-\" + loc1);\n+        loc1.gus();\n+     }\n+\n+    \/\/ This does not have a toString method\n+    static class JJ1 {\n+        String me;\n+\n+        JJ1(String whoAmI) {\n+            me = whoAmI;\n+        }\n+    }\n+\n+    \/\/ This has a toString method\n+    static class JJ2 {\n+        String me;\n+\n+        JJ2(String whoAmI) {\n+            me = whoAmI;\n+        }\n+        public String toString() {\n+            return me;\n+        }\n+\n+        public int meth1() {\n+            return 89;\n+        }\n+    }\n+}\n+\n+public class StringConvertTest extends JdbTest {\n+    public static void main(String argv[]) {\n+        new StringConvertTest().run();\n+    }\n+\n+    private StringConvertTest() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = StringConvertTarg.class.getName();\n+    private static final String SOURCE_FILE = \"StringConvertTest.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        \/\/ Run to breakpoint #1\n+        jdb.command(JdbCommand.run());\n+\n+        \/\/ Each print without the 'toString()' should print the\n+        \/\/ same thing as the following print with the toString().\n+        \/\/ The \"print 1\"s are just spacers\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x1\"));\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x1.toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x2\"));\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x2.toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ arrays is a special case.\n+        \/\/ StringConvertTarg prints:\n+        \/\/      x3.toString = [LStringConvertTarg$JJ2;@61443d8f\n+        \/\/ jdb \"print ((Object)StringConvertTarg.x3).toString()\" prints:\n+        \/\/      com.sun.tools.example.debug.expr.ParseException:\n+        \/\/              No instance field or method with the name toString in StringConvertTarg$JJ2[]\n+        \/\/      ((Object)StringConvertTarg.x3).toString() = null\n+        \/\/ jdb \"print (Object)(StringConvertTarg.x3)\" prints:\n+        \/\/      (Object)(StringConvertTarg.x3) = instance of StringConvertTarg$JJ2[2] (id=624)\n+        \/*\n+        jdb.command(JdbCommand.print(\"(Object)(StringConvertTarg.x3)\"));\n+        jdb.command(JdbCommand.print(\"((Object)StringConvertTarg.x3).toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+        *\/\n+\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x4\"));\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x4.toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ Make sure jdb doesn't call a method multiple times.\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.growit(\\\"xyz\\\")\"));\n+        jdb.command(JdbCommand.eval(\"StringConvertTarg.sbGrower.append(\\\"xyz\\\")\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        jdb.command(JdbCommand.eval(\"sbTim.toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        jdb.command(JdbCommand.print(\"this\"));\n+        jdb.command(JdbCommand.print(\"this.toString()\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ A possible bug is that this ends up with multiple \"s\n+        jdb.command(JdbCommand.print(\"\\\"--\\\"StringConvertTarg.x1\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        \/\/ This too\n+        jdb.command(JdbCommand.print(\"StringConvertTarg.x4 + 2\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        jdb.command(JdbCommand.print(\"this.ivar\"));\n+        jdb.command(JdbCommand.print(\"gusLoc\"));\n+        jdb.command(JdbCommand.print(\"1\"));\n+\n+        new OutputAnalyzer(jdb.getJdbOutput())\n+                .shouldNotContain(\"\\\"\\\"\")\n+                .shouldNotContain(\"instance of\")\n+                .shouldNotContain(\"xyzxyz\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/StringConvertTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -1,211 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4511950 4843082\n-#  @summary 1. jdb's expression evaluation doesn't perform string conversion properly\n-#           2. TTY: run on expression evaluation\n-#  @author jim\/suvasis mukherjee\n-#\n-#  @run shell StringConvertTest.sh\n-\n-#  Run this script to see the bug.  See comments at the end\n-#  of the .java file for info on what the bug looks like.\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-classname=StringConvertTest\n-compileOptions=-g\n-#java=java_g\n-#mode=-Xcomp\n-\n-#jdbOptions=-dbgtrace\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-class $classname {\n-    String me;\n-    static JJ1 x1;\n-    static JJ2 x2;\n-    static JJ2[] x3 = new JJ2[2];\n-    static String x4 = \"abc\";\n-    static int ii = 89;\n-    static String grower = \"grower\";\n-    static StringBuffer sbGrower = new StringBuffer(\"sbGrower\");\n-    int ivar = 89;\n-    $classname(String xx) {\n-        me = xx;\n-    }\n-\n-    static String fred() {\n-        return \"a static method\";\n-    }\n-\n-    void  gus() {\n-        int gusLoc = 1;\n-        StringBuffer sbTim = new StringBuffer(\"tim\");\n-        int kk = 1;                          \/\/@1 breakpoint\n-    }\n-\n-    static String growit(String extra) {\n-        grower += extra;\n-        return grower;\n-    }\n-\n-    static String sbGrowit(String extra) {\n-        sbGrower.append(extra);\n-        return sbGrower.toString();\n-    }\n-\n-    public static void main(String[] args) {\n-        x1 = new JJ1(\"first JJ1\");\n-        x2 = new JJ2(\"first JJ2\");\n-        x3[0] = new JJ2(\"array0\");\n-        x3[1] = new JJ2(\"array1\");\n-        $classname  loc1 = new $classname(\"first me\");\n-        \n-        \/\/ These just show what output should look like\n-        System.out.println(\"x1 = \" + x1);\n-        System.out.println(\"x2 = \" + x2);\n-        System.out.println(\"x3.toString = \" + x3.toString());\n-        System.out.println(\"x4.toString = \" + x4.toString());\n-\n-        \/\/ Dont want to call growit since it would change\n-        \/\/ the value.\n-\n-        System.out.println(\"loc1 = \" + loc1);\n-        System.out.println(\"-\" + loc1);\n-        loc1.gus();\n-     }\n-\n-  \/\/ This does not have a toString method\n-  static class JJ1 {\n-    String me;\n-\n-    JJ1(String whoAmI) {\n-        me = whoAmI;\n-    }\n-  }\n-\n-  \/\/ This has a toString method\n-  static class JJ2 {\n-    String me;\n-\n-    JJ2(String whoAmI) {\n-        me = whoAmI;\n-    }\n-    public String toString() {\n-        return me;\n-    }\n-\n-    public int meth1() {\n-        return 89;\n-    }\n-  }\n-}\n-\n-EOF\n-}\n-\n-# This is called to feed cmds to jdb.\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-\n-    # Each print without the 'toString()' should print the\n-    # same thing as the following print with the toString().\n-    # The print 1s are just spacers\n-\n-    cmd print $classname.x1\n-    cmd print \"$classname.x1.toString()\"\n-    cmd print 1\n-\n-    cmd print $classname.x2\n-    cmd print \"$classname.x2.toString()\"\n-    cmd print 1\n-\n-    # An unreported bug: this isn't handled correctly.\n-    # If we uncomment this line, we will get an 'instance of...'  line\n-    # which will cause the test to fail.\n-    #cmd print \"(Object)($classname.x3)\"\n-    cmd print \"((Object)$classname.x3).toString()\"\n-    cmd print 1\n-\n-    cmd print $classname.x4\n-    cmd print \"$classname.x4.toString()\"\n-    cmd print 1\n-\n-    # Make sure jdb doesn't call a method multiple times.\n-    cmd print \"$classname.growit(\\\"xyz\\\")\"\n-    cmd eval  \"$classname.sbGrower.append(\\\"xyz\\\")\"\n-    cmd print 1\n-    \n-    cmd eval \"sbTim.toString()\"\n-    cmd print 1\n-\n-    cmd print this\n-    cmd print \"this.toString()\"\n-    cmd print 1\n-\n-    # A possible bug is that this ends up with multiple \"s\n-    cmd print '\"--\" + '$classname.x1\n-    cmd print 1\n-\n-    # This too\n-    cmd print \"$classname.x4 + 2\"\n-    cmd print 1\n-\n-    cmd print \"this.ivar\"\n-    cmd print gusLoc\n-    cmd print 1\n-    cmd quit\n-}\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh\n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfPresent '\"\"'\n-jdbFailIfPresent 'instance of'\n-jdbFailIfPresent 'xyzxyz'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/StringConvertTest.sh","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4546478\n+ * @summary Enabling a watchpoint can kill following NotifyFramePops\n+ * @comment converted from test\/jdk\/com\/sun\/jdi\/WatchFramePop.sh\n+ *\n+ * @library \/lib\n+ * @run main\/othervm WatchFramePop\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import lib.jdb.JdbCommand;\n+import lib.jdb.JdbTest;\n+\n+class WatchFramePopTarg {\n+    int watchMe;\n+    static public void main(String[] args) {\n+        System.out.println(\"In Main\");\n+        WatchFramePopTarg mine = new WatchFramePopTarg();\n+        mine.a1();\n+        System.out.println(\"Test completed\");\n+    }\n+\n+    public void a1() {\n+        a2();                           \/\/ @1 breakpoint. We'll do a watch of watchMe here\n+    }\n+\n+    public void a2() {\n+        System.out.println(\"in a2\");\n+        a3();\n+    }                                   \/\/ line 18\n+\n+    public void a3() {\n+        System.out.println(\"in a3\");    \/\/ After the watch, we'll run to here, line 21\n+        a4();                           \/\/ We'll do a 'next' to here.  The failure is that this\n+    }                                   \/\/ runs to completion, or asserts with java_g\n+\n+    public void a4() {\n+        System.out.println(\"in a4\");\n+    }\n+\n+}\n+\n+public class WatchFramePop extends JdbTest {\n+    public static void main(String argv[]) {\n+        new WatchFramePop().run();\n+    }\n+\n+    private WatchFramePop() {\n+        super(DEBUGGEE_CLASS, SOURCE_FILE);\n+    }\n+\n+    private static final String DEBUGGEE_CLASS = WatchFramePopTarg.class.getName();\n+    private static final String SOURCE_FILE = \"WatchFramePop.java\";\n+\n+    @Override\n+    protected void runCases() {\n+        setBreakpoints(1);\n+        jdb.command(JdbCommand.run());\n+        jdb.command(JdbCommand.watch(DEBUGGEE_CLASS, \"watchMe\"));\n+        jdb.command(JdbCommand.stopIn(DEBUGGEE_CLASS, \"a3\"));\n+        jdb.command(JdbCommand.cont());                             \/\/ stops at the bkpt\n+        jdb.command(JdbCommand.next());                             \/\/ The bug is that this next runs to completion\n+        \/\/ In which case, so does jdb\n+        \/\/ so we never get here.\n+\n+        new OutputAnalyzer(jdb.getJdbOutput())\n+                .shouldNotContain(\"The application exited\");\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/WatchFramePop.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -1,110 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#  @test\n-#  @bug 4546478\n-#  @summary Enabling a watchpoint can kill following NotifyFramePops\n-#  @author Jim Holmlund\n-#\n-#  @run shell WatchFramePop.sh\n-\n-# These are variables that can be set to control execution\n-\n-#pkg=untitled7\n-#classname=Untitled3\n-#compileOptions=-g\n-#java=\"java_g\"\n-\n-createJavaFile()\n-{\n-    cat <<EOF > $1.java.1\n-\n-public class $1 {\n-    int watchMe;\n-    static public void main(String[] args) {\n-       System.out.println(\"In Main\");\n-       $1 mine = new $1();\n-       mine.a1();\n-       System.out.println(\"Test completed\");\n-    }\n-\n-    public void a1() {\n-      a2();                            \/\/ @1 breakpoint. We'll do a watch of watchMe here\n-    }\n-\n-    public void a2() {\n-      System.out.println(\"in a2\");\n-      a3();\n-    }                                  \/\/ line 18\n-\n-    public void a3() {\n-      System.out.println(\"in a3\");     \/\/ After the watch, we'll run to here, line 21\n-      a4();                            \/\/ We'll do a 'next' to here.  The failure is that this\n-    }                                  \/\/ runs to completion, or asserts with java_g\n-                                       \n-\n-    public void a4() {\n-      System.out.println(\"in a4\");\n-    }\n-\n-}\n-EOF\n-}\n-\n-# drive jdb by sending cmds to it and examining its output\n-dojdbCmds()\n-{\n-    setBkpts @1\n-    runToBkpt @1\n-    cmd watch  shtest.watchMe\n-    cmd stop in shtest.a3   # bkpt at line 17\n-    contToBkpt              # stops at the bkpt at \n-    cmd next                # The bug is that this next runs to completion\n-                            # In which case, so does jdb\n-    cmd quit                # so we never get here.\n-}\n-\n-\n-mysetup()\n-{\n-    if [ -z \"$TESTSRC\" ] ; then\n-        TESTSRC=.\n-    fi\n-\n-    for ii in . $TESTSRC $TESTSRC\/.. ; do\n-        if [ -r \"$ii\/ShellScaffold.sh\" ] ; then\n-            . $ii\/ShellScaffold.sh \n-            break\n-        fi\n-    done\n-}\n-\n-# You could replace this next line with the contents\n-# of ShellScaffold.sh and this script will run just the same.\n-mysetup\n-\n-runit\n-jdbFailIfPresent 'The application exited'\n-pass\n","filename":"jdk\/test\/com\/sun\/jdi\/WatchFramePop.sh","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/\/ ClassTransformer provides functionality to transform java source and compile it.\n+\/\/ We cannot use InMemoryJavaCompiler as test files usually contain 2 classes (the test itself and debuggee)\n+\/\/ and InMemoryJavaCompiler cannot compile them.\n+public class ClassTransformer {\n+\n+    private final List<String> lines;\n+    private String fileName;\n+    private String workDir = \"ver{0}\";\n+    private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n+\n+    private ClassTransformer(List<String> lines) {\n+        this.lines = lines;\n+    }\n+\n+    public ClassTransformer setFileName(String fileName) {\n+        this.fileName = fileName;\n+        return this;\n+    }\n+\n+    \/\/ workDir is a MessageFormat pattern, id (int) is an {0} arg of the pattern.\n+    \/\/ can be relative (relatively \"scratch\" dir) or absolute.\n+    public ClassTransformer setWorkDir(String dir) {\n+        workDir = dir;\n+        return this;\n+    }\n+\n+    public static ClassTransformer fromString(String content) {\n+        return new ClassTransformer(Arrays.asList(content.split(\"\\\\R\")));\n+    }\n+\n+    public static ClassTransformer fromFile(Path filePath) {\n+        try {\n+            return new ClassTransformer(Files.readAllLines(filePath))\n+                    .setFileName(filePath.getFileName().toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"failed to read \" + filePath, e);\n+        }\n+    }\n+    public static ClassTransformer fromFile(String filePath) {\n+        return fromFile(Paths.get(filePath));\n+    }\n+\n+    public static ClassTransformer fromTestSource(String fileName) {\n+        return fromFile(Paths.get(System.getProperty(\"test.src\")).resolve(fileName));\n+    }\n+\n+    \/\/ returns path to the .class file of the transformed class\n+    public String transform(int id, String className, String... compilerOptions) {\n+        Path subdir = Paths.get(\".\").resolve(MessageFormat.format(workDir, id));\n+        Path transformedSrc = subdir.resolve(fileName);\n+        try {\n+            Files.createDirectories(subdir);\n+            Files.write(transformedSrc, transform(id).getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"failed to write transformed \" + transformedSrc, e);\n+        }\n+        try {\n+            \/\/ need to add extra classpath args\n+            List<String> args = new LinkedList<>(Arrays.asList(compilerOptions));\n+            args.add(\"-cp\");\n+            args.add(System.getProperty(\"java.class.path\"));\n+            CompilerUtils.compile(subdir, subdir, false, args.toArray(new String[args.size()]));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"failed to compile \" + transformedSrc, e);\n+        }\n+        return subdir.resolve(className + \".class\").toString();\n+    }\n+\n+    \/*\n+    * To do RedefineClasses operations, embed @1 tags in the .java\n+    * file to tell this script how to modify it to produce the 2nd\n+    * version of the .class file to be used in the redefine operation.\n+    * Here are examples of each editing tag and what change\n+    * it causes in the new file.  Note that blanks are not preserved\n+    * in these editing operations.\n+    *\n+    * @1 uncomment\n+    *  orig:   \/\/ @1 uncomment   gus = 89;\n+    *  new:         gus = 89;\n+    *\n+    * @1 commentout\n+    *  orig:   gus = 89      \/\/ @1 commentout\n+    *  new: \/\/ gus = 89      \/\/ @1 commentout\n+    *\n+    * @1 delete\n+    *  orig:  gus = 89      \/\/ @1 delete\n+    *  new:   entire line deleted\n+    *\n+    * @1 newline\n+    *  orig:  gus = 89;     \/\/ @1 newline gus++;\n+    *  new:   gus = 89;     \/\/\n+    *         gus++;\n+    *\n+    * @1 replace\n+    *  orig:  gus = 89;     \/\/ @1 replace gus = 90;\n+    *  new:   gus = 90;\n+    *\/\n+    public String transform(int id) {\n+        Pattern delete = Pattern.compile(\"@\" + id + \" *delete\");\n+        Pattern uncomment = Pattern.compile(\"\/\/ *@\" + id + \" *uncomment (.*)\");\n+        Pattern commentout = Pattern.compile(\".* @\" + id + \" *commentout\");\n+        Pattern newline = Pattern.compile(\"(.*) @\" + id + \" *newline (.*)\");\n+        Pattern replace = Pattern.compile(\"@\" + id + \" *replace (.*)\");\n+        return lines.stream()\n+                .filter(s -> !delete.matcher(s).find())     \/\/ @1 delete\n+                .map(s -> {\n+                    Matcher m = uncomment.matcher(s);       \/\/ @1 uncomment\n+                    return m.find() ? m.group(1) : s;\n+                })\n+                .map(s-> {\n+                    Matcher m = commentout.matcher(s);      \/\/ @1 commentout\n+                    return m.find() ? \"\/\/\" + s : s;\n+                })\n+                .map(s -> {\n+                    Matcher m = newline.matcher(s);         \/\/ @1 newline\n+                    return m.find() ? m.group(1) + LINE_SEPARATOR + m.group(2) : s;\n+                })\n+                .map(s -> {\n+                    Matcher m = replace.matcher(s);         \/\/ @1 replace\n+                    return m.find() ? m.group(1) : s;\n+                })\n+                .collect(Collectors.joining(LINE_SEPARATOR));\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/lib\/jdb\/ClassTransformer.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Helper class to run java debuggee and parse agent listening transport\/address.\n+ * Usage:\n+ *   1)\n+ *      Debugee debugee = Debuggee.launcher(\"MyClass\").setTransport(\"dt_shmem\").launch();\n+ *      try {\n+ *          String transport = debuggee.getTransport();\n+ *          String addr = debuggee.getAddress();\n+ *      } finally {\n+ *          debuggee.shutdown();\n+ *      }\n+ *   2) (using try-with-resource)\n+ *      try (Debugee debugee = Debuggee.launcher(\"MyClass\").launch()) {\n+ *          String transport = debuggee.getTransport();\n+ *          String addr = debuggee.getAddress();\n+ *      }\n+ *   3)\n+ *      ProcessBuilder pb = Debuggee.launcher(\"MyClass\").setSuspended(false).prepare();\n+ *      ProcessTools.executeProcess(pb);\n+ *\/\n+public class Debuggee implements Closeable {\n+\n+    public static Launcher launcher(String mainClass) {\n+        return new Launcher(mainClass);\n+    }\n+\n+    public static class Launcher {\n+        private final String mainClass;\n+        private final List<String> options = new LinkedList<>();\n+        private String vmOptions = null;\n+        private String transport = \"dt_socket\";\n+        private String address = null;\n+        private boolean suspended = true;\n+        private boolean addTestVmAndJavaOptions = true;\n+\n+        private Launcher(String mainClass) {\n+            this.mainClass = mainClass;\n+        }\n+        public Launcher addOption(String option) {\n+            options.add(option);\n+            return this;\n+        }\n+        public Launcher addOptions(List<String> options) {\n+            this.options.addAll(options);\n+            return this;\n+        }\n+        public Launcher addVMOptions(String vmOptions) {\n+            this.vmOptions = vmOptions;\n+            return this;\n+        }\n+        \/\/ default is \"dt_socket\"\n+        public Launcher setTransport(String value) {\n+            transport = value;\n+            return this;\n+        }\n+        \/\/ default is \"null\" (auto-generate)\n+        public Launcher setAddress(String value) {\n+            address = value;\n+            return this;\n+        }\n+        \/\/ default is \"true\"\n+        public Launcher setSuspended(boolean value) {\n+            suspended = value;\n+            return this;\n+        }\n+        \/\/ default is \"true\"\n+        public Launcher addTestVmAndJavaOptions(boolean value) {\n+            addTestVmAndJavaOptions = value;\n+            return this;\n+        }\n+\n+        public ProcessBuilder prepare() {\n+            List<String> debuggeeArgs = new LinkedList<>();\n+            if (vmOptions != null) {\n+                debuggeeArgs.add(vmOptions);\n+            }\n+            debuggeeArgs.add(\"-agentlib:jdwp=transport=\" + transport\n+                    + (address == null ? \"\" : \",address=\" + address)\n+                    + \",server=y,suspend=\" + (suspended ? \"y\" : \"n\"));\n+            debuggeeArgs.addAll(options);\n+            debuggeeArgs.add(mainClass);\n+            return ProcessTools.createJavaProcessBuilder(addTestVmAndJavaOptions,\n+                    debuggeeArgs.toArray(new String[0]));\n+        }\n+\n+        public Debuggee launch(String name) {\n+            return new Debuggee(prepare(), name);\n+        }\n+        public Debuggee launch() {\n+            return launch(\"debuggee\");\n+        }\n+    }\n+\n+    \/\/ starts the process, waits for \"Listening for transport\" output and detects transport\/address\n+    private Debuggee(ProcessBuilder pb, String name) {\n+        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n+        String[] debuggeeListen = new String[2];\n+        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        try {\n+            p = ProcessTools.startProcess(name, pb,\n+                    s -> output.add(s),  \/\/ output consumer\n+                    s -> {  \/\/ warm-up predicate\n+                        Matcher m = listenRegexp.matcher(s);\n+                        if (!m.matches()) {\n+                            return false;\n+                        }\n+                        debuggeeListen[0] = m.group(1);\n+                        debuggeeListen[1] = m.group(2);\n+                        return true;\n+                    },\n+                    30, TimeUnit.SECONDS);\n+            transport = debuggeeListen[0];\n+            address = debuggeeListen[1];\n+        } catch (IOException | InterruptedException | TimeoutException ex) {\n+            throw new RuntimeException(\"failed to launch debuggee\", ex);\n+        }\n+    }\n+\n+    private final Process p;\n+    private final List<String> output = new LinkedList<>();\n+    private final String transport;\n+    private final String address;\n+\n+    public void shutdown() {\n+        try {\n+            close();\n+        } catch (IOException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    \/\/ waits until the process shutdown or crash\n+    public boolean waitFor(long timeout, TimeUnit unit) {\n+        try {\n+            return p.waitFor(Utils.adjustTimeout(timeout), unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ returns the whole debuggee output as a string\n+    public String getOutput() {\n+        return output.stream().collect(Collectors.joining(Utils.NEW_LINE));\n+    }\n+\n+    String getTransport() {\n+        return transport;\n+    }\n+\n+    public String getAddress() {\n+        return address;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (p.isAlive()) {\n+            p.destroy();\n+        }\n+    }\n+\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.StreamPumper;\n+\n+public class Jdb implements AutoCloseable {\n+    public Jdb(String... args) {\n+        ProcessBuilder pb = new ProcessBuilder(JDKToolFinder.getTestJDKTool(\"jdb\"));\n+        pb.command().add(\"-J-Duser.language=en\");\n+        pb.command().add(\"-J-Duser.country=US\");\n+        pb.command().addAll(Arrays.asList(args));\n+        try {\n+            jdb = pb.start();\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"failed to launch pdb\", ex);\n+        }\n+        try {\n+            StreamPumper stdout = new StreamPumper(jdb.getInputStream());\n+            StreamPumper stderr = new StreamPumper(jdb.getErrorStream());\n+\n+            stdout.addPump(new StreamPumper.StreamPump(outputHandler));\n+            stderr.addPump(new StreamPumper.StreamPump(outputHandler));\n+\n+            stdout.process();\n+            stderr.process();\n+\n+            inputWriter = new PrintWriter(jdb.getOutputStream(), true);\n+        } catch (Throwable ex) {\n+            \/\/ terminate jdb if something went wrong\n+            jdb.destroy();\n+            throw ex;\n+        }\n+    }\n+\n+    private final Process jdb;\n+    private final OutputHandler outputHandler = new OutputHandler();\n+    private final PrintWriter inputWriter;\n+    private final List<String> jdbOutput = new LinkedList<>();\n+\n+    private static final String lineSeparator = System.getProperty(\"line.separator\");\n+    \/\/ wait time before check jdb output (in ms)\n+    private static final long sleepTime = 1000;\n+    \/\/ max time to wait for  jdb output (in ms)\n+    private static final long timeout = Utils.adjustTimeout(60000);\n+\n+    \/\/ pattern for message of a breakpoint hit\n+    public static final String BREAKPOINT_HIT = \"Breakpoint hit:\";\n+    \/\/ pattern for message of an application exit\n+    public static final String APPLICATION_EXIT = \"The application exited\";\n+    \/\/ pattern for message of an application disconnect\n+    public static final String APPLICATION_DISCONNECTED = \"The application has been disconnected\";\n+\n+\n+    @Override\n+    public void close() throws Exception {\n+        shutdown();\n+    }\n+\n+    \/\/ waits until the process shutdown or crash\n+    public boolean waitFor(long timeout, TimeUnit unit) {\n+        try {\n+            return jdb.waitFor(Utils.adjustTimeout(timeout), unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void shutdown() {\n+        \/\/ shutdown jdb\n+        if (jdb.isAlive()) {\n+            try {\n+                quit();\n+                \/\/ wait some time after the command for the process termination\n+                waitFor(10, TimeUnit.SECONDS);\n+            } finally {\n+                if (jdb.isAlive()) {\n+                    jdb.destroy();\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ waits until string {@pattern} appears in the jdb output, within the last {@code lines} lines.\n+    \/* Comment from original \/test\/jdk\/com\/sun\/jdi\/ShellScaffold.sh\n+        # Now we have to wait for the next jdb prompt.  We wait for a pattern\n+        # to appear in the last line of jdb output.  Normally, the prompt is\n+        #\n+        # 1) ^main[89] @\n+        #\n+        # where ^ means start of line, and @ means end of file with no end of line\n+        # and 89 is the current command counter. But we have complications e.g.,\n+        # the following jdb output can appear:\n+        #\n+        # 2) a[89] = 10\n+        #\n+        # The above form is an array assignment and not a prompt.\n+        #\n+        # 3) ^main[89] main[89] ...\n+        #\n+        # This occurs if the next cmd is one that causes no jdb output, e.g.,\n+        # 'trace methods'.\n+        #\n+        # 4) ^main[89] [main[89]] .... > @\n+        #\n+        # jdb prints a > as a prompt after something like a cont.\n+        # Thus, even though the above is the last 'line' in the file, it\n+        # isn't the next prompt we are waiting for after the cont completes.\n+        # HOWEVER, sometimes we see this for a cont command:\n+        #\n+        #   ^main[89] $\n+        #      <lines output for hitting a bkpt>\n+        #\n+        # 5) ^main[89] > @\n+        #\n+        # i.e., the > prompt comes out AFTER the prompt we we need to wait for.\n+    *\/\n+    \/\/ compile regexp once\n+    private final static String promptPattern = \"[a-zA-Z0-9_-][a-zA-Z0-9_-]*\\\\[[1-9][0-9]*\\\\] [ >]*$\";\n+    final static Pattern PROMPT_REGEXP = Pattern.compile(promptPattern);\n+\n+    public List<String> waitForPrompt(int lines, boolean allowExit) {\n+        return waitForPrompt(lines, allowExit, PROMPT_REGEXP);\n+    }\n+\n+    \/\/ jdb prompt when debuggee is not started and is not suspended after breakpoint\n+    private static final String SIMPLE_PROMPT = \"> \";\n+    public List<String> waitForSimplePrompt(int lines, boolean allowExit) {\n+        return waitForPrompt(lines, allowExit, Pattern.compile(SIMPLE_PROMPT));\n+    }\n+\n+    private List<String> waitForPrompt(int lines, boolean allowExit, Pattern promptRegexp) {\n+        long startTime = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startTime < timeout) {\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException e) {\n+                \/\/ ignore\n+            }\n+            synchronized (outputHandler) {\n+                if (!outputHandler.updated()) {\n+                    try {\n+                        outputHandler.wait(sleepTime);\n+                    } catch (InterruptedException e) {\n+                        \/\/ ignore\n+                    }\n+                } else {\n+                    \/\/ if something appeared in the jdb output, reset the timeout\n+                    startTime = System.currentTimeMillis();\n+                }\n+            }\n+            List<String> reply = outputHandler.get();\n+            if ((promptRegexp.flags() & Pattern.MULTILINE) > 0) {\n+                String replyString = reply.stream().collect(Collectors.joining(lineSeparator));\n+                if (promptRegexp.matcher(replyString).find()) {\n+                    logJdb(reply);\n+                    return outputHandler.reset();\n+                }\n+            } else {\n+                for (String line : reply.subList(Math.max(0, reply.size() - lines), reply.size())) {\n+                    if (promptRegexp.matcher(line).find()) {\n+                        logJdb(reply);\n+                        return outputHandler.reset();\n+                    }\n+                }\n+            }\n+            if (!jdb.isAlive()) {\n+                \/\/ ensure we get the whole output\n+                reply = outputHandler.reset();\n+                logJdb(reply);\n+                if (!allowExit) {\n+                    throw new RuntimeException(\"waitForPrompt timed out after \" + (timeout\/1000)\n+                            + \" seconds, looking for '\" + promptRegexp.pattern() + \"', in \" + lines + \" lines\");\n+                }\n+                return reply;\n+            }\n+        }\n+        \/\/ timeout\n+        logJdb(outputHandler.get());\n+        throw new RuntimeException(\"waitForPrompt timed out after \" + (timeout\/1000)\n+                + \" seconds, looking for '\" + promptRegexp.pattern() + \"', in \" + lines + \" lines\");\n+    }\n+\n+    public List<String> command(JdbCommand cmd) {\n+        if (!jdb.isAlive()) {\n+            if (cmd.allowExit) {\n+                \/\/ return remaining output\n+                return outputHandler.reset();\n+            }\n+            throw new RuntimeException(\"Attempt to send command '\" + cmd.cmd + \"' to terminated jdb\");\n+        }\n+\n+        log(\"> \" + cmd.cmd);\n+\n+        inputWriter.println(cmd.cmd);\n+\n+        if (inputWriter.checkError()) {\n+            throw new RuntimeException(\"Unexpected IO error while writing command '\" + cmd.cmd + \"' to jdb stdin stream\");\n+        }\n+\n+        return waitForPrompt(1, cmd.allowExit, cmd.waitForPattern);\n+    }\n+\n+    public List<String> command(String cmd) {\n+        return command(new JdbCommand(cmd));\n+    }\n+\n+    \/\/ sends \"cont\" command up to maxTimes until debuggee exit\n+    public void contToExit(int maxTimes) {\n+        boolean exited = false;\n+        JdbCommand cont = JdbCommand.cont().allowExit();\n+        for (int i = 0; i < maxTimes && jdb.isAlive(); i++) {\n+            String reply = command(cont).stream().collect(Collectors.joining(lineSeparator));\n+            if (reply.contains(APPLICATION_EXIT)) {\n+                exited = true;\n+                break;\n+            }\n+        }\n+        if (!exited && jdb.isAlive()) {\n+            throw new RuntimeException(\"Debuggee did not exit after \" + maxTimes + \" <cont> commands\");\n+        }\n+    }\n+\n+    \/\/ quits jdb by using \"quit\" command\n+    public void quit() {\n+        command(JdbCommand.quit());\n+    }\n+\n+    void log(String s) {\n+        System.out.println(s);\n+    }\n+\n+    private void logJdb(List<String> reply) {\n+        jdbOutput.addAll(reply);\n+        reply.forEach(s -> log(\"[jdb] \" + s));\n+    }\n+\n+    \/\/ returns the whole jdb output as a string\n+    public String getJdbOutput() {\n+        return jdbOutput.stream().collect(Collectors.joining(lineSeparator));\n+    }\n+\n+    \/\/ handler for out\/err of the pdb process\n+    private class OutputHandler extends OutputStream {\n+        \/\/ there are 2 buffers:\n+        \/\/ outStream - data from the process stdout\/stderr after last get() call\n+        \/\/ cachedData - data collected at get(), cleared by reset()\n+\n+        private final ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+        \/\/ if the last line in the reply had EOL, the list's last element is empty\n+        private final List<String> cachedData = new ArrayList<>();\n+\n+        @Override\n+        public synchronized void write(int b) throws IOException {\n+            outStream.write((byte)(b & 0xFF));\n+            notifyAll();\n+        }\n+        @Override\n+        public synchronized void write(byte b[], int off, int len) throws IOException {\n+            outStream.write(b, off, len);\n+            notifyAll();\n+        }\n+\n+        \/\/ gets output after the last {@ reset}.\n+        \/\/ returned data becomes invalid after {@reset}.\n+        public synchronized List<String> get() {\n+            if (updated()) {\n+                \/\/ we don't want to discard empty lines\n+                String[] newLines = outStream.toString().split(\"\\\\R\", -1);\n+                if (!cachedData.isEmpty()) {\n+                    \/\/ concat the last line if previous data had no EOL\n+                    newLines[0] = cachedData.remove(cachedData.size()-1) + newLines[0];\n+                }\n+                cachedData.addAll(Arrays.asList(newLines));\n+                outStream.reset();\n+            }\n+            return Collections.unmodifiableList(cachedData);\n+        }\n+\n+        \/\/ clears last replay (does not touch replyStream)\n+        \/\/ returns list as the last get()\n+        public synchronized List<String> reset() {\n+            List<String> result = new ArrayList<>(cachedData);\n+            cachedData.clear();\n+            return result;\n+        }\n+\n+        \/\/ tests if there are some new data after the last lastReply() call\n+        public synchronized boolean updated() {\n+            return outStream.size() > 0;\n+        }\n+    }\n+}\n+\n","filename":"jdk\/test\/com\/sun\/jdi\/lib\/jdb\/Jdb.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import java.util.Arrays;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Represents list of commands of <code>jdb<\/code> from JDK1.4:\n+ *\n+ *   run [class [args]]        -- start execution of application's main class\n+ *\n+ *   threads [threadgroup]     -- list threads\n+ *   thread <thread id>        -- set default thread\n+ *   suspend [thread id(s)]    -- suspend threads (default: all)\n+ *   resume [thread id(s)]     -- resume threads (default: all)\n+ *   where [thread id] | all   -- dump a thread's stack\n+ *   wherei [thread id] | all  -- dump a thread's stack, with pc info\n+ *   up [n frames]             -- move up a thread's stack\n+ *   down [n frames]           -- move down a thread's stack\n+ *   kill <thread> <expr>      -- kill a thread with the given exception object\n+ *   interrupt <thread>        -- interrupt a thread\n+ *\n+ *   print <expr>              -- print value of expression\n+ *   dump <expr>               -- print all object information\n+ *   eval <expr>               -- evaluate expression (same as print)\n+ *   set <lvalue> = <expr>     -- assign new value to field\/variable\/array element\n+ *   locals                    -- print all local variables in current stack frame\n+ *\n+ *   classes                   -- list currently known classes\n+ *   class <class id>          -- show details of named class\n+ *   methods <class id>        -- list a class's methods\n+ *   fields <class id>         -- list a class's fields\n+ *\n+ *   threadgroups              -- list threadgroups\n+ *   threadgroup <name>        -- set current threadgroup\n+ *\n+ *   stop in <class id>.<method>[(argument_type,...)]\n+ *                             -- set a breakpoint in a method\n+ *   stop at <class id>:<line> -- set a breakpoint at a line\n+ *   clear <class id>.<method>[(argument_type,...)]\n+ *                             -- clear a breakpoint in a method\n+ *   clear <class id>:<line>   -- clear a breakpoint at a line\n+ *   clear                     -- list breakpoints\n+ *   catch <class id>          -- break when specified exception thrown\n+ *   ignore <class id>         -- cancel 'catch'  for the specified exception\n+ *   watch [access|all] <class id>.<field name>\n+ *                             -- watch access\/modifications to a field\n+ *   unwatch [access|all] <class id>.<field name>\n+ *                             -- discontinue watching access\/modifications to a field\n+ *   trace methods [thread]    -- trace method entry and exit\n+ *   untrace methods [thread]  -- stop tracing method entry and exit\n+ *   step                      -- execute current line\n+ *   step up                   -- execute until the current method returns to its caller\n+ *   stepi                     -- execute current instruction\n+ *   next                      -- step one line (step OVER calls)\n+ *   cont                      -- continue execution from breakpoint\n+ *\n+ *   list [line number|method] -- print source code\n+ *   use (or sourcepath) [source file path]\n+ *                             -- display or change the source path\n+ *   exclude [class id ... | \"none\"]\n+ *                             -- do not report step or method events for specified classes\n+ *   classpath                 -- print classpath info from target VM\n+ *\n+ *   monitor <command>         -- execute command each time the program stops\n+ *   monitor                   -- list monitors\n+ *   unmonitor <monitor#>      -- delete a monitor\n+ *   read <filename>           -- read and execute a command file\n+ *\n+ *   lock <expr>               -- print lock info for an object\n+ *   threadlocks [thread id]   -- print lock info for a thread\n+ *\n+ *   pop                       -- pop the stack through and including the current frame\n+ *   reenter                   -- same as pop, but current frame is reentered\n+ *   redefine <class id> <class file name>\n+ *                             -- redefine the code for a class\n+ *\n+ *   disablegc <expr>          -- prevent garbage collection of an object\n+ *   enablegc <expr>           -- permit garbage collection of an object\n+ *\n+ *   !!                        -- repeat last command\n+ *   <n> <command>             -- repeat command n times\n+ *   help (or ?)               -- list commands\n+ *   version                   -- print version information\n+ *   exit (or quit)            -- exit debugger\n+ *\n+ *   <class id>: full class name with package qualifiers or a\n+ *   pattern with a leading or trailing wildcard ('*').\n+ *   <thread id>: thread number as reported in the 'threads' command\n+ *   <expr>: a Java(tm) Programming Language expression.\n+ *   Most common syntax is supported.\n+ *\n+ *   Startup commands can be placed in either \"jdb.ini\" or \".jdbrc\"\n+ *   in user.home or user.dir\n+ *\/\n+public class JdbCommand {\n+    final String cmd;\n+    boolean allowExit = false;\n+    \/\/ Default pattern to wait for command to complete\n+    Pattern waitForPattern = Jdb.PROMPT_REGEXP;\n+\n+    public JdbCommand(String cmd) {\n+        this.cmd = cmd;\n+    }\n+\n+    public JdbCommand allowExit() {\n+        allowExit = true;\n+        return this;\n+    }\n+\n+    public JdbCommand waitForPrompt(String pattern, boolean isMultiline) {\n+        waitForPattern = Pattern.compile(pattern, isMultiline ? Pattern.MULTILINE : 0);\n+        return this;\n+    }\n+\n+\n+    public static JdbCommand run(String ... params) {\n+        return new JdbCommand(\"run \" + Arrays.stream(params).collect(Collectors.joining(\" \")));\n+    }\n+    public static JdbCommand cont() {\n+        return new JdbCommand(\"cont\");\n+    }\n+    public static JdbCommand dump(String what) {\n+        return new JdbCommand(\"dump \" + what);\n+    }\n+    public static JdbCommand quit() {\n+        \/\/ the command suppose jdb terminates\n+        return new JdbCommand(\"quit\").allowExit();\n+    }\n+    public static JdbCommand stopAt(String targetClass, int lineNum) {\n+        return new JdbCommand(\"stop at \" + targetClass + \":\" + lineNum);\n+    }\n+    public static JdbCommand stopThreadAt(String targetClass, int lineNum) {\n+        return new JdbCommand(\"stop thread at \" + targetClass + \":\" + lineNum);\n+    }\n+    public static JdbCommand stopGoAt(String targetClass, int lineNum) {\n+        return new JdbCommand(\"stop go at \" + targetClass + \":\" + lineNum);\n+    }\n+    public static JdbCommand stopIn(String targetClass, String methodName) {\n+        return new JdbCommand(\"stop in \" + targetClass + \".\" + methodName);\n+    }\n+    public static JdbCommand stopInThreadid(String targetClass, String methodName, String threadid) {\n+        return new JdbCommand(\"stop \" + threadid + \" in \" + targetClass + \".\" + methodName);\n+    }\n+    public static JdbCommand thread(int threadNumber) {\n+        return new JdbCommand(\"thread \" + threadNumber);\n+    }\n+    \/\/ clear <class id>:<line>   -- clear a breakpoint at a line\n+    public static JdbCommand clear(String targetClass, int lineNum) {\n+        return new JdbCommand(\"clear \" + targetClass + \":\" + lineNum);\n+    }\n+\n+    \/\/ exception type used by catch\/ignore\n+    public enum ExType{\n+        uncaught,\n+        caught,\n+        all\n+    }\n+    public static JdbCommand catch_(String classId) {\n+        return new JdbCommand(\"catch \" + classId);\n+    }\n+    public static JdbCommand catch_(ExType eType, String classId) {\n+        return catch_(eType.toString() + \" \" + classId);\n+    }\n+    public static JdbCommand ignore(String classId) {\n+        return new JdbCommand(\"ignore \" + classId);\n+    }\n+    public static JdbCommand ignore(ExType eType, String classId) {\n+        return ignore(eType.toString() + \" \" + classId);\n+    }\n+\n+    public static JdbCommand step() {\n+        return new JdbCommand(\"step\");\n+    }\n+    public static JdbCommand stepUp() {\n+        return new JdbCommand(\"step up\");\n+    }\n+    public static JdbCommand next() {\n+        return new JdbCommand(\"next\");\n+    }\n+\n+    \/\/ where [thread id] | all\n+    public static JdbCommand where(String threadId) {\n+        return new JdbCommand(\"where \" + threadId);\n+    }\n+    public static JdbCommand eval(String expr) {\n+        return new JdbCommand(\"eval \" + expr);\n+    }\n+    public static JdbCommand print(String expr) {\n+        return new JdbCommand(\"print \" + expr);\n+    }\n+\n+    public static JdbCommand locals() {\n+        return new JdbCommand(\"locals\");\n+    }\n+\n+    public static JdbCommand set(String lvalue, String expr) {\n+        return new JdbCommand(\"set \" + lvalue + \" = \" + expr);\n+    }\n+\n+    public static JdbCommand lock(String expr) {\n+        return new JdbCommand(\"lock \" + expr);\n+    }\n+\n+    public static JdbCommand methods(String classId) {\n+        return new JdbCommand(\"methods \" + classId);\n+    }\n+\n+    public static JdbCommand threads() {\n+        return new JdbCommand(\"threads\");\n+    }\n+\n+    \/\/ trace [go] methods [thread]\n+    \/\/                           -- trace method entries and exits.\n+    \/\/                           -- All threads are suspended unless 'go' is specified\n+    \/\/ trace [go] method exit | exits [thread]\n+    \/\/                           -- trace the current method's exit, or all methods' exits\n+    \/\/                           -- All threads are suspended unless 'go' is specified\n+    \/\/ untrace [methods]         -- stop tracing method entrys and\/or exits\n+    public static JdbCommand trace(boolean go, String  mode, Integer threadId) {\n+        return new JdbCommand(\" trace\"\n+                + (go ? \" go\" : \"\")\n+                + (mode != null ? \" \" + mode : \"\")\n+                + (threadId != null ? \" \" + threadId.toString() : \"\"));\n+    }\n+    \/\/ prints trace status\n+    public static JdbCommand trace() {\n+        return trace(false, null, null);\n+    }\n+    public static JdbCommand traceMethods(boolean go, Integer threadId) {\n+        return trace(go, \"methods\", threadId);\n+    }\n+    public static JdbCommand traceMethodExit(boolean go, Integer threadId) {\n+        return trace(go, \"method exit\", threadId);\n+    }\n+    public static JdbCommand traceMethodExits(boolean go, Integer threadId) {\n+        return trace(go, \"method exits\", threadId);\n+    }\n+    public static JdbCommand untrace() {\n+        return new JdbCommand(\"untrace\");\n+    }\n+\n+    \/\/ watch [access|all] <class id>.<field name>\n+    public static JdbCommand watch(String classId, String fieldName) {\n+        return new JdbCommand(\"watch \" + classId + \".\" + fieldName);\n+    }\n+\n+    public static JdbCommand pop() {\n+        return new JdbCommand(\"pop\");\n+    }\n+\n+    public static JdbCommand redefine(String classId, String classFileName) {\n+        return new JdbCommand(\"redefine \" + classId + \" \" + classFileName);\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/lib\/jdb\/JdbCommand.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public abstract class JdbTest {\n+\n+    public static class LaunchOptions {\n+        public final String debuggeeClass;\n+        public final List<String> debuggeeOptions = new LinkedList<>();\n+        public String sourceFilename;\n+        public String vmOptions = null;\n+\n+        public LaunchOptions(String debuggeeClass) {\n+            this.debuggeeClass = debuggeeClass;\n+        }\n+        public LaunchOptions addDebuggeeOption(String option) {\n+            debuggeeOptions.add(option);\n+            return this;\n+        }\n+        public LaunchOptions addDebuggeeOptions(String[] options) {\n+            debuggeeOptions.addAll(Arrays.asList(options));\n+            return this;\n+        }\n+        public LaunchOptions setSourceFilename(String name) {\n+            sourceFilename = name;\n+            return this;\n+        }\n+        public LaunchOptions addVMOptions(String vmOptions) {\n+            this.vmOptions = vmOptions;\n+            return this;\n+        }\n+    }\n+\n+    public JdbTest(LaunchOptions launchOptions) {\n+        this.launchOptions = launchOptions;\n+    }\n+    public JdbTest(String debuggeeClass) {\n+        this(new LaunchOptions(debuggeeClass));\n+    }\n+\n+    \/\/ sourceFilename is used by setBreakpoints and redefineClass\n+    public JdbTest(String debuggeeClass, String sourceFilename) {\n+        this(new LaunchOptions(debuggeeClass).setSourceFilename(sourceFilename));\n+    }\n+\n+    protected Jdb jdb;\n+    protected Debuggee debuggee;\n+    protected LaunchOptions launchOptions;\n+\n+    \/\/ returns the whole jdb output as a string\n+    public String getJdbOutput() {\n+        return jdb == null ? \"\" : jdb.getJdbOutput();\n+    }\n+\n+    \/\/ returns the whole debuggee output as a string\n+    public String getDebuggeeOutput() {\n+        return debuggee == null ? \"\" : debuggee.getOutput();\n+    }\n+\n+    public void run() {\n+        try {\n+            setup();\n+            runCases();\n+        } catch (Throwable e) {\n+            jdb.log(\"=======================================\");\n+            jdb.log(\"Exception thrown during test execution: \" + e.getMessage());\n+            jdb.log(\"=======================================\");\n+            throw e;\n+        } finally {\n+            shutdown();\n+        }\n+    }\n+\n+    protected void setup() {\n+        \/* run debuggee as:\n+            java -agentlib:jdwp=transport=dt_socket,server=n,suspend=y <debuggeeClass>\n+        it reports something like : Listening for transport dt_socket at address: 60810\n+        after that connect jdb by:\n+            jdb -connect com.sun.jdi.SocketAttach:port=60810\n+        *\/\n+        \/\/ launch debuggee\n+        debuggee = Debuggee.launcher(launchOptions.debuggeeClass)\n+                .addOptions(launchOptions.debuggeeOptions)\n+                .addVMOptions(launchOptions.vmOptions)\n+                .launch();\n+\n+        \/\/ launch jdb\n+        try {\n+            jdb = new Jdb(\"-connect\", \"com.sun.jdi.SocketAttach:port=\" + debuggee.getAddress());\n+        } catch (Throwable ex) {\n+            \/\/ terminate debuggee if something went wrong\n+            debuggee.shutdown();\n+            throw ex;\n+        }\n+        \/\/ wait while jdb is initialized\n+        jdb.waitForPrompt(1, false);\n+    }\n+\n+    protected abstract void runCases();\n+\n+    protected void shutdown() {\n+        if (jdb != null) {\n+            jdb.shutdown();\n+        }\n+        \/\/ shutdown debuggee\n+        if (debuggee != null) {\n+            if (!debuggee.waitFor(10, TimeUnit.SECONDS)) {\n+                debuggee.shutdown();\n+            }\n+        }\n+    }\n+\n+    protected static final String lineSeparator = System.getProperty(\"line.separator\");\n+\n+\n+    \/\/ Parses the specified source file for \"@{id} breakpoint\" tags and returns\n+    \/\/ list of the line numbers containing the tag.\n+    \/\/ Example:\n+    \/\/   System.out.println(\"BP is here\");  \/\/ @1 breakpoint\n+    public static List<Integer> parseBreakpoints(String filePath, int id) {\n+        final String pattern = \"@\" + id + \" breakpoint\";\n+        int lineNum = 1;\n+        List<Integer> result = new LinkedList<>();\n+        try {\n+            for (String line: Files.readAllLines(Paths.get(filePath))) {\n+                if (line.contains(pattern)) {\n+                    result.add(lineNum);\n+                }\n+                lineNum++;\n+            }\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"failed to parse \" + filePath, ex);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ sets breakpoints to the lines parsed by {@code parseBreakpoints}\n+    \/\/ returns number of the breakpoints set.\n+    public static int setBreakpoints(Jdb jdb, String debuggeeClass, String sourcePath, int id) {\n+        List<Integer> bps = parseBreakpoints(sourcePath, id);\n+        for (int bp : bps) {\n+            String reply = jdb.command(JdbCommand.stopAt(debuggeeClass, bp)).stream()\n+                    .collect(Collectors.joining(\"\\n\"));\n+            if (reply.contains(\"Unable to set\")) {\n+                throw new RuntimeException(\"jdb failed to set breakpoint at \" + debuggeeClass + \":\" + bp);\n+            }\n+\n+        }\n+        return bps.size();\n+    }\n+\n+    \/\/ sets breakpoints to the lines parsed by {@code parseBreakpoints}\n+    \/\/ from the file from test source directory.\n+    \/\/ returns number of the breakpoints set.\n+    protected int setBreakpointsFromTestSource(String debuggeeFileName, int id) {\n+        return setBreakpoints(jdb, launchOptions.debuggeeClass,\n+                              getTestSourcePath(debuggeeFileName), id);\n+    }\n+\n+    \/\/ sets breakpoints in the class {@code launchOptions.debuggeeClass}\n+    \/\/ to the lines parsed by {@code parseBreakpoints}\n+    \/\/ from the file from test source directory specified by {@code launchOptions.sourceFilename}.\n+    \/\/ returns number of the breakpoints set.\n+    protected int setBreakpoints(int id) {\n+        verifySourceFilename();\n+        return setBreakpointsFromTestSource(launchOptions.sourceFilename, id);\n+    }\n+\n+    \/\/ transforms class with the specified id (see {@code ClassTransformer})\n+    \/\/ and executes \"redefine\" jdb command for {@code launchOptions.debuggeeClass}.\n+    \/\/ returns reply for the command.\n+    protected List<String> redefineClass(int id, String... compilerOptions) {\n+        verifySourceFilename();\n+        String transformedClassFile = ClassTransformer.fromTestSource(launchOptions.sourceFilename)\n+                .transform(id, launchOptions.debuggeeClass, compilerOptions);\n+        return jdb.command(JdbCommand.redefine(launchOptions.debuggeeClass, transformedClassFile));\n+    }\n+\n+    \/\/ gets full test source path for the given test filename\n+    public static String getTestSourcePath(String fileName) {\n+        return Paths.get(System.getProperty(\"test.src\")).resolve(fileName).toString();\n+    }\n+\n+    \/\/ verifies that sourceFilename is specified in ctor\n+    private void verifySourceFilename() {\n+        if (launchOptions.sourceFilename == null) {\n+            throw new RuntimeException(\"launchOptions.sourceFilename must be specified.\");\n+        }\n+    }\n+\n+    protected OutputAnalyzer execCommand(JdbCommand cmd) {\n+        List<String> reply = jdb.command(cmd);\n+        return new OutputAnalyzer(reply.stream().collect(Collectors.joining(lineSeparator)));\n+    }\n+\n+    \/\/ helpers for \"eval\" jdb command.\n+    \/\/ executes \"eval <expr>\" and verifies output contains the specified text\n+    protected void evalShouldContain(String expr, String expectedString) {\n+        execCommand(JdbCommand.eval(expr))\n+                .shouldContain(expectedString);\n+    }\n+    \/\/ executes \"eval <expr>\" and verifies output does not contain the specified text\n+    protected void evalShouldNotContain(String expr, String unexpectedString) {\n+        execCommand(JdbCommand.eval(expr))\n+                .shouldNotContain(unexpectedString);\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/jdi\/lib\/jdb\/JdbTest.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -27,2 +27,0 @@\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.StandardLocation;\n@@ -30,0 +28,1 @@\n+import java.io.File;\n@@ -33,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -38,0 +38,3 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -43,0 +46,4 @@\n+    private static final String TEST_JAVA_HOME = System.getProperty(\"test.jdk\");\n+    private static final String FS = File.separator;\n+    private static final String JAVAC = TEST_JAVA_HOME + FS + \"bin\" + FS + \"javac\";\n+\n@@ -105,1 +112,0 @@\n-        StandardJavaFileManager jfm = compiler.getStandardFileManager(null, null, null);\n@@ -113,4 +119,0 @@\n-        jfm.setLocation(StandardLocation.CLASS_PATH, Collections.emptyList());\n-        jfm.setLocationFromPaths(StandardLocation.CLASS_OUTPUT,\n-                Collections.singletonList(destination));\n-\n@@ -118,3 +120,19 @@\n-        JavaCompiler.CompilationTask task\n-            = compiler.getTask(null, jfm, null, opts, null,\n-                jfm.getJavaFileObjectsFromPaths(sources));\n+        List<String> compileargs = new ArrayList<String> ();\n+        compileargs.add(JAVAC);\n+        compileargs.add(\"-d\");\n+        compileargs.add(destination.toString());\n+        for(String opt: opts) {\n+            compileargs.add(opt);\n+        }\n+        for(Path p: sources) {\n+            compileargs.add(p.toString());\n+        }\n+\n+        OutputAnalyzer output = null;\n+        try {\n+            String[] sarr = compileargs.toArray(new String[0]);\n+            output = ProcessTools.executeCommand(sarr);\n+            output.shouldHaveExitValue(0);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Javac failed\", t);\n+        }\n@@ -122,1 +140,1 @@\n-        return task.call();\n+        return true;\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/compiler\/CompilerUtils.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"}]}