{"files":[{"patch":"@@ -1,276 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.util;\n-\n-import jdk.test.lib.Platform;\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.io.UncheckedIOException;\n-import java.lang.ProcessBuilder.Redirect;\n-import java.nio.file.DirectoryNotEmptyException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.time.Instant;\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.ArrayDeque;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Common library for various test file utility functions.\n- *\/\n-public final class FileUtils {\n-    private static final boolean IS_WINDOWS = Platform.isWindows();\n-    private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;\n-    private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;\n-\n-    \/**\n-     * Deletes a file, retrying if necessary.\n-     *\n-     * @param path  the file to delete\n-     *\n-     * @throws NoSuchFileException\n-     *         if the file does not exist (optional specific exception)\n-     * @throws DirectoryNotEmptyException\n-     *         if the file is a directory and could not otherwise be deleted\n-     *         because the directory is not empty (optional specific exception)\n-     * @throws IOException\n-     *         if an I\/O error occurs\n-     *\/\n-    public static void deleteFileWithRetry(Path path) throws IOException {\n-        try {\n-            deleteFileWithRetry0(path);\n-        } catch (InterruptedException x) {\n-            throw new IOException(\"Interrupted while deleting.\", x);\n-        }\n-    }\n-\n-    \/**\n-     * Deletes a file, retrying if necessary.\n-     * No exception thrown if file doesn't exist.\n-     *\n-     * @param path  the file to delete\n-     *\n-     * @throws NoSuchFileException\n-     *         if the file does not exist (optional specific exception)\n-     * @throws DirectoryNotEmptyException\n-     *         if the file is a directory and could not otherwise be deleted\n-     *         because the directory is not empty (optional specific exception)\n-     * @throws IOException\n-     *         if an I\/O error occurs\n-     *\/\n-    public static void deleteFileIfExistsWithRetry(Path path) throws IOException {\n-        try {\n-            if (Files.exists(path)) {\n-                deleteFileWithRetry0(path);\n-            }\n-        } catch (InterruptedException x) {\n-            throw new IOException(\"Interrupted while deleting.\", x);\n-        }\n-    }\n-\n-    private static void deleteFileWithRetry0(Path path)\n-            throws IOException, InterruptedException {\n-        int times = 0;\n-        IOException ioe = null;\n-        while (true) {\n-            try {\n-                Files.delete(path);\n-                \/\/ Checks for absence of the file. Semantics of Files.exists() is not the same.\n-                while (!Files.notExists(path)) {\n-                    times++;\n-                    if (times > MAX_RETRY_DELETE_TIMES) {\n-                        throw new IOException(\"File still exists after \" + times + \" waits.\");\n-                    }\n-                    Thread.sleep(RETRY_DELETE_MILLIS);\n-                }\n-                break;\n-            } catch (NoSuchFileException | DirectoryNotEmptyException x) {\n-                throw x;\n-            } catch (IOException x) {\n-                \/\/ Backoff\/retry in case another process is accessing the file\n-                times++;\n-                if (ioe == null) {\n-                    ioe = x;\n-                } else {\n-                    ioe.addSuppressed(x);\n-                }\n-\n-                if (times > MAX_RETRY_DELETE_TIMES) {\n-                    throw ioe;\n-                }\n-                Thread.sleep(RETRY_DELETE_MILLIS);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Deletes a directory and its subdirectories, retrying if necessary.\n-     *\n-     * @param dir  the directory to delete\n-     *\n-     * @throws  IOException\n-     *          If an I\/O error occurs. Any such exceptions are caught\n-     *          internally. If only one is caught, then it is re-thrown.\n-     *          If more than one exception is caught, then the second and\n-     *          following exceptions are added as suppressed exceptions of the\n-     *          first one caught, which is then re-thrown.\n-     *\/\n-    public static void deleteFileTreeWithRetry(Path dir) throws IOException {\n-        IOException ioe = null;\n-        final List<IOException> excs = deleteFileTreeUnchecked(dir);\n-        if (!excs.isEmpty()) {\n-            ioe = excs.remove(0);\n-            for (IOException x : excs) {\n-                ioe.addSuppressed(x);\n-            }\n-        }\n-        if (ioe != null) {\n-            throw ioe;\n-        }\n-    }\n-\n-    public static List<IOException> deleteFileTreeUnchecked(Path dir) {\n-        final List<IOException> excs = new ArrayList<>();\n-        try {\n-            java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<>() {\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n-                    try {\n-                        deleteFileWithRetry0(file);\n-                    } catch (IOException x) {\n-                        excs.add(x);\n-                    } catch (InterruptedException x) {\n-                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n-                        return FileVisitResult.TERMINATE;\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n-                    try {\n-                        deleteFileWithRetry0(dir);\n-                    } catch (IOException x) {\n-                        excs.add(x);\n-                    } catch (InterruptedException x) {\n-                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n-                        return FileVisitResult.TERMINATE;\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n-                    excs.add(exc);\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-        } catch (IOException x) {\n-            excs.add(x);\n-        }\n-        return excs;\n-    }\n-\n-    \/**\n-     * Checks whether all file systems are accessible. This is performed\n-     * by checking free disk space on all mounted file systems via a\n-     * separate, spawned process. File systems are considered to be\n-     * accessible if this process completes successfully before a given\n-     * fixed duration has elapsed.\n-     *\n-     * @implNote On Unix this executes the {@code df} command in a separate\n-     * process and on Windows always returns {@code true}.\n-     *\/\n-    public static boolean areFileSystemsAccessible() throws IOException {\n-        boolean areFileSystemsAccessible = true;\n-        if (!IS_WINDOWS) {\n-            \/\/ try to check whether 'df' hangs\n-            System.out.println(\"\\n--- df output ---\");\n-            System.out.flush();\n-            Process proc = new ProcessBuilder(\"df\").inheritIO().start();\n-            try {\n-                proc.waitFor(90, TimeUnit.SECONDS);\n-            } catch (InterruptedException ignored) {\n-            }\n-            try {\n-                int exitValue = proc.exitValue();\n-                if (exitValue != 0) {\n-                    System.err.printf(\"df process exited with %d != 0%n\",\n-                        exitValue);\n-                    areFileSystemsAccessible = false;\n-                }\n-            } catch (IllegalThreadStateException ignored) {\n-                System.err.println(\"df command apparently hung\");\n-                areFileSystemsAccessible = false;\n-            }\n-        }\n-        return areFileSystemsAccessible;\n-    }\n-\n-    \/**\n-     * List the open file descriptors (if supported by the 'lsof' command).\n-     * @param ps a printStream to send the output to\n-     * @throws UncheckedIOException if an error occurs\n-     *\/\n-    public static void listFileDescriptors(PrintStream ps) {\n-        List<String> lsofDirs = List.of(\"\/usr\/bin\", \"\/usr\/sbin\");\n-        Optional<Path> lsof = lsofDirs.stream()\n-                .map(s -> Paths.get(s, \"lsof\"))\n-                .filter(f -> Files.isExecutable(f))\n-                .findFirst();\n-        lsof.ifPresent(exe -> {\n-            try {\n-                ps.printf(\"Open File Descriptors:%n\");\n-                long pid = ProcessHandle.current().pid();\n-                ProcessBuilder pb = new ProcessBuilder(exe.toString(), \"-p\", Integer.toString((int) pid));\n-                pb.redirectErrorStream(true);   \/\/ combine stderr and stdout\n-                pb.redirectOutput(Redirect.PIPE);\n-\n-                Process p = pb.start();\n-                Instant start = Instant.now();\n-                p.getInputStream().transferTo(ps);\n-\n-                try {\n-                    int timeout = 10;\n-                    if (!p.waitFor(timeout, TimeUnit.SECONDS)) {\n-                        System.out.printf(\"waitFor timed out: %d%n\", timeout);\n-                    }\n-                } catch (InterruptedException ie) {\n-                    throw new IOException(\"interrupted\", ie);\n-                }\n-                ps.println();\n-            } catch (IOException ioe) {\n-                throw new UncheckedIOException(\"error listing file descriptors\", ioe);\n-            }\n-        });\n-    }\n-}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":0,"deletions":276,"binary":false,"changes":276,"status":"deleted"}]}