{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Random;\n+import java.util.NavigableSet;\n@@ -32,1 +30,0 @@\n-import java.util.LinkedList;\n@@ -45,0 +42,5 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n@@ -730,8 +732,4 @@\n-    \/*\n-     * Cached addresses - our own litle nis, not!\n-     *\/\n-    private static Cache addressCache = new Cache(Cache.Type.Positive);\n-\n-    private static Cache negativeCache = new Cache(Cache.Type.Negative);\n-\n-    private static boolean addressCacheInit = false;\n+    \/\/ mapping from host name to Addresses - either NameServiceAddresses (while\n+    \/\/ still being looked-up by NameService(s)) or CachedAddresses when cached\n+    private static final ConcurrentMap<String, Addresses> cache =\n+        new ConcurrentHashMap<>();\n@@ -739,1 +737,4 @@\n-    static InetAddress[]    unknown_array; \/\/ put THIS in cache\n+    \/\/ CachedAddresses that have to expire are kept ordered in this NavigableSet\n+    \/\/ which is scanned on each access\n+    private static final NavigableSet<CachedAddresses> expirySet =\n+        new ConcurrentSkipListSet<>();\n@@ -741,16 +742,3 @@\n-    static InetAddressImpl  impl;\n-\n-    private static final HashMap<String, Void> lookupTable = new HashMap<>();\n-\n-    \/**\n-     * Represents a cache entry\n-     *\/\n-    static final class CacheEntry {\n-\n-        CacheEntry(InetAddress[] addresses, long expiration) {\n-            this.addresses = addresses;\n-            this.expiration = expiration;\n-        }\n-\n-        InetAddress[] addresses;\n-        long expiration;\n+    \/\/ common interface\n+    private interface Addresses {\n+        InetAddress[] get() throws UnknownHostException;\n@@ -759,16 +747,12 @@\n-    \/**\n-     * A cache that manages entries based on a policy specified\n-     * at creation time.\n-     *\/\n-    static final class Cache {\n-        private LinkedHashMap<String, CacheEntry> cache;\n-        private Type type;\n-\n-        enum Type {Positive, Negative};\n-\n-        \/**\n-         * Create cache\n-         *\/\n-        public Cache(Type type) {\n-            this.type = type;\n-            cache = new LinkedHashMap<String, CacheEntry>();\n+    \/\/ a holder for cached addresses with required metadata\n+    private static final class CachedAddresses  implements Addresses, Comparable<CachedAddresses> {\n+        private static final AtomicLong seq = new AtomicLong();\n+        final String host;\n+        final InetAddress[] inetAddresses;\n+        final long expiryTime; \/\/ time of expiry (in terms of System.nanoTime())\n+        final long id = seq.incrementAndGet(); \/\/ each instance is unique\n+\n+        CachedAddresses(String host, InetAddress[] inetAddresses, long expiryTime) {\n+            this.host = host;\n+            this.inetAddresses = inetAddresses;\n+            this.expiryTime = expiryTime;\n@@ -777,5 +761,4 @@\n-        private int getPolicy() {\n-            if (type == Type.Positive) {\n-                return InetAddressCachePolicy.get();\n-            } else {\n-                return InetAddressCachePolicy.getNegative();\n+        @Override\n+        public InetAddress[] get() throws UnknownHostException {\n+            if (inetAddresses == null) {\n+                throw new UnknownHostException(host);\n@@ -783,0 +766,1 @@\n+            return inetAddresses;\n@@ -785,12 +769,13 @@\n-        \/**\n-         * Add an entry to the cache. If there's already an\n-         * entry then for this host then the entry will be\n-         * replaced.\n-         *\/\n-        public Cache put(String host, InetAddress[] addresses) {\n-            int policy = getPolicy();\n-            if (policy == InetAddressCachePolicy.NEVER) {\n-                return this;\n-            }\n-\n-            \/\/ purge any expired entries\n+        @Override\n+        public int compareTo(CachedAddresses other) {\n+            \/\/ natural order is expiry time -\n+            \/\/ compare difference of expiry times rather than\n+            \/\/ expiry times directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            long diff = this.expiryTime - other.expiryTime;\n+            if (diff < 0L) return -1;\n+            if (diff > 0L) return 1;\n+            \/\/ ties are broken using unique id\n+            return Long.compare(this.id, other.id);\n+        }\n+    }\n@@ -798,1 +783,5 @@\n-            if (policy != InetAddressCachePolicy.FOREVER) {\n+    \/\/ a name service lookup based Addresses implementation which replaces itself\n+    \/\/ in cache when the result is obtained\n+    private static final class NameServiceAddresses implements Addresses {\n+        private final String host;\n+        private final InetAddress reqAddr;\n@@ -800,6 +789,4 @@\n-                \/\/ As we iterate in insertion order we can\n-                \/\/ terminate when a non-expired entry is found.\n-                LinkedList<String> expired = new LinkedList<>();\n-                long now = System.currentTimeMillis();\n-                for (String key : cache.keySet()) {\n-                    CacheEntry entry = cache.get(key);\n+        NameServiceAddresses(String host, InetAddress reqAddr) {\n+            this.host = host;\n+            this.reqAddr = reqAddr;\n+        }\n@@ -807,2 +794,32 @@\n-                    if (entry.expiration >= 0 && entry.expiration < now) {\n-                        expired.add(key);\n+        @Override\n+        public InetAddress[] get() throws UnknownHostException {\n+            Addresses addresses;\n+            \/\/ only one thread is doing lookup to name service\n+            \/\/ for particular host at any time.\n+            synchronized (this) {\n+                \/\/ re-check that we are still us + re-install us if slot empty\n+                addresses = cache.putIfAbsent(host, this);\n+                if (addresses == null) {\n+                    \/\/ this can happen when we were replaced by CachedAddresses in\n+                    \/\/ some other thread, then CachedAddresses expired and were\n+                    \/\/ removed from cache while we were waiting for lock...\n+                    addresses = this;\n+                }\n+                \/\/ still us ?\n+                if (addresses == this) {\n+                    \/\/ lookup name services\n+                    InetAddress[] inetAddresses;\n+                    UnknownHostException ex;\n+                    int cachePolicy;\n+                    try {\n+                        inetAddresses = getAddressesFromNameService(host, reqAddr);\n+                        ex = null;\n+                        cachePolicy = InetAddressCachePolicy.get();\n+                    } catch (UnknownHostException uhe) {\n+                        inetAddresses = null;\n+                        ex = uhe;\n+                        cachePolicy = InetAddressCachePolicy.getNegative();\n+                    }\n+                    \/\/ remove or replace us with cached addresses according to cachePolicy\n+                    if (cachePolicy == InetAddressCachePolicy.NEVER) {\n+                        cache.remove(host, this);\n@@ -810,1 +827,13 @@\n-                        break;\n+                        CachedAddresses cachedAddresses = new CachedAddresses(\n+                            host,\n+                            inetAddresses,\n+                            cachePolicy == InetAddressCachePolicy.FOREVER\n+                            ? 0L\n+                            \/\/ cachePolicy is in [s] - we need [ns]\n+                            : System.nanoTime() + 1000_000_000L * cachePolicy\n+                        );\n+                        if (cache.replace(host, this, cachedAddresses) &&\n+                            cachePolicy != InetAddressCachePolicy.FOREVER) {\n+                            \/\/ schedule expiry\n+                            expirySet.add(cachedAddresses);\n+                        }\n@@ -812,0 +841,4 @@\n+                    if (inetAddresses == null) {\n+                        throw ex == null ? new UnknownHostException(host) : ex;\n+                    }\n+                    return inetAddresses;\n@@ -813,39 +846,1 @@\n-\n-                for (String key : expired) {\n-                    cache.remove(key);\n-                }\n-            }\n-\n-            \/\/ create new entry and add it to the cache\n-            \/\/ -- as a HashMap replaces existing entries we\n-            \/\/    don't need to explicitly check if there is\n-            \/\/    already an entry for this host.\n-            long expiration;\n-            if (policy == InetAddressCachePolicy.FOREVER) {\n-                expiration = -1;\n-            } else {\n-                expiration = System.currentTimeMillis() + (policy * 1000);\n-            }\n-            CacheEntry entry = new CacheEntry(addresses, expiration);\n-            cache.put(host, entry);\n-            return this;\n-        }\n-\n-        \/**\n-         * Query the cache for the specific host. If found then\n-         * return its CacheEntry, or null if not found.\n-         *\/\n-        public CacheEntry get(String host) {\n-            int policy = getPolicy();\n-            if (policy == InetAddressCachePolicy.NEVER) {\n-                return null;\n-            }\n-            CacheEntry entry = cache.get(host);\n-\n-            \/\/ check if entry has expired\n-            if (entry != null && policy != InetAddressCachePolicy.FOREVER) {\n-                if (entry.expiration >= 0 &&\n-                    entry.expiration < System.currentTimeMillis()) {\n-                    cache.remove(host);\n-                    entry = null;\n-                }\n+                \/\/ else addresses != this\n@@ -853,2 +848,3 @@\n-\n-            return entry;\n+            \/\/ delegate to different addresses when we are already replaced\n+            \/\/ but outside of synchronized block to avoid any chance of dead-locking\n+            return addresses.get();\n@@ -858,60 +854,1 @@\n-    \/*\n-     * Initialize cache and insert anyLocalAddress into the\n-     * unknown array with no expiry.\n-     *\/\n-    private static void cacheInitIfNeeded() {\n-        assert Thread.holdsLock(addressCache);\n-        if (addressCacheInit) {\n-            return;\n-        }\n-        unknown_array = new InetAddress[1];\n-        unknown_array[0] = impl.anyLocalAddress();\n-\n-        addressCache.put(impl.anyLocalAddress().getHostName(),\n-                         unknown_array);\n-\n-        addressCacheInit = true;\n-    }\n-\n-    \/*\n-     * Cache the given hostname and addresses.\n-     *\/\n-    private static void cacheAddresses(String hostname,\n-                                       InetAddress[] addresses,\n-                                       boolean success) {\n-        hostname = hostname.toLowerCase();\n-        synchronized (addressCache) {\n-            cacheInitIfNeeded();\n-            if (success) {\n-                addressCache.put(hostname, addresses);\n-            } else {\n-                negativeCache.put(hostname, addresses);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Lookup hostname in cache (positive & negative cache). If\n-     * found return addresses, null if not found.\n-     *\/\n-    private static InetAddress[] getCachedAddresses(String hostname) {\n-        hostname = hostname.toLowerCase();\n-\n-        \/\/ search both positive & negative caches\n-\n-        synchronized (addressCache) {\n-            cacheInitIfNeeded();\n-\n-            CacheEntry entry = addressCache.get(hostname);\n-            if (entry == null) {\n-                entry = negativeCache.get(hostname);\n-            }\n-\n-            if (entry != null) {\n-                return entry.addresses;\n-            }\n-        }\n-\n-        \/\/ not found\n-        return null;\n-    }\n+    static InetAddressImpl  impl;\n@@ -1193,1 +1130,1 @@\n-        return getAllByName0(host, reqAddr, true);\n+        return getAllByName0(host, reqAddr, true, true);\n@@ -1254,1 +1191,1 @@\n-        return getAllByName0 (host, null, check);\n+        return getAllByName0 (host, null, check, true);\n@@ -1257,1 +1194,15 @@\n-    private static InetAddress[] getAllByName0 (String host, InetAddress reqAddr, boolean check)\n+    \/**\n+     * Designated lookup method.\n+     *\n+     * @param host host name to look up\n+     * @param reqAddr requested address to be the 1st in returned array\n+     * @param check perform security check\n+     * @param useCache use cached value if not expired else always\n+     *                 perform name service lookup (and cache the result)\n+     * @return array of InetAddress(es)\n+     * @throws UnknownHostException if host name is not found\n+     *\/\n+    private static InetAddress[] getAllByName0(String host,\n+                                               InetAddress reqAddr,\n+                                               boolean check,\n+                                               boolean useCache)\n@@ -1261,1 +1212,0 @@\n-        \/* Cache.get can return: null, unknownAddress, or InetAddress[] *\/\n@@ -1273,1 +1223,19 @@\n-        InetAddress[] addresses = getCachedAddresses(host);\n+        \/\/ remove expired addresses from cache - expirySet keeps them ordered\n+        \/\/ by expiry time so we only need to iterate the prefix of the NavigableSet...\n+        long now = System.nanoTime();\n+        for (CachedAddresses caddrs : expirySet) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((caddrs.expiryTime - now) < 0L) {\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(caddrs)) {\n+                    \/\/ ... remove from cache\n+                    cache.remove(caddrs.host, caddrs);\n+                }\n+            } else {\n+                \/\/ we encountered 1st element that expires in future\n+                break;\n+            }\n+        }\n@@ -1275,3 +1243,13 @@\n-        \/* If no entry in cache, then do the host lookup *\/\n-        if (addresses == null) {\n-            addresses = getAddressesFromNameService(host, reqAddr);\n+        \/\/ look-up or remove from cache\n+        Addresses addrs;\n+        if (useCache) {\n+            addrs = cache.get(host);\n+        } else {\n+            addrs = cache.remove(host);\n+            if (addrs != null) {\n+                if (addrs instanceof CachedAddresses) {\n+                    \/\/ try removing from expirySet too if CachedAddresses\n+                    expirySet.remove(addrs);\n+                }\n+                addrs = null;\n+            }\n@@ -1280,2 +1258,11 @@\n-        if (addresses == unknown_array)\n-            throw new UnknownHostException(host);\n+        if (addrs == null) {\n+            \/\/ create a NameServiceAddresses instance which will look up\n+            \/\/ the name service and install it within cache...\n+            Addresses oldAddrs = cache.putIfAbsent(\n+                host,\n+                addrs = new NameServiceAddresses(host, reqAddr)\n+            );\n+            if (oldAddrs != null) { \/\/ lost putIfAbsent race\n+                addrs = oldAddrs;\n+            }\n+        }\n@@ -1283,1 +1270,2 @@\n-        return addresses.clone();\n+        \/\/ ask Addresses to get an array of InetAddress(es) and clone it\n+        return addrs.get().clone();\n@@ -1286,1 +1274,1 @@\n-    private static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)\n+    static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)\n@@ -1290,1 +1278,0 @@\n-        boolean success = false;\n@@ -1293,19 +1280,1 @@\n-        \/\/ Check whether the host is in the lookupTable.\n-        \/\/ 1) If the host isn't in the lookupTable when\n-        \/\/    checkLookupTable() is called, checkLookupTable()\n-        \/\/    would add the host in the lookupTable and\n-        \/\/    return null. So we will do the lookup.\n-        \/\/ 2) If the host is in the lookupTable when\n-        \/\/    checkLookupTable() is called, the current thread\n-        \/\/    would be blocked until the host is removed\n-        \/\/    from the lookupTable. Then this thread\n-        \/\/    should try to look up the addressCache.\n-        \/\/     i) if it found the addresses in the\n-        \/\/        addressCache, checkLookupTable()  would\n-        \/\/        return the addresses.\n-        \/\/     ii) if it didn't find the addresses in the\n-        \/\/         addressCache for any reason,\n-        \/\/         it should add the host in the\n-        \/\/         lookupTable and return null so the\n-        \/\/         following code would do  a lookup itself.\n-        if ((addresses = checkLookupTable(host)) == null) {\n+        for (NameService nameService : nameServices) {\n@@ -1313,27 +1282,6 @@\n-                \/\/ This is the first thread which looks up the addresses\n-                \/\/ this host or the cache entry for this host has been\n-                \/\/ expired so this thread should do the lookup.\n-                for (NameService nameService : nameServices) {\n-                    try {\n-                        \/*\n-                         * Do not put the call to lookup() inside the\n-                         * constructor.  if you do you will still be\n-                         * allocating space when the lookup fails.\n-                         *\/\n-\n-                        addresses = nameService.lookupAllHostAddr(host);\n-                        success = true;\n-                        break;\n-                    } catch (UnknownHostException uhe) {\n-                        if (host.equalsIgnoreCase(\"localhost\")) {\n-                            InetAddress[] local = new InetAddress[] { impl.loopbackAddress() };\n-                            addresses = local;\n-                            success = true;\n-                            break;\n-                        }\n-                        else {\n-                            addresses = unknown_array;\n-                            success = false;\n-                            ex = uhe;\n-                        }\n-                    }\n+                addresses = nameService.lookupAllHostAddr(host);\n+                break;\n+            } catch (UnknownHostException uhe) {\n+                if (host.equalsIgnoreCase(\"localhost\")) {\n+                    addresses = new InetAddress[] { impl.loopbackAddress() };\n+                    break;\n@@ -1341,20 +1289,2 @@\n-\n-                \/\/ More to do?\n-                if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {\n-                    \/\/ Find it?\n-                    int i = 1;\n-                    for (; i < addresses.length; i++) {\n-                        if (addresses[i].equals(reqAddr)) {\n-                            break;\n-                        }\n-                    }\n-                    \/\/ Rotate\n-                    if (i < addresses.length) {\n-                        InetAddress tmp, tmp2 = reqAddr;\n-                        for (int j = 0; j < i; j++) {\n-                            tmp = addresses[j];\n-                            addresses[j] = tmp2;\n-                            tmp2 = tmp;\n-                        }\n-                        addresses[i] = tmp2;\n-                    }\n+                else {\n+                    ex = uhe;\n@@ -1362,10 +1292,0 @@\n-                \/\/ Cache the address.\n-                cacheAddresses(host, addresses, success);\n-\n-                if (!success && ex != null)\n-                    throw ex;\n-\n-            } finally {\n-                \/\/ Delete host from the lookupTable and notify\n-                \/\/ all threads waiting on the lookupTable monitor.\n-                updateLookupTable(host);\n@@ -1375,13 +1295,3 @@\n-        return addresses;\n-    }\n-\n-\n-    private static InetAddress[] checkLookupTable(String host) {\n-        synchronized (lookupTable) {\n-            \/\/ If the host isn't in the lookupTable, add it in the\n-            \/\/ lookuptable and return null. The caller should do\n-            \/\/ the lookup.\n-            if (lookupTable.containsKey(host) == false) {\n-                lookupTable.put(host, null);\n-                return null;\n-            }\n+        if (addresses == null) {\n+            throw ex == null ? new UnknownHostException(host) : ex;\n+        }\n@@ -1389,7 +1299,7 @@\n-            \/\/ If the host is in the lookupTable, it means that another\n-            \/\/ thread is trying to look up the addresses of this host.\n-            \/\/ This thread should wait.\n-            while (lookupTable.containsKey(host)) {\n-                try {\n-                    lookupTable.wait();\n-                } catch (InterruptedException e) {\n+        \/\/ More to do?\n+        if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {\n+            \/\/ Find it?\n+            int i = 1;\n+            for (; i < addresses.length; i++) {\n+                if (addresses[i].equals(reqAddr)) {\n+                    break;\n@@ -1398,11 +1308,9 @@\n-        }\n-\n-        \/\/ The other thread has finished looking up the addresses of\n-        \/\/ the host. This thread should retry to get the addresses\n-        \/\/ from the addressCache. If it doesn't get the addresses from\n-        \/\/ the cache, it will try to look up the addresses itself.\n-        InetAddress[] addresses = getCachedAddresses(host);\n-        if (addresses == null) {\n-            synchronized (lookupTable) {\n-                lookupTable.put(host, null);\n-                return null;\n+            \/\/ Rotate\n+            if (i < addresses.length) {\n+                InetAddress tmp, tmp2 = reqAddr;\n+                for (int j = 0; j < i; j++) {\n+                    tmp = addresses[j];\n+                    addresses[j] = tmp2;\n+                    tmp2 = tmp;\n+                }\n+                addresses[i] = tmp2;\n@@ -1415,7 +1323,0 @@\n-    private static void updateLookupTable(String host) {\n-        synchronized (lookupTable) {\n-            lookupTable.remove(host);\n-            lookupTable.notifyAll();\n-        }\n-    }\n-\n@@ -1443,4 +1344,12 @@\n-    private static InetAddress cachedLocalHost = null;\n-    private static long cacheTime = 0;\n-    private static final long maxCacheTime = 5000L;\n-    private static final Object cacheLock = new Object();\n+    private static final class CachedLocalHost {\n+        final String host;\n+        final InetAddress addr;\n+        final long expiryTime = System.nanoTime() + 5000_000_000L; \/\/ now + 5s;\n+\n+        CachedLocalHost(String host, InetAddress addr) {\n+            this.host = host;\n+            this.addr = addr;\n+        }\n+    }\n+\n+    private static volatile CachedLocalHost cachedLocalHost;\n@@ -1475,0 +1384,9 @@\n+            \/\/ is cached data still valid?\n+            CachedLocalHost clh = cachedLocalHost;\n+            if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n+                if (security != null) {\n+                    security.checkConnect(clh.host, -1);\n+                }\n+                return clh.addr;\n+            }\n+\n@@ -1481,0 +1399,1 @@\n+            InetAddress localAddr;\n@@ -1482,31 +1401,14 @@\n-                return impl.loopbackAddress();\n-            }\n-\n-            InetAddress ret = null;\n-            synchronized (cacheLock) {\n-                long now = System.currentTimeMillis();\n-                if (cachedLocalHost != null) {\n-                    if ((now - cacheTime) < maxCacheTime) \/\/ Less than 5s old?\n-                        ret = cachedLocalHost;\n-                    else\n-                        cachedLocalHost = null;\n-                }\n-\n-                \/\/ we are calling getAddressesFromNameService directly\n-                \/\/ to avoid getting localHost from cache\n-                if (ret == null) {\n-                    InetAddress[] localAddrs;\n-                    try {\n-                        localAddrs =\n-                            InetAddress.getAddressesFromNameService(local, null);\n-                    } catch (UnknownHostException uhe) {\n-                        \/\/ Rethrow with a more informative error message.\n-                        UnknownHostException uhe2 =\n-                            new UnknownHostException(local + \": \" +\n-                                                     uhe.getMessage());\n-                        uhe2.initCause(uhe);\n-                        throw uhe2;\n-                    }\n-                    cachedLocalHost = localAddrs[0];\n-                    cacheTime = now;\n-                    ret = localAddrs[0];\n+                \/\/ shortcut for \"localhost\" host name\n+                localAddr = impl.loopbackAddress();\n+            } else {\n+                \/\/ call getAllByName0 without security checks and\n+                \/\/ without using cached data\n+                try {\n+                    localAddr = getAllByName0(local, null, false, false)[0];\n+                } catch (UnknownHostException uhe) {\n+                    \/\/ Rethrow with a more informative error message.\n+                    UnknownHostException uhe2 =\n+                        new UnknownHostException(local + \": \" +\n+                                                 uhe.getMessage());\n+                    uhe2.initCause(uhe);\n+                    throw uhe2;\n@@ -1515,1 +1417,2 @@\n-            return ret;\n+            cachedLocalHost = new CachedLocalHost(local, localAddr);\n+            return localAddr;\n","filename":"jdk\/src\/share\/classes\/java\/net\/InetAddress.java","additions":240,"deletions":337,"binary":false,"changes":577,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private static int cachePolicy = FOREVER;\n+    private static volatile int cachePolicy = FOREVER;\n@@ -69,1 +69,1 @@\n-    private static int negativeCachePolicy = NEVER;\n+    private static volatile int negativeCachePolicy = NEVER;\n@@ -113,4 +113,1 @@\n-            cachePolicy = tmp.intValue();\n-            if (cachePolicy < 0) {\n-                cachePolicy = FOREVER;\n-            }\n+            cachePolicy = tmp < 0 ? FOREVER : tmp;\n@@ -151,4 +148,1 @@\n-            negativeCachePolicy = tmp.intValue();\n-            if (negativeCachePolicy < 0) {\n-                negativeCachePolicy = FOREVER;\n-            }\n+            negativeCachePolicy = tmp < 0 ? FOREVER : tmp;\n@@ -159,1 +153,1 @@\n-    public static synchronized int get() {\n+    public static int get() {\n@@ -163,1 +157,1 @@\n-    public static synchronized int getNegative() {\n+    public static int getNegative() {\n@@ -193,1 +187,1 @@\n-    public static synchronized void setNegativeIfNotSet(int newPolicy) {\n+    public static void setNegativeIfNotSet(int newPolicy) {\n@@ -203,1 +197,2 @@\n-            negativeCachePolicy = newPolicy;\n+            \/\/ but we should normalize negative policy\n+            negativeCachePolicy = newPolicy < 0 ? FOREVER : newPolicy;\n","filename":"jdk\/src\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"}]}