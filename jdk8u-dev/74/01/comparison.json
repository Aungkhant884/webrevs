{"files":[{"patch":"@@ -3748,3 +3748,1 @@\n-  const int N_MAX_OPTIONS = 64;\n-  const int OPTION_BUFFER_SIZE = 1024;\n-  char buffer[OPTION_BUFFER_SIZE];\n+  char *buffer = ::getenv(name);\n@@ -3752,2 +3750,1 @@\n-  \/\/ The variable will be ignored if it exceeds the length of the buffer.\n-  \/\/ Don't check this variable if user has special privileges\n+  \/\/ Don't check this environment variable if user has special privileges\n@@ -3755,32 +3752,50 @@\n-  if (os::getenv(name, buffer, sizeof(buffer)) &&\n-      !os::have_special_privileges()) {\n-    JavaVMOption options[N_MAX_OPTIONS];      \/\/ Construct option array\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"Picked up %s: %s\\n\", name, buffer);\n-    char* rd = buffer;                        \/\/ pointer to the input string (rd)\n-    int i;\n-    for (i = 0; i < N_MAX_OPTIONS;) {         \/\/ repeat for all options in the input string\n-      while (isspace(*rd)) rd++;              \/\/ skip whitespace\n-      if (*rd == 0) break;                    \/\/ we re done when the input string is read completely\n-\n-      \/\/ The output, option string, overwrites the input string.\n-      \/\/ Because of quoting, the pointer to the option string (wrt) may lag the pointer to\n-      \/\/ input string (rd).\n-      char* wrt = rd;\n-\n-      options[i++].optionString = wrt;        \/\/ Fill in option\n-      while (*rd != 0 && !isspace(*rd)) {     \/\/ unquoted strings terminate with a space or NULL\n-        if (*rd == '\\'' || *rd == '\"') {      \/\/ handle a quoted string\n-          int quote = *rd;                    \/\/ matching quote to look for\n-          rd++;                               \/\/ don't copy open quote\n-          while (*rd != quote) {              \/\/ include everything (even spaces) up until quote\n-            if (*rd == 0) {                   \/\/ string termination means unmatched string\n-              jio_fprintf(defaultStream::error_stream(),\n-                          \"Unmatched quote in %s\\n\", name);\n-              return JNI_ERR;\n-            }\n-            *wrt++ = *rd++;                   \/\/ copy to option string\n-          }\n-          rd++;                               \/\/ don't copy close quote\n-        } else {\n-          *wrt++ = *rd++;                     \/\/ copy to option string\n+  if (buffer == NULL || os::have_special_privileges()) {\n+    return JNI_OK;\n+  }\n+\n+  if ((buffer = os::strdup(buffer)) == NULL) {\n+    return JNI_ENOMEM;\n+  }\n+\n+  jio_fprintf(defaultStream::error_stream(),\n+              \"Picked up %s: %s\\n\", name, buffer);\n+\n+  int retcode = parse_options_buffer(name, buffer, strlen(buffer), scp_p, scp_assembly_required_p);\n+\n+  os::free(buffer);\n+  return retcode;\n+}\n+\n+jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, SysClassPath* scp_p, bool* scp_assembly_required_p) {\n+  GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<JavaVMOption>(2, true);    \/\/ Construct option array\n+\n+  \/\/ some pointers to help with parsing\n+  char *buffer_end = buffer + buf_len;\n+  char *opt_hd = buffer;\n+  char *wrt = buffer;\n+  char *rd = buffer;\n+\n+  \/\/ parse all options\n+  while (rd < buffer_end) {\n+    \/\/ skip leading white space from the input string\n+    while (rd < buffer_end && isspace(*rd)) {\n+      rd++;\n+    }\n+\n+    if (rd >= buffer_end) {\n+      break;\n+    }\n+\n+    \/\/ Remember this is where we found the head of the token.\n+    opt_hd = wrt;\n+\n+    \/\/ Tokens are strings of non white space characters separated\n+    \/\/ by one or more white spaces.\n+    while (rd < buffer_end && !isspace(*rd)) {\n+      if (*rd == '\\'' || *rd == '\"') {      \/\/ handle a quoted string\n+        int quote = *rd;                    \/\/ matching quote to look for\n+        rd++;                               \/\/ don't copy open quote\n+        while (rd < buffer_end && *rd != quote) {\n+                                            \/\/ include everything (even spaces)\n+                                            \/\/ up until the close quote\n+          *wrt++ = *rd++;                   \/\/ copy to option string\n@@ -3788,22 +3803,9 @@\n-      }\n-      \/\/ Need to check if we're done before writing a NULL,\n-      \/\/ because the write could be to the byte that rd is pointing to.\n-      if (*rd++ == 0) {\n-        *wrt = 0;\n-        break;\n-      }\n-      *wrt = 0;                               \/\/ Zero terminate option\n-    }\n-    \/\/ Construct JavaVMInitArgs structure and parse as if it was part of the command line\n-    JavaVMInitArgs vm_args;\n-    vm_args.version = JNI_VERSION_1_2;\n-    vm_args.options = options;\n-    vm_args.nOptions = i;\n-    vm_args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;\n-\n-    if (PrintVMOptions) {\n-      const char* tail;\n-      for (int i = 0; i < vm_args.nOptions; i++) {\n-        const JavaVMOption *option = vm_args.options + i;\n-        if (match_option(option, \"-XX:\", &tail)) {\n-          logOption(tail);\n+\n+        if (rd < buffer_end) {\n+          rd++;                             \/\/ don't copy close quote\n+        } else {\n+                                            \/\/ did not see closing quote\n+          jio_fprintf(defaultStream::error_stream(),\n+                      \"Unmatched quote in %s\\n\", name);\n+          delete options;\n+          return JNI_ERR;\n@@ -3811,0 +3813,2 @@\n+      } else {\n+        *wrt++ = *rd++;                     \/\/ copy to option string\n@@ -3814,1 +3818,9 @@\n-    return(parse_each_vm_init_arg(&vm_args, scp_p, scp_assembly_required_p, Flag::ENVIRON_VAR));\n+    \/\/ steal a white space character and set it to NULL\n+    *wrt++ = '\\0';\n+    \/\/ We now have a complete token\n+\n+    JavaVMOption option;\n+    option.optionString = opt_hd;\n+    options->append(option);                \/\/ Fill in option\n+\n+    rd++;  \/\/ Advance to next character\n@@ -3816,1 +3828,22 @@\n-  return JNI_OK;\n+\n+  \/\/ Construct JavaVMInitArgs structure and parse as if it was part of the command line\n+  JavaVMInitArgs vm_args;\n+  vm_args.version = JNI_VERSION_1_2;\n+  vm_args.options = options->adr_at(0);\n+  vm_args.nOptions = options->length();\n+  vm_args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;\n+\n+  if (PrintVMOptions) {\n+    const char* tail;\n+    for (int i = 0; i < vm_args.nOptions; i++) {\n+      const JavaVMOption *option = vm_args.options + i;\n+      if (match_option(option, \"-XX:\", &tail)) {\n+        logOption(tail);\n+      }\n+    }\n+  }\n+\n+  int parse_result = parse_each_vm_init_arg(&vm_args, scp_p, scp_assembly_required_p, Flag::ENVIRON_VAR);\n+\n+  delete options;\n+  return parse_result;\n","filename":"hotspot\/src\/share\/vm\/runtime\/arguments.cpp","additions":94,"deletions":61,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  static jint parse_options_buffer(const char* name, char* buffer, const size_t buf_len, SysClassPath* scp_p, bool* scp_assembly_required_p);\n","filename":"hotspot\/src\/share\/vm\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}