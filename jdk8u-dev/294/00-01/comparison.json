{"files":[{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.lang.instrument.*;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-\/*\n- * Helper class to write tests that redefine classes.\n- * When main method is run, it will create a redefineagent.jar that can be used\n- * with the -javaagent option to support redefining classes in jtreg tests.\n- *\n- * See sample test in test\/testlibrary_tests\/RedefineClassTest.java\n- *\/\n-public class RedefineClassHelper {\n-\n-    public static Instrumentation instrumentation;\n-    public static void premain(String agentArgs, Instrumentation inst) {\n-        instrumentation = inst;\n-    }\n-\n-    \/**\n-     * Redefine a class\n-     *\n-     * @param clazz Class to redefine\n-     * @param javacode String with the new java code for the class to be redefined\n-     *\/\n-    public static void redefineClass(Class clazz, String javacode) throws Exception {\n-        byte[] bytecode = InMemoryJavaCompiler.compile(clazz.getName(), javacode);\n-        redefineClass(clazz, bytecode);\n-    }\n-\n-    \/**\n-     * Redefine a class\n-     *\n-     * @param clazz Class to redefine\n-     * @param bytecode byte[] with the new class\n-     *\/\n-    public static void redefineClass(Class clazz, byte[] bytecode) throws Exception {\n-        instrumentation.redefineClasses(new ClassDefinition(clazz, bytecode));\n-    }\n-\n-    \/**\n-     * Main method to be invoked before test to create the redefineagent.jar\n-     *\/\n-    public static void main(String[] args) throws Exception {\n-        ClassFileInstaller.main(\"RedefineClassHelper\");\n-\n-        PrintWriter pw = new PrintWriter(\"MANIFEST.MF\");\n-        pw.println(\"Premain-Class: RedefineClassHelper\");\n-        pw.println(\"Can-Redefine-Classes: true\");\n-        pw.close();\n-\n-        sun.tools.jar.Main jarTool = new sun.tools.jar.Main(System.out, System.err, \"jar\");\n-        if (!jarTool.run(new String[] { \"-cmf\", \"MANIFEST.MF\", \"redefineagent.jar\", \"RedefineClassHelper.class\" })) {\n-            throw new Exception(\"jar operation failed\");\n-        }\n-    }\n-}\n","filename":"test\/lib\/RedefineClassHelper.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class SecurityTools {\n-\n-    public static final String RESPONSE_FILE = \"security_tools_response.txt\";\n-\n-    private static ProcessBuilder getProcessBuilder(String tool, List<String> args) {\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(tool)\n-                .addVMArg(\"-Duser.language=en\")\n-                .addVMArg(\"-Duser.country=US\");\n-        if (!Platform.isWindows()) {\n-            launcher.addVMArg(\"-Djava.security.egd=file:\/dev\/.\/urandom\");\n-        }\n-        for (String arg : args) {\n-            if (arg.startsWith(\"-J\")) {\n-                launcher.addVMArg(arg.substring(2));\n-            } else {\n-                launcher.addToolArg(arg);\n-            }\n-        }\n-        return new ProcessBuilder(launcher.getCommand());\n-    }\n-\n-    \/\/ keytool\n-\n-    public static OutputAnalyzer keytool(List<String> args)\n-            throws Exception {\n-\n-        ProcessBuilder pb = getProcessBuilder(\"keytool\", args);\n-\n-        Path p = Paths.get(RESPONSE_FILE);\n-        if (!Files.exists(p)) {\n-            Files.createFile(p);\n-        }\n-        pb.redirectInput(ProcessBuilder.Redirect.from(new File(RESPONSE_FILE)));\n-\n-        try {\n-            return execute(pb);\n-        } finally {\n-            Files.delete(p);\n-        }\n-    }\n-\n-    \/\/ Only call this if there is no white space in every argument\n-    public static OutputAnalyzer keytool(String args) throws Exception {\n-        return keytool(args.split(\"\\\\s+\"));\n-    }\n-\n-    public static OutputAnalyzer keytool(String... args) throws Exception {\n-        return keytool(List.of(args));\n-    }\n-\n-    public static void setResponse(String... responses) throws IOException {\n-        String text;\n-        if (responses.length > 0) {\n-            text = Stream.of(responses).collect(\n-                    Collectors.joining(\"\\n\", \"\", \"\\n\"));\n-        } else {\n-            text = \"\";\n-        }\n-        Files.write(Paths.get(RESPONSE_FILE), text.getBytes());\n-    }\n-\n-    \/\/ jarsigner\n-\n-    public static OutputAnalyzer jarsigner(List<String> args)\n-            throws Exception {\n-        return execute(getProcessBuilder(\"jarsigner\", args));\n-    }\n-\n-    private static OutputAnalyzer execute(ProcessBuilder pb) throws Exception {\n-        try {\n-            OutputAnalyzer oa = ProcessTools.executeCommand(pb);\n-            System.out.println(\"Exit value: \" + oa.getExitValue());\n-            return oa;\n-        } catch (Throwable t) {\n-            if (t instanceof Exception) {\n-                throw (Exception) t;\n-            } else {\n-                throw new Exception(t);\n-            }\n-        }\n-    }\n-\n-    \/\/ Only call this if there is no white space in every argument\n-    public static OutputAnalyzer jarsigner(String args) throws Exception {\n-\n-        return jarsigner(args.split(\"\\\\s+\"));\n-    }\n-\n-    public static OutputAnalyzer jarsigner(String... args) throws Exception {\n-        return jarsigner(List.of(args));\n-    }\n-}\n-\n","filename":"test\/lib\/jdk\/test\/lib\/SecurityTools.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,518 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.apps;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.StringReader;\n-import java.nio.file.Files;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.UUID;\n-\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.OutputBuffer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.StreamPumper;\n-\n-\/**\n- * This is a framework to launch an app that could be synchronized with caller\n- * to make further attach actions reliable across supported platforms\n-\n- * Caller example:\n- *   SmartTestApp a = SmartTestApp.startApp(cmd);\n- *     \/\/ do something\n- *   a.stopApp();\n- *\n- *   or fine grained control\n- *\n- *   a = new SmartTestApp(\"MyLock.lck\");\n- *   a.createLock();\n- *   a.runApp();\n- *   a.waitAppReady();\n- *     \/\/ do something\n- *   a.deleteLock();\n- *   a.waitAppTerminate();\n- *\n- *  Then you can work with app output and process object\n- *\n- *   output = a.getAppOutput();\n- *   process = a.getProcess();\n- *\n- *\/\n-public class LingeredApp {\n-\n-    private static final long spinDelay = 1000;\n-\n-    private long lockCreationTime;\n-    private ByteArrayOutputStream stderrBuffer;\n-    private ByteArrayOutputStream stdoutBuffer;\n-    private Thread outPumperThread;\n-    private Thread errPumperThread;\n-\n-    protected Process appProcess;\n-    protected OutputBuffer output;\n-    protected static final int appWaitTime = 100;\n-    protected final String lockFileName;\n-\n-    \/**\n-     * Create LingeredApp object on caller side. Lock file have be a valid filename\n-     * at writable location\n-     *\n-     * @param lockFileName - the name of lock file\n-     *\/\n-    public LingeredApp(String lockFileName) {\n-        this.lockFileName = lockFileName;\n-    }\n-\n-    public LingeredApp() {\n-        final String lockName = UUID.randomUUID().toString() + \".lck\";\n-        this.lockFileName = lockName;\n-    }\n-\n-    \/**\n-     *\n-     * @return name of lock file\n-     *\/\n-    public String getLockFileName() {\n-        return this.lockFileName;\n-    }\n-\n-    \/**\n-     *\n-     * @return name of testapp\n-     *\/\n-    public String getAppName() {\n-        return this.getClass().getName();\n-    }\n-\n-    \/**\n-     *\n-     *  @return pid of java process running testapp\n-     *\/\n-    public long getPid() {\n-        if (appProcess == null) {\n-            throw new RuntimeException(\"Process is not alive\");\n-        }\n-        return appProcess.pid();\n-    }\n-\n-    \/**\n-     *\n-     * @return process object\n-     *\/\n-    public Process getProcess() {\n-        return appProcess;\n-    }\n-\n-    \/**\n-     *\n-     * @return OutputBuffer object for the LingeredApp's output. Can only be called\n-     * after LingeredApp has exited.\n-     *\/\n-    public OutputBuffer getOutput() {\n-        if (appProcess.isAlive()) {\n-            throw new RuntimeException(\"Process is still alive. Can't get its output.\");\n-        }\n-        if (output == null) {\n-            output = new OutputBuffer(stdoutBuffer.toString(), stderrBuffer.toString());\n-        }\n-        return output;\n-    }\n-\n-    \/*\n-     * Capture all stdout and stderr output from the LingeredApp so it can be returned\n-     * to the driver app later. This code is modeled after ProcessTools.getOutput().\n-     *\/\n-    private void startOutputPumpers() {\n-        stderrBuffer = new ByteArrayOutputStream();\n-        stdoutBuffer = new ByteArrayOutputStream();\n-        StreamPumper outPumper = new StreamPumper(appProcess.getInputStream(), stdoutBuffer);\n-        StreamPumper errPumper = new StreamPumper(appProcess.getErrorStream(), stderrBuffer);\n-        outPumperThread = new Thread(outPumper);\n-        errPumperThread = new Thread(errPumper);\n-\n-        outPumperThread.setDaemon(true);\n-        errPumperThread.setDaemon(true);\n-\n-        outPumperThread.start();\n-        errPumperThread.start();\n-    }\n-\n-    \/**\n-     *\n-     * @return application output as List. Empty List if application produced no output\n-     *\/\n-    public List<String> getAppOutput() {\n-        if (appProcess.isAlive()) {\n-            throw new RuntimeException(\"Process is still alive. Can't get its output.\");\n-        }\n-        BufferedReader bufReader = new BufferedReader(new StringReader(output.getStdout()));\n-        return bufReader.lines().collect(Collectors.toList());\n-    }\n-\n-    \/* Make sure all part of the app use the same method to get dates,\n-     as different methods could produce different results\n-     *\/\n-    private static long epoch() {\n-        return new Date().getTime();\n-    }\n-\n-    private static long lastModified(String fileName) throws IOException {\n-        Path path = Paths.get(fileName);\n-        BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);\n-        return attr.lastModifiedTime().toMillis();\n-    }\n-\n-    private static void setLastModified(String fileName, long newTime) throws IOException {\n-        Path path = Paths.get(fileName);\n-        FileTime fileTime = FileTime.fromMillis(newTime);\n-        Files.setLastModifiedTime(path, fileTime);\n-    }\n-\n-    \/**\n-     * create lock\n-     *\n-     * @throws IOException\n-     *\/\n-    public void createLock() throws IOException {\n-        Path path = Paths.get(lockFileName);\n-        \/\/ Files.deleteIfExists(path);\n-        Files.createFile(path);\n-        lockCreationTime = lastModified(lockFileName);\n-    }\n-\n-    \/**\n-     * Delete lock\n-     *\n-     * @throws IOException\n-     *\/\n-    public void deleteLock() throws IOException {\n-        try {\n-            Path path = Paths.get(lockFileName);\n-            Files.delete(path);\n-        } catch (NoSuchFileException ex) {\n-            \/\/ Lock already deleted. Ignore error\n-        }\n-    }\n-\n-    public void waitAppTerminate() {\n-        \/\/ This code is modeled after tail end of ProcessTools.getOutput().\n-        try {\n-            \/\/ If the app hangs, we don't want to wait for the to test timeout.\n-            if (!appProcess.waitFor(Utils.adjustTimeout(appWaitTime), TimeUnit.SECONDS)) {\n-                appProcess.destroy();\n-                appProcess.waitFor();\n-            }\n-            outPumperThread.join();\n-            errPumperThread.join();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            \/\/ pass\n-        }\n-    }\n-\n-    \/**\n-     * The app touches the lock file when it's started\n-     * wait while it happens. Caller have to delete lock on wait error.\n-     *\n-     * @param timeout\n-     * @throws java.io.IOException\n-     *\/\n-    public void waitAppReady(long timeout) throws IOException {\n-        long here = epoch();\n-        while (true) {\n-            long epoch = epoch();\n-            if (epoch - here > (timeout * 1000)) {\n-                throw new IOException(\"App waiting timeout\");\n-            }\n-\n-            \/\/ Live process should touch lock file every second\n-            long lm = lastModified(lockFileName);\n-            if (lm > lockCreationTime) {\n-                break;\n-            }\n-\n-            \/\/ Make sure process didn't already exit\n-            if (!appProcess.isAlive()) {\n-                throw new IOException(\"App exited unexpectedly with \" + appProcess.exitValue());\n-            }\n-\n-            try {\n-                Thread.sleep(spinDelay);\n-            } catch (InterruptedException ex) {\n-                \/\/ pass\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Analyze an environment and prepare a command line to\n-     * run the app, app name should be added explicitly\n-     *\/\n-    public List<String> runAppPrepare(List<String> vmArguments) {\n-        \/\/ We should always use testjava or throw an exception,\n-        \/\/ so we can't use JDKToolFinder.getJDKTool(\"java\");\n-        \/\/ that falls back to compile java on error\n-        String jdkPath = System.getProperty(\"test.jdk\");\n-        if (jdkPath == null) {\n-            \/\/ we are not under jtreg, try env\n-            Map<String, String> env = System.getenv();\n-            jdkPath = env.get(\"TESTJAVA\");\n-        }\n-\n-        if (jdkPath == null) {\n-            throw new RuntimeException(\"Can't determine jdk path neither test.jdk property no TESTJAVA env are set\");\n-        }\n-\n-        String osname = System.getProperty(\"os.name\");\n-        String javapath = jdkPath + ((osname.startsWith(\"window\")) ? \"\/bin\/java.exe\" : \"\/bin\/java\");\n-\n-        List<String> cmd = new ArrayList<String>();\n-        cmd.add(javapath);\n-\n-        if (vmArguments == null) {\n-            \/\/ Propagate test.vm.options to LingeredApp, filter out possible empty options\n-            String testVmOpts[] = System.getProperty(\"test.vm.opts\",\"\").split(\"\\\\s+\");\n-            for (String s : testVmOpts) {\n-                if (!s.equals(\"\")) {\n-                    cmd.add(s);\n-                }\n-            }\n-        } else {\n-            \/\/ Lets user manage LingeredApp options\n-            cmd.addAll(vmArguments);\n-        }\n-\n-        \/\/ Make sure we set correct classpath to run the app\n-        cmd.add(\"-cp\");\n-        String classpath = System.getProperty(\"test.class.path\");\n-        cmd.add((classpath == null) ? \".\" : classpath);\n-\n-        return cmd;\n-    }\n-\n-    \/**\n-     * Assemble command line to a printable string\n-     *\/\n-    public void printCommandLine(List<String> cmd) {\n-        \/\/ A bit of verbosity\n-        StringBuilder cmdLine = new StringBuilder();\n-        for (String strCmd : cmd) {\n-            cmdLine.append(\"'\").append(strCmd).append(\"' \");\n-        }\n-\n-        System.err.println(\"Command line: [\" + cmdLine.toString() + \"]\");\n-    }\n-\n-    \/**\n-     * Run the app.\n-     *\n-     * @param vmArguments\n-     * @throws IOException\n-     *\/\n-    public void runApp(List<String> vmArguments)\n-            throws IOException {\n-\n-        List<String> cmd = runAppPrepare(vmArguments);\n-\n-        cmd.add(this.getAppName());\n-        cmd.add(lockFileName);\n-\n-        printCommandLine(cmd);\n-\n-        ProcessBuilder pb = new ProcessBuilder(cmd);\n-        \/\/ ProcessBuilder.start can throw IOException\n-        appProcess = pb.start();\n-\n-        startOutputPumpers();\n-    }\n-\n-    private void finishApp() {\n-        OutputBuffer output = getOutput();\n-        String msg =\n-            \" LingeredApp stdout: [\" + output.getStdout() + \"];\\n\" +\n-            \" LingeredApp stderr: [\" + output.getStderr() + \"]\\n\" +\n-            \" LingeredApp exitValue = \" + appProcess.exitValue();\n-\n-        System.err.println(msg);\n-    }\n-\n-    \/**\n-     * Delete lock file that signals app to terminate, then\n-     * wait until app is actually terminated.\n-     * @throws IOException\n-     *\/\n-    public void stopApp() throws IOException {\n-        deleteLock();\n-        \/\/ The startApp() of the derived app can throw\n-        \/\/ an exception before the LA actually starts\n-        if (appProcess != null) {\n-            waitAppTerminate();\n-            int exitcode = appProcess.exitValue();\n-            if (exitcode != 0) {\n-                throw new IOException(\"LingeredApp terminated with non-zero exit code \" + exitcode);\n-            }\n-        }\n-        finishApp();\n-    }\n-\n-    \/**\n-     *  High level interface for test writers\n-     *\/\n-    \/**\n-     * Factory method that creates LingeredApp object with ready to use application\n-     * lock name is autogenerated\n-     * @param cmd - vm options, could be null to auto add testvm.options\n-     * @return LingeredApp object\n-     * @throws IOException\n-     *\/\n-    public static LingeredApp startApp(List<String> cmd) throws IOException {\n-        LingeredApp a = new LingeredApp();\n-        a.createLock();\n-        try {\n-            a.runApp(cmd);\n-            a.waitAppReady(appWaitTime);\n-        } catch (Exception ex) {\n-            a.deleteLock();\n-            System.err.println(\"LingeredApp failed to start: \" + ex);\n-            a.finishApp();\n-            throw ex;\n-        }\n-\n-        return a;\n-    }\n-\n-    \/**\n-     * Factory method that starts pre-created LingeredApp\n-     * lock name is autogenerated\n-     * @param cmd - vm options, could be null to auto add testvm.options\n-     * @param theApp - app to start\n-     * @return LingeredApp object\n-     * @throws IOException\n-     *\/\n-\n-    public static void startApp(List<String> cmd, LingeredApp theApp) throws IOException {\n-        theApp.createLock();\n-        try {\n-            theApp.runApp(cmd);\n-            theApp.waitAppReady(appWaitTime);\n-        } catch (Exception ex) {\n-            theApp.deleteLock();\n-            throw ex;\n-        }\n-    }\n-\n-    public static LingeredApp startApp() throws IOException {\n-        return startApp(null);\n-    }\n-\n-    public static void stopApp(LingeredApp app) throws IOException {\n-        if (app != null) {\n-            \/\/ LingeredApp can throw an exception during the intialization,\n-            \/\/ make sure we don't have cascade NPE\n-            app.stopApp();\n-        }\n-    }\n-\n-    \/**\n-     * LastModified time might not work correctly in some cases it might\n-     * cause later failures\n-     *\/\n-\n-    public static boolean isLastModifiedWorking() {\n-        boolean sane = true;\n-        try {\n-            long lm = lastModified(\".\");\n-            if (lm == 0) {\n-                System.err.println(\"SANITY Warning! The lastModifiedTime() doesn't work on this system, it returns 0\");\n-                sane = false;\n-            }\n-\n-            long now = epoch();\n-            if (lm > now) {\n-                System.err.println(\"SANITY Warning! The Clock is wrong on this system lastModifiedTime() > getTime()\");\n-                sane = false;\n-            }\n-\n-            setLastModified(\".\", epoch());\n-            long lm1 = lastModified(\".\");\n-            if (lm1 <= lm) {\n-                System.err.println(\"SANITY Warning! The setLastModified doesn't work on this system\");\n-                sane = false;\n-            }\n-        }\n-        catch(IOException e) {\n-            System.err.println(\"SANITY Warning! IOException during sanity check \" + e);\n-            sane = false;\n-        }\n-\n-        return sane;\n-    }\n-\n-    \/**\n-     * This part is the application it self\n-     *\/\n-    public static void main(String args[]) {\n-\n-        if (args.length != 1) {\n-            System.err.println(\"Lock file name is not specified\");\n-            System.exit(7);\n-        }\n-\n-        String theLockFileName = args[0];\n-\n-        try {\n-            Path path = Paths.get(theLockFileName);\n-\n-            while (Files.exists(path)) {\n-                \/\/ Touch the lock to indicate our readiness\n-                setLastModified(theLockFileName, epoch());\n-                Thread.sleep(spinDelay);\n-            }\n-        } catch (NoSuchFileException ex) {\n-            \/\/ Lock deleted while we are setting last modified time.\n-            \/\/ Ignore error and lets the app exits\n-        } catch (Exception ex) {\n-            System.err.println(\"LingeredApp ERROR: \" + ex);\n-            \/\/ Leave exit_code = 1 to Java launcher\n-            System.exit(3);\n-        }\n-\n-        System.exit(0);\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":0,"deletions":518,"binary":false,"changes":518,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.test.lib.apps;\n-\n-import java.util.concurrent.Phaser;\n-\n-public class LingeredAppWithDeadlock extends LingeredApp {\n-\n-    private static final Object Lock1 = new Object();\n-    private static final Object Lock2 = new Object();\n-\n-    private static volatile int reachCount = 0;\n-\n-    private static final Phaser p = new Phaser(2);\n-\n-    private static class ThreadOne extends Thread {\n-        public void run() {\n-            \/\/ wait Lock2 is locked\n-            p.arriveAndAwaitAdvance();\n-            synchronized (Lock1) {\n-                \/\/ signal Lock1 is locked\n-                p.arriveAndAwaitAdvance();\n-                synchronized (Lock2) {\n-                    reachCount += 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static class ThreadTwo extends Thread {\n-        public void run() {\n-            synchronized (Lock2) {\n-                \/\/ signal Lock2 is locked\n-                p.arriveAndAwaitAdvance();\n-                \/\/ wait Lock1 is locked\n-                p.arriveAndAwaitAdvance();\n-                synchronized (Lock1) {\n-                    reachCount += 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        if (args.length != 1) {\n-            System.err.println(\"Lock file name is not specified\");\n-            System.exit(7);\n-        }\n-\n-        \/\/ Run two theads that should come to deadlock\n-        new ThreadOne().start();\n-        new ThreadTwo().start();\n-\n-        if (reachCount > 0) {\n-            \/\/ Not able to deadlock, exiting\n-            System.exit(3);\n-        }\n-\n-        LingeredApp.main(args);\n-    }\n- }\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredAppWithDeadlock.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.compiler;\n-\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.StandardLocation;\n-import javax.tools.ToolProvider;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * This class consists exclusively of static utility methods for invoking the\n- * java compiler.\n- *\/\n-public final class CompilerUtils {\n-    private CompilerUtils() { }\n-\n-    \/**\n-     * Compile all the java sources in {@code <source>\/**} to\n-     * {@code <destination>\/**}. The destination directory will be created if\n-     * it doesn't exist.\n-     *\n-     * Equivalent to calling {@code compile(source, destination, true, options);}.\n-     *\n-     * All warnings\/errors emitted by the compiler are output to System.out\/err.\n-     *\n-     * @param source Path to the source directory\n-     * @param destination Path to the destination directory\n-     * @param options Any options to pass to the compiler\n-     *\n-     * @return true if the compilation is successful\n-     *\n-     * @throws IOException\n-     *         if there is an I\/O error scanning the source tree or\n-     *         creating the destination directory\n-     * @throws UnsupportedOperationException\n-     *         if there is no system java compiler\n-     *\/\n-    public static boolean compile(Path source, Path destination, String... options)\n-        throws IOException\n-    {\n-        return compile(source, destination, true, options);\n-    }\n-\n-    \/**\n-     * Compile all the java sources in {@code <source>} and optionally its\n-     * subdirectories, to\n-     * {@code <destination>}. The destination directory will be created if\n-     * it doesn't exist.\n-     *\n-     * All warnings\/errors emitted by the compiler are output to System.out\/err.\n-     *\n-     * @param source Path to the source directory\n-     * @param destination Path to the destination directory\n-     * @param recurse If {@code true} recurse into any {@code source} subdirectories\n-     *        to compile all java source files; else only compile those directly in\n-     *        {@code source}.\n-     * @param options Any options to pass to the compiler\n-     *\n-     * @return true if the compilation is successful\n-     *\n-     * @throws IOException\n-     *         if there is an I\/O error scanning the source tree or\n-     *         creating the destination directory\n-     * @throws UnsupportedOperationException\n-     *         if there is no system java compiler\n-     *\/\n-\n-   public static boolean compile(Path source, Path destination, boolean recurse, String... options)\n-        throws IOException\n-    {\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        if (compiler == null) {\n-            \/\/ no compiler available\n-            throw new UnsupportedOperationException(\"Unable to get system java compiler. \"\n-                    + \"Perhaps, jdk.compiler module is not available.\");\n-        }\n-        StandardJavaFileManager jfm = compiler.getStandardFileManager(null, null, null);\n-\n-        List<Path> sources\n-            = Files.find(source, (recurse ? Integer.MAX_VALUE : 1),\n-                (file, attrs) -> (file.toString().endsWith(\".java\")))\n-                .collect(Collectors.toList());\n-\n-        Files.createDirectories(destination);\n-        jfm.setLocation(StandardLocation.CLASS_PATH, Collections.emptyList());\n-        jfm.setLocationFromPaths(StandardLocation.CLASS_OUTPUT,\n-                Collections.singletonList(destination));\n-\n-        List<String> opts = Arrays.asList(options);\n-        JavaCompiler.CompilationTask task\n-            = compiler.getTask(null, jfm, null, opts, null,\n-                jfm.getJavaFileObjectsFromPaths(sources));\n-\n-        return task.call();\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/CompilerUtils.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,200 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.compiler;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.FileObject;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaCompiler.CompilationTask;\n-import javax.tools.JavaFileObject;\n-import javax.tools.JavaFileObject.Kind;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.StandardLocation;\n-import javax.tools.ToolProvider;\n-\n-\/**\n- * {@code InMemoryJavaCompiler} can be used for compiling a {@link\n- * CharSequence} to a {@code byte[]}.\n- *\n- * The compiler will not use the file system at all, instead using a {@link\n- * ByteArrayOutputStream} for storing the byte code. For the source code, any\n- * kind of {@link CharSequence} can be used, e.g. {@link String}, {@link\n- * StringBuffer} or {@link StringBuilder}.\n- *\n- * The {@code InMemoryCompiler} can easily be used together with a {@code\n- * ByteClassLoader} to easily compile and load source code in a {@link String}:\n- *\n- * <pre>\n- * {@code\n- * import jdk.test.lib.compiler.InMemoryJavaCompiler;\n- * import jdk.test.lib.ByteClassLoader;\n- *\n- * class Example {\n- *     public static void main(String[] args) {\n- *         String className = \"Foo\";\n- *         String sourceCode = \"public class \" + className + \" {\" +\n- *                             \"    public void bar() {\" +\n- *                             \"        System.out.println(\"Hello from bar!\");\" +\n- *                             \"    }\" +\n- *                             \"}\";\n- *         byte[] byteCode = InMemoryJavaCompiler.compile(className, sourceCode);\n- *         Class fooClass = ByteClassLoader.load(className, byteCode);\n- *     }\n- * }\n- * }\n- * <\/pre>\n- *\/\n-public class InMemoryJavaCompiler {\n-    private static class MemoryJavaFileObject extends SimpleJavaFileObject {\n-        private final String className;\n-        private final CharSequence sourceCode;\n-        private final ByteArrayOutputStream byteCode;\n-\n-        public MemoryJavaFileObject(String className, CharSequence sourceCode) {\n-            super(URI.create(\"string:\/\/\/\" + className.replace('.','\/') + Kind.SOURCE.extension), Kind.SOURCE);\n-            this.className = className;\n-            this.sourceCode = sourceCode;\n-            this.byteCode = new ByteArrayOutputStream();\n-        }\n-\n-        @Override\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-            return sourceCode;\n-        }\n-\n-        @Override\n-        public OutputStream openOutputStream() throws IOException {\n-            return byteCode;\n-        }\n-\n-        public byte[] getByteCode() {\n-            return byteCode.toByteArray();\n-        }\n-\n-        public String getClassName() {\n-            return className;\n-        }\n-    }\n-\n-    private static class FileManagerWrapper extends ForwardingJavaFileManager {\n-        private static final Location PATCH_LOCATION = new Location() {\n-            @Override\n-            public String getName() {\n-                return \"patch module location\";\n-            }\n-\n-            @Override\n-            public boolean isOutputLocation() {\n-                return false;\n-            }\n-        };\n-        private final MemoryJavaFileObject file;\n-        private final String moduleOverride;\n-\n-        public FileManagerWrapper(MemoryJavaFileObject file, String moduleOverride) {\n-            super(getCompiler().getStandardFileManager(null, null, null));\n-            this.file = file;\n-            this.moduleOverride = moduleOverride;\n-        }\n-\n-        @Override\n-        public JavaFileObject getJavaFileForOutput(Location location, String className,\n-                                                   Kind kind, FileObject sibling)\n-            throws IOException {\n-            if (!file.getClassName().equals(className)) {\n-                throw new IOException(\"Expected class with name \" + file.getClassName() +\n-                                      \", but got \" + className);\n-            }\n-            return file;\n-        }\n-\n-        @Override\n-        public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {\n-            if (fo == file && moduleOverride != null) {\n-                return PATCH_LOCATION;\n-            }\n-            return super.getLocationForModule(location, fo);\n-        }\n-\n-        @Override\n-        public String inferModuleName(Location location) throws IOException {\n-            if (location == PATCH_LOCATION) {\n-                return moduleOverride;\n-            }\n-            return super.inferModuleName(location);\n-        }\n-\n-        @Override\n-        public boolean hasLocation(Location location) {\n-            return super.hasLocation(location) || location == StandardLocation.PATCH_MODULE_PATH;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Compiles the class with the given name and source code.\n-     *\n-     * @param className The name of the class\n-     * @param sourceCode The source code for the class with name {@code className}\n-     * @param options additional command line options\n-     * @throws RuntimeException if the compilation did not succeed\n-     * @return The resulting byte code from the compilation\n-     *\/\n-    public static byte[] compile(String className, CharSequence sourceCode, String... options) {\n-        MemoryJavaFileObject file = new MemoryJavaFileObject(className, sourceCode);\n-        CompilationTask task = getCompilationTask(file, options);\n-\n-        if(!task.call()) {\n-            throw new RuntimeException(\"Could not compile \" + className + \" with source code \" + sourceCode);\n-        }\n-\n-        return file.getByteCode();\n-    }\n-\n-    private static JavaCompiler getCompiler() {\n-        return ToolProvider.getSystemJavaCompiler();\n-    }\n-\n-    private static CompilationTask getCompilationTask(MemoryJavaFileObject file, String... options) {\n-        List<String> opts = new ArrayList<>();\n-        String moduleOverride = null;\n-        for (String opt : options) {\n-            if (opt.startsWith(\"--patch-module=\")) {\n-                moduleOverride = opt.substring(\"--patch-module=\".length());\n-            } else {\n-                opts.add(opt);\n-            }\n-        }\n-        return getCompiler().getTask(null, new FileManagerWrapper(file, moduleOverride), null, opts, null, Arrays.asList(file));\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java","additions":0,"deletions":200,"binary":false,"changes":200,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.compiler;\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-\n-\/**\n- * Utility class for creating test modules.\n- *\/\n-public class ModuleInfoMaker {\n-    private static final String MODULE_INFO_JAVA = \"module-info.java\";\n-    private static final Pattern MODULE_PATTERN =\n-        Pattern.compile(\"module\\\\s+((?:\\\\w+\\\\.)*)\");\n-    private static final Pattern PACKAGE_PATTERN =\n-                       Pattern.compile(\"package\\\\s+(((?:\\\\w+\\\\.)*)(?:\\\\w+))\");\n-    private static final Pattern CLASS_PATTERN =\n-          Pattern.compile(\"(?:public\\\\s+)?(?:class|enum|interface)\\\\s+(\\\\w+)\");\n-\n-    private final Path dir;\n-\n-    public ModuleInfoMaker(Path dir) {\n-        this.dir = dir;\n-    }\n-\n-    \/**\n-     * Create java source files of the given module\n-     *\/\n-    public void writeJavaFiles(String module, String moduleInfoJava, String... contents)\n-        throws IOException\n-    {\n-        Path msrc = dir.resolve(module);\n-        new JavaSource(moduleInfoJava).write(msrc);\n-        for (String c : contents) {\n-            new JavaSource(c).write(msrc);\n-        }\n-    }\n-\n-    \/**\n-     * Compile the module to the given destination.\n-     *\/\n-    public void compile(String module, Path dest, String... options)\n-        throws IOException\n-    {\n-        Path msrc = dir.resolve(module);\n-        String[] args =\n-            Stream.concat(Arrays.stream(options),\n-                          Stream.of(\"--module-source-path\",\n-                                    dir.toString())).toArray(String[]::new);\n-        if (!CompilerUtils.compile(msrc, dest, args)) {\n-            throw new Error(\"Fail to compile \" + module);\n-        }\n-    }\n-\n-    static class JavaSource {\n-        final String source;\n-        JavaSource(String source) {\n-            this.source = source;\n-        }\n-\n-        \/**\n-         * Writes the source code to a file in a specified directory.\n-         * @param dir the directory\n-         * @throws IOException if there is a problem writing the file\n-         *\/\n-        public void write(Path dir) throws IOException {\n-            Path file = dir.resolve(getJavaFileNameFromSource(source));\n-            Files.createDirectories(file.getParent());\n-            try (BufferedWriter out = Files.newBufferedWriter(file)) {\n-                out.write(source.replace(\"\\n\", System.lineSeparator()));\n-            }\n-        }\n-\n-        \/**\n-         * Extracts the Java file name from the class declaration.\n-         * This method is intended for simple files and uses regular expressions,\n-         * so comments matching the pattern can make the method fail.\n-         *\/\n-        static String getJavaFileNameFromSource(String source) {\n-            String packageName = null;\n-\n-            Matcher matcher = MODULE_PATTERN.matcher(source);\n-            if (matcher.find())\n-                return MODULE_INFO_JAVA;\n-\n-            matcher = PACKAGE_PATTERN.matcher(source);\n-            if (matcher.find())\n-                packageName = matcher.group(1).replace(\".\", \"\/\");\n-\n-            matcher = CLASS_PATTERN.matcher(source);\n-            if (matcher.find()) {\n-                String className = matcher.group(1) + \".java\";\n-                return (packageName == null) ? className : packageName + \"\/\" + className;\n-            } else if (packageName != null) {\n-                return packageName + \"\/package-info.java\";\n-            } else {\n-                throw new Error(\"Could not extract the java class \" +\n-                    \"name from the provided source\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/ModuleInfoMaker.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.util;\n-\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.jar.JarOutputStream;\n-import java.util.jar.Manifest;\n-\n-\/**\n- * Common library for various test jar file utility functions.\n- *\/\n-public final class JarUtils {\n-\n-    \/**\n-     * Create jar file with specified files. If a specified file does not exist,\n-     * a new jar entry will be created with the file name itself as the content.\n-     *\/\n-    public static void createJar(String dest, String... files)\n-            throws IOException {\n-        try (JarOutputStream jos = new JarOutputStream(\n-                new FileOutputStream(dest), new Manifest())) {\n-            for (String file : files) {\n-                System.out.println(String.format(\"Adding %s to %s\",\n-                        file, dest));\n-\n-                \/\/ add an archive entry, and write a file\n-                jos.putNextEntry(new JarEntry(file));\n-                try (FileInputStream fis = new FileInputStream(file)) {\n-                    fis.transferTo(jos);\n-                } catch (FileNotFoundException e) {\n-                    jos.write(file.getBytes());\n-                }\n-            }\n-        }\n-        System.out.println();\n-    }\n-\n-    \/**\n-     * Add or remove specified files to existing jar file. If a specified file\n-     * to be updated or added does not exist, the jar entry will be created\n-     * with the file name itself as the content.\n-     *\n-     * @param src the original jar file name\n-     * @param dest the new jar file name\n-     * @param files the files to update. The list is broken into 2 groups\n-     *              by a \"-\" string. The files before in the 1st group will\n-     *              be either updated or added. The files in the 2nd group\n-     *              will be removed. If no \"-\" exists, all files belong to\n-     *              the 1st group.\n-     *\/\n-    public static void updateJar(String src, String dest, String... files)\n-            throws IOException {\n-        Map<String,Object> changes = new HashMap<>();\n-        boolean update = true;\n-        for (String file : files) {\n-            if (file.equals(\"-\")) {\n-                update = false;\n-            } else if (update) {\n-                try {\n-                    Path p = Paths.get(file);\n-                    if (Files.exists(p)) {\n-                        changes.put(file, p);\n-                    } else {\n-                        changes.put(file, file);\n-                    }\n-                } catch (InvalidPathException e) {\n-                    \/\/ Fallback if file not a valid Path.\n-                    changes.put(file, file);\n-                }\n-            } else {\n-                changes.put(file, Boolean.FALSE);\n-            }\n-        }\n-        updateJar(src, dest, changes);\n-    }\n-\n-    \/**\n-     * Update content of a jar file.\n-     *\n-     * @param src the original jar file name\n-     * @param dest the new jar file name\n-     * @param changes a map of changes, key is jar entry name, value is content.\n-     *                Value can be Path, byte[] or String. If key exists in\n-     *                src but value is Boolean FALSE. The entry is removed.\n-     *                Existing entries in src not a key is unmodified.\n-     * @throws IOException\n-     *\/\n-    public static void updateJar(String src, String dest,\n-                                 Map<String,Object> changes)\n-            throws IOException {\n-\n-        \/\/ What if input changes is immutable?\n-        changes = new HashMap<>(changes);\n-\n-        System.out.printf(\"Creating %s from %s...\\n\", dest, src);\n-        try (JarOutputStream jos = new JarOutputStream(\n-                new FileOutputStream(dest))) {\n-\n-            try (JarFile srcJarFile = new JarFile(src)) {\n-                Enumeration<JarEntry> entries = srcJarFile.entries();\n-                while (entries.hasMoreElements()) {\n-                    JarEntry entry = entries.nextElement();\n-                    String name = entry.getName();\n-                    if (changes.containsKey(name)) {\n-                        System.out.println(String.format(\"- Update %s\", name));\n-                        updateEntry(jos, name, changes.get(name));\n-                        changes.remove(name);\n-                    } else {\n-                        System.out.println(String.format(\"- Copy %s\", name));\n-                        jos.putNextEntry(entry);\n-                        srcJarFile.getInputStream(entry).transferTo(jos);\n-                    }\n-                }\n-            }\n-            for (Map.Entry<String, Object> e : changes.entrySet()) {\n-                System.out.println(String.format(\"- Add %s\", e.getKey()));\n-                updateEntry(jos, e.getKey(), e.getValue());\n-            }\n-        }\n-        System.out.println();\n-    }\n-\n-    private static void updateEntry(JarOutputStream jos, String name, Object content)\n-           throws IOException {\n-        if (content instanceof Boolean) {\n-            if (((Boolean) content).booleanValue()) {\n-                throw new RuntimeException(\"Boolean value must be FALSE\");\n-            }\n-        } else {\n-            jos.putNextEntry(new JarEntry(name));\n-            if (content instanceof Path) {\n-                Files.newInputStream((Path) content).transferTo(jos);\n-            } else if (content instanceof byte[]) {\n-                jos.write((byte[]) content);\n-            } else if (content instanceof String) {\n-                jos.write(((String) content).getBytes());\n-            } else {\n-                throw new RuntimeException(\"Unknown type \" + content.getClass());\n-            }\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/util\/JarUtils.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"}]}