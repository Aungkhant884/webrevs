{"files":[{"patch":"@@ -83,1 +83,0 @@\n-  \/\/ Handle all program errors.\n@@ -93,1 +92,0 @@\n-  \/\/ Handle all program errors.\n@@ -103,0 +101,1 @@\n+\n@@ -107,0 +106,5 @@\n+  \/\/ and all other synchronous signals too.\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  sigthreadmask(SIG_UNBLOCK, &newset, NULL);\n@@ -108,1 +112,2 @@\n-  Unimplemented();\n+  VMError err(NULL, sig, NULL, info, ucVoid);\n+  err.report_and_die();\n","filename":"hotspot\/src\/os\/aix\/vm\/vmError_aix.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,0 +66,6 @@\n+\/\/ handle all synchronous program error signals which may happen during error\n+\/\/ reporting. They must be unblocked, caught, handled.\n+\n+static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n+static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n+\n@@ -67,2 +73,2 @@\n-static int resettedSigflags[2];\n-static address resettedSighandler[2];\n+static int resettedSigflags[NUM_SIGNALS];\n+static address resettedSighandler[NUM_SIGNALS];\n@@ -81,4 +87,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSigflags[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSigflags[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSigflags[i];\n+    }\n@@ -90,4 +96,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSighandler[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSighandler[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSighandler[i];\n+    }\n@@ -103,1 +109,5 @@\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n+  \/\/ also unmask other synchronous signals\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  pthread_sigmask(SIG_UNBLOCK, &newset, NULL);\n@@ -110,5 +120,10 @@\n-  \/\/ Save sigflags for resetted signals\n-  save_signal(0, SIGSEGV);\n-  save_signal(1, SIGBUS);\n-  os::signal(SIGSEGV, CAST_FROM_FN_PTR(void *, crash_handler));\n-  os::signal(SIGBUS, CAST_FROM_FN_PTR(void *, crash_handler));\n+  \/\/ install signal handlers for all synchronous program error signals\n+  sigset_t newset;\n+  sigemptyset(&newset);\n+\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    save_signal(i, SIGNALS[i]);\n+    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  pthread_sigmask(SIG_UNBLOCK, &newset, NULL);\n","filename":"hotspot\/src\/os\/bsd\/vm\/vmError_bsd.cpp","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -66,0 +66,6 @@\n+\/\/ handle all synchronous program error signals which may happen during error\n+\/\/ reporting. They must be unblocked, caught, handled.\n+\n+static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n+static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n+\n@@ -67,2 +73,2 @@\n-static int resettedSigflags[2];\n-static address resettedSighandler[2];\n+static int resettedSigflags[NUM_SIGNALS];\n+static address resettedSighandler[NUM_SIGNALS];\n@@ -81,4 +87,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSigflags[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSigflags[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSigflags[i];\n+    }\n@@ -90,4 +96,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSighandler[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSighandler[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSighandler[i];\n+    }\n@@ -103,1 +109,5 @@\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n+  \/\/ also unmask other synchronous signals\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  pthread_sigmask(SIG_UNBLOCK, &newset, NULL);\n@@ -110,5 +120,11 @@\n-  \/\/ Save sigflags for resetted signals\n-  save_signal(0, SIGSEGV);\n-  save_signal(1, SIGBUS);\n-  os::signal(SIGSEGV, CAST_FROM_FN_PTR(void *, crash_handler));\n-  os::signal(SIGBUS, CAST_FROM_FN_PTR(void *, crash_handler));\n+  \/\/ install signal handlers for all synchronous program error signals\n+  sigset_t newset;\n+  sigemptyset(&newset);\n+\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    save_signal(i, SIGNALS[i]);\n+    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  pthread_sigmask(SIG_UNBLOCK, &newset, NULL);\n+\n","filename":"hotspot\/src\/os\/linux\/vm\/vmError_linux.cpp","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include <thread.h>\n@@ -62,0 +63,6 @@\n+\/\/ handle all synchronous program error signals which may happen during error\n+\/\/ reporting. They must be unblocked, caught, handled.\n+\n+static const int SIGNALS[] = { SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP }; \/\/ add more if needed\n+static const int NUM_SIGNALS = sizeof(SIGNALS) \/ sizeof(int);\n+\n@@ -63,2 +70,2 @@\n-static int resettedSigflags[2];\n-static address resettedSighandler[2];\n+static int resettedSigflags[NUM_SIGNALS];\n+static address resettedSighandler[NUM_SIGNALS];\n@@ -77,4 +84,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSigflags[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSigflags[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSigflags[i];\n+    }\n@@ -86,4 +93,4 @@\n-  if(SIGSEGV == sig) {\n-    return resettedSighandler[0];\n-  } else if(SIGBUS == sig) {\n-    return resettedSighandler[1];\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    if (SIGNALS[i] == sig) {\n+      return resettedSighandler[i];\n+    }\n@@ -99,1 +106,5 @@\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n+  \/\/ also unmask other synchronous signals\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  thr_sigsetmask(SIG_UNBLOCK, &newset, NULL);\n@@ -106,5 +117,10 @@\n-  \/\/ Save sigflags for resetted signals\n-  save_signal(0, SIGSEGV);\n-  save_signal(1, SIGBUS);\n-  os::signal(SIGSEGV, CAST_FROM_FN_PTR(void *, crash_handler));\n-  os::signal(SIGBUS, CAST_FROM_FN_PTR(void *, crash_handler));\n+  \/\/ install signal handlers for all synchronous program error signals\n+  sigset_t newset;\n+  sigemptyset(&newset);\n+\n+  for (int i = 0; i < NUM_SIGNALS; i++) {\n+    save_signal(i, SIGNALS[i]);\n+    os::signal(SIGNALS[i], CAST_FROM_FN_PTR(void *, crash_handler));\n+    sigaddset(&newset, SIGNALS[i]);\n+  }\n+  thr_sigsetmask(SIG_UNBLOCK, &newset, NULL);\n","filename":"hotspot\/src\/os\/solaris\/vm\/vmError_solaris.cpp","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -906,0 +906,4 @@\n+  notproduct(uintx, TestCrashInErrorHandler, 0,                             \\\n+          \"If > 0, provokes an error inside VM error handler (a secondary \" \\\n+          \"crash). see test_error_handler() in debug.cpp.\")                 \\\n+                                                                            \\\n","filename":"hotspot\/src\/share\/vm\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -340,0 +340,32 @@\n+typedef void (*voidfun_t)();\n+\/\/ Crash with an authentic sigfpe\n+static void crash_with_sigfpe() {\n+  \/\/ generate a native synchronous SIGFPE where possible;\n+  \/\/ if that did not cause a signal (e.g. on ppc), just\n+  \/\/ raise the signal.\n+  volatile int x = 0;\n+  volatile int y = 1\/x;\n+#ifndef _WIN32\n+  raise(SIGFPE);\n+#endif\n+} \/\/ end: crash_with_sigfpe\n+\n+\/\/ crash with sigsegv at non-null address.\n+static void crash_with_segfault() {\n+\n+  char* const crash_addr = (char*) get_segfault_address();\n+  *crash_addr = 'X';\n+\n+} \/\/ end: crash_with_segfault\n+\n+\/\/ returns an address which is guaranteed to generate a SIGSEGV on read,\n+\/\/ for test purposes, which is not NULL and contains bits in every word\n+void* get_segfault_address() {\n+  return (void*)\n+#ifdef _LP64\n+    0xABC0000000000ABCULL;\n+#else\n+    0x00000ABC;\n+#endif\n+}\n+\n@@ -341,2 +373,5 @@\n-  uintx test_num = ErrorHandlerTest;\n-  if (test_num == 0) return;\n+  controlled_crash(ErrorHandlerTest);\n+}\n+\n+void controlled_crash(int how) {\n+  if (how == 0) return;\n@@ -345,2 +380,1 @@\n-  size_t n = test_num;\n-  NOT_DEBUG(if (n <= 2) n += 2);\n+  NOT_DEBUG(if (how <= 2) how += 2);\n@@ -357,1 +391,1 @@\n-  switch (n) {\n+  switch (how) {\n@@ -382,0 +416,2 @@\n+    case 14: crash_with_segfault(); break;\n+    case 15: crash_with_sigfpe(); break;\n@@ -383,1 +419,1 @@\n-    default: tty->print_cr(\"ERROR: %d: unexpected test_num value.\", n);\n+    default: tty->print_cr(\"ERROR: %d: unexpected test_num value.\", how);\n","filename":"hotspot\/src\/share\/vm\/utilities\/debug.cpp","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -269,0 +269,18 @@\n+\/\/ crash in a controlled way:\n+\/\/ how can be one of:\n+\/\/ 1,2 - asserts\n+\/\/ 3,4 - guarantee\n+\/\/ 5-7 - fatal\n+\/\/ 8 - vm_exit_out_of_memory\n+\/\/ 9 - ShouldNotCallThis\n+\/\/ 10 - ShouldNotReachHere\n+\/\/ 11 - Unimplemented\n+\/\/ 12,13 - (not guaranteed) crashes\n+\/\/ 14 - SIGSEGV\n+\/\/ 15 - SIGFPE\n+NOT_PRODUCT(void controlled_crash(int how);)\n+\n+\/\/ returns an address which is guaranteed to generate a SIGSEGV on read,\n+\/\/ for test purposes, which is not NULL and contains bits in every word\n+NOT_PRODUCT(void* get_segfault_address();)\n+\n","filename":"hotspot\/src\/share\/vm\/utilities\/debug.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -400,0 +400,20 @@\n+#ifndef PRODUCT\n+  \/\/ Error handler self tests\n+\n+  \/\/ test secondary error handling. Test it twice, to test that resetting\n+  \/\/ error handler after a secondary crash works.\n+  STEP(13, \"(test secondary crash 1)\")\n+    if (_verbose && TestCrashInErrorHandler != 0) {\n+      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%d)...\",\n+        TestCrashInErrorHandler);\n+      controlled_crash(TestCrashInErrorHandler);\n+    }\n+\n+  STEP(14, \"(test secondary crash 2)\")\n+    if (_verbose && TestCrashInErrorHandler != 0) {\n+      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%d)...\",\n+        TestCrashInErrorHandler);\n+      controlled_crash(TestCrashInErrorHandler);\n+    }\n+#endif \/\/ PRODUCT\n+\n@@ -832,0 +852,9 @@\n+#ifndef PRODUCT\n+  \/\/ print a defined marker to show that error handling finished correctly.\n+  STEP(290, \"(printing end marker)\" )\n+\n+     if (_verbose) {\n+       st->print_cr(\"END.\");\n+     }\n+#endif\n+\n","filename":"hotspot\/src\/share\/vm\/utilities\/vmError.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}