{"files":[{"patch":"@@ -897,2 +897,26 @@\n-          \/\/ Push appendix argument, if one.\n-          if (s.has_appendix()) {\n+          \/\/ If the current bytecode has an attached appendix argument,\n+          \/\/ push an unknown object to represent that argument. (Analysis\n+          \/\/ of dynamic call sites, especially invokehandle calls, needs\n+          \/\/ the appendix argument on the stack, in addition to \"regular\" arguments\n+          \/\/ pushed onto the stack by bytecode instructions preceding the call.)\n+          \/\/\n+          \/\/ The escape analyzer does _not_ use the ciBytecodeStream::has_appendix(s)\n+          \/\/ method to determine whether the current bytecode has an appendix argument.\n+          \/\/ The has_appendix() method obtains the appendix from the\n+          \/\/ ConstantPoolCacheEntry::_f1 field, which can happen concurrently with\n+          \/\/ resolution of dynamic call sites. Callees in the\n+          \/\/ ciBytecodeStream::get_method() call above also access the _f1 field;\n+          \/\/ interleaving the get_method() and has_appendix() calls in the current\n+          \/\/ method with call site resolution can lead to an inconsistent view of\n+          \/\/ the current method's argument count. In particular, some interleaving(s)\n+          \/\/ can cause the method's argument count to not include the appendix, which\n+          \/\/ then leads to stack over-\/underflow in the escape analyzer.\n+          \/\/\n+          \/\/ Instead of pushing the argument if has_appendix() is true, the escape analyzer\n+          \/\/ pushes an appendix for all call sites targeted by invokedynamic and invokehandle\n+          \/\/ instructions, except if the call site is the _invokeBasic intrinsic\n+          \/\/ (that intrinsic is always targeted by an invokehandle instruction but does\n+          \/\/ not have an appendix argument).\n+          if (target->is_loaded() &&\n+              Bytecodes::has_optional_appendix(s.cur_bc_raw()) &&\n+              target->intrinsic_id() != vmIntrinsics::_invokeBasic) {\n","filename":"hotspot\/src\/share\/vm\/ci\/bcEscapeAnalyzer.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -136,3 +136,8 @@\n-  \/\/ Report the number of elements on stack when invoking this method.\n-  \/\/ This is different than the regular arg_size because invokedynamic\n-  \/\/ has an implicit receiver.\n+  \/\/ Report the number of elements on stack when invoking the current method.\n+  \/\/ If the method is loaded, arg_size() gives precise information about the\n+  \/\/ number of stack elements (using the method's signature and its flags).\n+  \/\/ However, if the method is not loaded, the number of stack elements must\n+  \/\/ be determined differently, as the method's flags are not yet available.\n+  \/\/ The invoke_arg_size() method assumes in that case that all bytecodes except\n+  \/\/ invokestatic and invokedynamic have a receiver that is also pushed onto the\n+  \/\/ stack by the caller of the current method.\n@@ -144,1 +149,0 @@\n-      \/\/ Add a receiver argument, maybe:\n","filename":"hotspot\/src\/share\/vm\/ci\/ciMethod.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}