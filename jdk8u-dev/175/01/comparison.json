{"files":[{"patch":"@@ -37,1 +37,1 @@\n-        run: echo \"::set-output name=should_run::${{ github.event.inputs.platforms != '' || (!secrets.JDK_SUBMIT_FILTER || startsWith(github.ref, 'refs\/heads\/submit\/')) }}\"\n+        run: echo \"should_run=${{ github.event.inputs.platforms != '' || (!secrets.JDK_SUBMIT_FILTER || startsWith(github.ref, 'refs\/heads\/submit\/')) }}\" >> $GITHUB_OUTPUT\n@@ -42,6 +42,6 @@\n-          echo \"::set-output name=platform_linux_additional::${{ contains(github.event.inputs.platforms, 'linux additional (hotspot only)') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux additional (hotspot only)'))) }}\"\n-          echo \"::set-output name=platform_linux_x64::${{ contains(github.event.inputs.platforms, 'linux x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x64'))) }}\"\n-          echo \"::set-output name=platform_linux_x86::${{ contains(github.event.inputs.platforms, 'linux x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x86'))) }}\"\n-          echo \"::set-output name=platform_windows_x64::${{ contains(github.event.inputs.platforms, 'windows x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows x64'))) }}\"\n-          echo \"::set-output name=platform_windows_x86::${{ contains(github.event.inputs.platforms, 'windows x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows x86'))) }}\"\n-          echo \"::set-output name=platform_macos_x64::${{ contains(github.event.inputs.platforms, 'macos x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos x64'))) }}\"\n+          echo \"platform_linux_additional=${{ contains(github.event.inputs.platforms, 'linux additional (hotspot only)') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux additional (hotspot only)'))) }}\" >> $GITHUB_OUTPUT\n+          echo \"platform_linux_x64=${{ contains(github.event.inputs.platforms, 'linux x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x64'))) }}\" >> $GITHUB_OUTPUT\n+          echo \"platform_linux_x86=${{ contains(github.event.inputs.platforms, 'linux x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x86'))) }}\" >> $GITHUB_OUTPUT\n+          echo \"platform_windows_x64=${{ contains(github.event.inputs.platforms, 'windows x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows x64'))) }}\" >> $GITHUB_OUTPUT\n+          echo \"platform_windows_x86=${{ contains(github.event.inputs.platforms, 'windows x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows x86'))) }}\" >> $GITHUB_OUTPUT\n+          echo \"platform_macos_x64=${{ contains(github.event.inputs.platforms, 'macos x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos x64'))) }}\" >> $GITHUB_OUTPUT\n@@ -52,1 +52,1 @@\n-        run: echo \"::set-output name=bundle_id::${GITHUB_ACTOR}_${GITHUB_SHA:0:8}\"\n+        run: echo \"bundle_id=${GITHUB_ACTOR}_${GITHUB_SHA:0:8}\" >> $GITHUB_OUTPUT\n@@ -56,1 +56,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -63,1 +63,1 @@\n-        run: \"echo ::set-output name=dependencies::`cat common\/autoconf\/version-numbers make\/conf\/test-dependencies | sed -e '1i {' -e 's\/#.*\/\/g' -e 's\/\\\"\/\/g' -e 's\/\\\\(.*\\\\)=\\\\(.*\\\\)\/\\\"\\\\1\\\": \\\"\\\\2\\\",\/g' -e '$s\/,\\\\s\\\\{0,\\\\}$\/\\\\}\/'`\"\n+        run: \"echo dependencies=`cat common\/autoconf\/version-numbers make\/conf\/test-dependencies | sed -e '1i {' -e 's\/#.*\/\/g' -e 's\/\\\"\/\/g' -e 's\/\\\\(.*\\\\)=\\\\(.*\\\\)\/\\\"\\\\1\\\": \\\"\\\\2\\\",\/g' -e '$s\/,\\\\s\\\\{0,\\\\}$\/\\\\}\/'` >> $GITHUB_OUTPUT\"\n@@ -85,1 +85,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -92,1 +92,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -110,1 +110,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -138,1 +138,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -144,1 +144,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -151,1 +151,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -186,1 +186,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -204,2 +204,2 @@\n-#          - langtools\/tier1\n-#          - hotspot\/tier1\n+          - langtools\/tier1\n+          - hotspot\/tier1\n@@ -209,4 +209,4 @@\n-#          - test: langtools\/tier1\n-#            suites: langtools_tier1\n-#          - test: hotspot\/tier1\n-#            suites: hotspot_tier1\n+          - test: langtools\/tier1\n+            suites: langtools_tier1\n+          - test: hotspot\/tier1\n+            suites: hotspot_tier1\n@@ -220,1 +220,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -224,1 +224,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -231,1 +231,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -239,1 +239,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -246,1 +246,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -300,1 +300,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -358,1 +358,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -364,1 +364,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -371,1 +371,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -402,1 +402,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -486,1 +486,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -492,1 +492,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -499,1 +499,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -542,1 +542,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -560,1 +560,1 @@\n-#          - langtools\/tier1\n+          - langtools\/tier1\n@@ -565,2 +565,2 @@\n-#          - test: langtools\/tier1\n-#            suites: langtools_tier1\n+          - test: langtools\/tier1\n+            suites: langtools_tier1\n@@ -577,1 +577,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -581,1 +581,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -588,1 +588,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -596,1 +596,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -603,1 +603,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -657,1 +657,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -690,0 +690,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -692,1 +705,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -699,2 +712,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -704,1 +715,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -709,1 +720,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -717,1 +728,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -734,1 +745,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -741,1 +752,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -748,1 +759,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -823,1 +834,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -858,0 +869,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -860,1 +884,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -867,2 +891,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -872,1 +894,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -877,1 +899,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -885,1 +907,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -902,1 +924,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -923,1 +945,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -930,1 +952,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -983,1 +1005,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -1001,2 +1023,2 @@\n-#          - langtools\/tier1\n-#          - hotspot\/tier1\n+          - langtools\/tier1\n+          - hotspot\/tier1\n@@ -1006,4 +1028,4 @@\n-#          - test: langtools\/tier1\n-#            suites: langtools_tier1\n-#          - test: hotspot\/tier1\n-#            suites: hotspot_tier1\n+          - test: langtools\/tier1\n+            suites: langtools_tier1\n+          - test: hotspot\/tier1\n+            suites: hotspot_tier1\n@@ -1020,1 +1042,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -1024,1 +1046,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1039,0 +1061,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -1041,1 +1076,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1048,2 +1083,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -1054,1 +1087,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1061,1 +1094,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1069,1 +1102,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1076,1 +1109,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1129,1 +1162,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -1146,1 +1179,1 @@\n-#          - langtools\/tier1\n+          - langtools\/tier1\n@@ -1151,2 +1184,2 @@\n-#          - test: langtools\/tier1\n-#            suites: langtools_tier1\n+          - test: langtools\/tier1\n+            suites: langtools_tier1\n@@ -1165,1 +1198,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -1169,1 +1202,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1184,0 +1217,13 @@\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n@@ -1186,1 +1232,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1193,2 +1239,0 @@\n-          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n-          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n@@ -1199,1 +1243,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1206,1 +1250,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1214,1 +1258,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1221,1 +1265,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1274,1 +1318,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -1306,1 +1350,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -1312,1 +1356,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1328,1 +1372,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1335,1 +1379,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1371,1 +1415,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -1389,2 +1433,2 @@\n-#          - langtools\/tier1\n-#          - hotspot\/tier1\n+          - langtools\/tier1\n+          - hotspot\/tier1\n@@ -1394,4 +1438,4 @@\n-#          - test: langtools\/tier1\n-#            suites: langtools_tier1\n-#          - test: hotspot\/tier1\n-#            suites: hotspot_tier1\n+          - test: langtools\/tier1\n+            suites: langtools_tier1\n+          - test: hotspot\/tier1\n+            suites: hotspot_tier1\n@@ -1408,1 +1452,1 @@\n-        uses: actions\/checkout@v2\n+        uses: actions\/checkout@v3\n@@ -1412,1 +1456,1 @@\n-        uses: actions\/cache@v2\n+        uses: actions\/cache@v3\n@@ -1428,1 +1472,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1435,1 +1479,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1443,1 +1487,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1450,1 +1494,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1504,1 +1548,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n@@ -1525,1 +1569,1 @@\n-        uses: actions\/github-script@v3\n+        uses: actions\/github-script@v6\n@@ -1548,1 +1592,1 @@\n-        uses: actions\/download-artifact@v2\n+        uses: actions\/download-artifact@v3\n@@ -1565,1 +1609,1 @@\n-        uses: actions\/upload-artifact@v2\n+        uses: actions\/upload-artifact@v3\n","filename":".github\/workflows\/submit.yml","additions":160,"deletions":116,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=openjdk8u362\n+version=openjdk8u372\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,0 +501,2 @@\n+      # Corresponds to --with-vcruntime-1-dll\n+      BASIC_EVAL_DEVKIT_VARIABLE([DEVKIT_VCRUNTIME_1_DLL])\n","filename":"common\/autoconf\/basics.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -644,0 +644,1 @@\n+VCRUNTIME_1_DLL\n@@ -1117,0 +1118,1 @@\n+with_vcruntime_1_dll\n@@ -2007,0 +2009,2 @@\n+  --with-vcruntime-1-dll  path to microsoft C++ runtime dll (vcruntime*_1.dll)\n+                          (Windows only) [probed]\n@@ -4366,1 +4370,1 @@\n-VS_VERSION_INTERNAL_2019=141\n+VS_VERSION_INTERNAL_2019=142\n@@ -4368,0 +4372,1 @@\n+VS_VCRUNTIME_1_2019=vcruntime140_1.dll\n@@ -4420,1 +4425,1 @@\n-DATE_WHEN_GENERATED=1652838310\n+DATE_WHEN_GENERATED=1669893448\n@@ -14987,0 +14992,6 @@\n+      # Corresponds to --with-vcruntime-1-dll\n+\n+  if test \"x$DEVKIT_VCRUNTIME_1_DLL\" = x; then\n+    eval DEVKIT_VCRUNTIME_1_DLL=\"\\${DEVKIT_VCRUNTIME_1_DLL_${OPENJDK_TARGET_CPU}}\"\n+  fi\n+\n@@ -25802,0 +25813,1 @@\n+    eval VCRUNTIME_1_NAME=\"\\${VS_VCRUNTIME_1_${VS_VERSION}}\"\n@@ -26537,0 +26549,1 @@\n+      eval VCRUNTIME_1_NAME=\"\\${VS_VCRUNTIME_1_${VS_VERSION}}\"\n@@ -49979,2 +49992,1043 @@\n-    if test \"x$MSVC_DLL\" = x; then\n-      as_fn_error $? \"Could not find a proper $MSVCR_NAME as specified by devkit\" \"$LINENO\" 5\n+    if test \"x$MSVC_DLL\" = x; then\n+      as_fn_error $? \"Could not find a proper $MSVCR_NAME as specified by devkit\" \"$LINENO\" 5\n+    fi\n+    MSVCR_DLL=\"$MSVC_DLL\"\n+  else\n+\n+  DLL_NAME=\"${MSVCR_NAME}\"\n+  MSVC_DLL=\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    if test \"x$VCINSTALLDIR\" != x; then\n+      CYGWIN_VC_INSTALL_DIR=\"$VCINSTALLDIR\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$CYGWIN_VC_INSTALL_DIR\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of CYGWIN_VC_INSTALL_DIR, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of CYGWIN_VC_INSTALL_DIR, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of CYGWIN_VC_INSTALL_DIR\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    CYGWIN_VC_INSTALL_DIR=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting CYGWIN_VC_INSTALL_DIR to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting CYGWIN_VC_INSTALL_DIR to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$CYGWIN_VC_INSTALL_DIR\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    CYGWIN_VC_INSTALL_DIR=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting CYGWIN_VC_INSTALL_DIR to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting CYGWIN_VC_INSTALL_DIR to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$CYGWIN_VC_INSTALL_DIR\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of CYGWIN_VC_INSTALL_DIR, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of CYGWIN_VC_INSTALL_DIR, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of CYGWIN_VC_INSTALL_DIR, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    CYGWIN_VC_INSTALL_DIR=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      if test \"$VS_VERSION\" -lt 2017; then\n+        # Probe: Using well-known location from Visual Studio 12.0 and older\n+        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n+        else\n+          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n+        fi\n+      else\n+        # Probe: Using well-known location from VS 2017 and VS 2019\n+        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_INSTALL_DIR\/Redist\/MSVC\/*\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n+        else\n+          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_INSTALL_DIR\/Redist\/MSVC\/*\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n+        fi\n+      fi\n+      # In case any of the above finds more than one file, loop over them.\n+      for possible_msvc_dll in $POSSIBLE_MSVC_DLL; do\n+        $ECHO \"POSSIBLE_MSVC_DLL $possible_msvc_dll\"\n+\n+  DLL_NAME=\"$DLL_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$possible_msvc_dll\"\n+  METHOD=\"well-known location in VCINSTALLDIR\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+      done\n+    fi\n+  fi\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    # Probe: Check in the Boot JDK directory.\n+    POSSIBLE_MSVC_DLL=\"$BOOT_JDK\/bin\/$DLL_NAME\"\n+\n+  DLL_NAME=\"$DLL_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+  METHOD=\"well-known location in Boot JDK\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+  fi\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    # Probe: Look in the Windows system32 directory\n+    CYGWIN_SYSTEMROOT=\"$SYSTEMROOT\"\n+\n+  windows_path=\"$CYGWIN_SYSTEMROOT\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    CYGWIN_SYSTEMROOT=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    CYGWIN_SYSTEMROOT=\"$unix_path\"\n+  fi\n+\n+    POSSIBLE_MSVC_DLL=\"$CYGWIN_SYSTEMROOT\/system32\/$DLL_NAME\"\n+\n+  DLL_NAME=\"$DLL_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+  METHOD=\"well-known location in SYSTEMROOT\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+  fi\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    # Probe: If Visual Studio Express is installed, there is usually one with the debugger\n+    if test \"x$VS100COMNTOOLS\" != x; then\n+      CYGWIN_VS_TOOLS_DIR=\"$VS100COMNTOOLS\/..\"\n+\n+  windows_path=\"$CYGWIN_VS_TOOLS_DIR\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    CYGWIN_VS_TOOLS_DIR=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    CYGWIN_VS_TOOLS_DIR=\"$unix_path\"\n+  fi\n+\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n+            | $GREP -i \/x64\/ | $HEAD --lines 1`\n+      else\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n+            | $GREP -i \/x86\/ | $HEAD --lines 1`\n+      fi\n+\n+  DLL_NAME=\"$DLL_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+  METHOD=\"search of VS100COMNTOOLS\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+    fi\n+  fi\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    # Probe: Search wildly in the VCINSTALLDIR. We've probably lost by now.\n+    # (This was the original behaviour; kept since it might turn something up)\n+    if test \"x$CYGWIN_VC_INSTALL_DIR\" != x; then\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n+          | $GREP x64 | $HEAD --lines 1`\n+      else\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n+          | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $HEAD --lines 1`\n+        if test \"x$POSSIBLE_MSVC_DLL\" = x; then\n+          # We're grasping at straws now...\n+          POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n+              | $HEAD --lines 1`\n+        fi\n+      fi\n+\n+\n+  DLL_NAME=\"$DLL_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+  METHOD=\"search of VCINSTALLDIR\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n@@ -49982,0 +51036,10 @@\n+  fi\n+\n+  if test \"x$MSVC_DLL\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+    as_fn_error $? \"Could not find $DLL_NAME. Please specify using --with-msvcr-dll.\" \"$LINENO\" 5\n+  fi\n+\n@@ -49983,0 +51047,147 @@\n+  fi\n+\n+\n+\n+# Check whether --with-msvcp-dll was given.\n+if test \"${with_msvcp_dll+set}\" = set; then :\n+  withval=$with_msvcp_dll;\n+fi\n+\n+\n+  if test \"x$MSVCP_NAME\" != \"x\"; then\n+    if test \"x$with_msvcp_dll\" != x; then\n+      # If given explicitely by user, do not probe. If not present, fail directly.\n+\n+  DLL_NAME=\"$MSVCP_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$with_msvcp_dll\"\n+  METHOD=\"--with-msvcp-dll\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n@@ -49984,0 +51195,8 @@\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n@@ -49985,1 +51204,198 @@\n-  DLL_NAME=\"${MSVCR_NAME}\"\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+      if test \"x$MSVC_DLL\" = x; then\n+        as_fn_error $? \"Could not find a proper $MSVCP_NAME as specified by --with-msvcp-dll\" \"$LINENO\" 5\n+      fi\n+      MSVCP_DLL=\"$MSVC_DLL\"\n+    elif test \"x$DEVKIT_MSVCP_DLL\" != x; then\n+\n+  DLL_NAME=\"$MSVCP_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$DEVKIT_MSVCP_DLL\"\n+  METHOD=\"devkit\"\n+  if test -n \"$POSSIBLE_MSVC_DLL\" -a -e \"$POSSIBLE_MSVC_DLL\"; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&5\n+$as_echo \"$as_me: Found $DLL_NAME at $POSSIBLE_MSVC_DLL using $METHOD\" >&6;}\n+\n+    # Need to check if the found msvcr is correct architecture\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking found $DLL_NAME architecture\" >&5\n+$as_echo_n \"checking found $DLL_NAME architecture... \" >&6; }\n+    MSVC_DLL_FILETYPE=`$FILE -b \"$POSSIBLE_MSVC_DLL\"`\n+    if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+      # The MSYS 'file' command returns \"PE32 executable for MS Windows (DLL) (GUI) Intel 80386 32-bit\"\n+      # on x32 and \"PE32+ executable for MS Windows (DLL) (GUI) Mono\/.Net assembly\" on x64 systems.\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=\"PE32 executable\"\n+      else\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n+      fi\n+    else\n+      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        CORRECT_MSVCR_ARCH=386\n+      else\n+        CORRECT_MSVCR_ARCH=x86-64\n+      fi\n+    fi\n+    if $ECHO \"$MSVC_DLL_FILETYPE\" | $GREP \"$CORRECT_MSVCR_ARCH\" 2>&1 > \/dev\/null; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ok\" >&5\n+$as_echo \"ok\" >&6; }\n+      MSVC_DLL=\"$POSSIBLE_MSVC_DLL\"\n+\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+\n+  # Input might be given as Windows format, start by converting to\n+  # unix format.\n+  path=\"$MSVC_DLL\"\n+  new_path=`$CYGPATH -u \"$path\"`\n+\n+  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n+  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n+  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n+  # \"foo.exe\" is OK but \"foo\" is an error.\n+  #\n+  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n+  # It is also a way to make sure we got the proper file name for the real test later on.\n+  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n+  if test \"x$test_shortpath\" = x; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+    as_fn_error $? \"Cannot locate the the path of MSVC_DLL\" \"$LINENO\" 5\n+  fi\n+\n+  # Call helper function which possibly converts this using DOS-style short mode.\n+  # If so, the updated path is stored in $new_path.\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-._\/a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n+    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n+    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n+      # Going to short mode and back again did indeed matter. Since short mode is\n+      # case insensitive, let's make it lowercase to improve readability.\n+      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+      # Now convert it back to Unix-style (cygpath)\n+      input_path=`$CYGPATH -u \"$shortmode_path\"`\n+      new_path=\"$input_path\"\n+    fi\n+  fi\n+\n+  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n+  if test \"x$test_cygdrive_prefix\" = x; then\n+    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n+    if test \"x`$ECHO $new_path | $GREP ^\/usr\/bin\/`\" = x; then\n+      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n+      # a path prefixed by \/cygdrive for fixpath to work.\n+      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n+    fi\n+  fi\n+\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+\n+  path=\"$MSVC_DLL\"\n+  has_colon=`$ECHO $path | $GREP ^.:`\n+  new_path=\"$path\"\n+  if test \"x$has_colon\" = x; then\n+    # Not in mixed or Windows style, start by that.\n+    new_path=`cmd \/\/c echo $path`\n+  fi\n+\n+\n+  input_path=\"$new_path\"\n+  # Check if we need to convert this using DOS-style short mode. If the path\n+  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n+  # take no chances and rewrite it.\n+  # Note: m4 eats our [], so we need to use [ and ] instead.\n+  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP [^-_\/:a-zA-Z0-9]`\n+  if test \"x$has_forbidden_chars\" != x; then\n+    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n+    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+  fi\n+\n+\n+  windows_path=\"$new_path\"\n+  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n+    unix_path=`$CYGPATH -u \"$windows_path\"`\n+    new_path=\"$unix_path\"\n+  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n+    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n+    new_path=\"$unix_path\"\n+  fi\n+\n+  if test \"x$path\" != \"x$new_path\"; then\n+    MSVC_DLL=\"$new_path\"\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&5\n+$as_echo \"$as_me: Rewriting MSVC_DLL to \\\"$new_path\\\"\" >&6;}\n+  fi\n+\n+  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n+  all_fixpath_prefixes=(\"${all_fixpath_prefixes[@]}\" \"${new_path:0:10}\")\n+\n+  else\n+    # We're on a posix platform. Hooray! :)\n+    path=\"$MSVC_DLL\"\n+    has_space=`$ECHO \"$path\" | $GREP \" \"`\n+    if test \"x$has_space\" != x; then\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&5\n+$as_echo \"$as_me: The path of MSVC_DLL, which resolves as \\\"$path\\\", is invalid.\" >&6;}\n+      as_fn_error $? \"Spaces are not allowed in this path.\" \"$LINENO\" 5\n+    fi\n+\n+    # Use eval to expand a potential ~\n+    eval path=\"$path\"\n+    if test ! -f \"$path\" && test ! -d \"$path\"; then\n+      as_fn_error $? \"The path of MSVC_DLL, which resolves as \\\"$path\\\", is not found.\" \"$LINENO\" 5\n+    fi\n+\n+    MSVC_DLL=\"`cd \"$path\"; $THEPWDCMD -L`\"\n+  fi\n+\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $DLL_NAME\" >&5\n+$as_echo_n \"checking for $DLL_NAME... \" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $MSVC_DLL\" >&5\n+$as_echo \"$MSVC_DLL\" >&6; }\n+    else\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: incorrect, ignoring\" >&5\n+$as_echo \"incorrect, ignoring\" >&6; }\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&5\n+$as_echo \"$as_me: The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE\" >&6;}\n+    fi\n+  fi\n+\n+      if test \"x$MSVC_DLL\" = x; then\n+        as_fn_error $? \"Could not find a proper $MSVCP_NAME as specified by devkit\" \"$LINENO\" 5\n+      fi\n+      MSVCP_DLL=\"$MSVC_DLL\"\n+    else\n+\n+  DLL_NAME=\"${MSVCP_NAME}\"\n@@ -51033,2 +52449,2 @@\n-    MSVCR_DLL=\"$MSVC_DLL\"\n-  fi\n+      MSVCP_DLL=\"$MSVC_DLL\"\n+    fi\n@@ -51036,0 +52452,1 @@\n+  fi\n@@ -51038,3 +52455,3 @@\n-# Check whether --with-msvcp-dll was given.\n-if test \"${with_msvcp_dll+set}\" = set; then :\n-  withval=$with_msvcp_dll;\n+# Check whether --with-vcruntime-1-dll was given.\n+if test \"${with_vcruntime_1_dll+set}\" = set; then :\n+  withval=$with_vcruntime_1_dll;\n@@ -51044,3 +52461,3 @@\n-  if test \"x$MSVCP_NAME\" != \"x\"; then\n-    if test \"x$with_msvcp_dll\" != x; then\n-      # If given explicitely by user, do not probe. If not present, fail directly.\n+  if test \"x$VCRUNTIME_1_NAME\" != \"x\" && test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+    if test \"x$with_vcruntime_1_dll\" != x; then\n+      # If given explicitly by user, do not probe. If not present, fail directly.\n@@ -51048,3 +52465,3 @@\n-  DLL_NAME=\"$MSVCP_NAME\"\n-  POSSIBLE_MSVC_DLL=\"$with_msvcp_dll\"\n-  METHOD=\"--with-msvcp-dll\"\n+  DLL_NAME=\"$VCRUNTIME_1_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$with_vcruntime_1_dll\"\n+  METHOD=\"--with-vcruntime-1-dll\"\n@@ -51213,1 +52630,1 @@\n-        as_fn_error $? \"Could not find a proper $MSVCP_NAME as specified by --with-msvcp-dll\" \"$LINENO\" 5\n+        as_fn_error $? \"Could not find a proper $VCRUNTIME_1_NAME as specified by --with-vcruntime-1-dll\" \"$LINENO\" 5\n@@ -51215,2 +52632,2 @@\n-      MSVCP_DLL=\"$MSVC_DLL\"\n-    elif test \"x$DEVKIT_MSVCP_DLL\" != x; then\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n+    elif test \"x$DEVKIT_VCRUNTIME_1_DLL\" != x; then\n@@ -51218,2 +52635,2 @@\n-  DLL_NAME=\"$MSVCP_NAME\"\n-  POSSIBLE_MSVC_DLL=\"$DEVKIT_MSVCP_DLL\"\n+  DLL_NAME=\"$VCRUNTIME_1_NAME\"\n+  POSSIBLE_MSVC_DLL=\"$DEVKIT_VCRUNTIME_1_DLL\"\n@@ -51383,1 +52800,1 @@\n-        as_fn_error $? \"Could not find a proper $MSVCP_NAME as specified by devkit\" \"$LINENO\" 5\n+        as_fn_error $? \"Could not find a proper $VCRUNTIME_1_NAME as specified by devkit\" \"$LINENO\" 5\n@@ -51385,1 +52802,1 @@\n-      MSVCP_DLL=\"$MSVC_DLL\"\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n@@ -51388,1 +52805,1 @@\n-  DLL_NAME=\"${MSVCP_NAME}\"\n+  DLL_NAME=\"${VCRUNTIME_1_NAME}\"\n@@ -52436,1 +53853,1 @@\n-      MSVCP_DLL=\"$MSVC_DLL\"\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n","filename":"common\/autoconf\/generated-configure.sh","additions":1442,"deletions":25,"binary":false,"changes":1467,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+VCRUNTIME_1_DLL:=@VCRUNTIME_1_DLL@\n","filename":"common\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-VS_VERSION_INTERNAL_2019=141\n+VS_VERSION_INTERNAL_2019=142\n@@ -89,0 +89,1 @@\n+VS_VCRUNTIME_1_2019=vcruntime140_1.dll\n@@ -282,0 +283,1 @@\n+    eval VCRUNTIME_1_NAME=\"\\${VS_VCRUNTIME_1_${VS_VERSION}}\"\n@@ -328,0 +330,1 @@\n+      eval VCRUNTIME_1_NAME=\"\\${VS_VCRUNTIME_1_${VS_VERSION}}\"\n@@ -663,0 +666,25 @@\n+  AC_ARG_WITH(vcruntime-1-dll, [AS_HELP_STRING([--with-vcruntime-1-dll],\n+      [path to microsoft C++ runtime dll (vcruntime*_1.dll) (Windows only) @<:@probed@:>@])])\n+\n+  if test \"x$VCRUNTIME_1_NAME\" != \"x\" && test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+    if test \"x$with_vcruntime_1_dll\" != x; then\n+      # If given explicitly by user, do not probe. If not present, fail directly.\n+      TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL($VCRUNTIME_1_NAME, [$with_vcruntime_1_dll],\n+          [--with-vcruntime-1-dll])\n+      if test \"x$MSVC_DLL\" = x; then\n+        AC_MSG_ERROR([Could not find a proper $VCRUNTIME_1_NAME as specified by --with-vcruntime-1-dll])\n+      fi\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n+    elif test \"x$DEVKIT_VCRUNTIME_1_DLL\" != x; then\n+      TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL($VCRUNTIME_1_NAME, [$DEVKIT_VCRUNTIME_1_DLL], [devkit])\n+      if test \"x$MSVC_DLL\" = x; then\n+        AC_MSG_ERROR([Could not find a proper $VCRUNTIME_1_NAME as specified by devkit])\n+      fi\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n+    else\n+      TOOLCHAIN_SETUP_MSVC_DLL([${VCRUNTIME_1_NAME}])\n+      VCRUNTIME_1_DLL=\"$MSVC_DLL\"\n+    fi\n+    AC_SUBST(VCRUNTIME_1_DLL)\n+  fi\n+\n","filename":"common\/autoconf\/toolchain_windows.m4","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-JDK_UPDATE_VERSION=362\n+JDK_UPDATE_VERSION=372\n","filename":"common\/autoconf\/version-numbers","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,0 +172,3 @@\n+!if \"$(MSC_VER)\" >= \"1920\" && \"$(MSC_VER)\" <= \"1929\"\n+COMPILER_NAME=VS2019\n+!endif\n@@ -321,0 +324,15 @@\n+!if \"$(COMPILER_NAME)\" == \"VS2019\"\n+PRODUCT_OPT_OPTION   = \/O2 \/Oy-\n+FASTDEBUG_OPT_OPTION = \/O2 \/Oy-\n+DEBUG_OPT_OPTION     = \/Od\n+GX_OPTION = \/EHsc\n+LD_FLAGS = \/manifest $(LD_FLAGS)\n+MP_FLAG = \/MP\n+# Manifest Tool - used in VS2005 and later to adjust manifests stored\n+# as resources inside build artifacts.\n+!if \"x$(MT)\" == \"x\"\n+MT=mt.exe\n+!endif\n+SAFESEH_FLAG = \/SAFESEH\n+!endif\n+\n","filename":"hotspot\/make\/windows\/makefiles\/compile.make","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\tif \"$(MSC_VER)\" NEQ \"1920\" if \"$(MSC_VER)\" NEQ \"1921\" if \"$(MSC_VER)\" NEQ \"1922\" if \"$(MSC_VER)\" NEQ \"1923\" if \"$(MSC_VER)\" NEQ \"1924\" \\\n+\tif \"$(MSC_VER)\" NEQ \"1925\" if \"$(MSC_VER)\" NEQ \"1926\" if \"$(MSC_VER)\" NEQ \"1927\" if \"$(MSC_VER)\" NEQ \"1928\" if \"$(MSC_VER)\" NEQ \"1929\" \\\n@@ -42,0 +44,2 @@\n+\tif \"$(LD_VER)\" NEQ \"1420\" if \"$(LD_VER)\" NEQ \"1421\" if \"$(LD_VER)\" NEQ \"1422\" if \"$(LD_VER)\" NEQ \"1423\" if \"$(LD_VER)\" NEQ \"1424\" \\\n+\tif \"$(LD_VER)\" NEQ \"1425\" if \"$(LD_VER)\" NEQ \"1426\" if \"$(LD_VER)\" NEQ \"1427\" if \"$(LD_VER)\" NEQ \"1428\" if \"$(LD_VER)\" NEQ \"1429\" \\\n","filename":"hotspot\/make\/windows\/makefiles\/sanity.make","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-!if \"$(COMPILER_NAME)\" == \"VS2012\" || \"$(COMPILER_NAME)\" == \"VS2013\" || \"$(COMPILER_NAME)\" == \"VS2015\" || \"$(COMPILER_NAME)\" == \"VS2017\"\n+!if \"$(COMPILER_NAME)\" == \"VS2012\" || \"$(COMPILER_NAME)\" == \"VS2013\" || \"$(COMPILER_NAME)\" == \"VS2015\" || \"$(COMPILER_NAME)\" == \"VS2017\" || \"$(COMPILER_NAME)\" == \"VS2019\"\n","filename":"hotspot\/make\/windows\/makefiles\/vm.make","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,550 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+CgroupSubsystem* CgroupSubsystemFactory::create() {\n+  CgroupV1MemoryController* memory = NULL;\n+  CgroupV1Controller* cpuset = NULL;\n+  CgroupV1Controller* cpu = NULL;\n+  CgroupV1Controller* cpuacct = NULL;\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  u1 cg_type_flags = INVALID_CGROUPS_GENERIC;\n+  const char* proc_cgroups = \"\/proc\/cgroups\";\n+  const char* proc_self_cgroup = \"\/proc\/self\/cgroup\";\n+  const char* proc_self_mountinfo = \"\/proc\/self\/mountinfo\";\n+\n+  bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &cg_type_flags);\n+\n+  if (!valid_cgroup) {\n+    \/\/ Could not detect cgroup type\n+    return NULL;\n+  }\n+  assert(is_valid_cgroup(&cg_type_flags), \"Expected valid cgroup type\");\n+\n+  if (is_cgroup_v2(&cg_type_flags)) {\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    if(PrintContainerInfo)\n+      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n+    cleanup(cg_infos);\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/*\n+   * Cgroup v1 case:\n+   *\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  assert(is_cgroup_v1(&cg_type_flags), \"Cgroup v1 expected\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  cleanup(cg_infos);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,\n+                                            const char* proc_cgroups,\n+                                            const char* proc_self_cgroup,\n+                                            const char* proc_self_mountinfo,\n+                                            u1* flags) {\n+  FILE *mntinfo = NULL;\n+  FILE *cgroups = NULL;\n+  FILE *cgroup = NULL;\n+  char buf[MAXPATHLEN+1];\n+  char *p;\n+  bool is_cgroupsV2;\n+  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ at the kernel level.\n+  bool all_controllers_enabled;\n+\n+  \/*\n+   * Read \/proc\/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.\n+   *\n+   * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field and relevant controllers mounted.\n+   * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory\n+   * controllers must have hierarchy ID 0 and the unified controller mounted.\n+   *\/\n+  cgroups = fopen(proc_cgroups, \"r\");\n+  if (cgroups == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_cgroups, strerror(errno));\n+      }\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {\n+    char name[MAXPATHLEN+1];\n+    int  hierarchy_id;\n+    int  enabled;\n+\n+    \/\/ Format of \/proc\/cgroups documented via man 7 cgroups\n+    if (sscanf(p, \"%s %d %*d %d\", name, &hierarchy_id, &enabled) != 3) {\n+      continue;\n+    }\n+    if (strcmp(name, \"memory\") == 0) {\n+      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n+      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuset\") == 0) {\n+      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n+      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpu\") == 0) {\n+      cg_infos[CPU_IDX]._name = os::strdup(name);\n+      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuacct\") == 0) {\n+      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n+      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n+    }\n+  }\n+  fclose(cgroups);\n+\n+  is_cgroupsV2 = true;\n+  all_controllers_enabled = true;\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+  }\n+\n+  if (!all_controllers_enabled) {\n+    \/\/ one or more controllers disabled, disable container support\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"One or more required controllers disabled at kernel level.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  \/*\n+   * Read \/proc\/self\/cgroup and determine:\n+   *  - the cgroup path for cgroups v2 or\n+   *  - on a cgroups v1 system, collect info for mapping\n+   *    the host mount point to the local one via \/proc\/self\/mountinfo below.\n+   *\/\n+  cgroup = fopen(proc_self_cgroup, \"r\");\n+  if (cgroup == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Can't open %s, %s\",\n+                    proc_self_cgroup, strerror(errno));\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n+    char *controllers;\n+    char *token;\n+    char *hierarchy_id_str;\n+    int  hierarchy_id;\n+    char *cgroup_path;\n+\n+    hierarchy_id_str = strsep(&p, \":\");\n+    hierarchy_id = atoi(hierarchy_id_str);\n+    \/* Get controllers and base *\/\n+    controllers = strsep(&p, \":\");\n+    cgroup_path = strsep(&p, \"\\n\");\n+\n+    if (controllers == NULL) {\n+      continue;\n+    }\n+\n+    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != NULL) {\n+      if (strcmp(token, \"memory\") == 0) {\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuset\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpu\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuacct\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+    if (is_cgroupsV2) {\n+      for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+        cg_infos[i]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+  }\n+  fclose(cgroup);\n+\n+  \/\/ Find various mount points by reading \/proc\/self\/mountinfo\n+  \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+  mntinfo = fopen(proc_self_mountinfo, \"r\");\n+  if (mntinfo == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_self_mountinfo, strerror(errno));\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  bool cgroupv2_mount_point_found = false;\n+  bool any_cgroup_mounts_found = false;\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmp_mount_point[MAXPATHLEN+1];\n+    char tmp_fs_type[MAXPATHLEN+1];\n+    char tmproot[MAXPATHLEN+1];\n+    char tmpmount[MAXPATHLEN+1];\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+    \/\/ block in the hybrid case.\n+    \/\/\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s %*s %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+      \/\/ we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype\n+      if (!cgroupv2_mount_point_found && strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+        cgroupv2_mount_point_found = true;\n+        any_cgroup_mounts_found = true;\n+        for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+          assert(cg_infos[i]._mount_path == NULL, \"_mount_path memory stomping\");\n+          cg_infos[i]._mount_path = os::strdup(tmp_mount_point);\n+        }\n+      }\n+    }\n+\n+    \/* Cgroup v1 relevant info\n+     *\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     *\n+     * Example for docker:\n+     * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+     *\n+     * Example for host:\n+     * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+     *\/\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+      if (strcmp(\"cgroup\", tmp_fs_type) != 0) {\n+        \/\/ Skip cgroup2 fs lines on hybrid or unified hierarchy.\n+        continue;\n+      }\n+      while ((token = strsep(&cptr, \",\")) != NULL) {\n+        if (strcmp(token, \"memory\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[MEMORY_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[MEMORY_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuset\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          if (cg_infos[CPUSET_IDX]._mount_path != NULL) {\n+            \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+            \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+            \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+            if (strstr(cg_infos[CPUSET_IDX]._mount_path, \"\/sys\/fs\/cgroup\") != cg_infos[CPUSET_IDX]._mount_path) {\n+              if (PrintContainerInfo) {\n+                tty->print_cr(\"Duplicate cpuset controllers detected. Picking %s, skipping %s.\",\n+                              tmpmount, cg_infos[CPUSET_IDX]._mount_path);\n+              }\n+              os::free(cg_infos[CPUSET_IDX]._mount_path);\n+              cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+            } else {\n+              if (PrintContainerInfo) {\n+                tty->print_cr(\"Duplicate cpuset controllers detected. Picking %s, skipping %s.\",\n+                              cg_infos[CPUSET_IDX]._mount_path, tmpmount);\n+              }\n+            }\n+          } else {\n+            cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+          }\n+          cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUSET_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpu\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[CPU_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPU_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuacct\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUACCT_IDX]._data_complete = true;\n+        }\n+      }\n+    }\n+  }\n+  fclose(mntinfo);\n+\n+  \/\/ Neither cgroup2 nor cgroup filesystems mounted via \/proc\/self\/mountinfo\n+  \/\/ No point in continuing.\n+  if (!any_cgroup_mounts_found) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"No relevant cgroup controllers mounted.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_NO_MOUNT;\n+    return false;\n+  }\n+\n+  if (is_cgroupsV2) {\n+    if (!cgroupv2_mount_point_found) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Mount point for cgroupv2 not found in \/proc\/self\/mountinfo\");\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_V2;\n+      return false;\n+    }\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    *flags = CGROUPS_V2;\n+    return true;\n+  }\n+\n+  \/\/ What follows is cgroups v1\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers\");\n+  }\n+\n+  if (!cg_infos[MEMORY_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 memory subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUSET_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpuset subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPU_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpu subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpuacct subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  \/\/ Cgroups v1 case, we have all the info we need.\n+  *flags = CGROUPS_V1;\n+  return true;\n+\n+};\n+\n+void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n+  assert(cg_infos != NULL, \"Invariant\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    os::free(cg_infos[i]._name);\n+    os::free(cg_infos[i]._cgroup_path);\n+    os::free(cg_infos[i]._root_mount_path);\n+    os::free(cg_infos[i]._mount_path);\n+  }\n+}\n+\n+\/* active_processor_count\n+ *\n+ * Calculate an appropriate number of active processors for the\n+ * VM to use based on these three inputs.\n+ *\n+ * cpu affinity\n+ * cgroup cpu quota & cpu period\n+ * cgroup cpu shares\n+ *\n+ * Algorithm:\n+ *\n+ * Determine the number of available CPUs from sched_getaffinity\n+ *\n+ * If user specified a quota (quota != -1), calculate the number of\n+ * required CPUs by dividing quota by period.\n+ *\n+ * If shares are in effect (shares != -1), calculate the number\n+ * of CPUs required for the shares by dividing the share value\n+ * by PER_CPU_SHARES.\n+ *\n+ * All results of division are rounded up to the next whole number.\n+ *\n+ * If neither shares or quotas have been specified, return the\n+ * number of active processors in the system.\n+ *\n+ * If both shares and quotas have been specified, the results are\n+ * based on the flag PreferContainerQuotaForCPUCount.  If true,\n+ * return the quota value.  If false return the smallest value\n+ * between shares or quotas.\n+ *\n+ * If shares and\/or quotas have been specified, the resulting number\n+ * returned will never exceed the number of active processors.\n+ *\n+ * return:\n+ *    number of CPUs\n+ *\/\n+int CgroupSubsystem::active_processor_count() {\n+  int quota_count = 0, share_count = 0;\n+  int cpu_count, limit_count;\n+  int result;\n+\n+  \/\/ We use a cache with a timeout to avoid performing expensive\n+  \/\/ computations in the event this function is called frequently.\n+  \/\/ [See 8227006].\n+  CachingCgroupController* contrl = cpu_controller();\n+  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  if (!cpu_limit->should_check_metric()) {\n+    int val = (int)cpu_limit->value();\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n+    }\n+    return val;\n+  }\n+\n+  cpu_count = limit_count = os::Linux::active_processor_count();\n+  int quota  = cpu_quota();\n+  int period = cpu_period();\n+  int share  = cpu_shares();\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+    }\n+  }\n+  if (share > -1) {\n+    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n+    }\n+  }\n+\n+  \/\/ If both shares and quotas are setup results depend\n+  \/\/ on flag PreferContainerQuotaForCPUCount.\n+  \/\/ If true, limit CPU count to quota\n+  \/\/ If false, use minimum of shares and quotas\n+  if (quota_count !=0 && share_count != 0) {\n+    if (PreferContainerQuotaForCPUCount) {\n+      limit_count = quota_count;\n+    } else {\n+      limit_count = MIN2(quota_count, share_count);\n+    }\n+  } else if (quota_count != 0) {\n+    limit_count = quota_count;\n+  } else if (share_count != 0) {\n+    limit_count = share_count;\n+  }\n+\n+  result = MIN2(cpu_count, limit_count);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n+  }\n+\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  cpu_limit->set_value(result, OSCONTAINER_CACHE_TIMEOUT);\n+\n+  return result;\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupSubsystem::memory_limit_in_bytes() {\n+  CachingCgroupController* contrl = memory_controller();\n+  CachedMetric* memory_limit = contrl->metrics_cache();\n+  if (!memory_limit->should_check_metric()) {\n+    return memory_limit->value();\n+  }\n+  jlong mem_limit = read_memory_limit_in_bytes();\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  memory_limit->set_value(mem_limit, OSCONTAINER_CACHE_TIMEOUT);\n+  return mem_limit;\n+}\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.cpp","additions":550,"deletions":0,"binary":false,"changes":550,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_SUBSYSTEM_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"osContainer_linux.hpp\"\n+\n+\/\/ Shared cgroups code (used by cgroup version 1 and version 2)\n+\n+\/*\n+ * PER_CPU_SHARES has been set to 1024 because CPU shares' quota\n+ * is commonly used in cloud frameworks like Kubernetes[1],\n+ * AWS[2] and Mesos[3] in a similar way. They spawn containers with\n+ * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do\n+ * the inverse for determining the number of possible available\n+ * CPUs to the JVM inside a container. See JDK-8216366.\n+ *\n+ * [1] https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-compute-resources-container\/#meaning-of-cpu\n+ *     In particular:\n+ *        When using Docker:\n+ *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially\n+ *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the\n+ *          --cpu-shares flag in the docker run command.\n+ * [2] https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/APIReference\/API_ContainerDefinition.html\n+ * [3] https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/docker\/docker.cpp#L648\n+ *     https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/slave\/containerizer\/mesos\/isolators\/cgroups\/constants.hpp#L30\n+ *\/\n+#define PER_CPU_SHARES 1024\n+\n+#define CGROUPS_V1               1\n+#define CGROUPS_V2               2\n+#define INVALID_CGROUPS_V2       3\n+#define INVALID_CGROUPS_V1       4\n+#define INVALID_CGROUPS_NO_MOUNT 5\n+#define INVALID_CGROUPS_GENERIC  6\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+#define CPUSET_IDX     0\n+#define CPU_IDX        1\n+#define CPUACCT_IDX    2\n+#define MEMORY_IDX     3\n+\n+typedef char * cptr;\n+\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path() = 0;\n+};\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int subsystem_file_line_contents(CgroupController* c,\n+                                              const char *filename,\n+                                              const char *matchline,\n+                                              const char *scan_fmt,\n+                                              T returnval) {\n+  FILE *fp = NULL;\n+  char *p;\n+  char file[MAXPATHLEN+1];\n+  char buf[MAXPATHLEN+1];\n+  char discard[MAXPATHLEN+1];\n+  bool found_match = false;\n+\n+  if (c == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"subsystem_file_line_contents: subsystem path is NULL\");\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n+  file[MAXPATHLEN-1] = '\\0';\n+  int filelen = strlen(file);\n+  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"File path too long %s, %s\", file, filename);\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+  strncat(file, filename, MAXPATHLEN-filelen);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Path to %s is %s\", filename, file);\n+  }\n+  fp = fopen(file, \"r\");\n+  if (fp != NULL) {\n+    int err = 0;\n+    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n+      found_match = false;\n+      if (matchline == NULL) {\n+        \/\/ single-line file case\n+        int matched = sscanf(p, scan_fmt, returnval);\n+        found_match = (matched == 1);\n+      } else {\n+        \/\/ multi-line file case\n+        if (strstr(p, matchline) != NULL) {\n+          \/\/ discard matchline string prefix\n+          int matched = sscanf(p, scan_fmt, discard, returnval);\n+          found_match = (matched == 2);\n+        } else {\n+          continue; \/\/ substring not found\n+        }\n+      }\n+      if (found_match) {\n+        fclose(fp);\n+        return 0;\n+      } else {\n+        err = 1;\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Type %s not found in file %s\", scan_fmt, file);\n+        }\n+      }\n+    }\n+    if (err == 0) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Empty file %s\", file);\n+      }\n+    }\n+  } else {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Open of file %s failed, %s\", file, strerror(errno));\n+    }\n+  }\n+  if (fp != NULL)\n+    fclose(fp);\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n+                           logstring, scan_fmt, variable)                 \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     &variable);                          \\\n+  if (err != 0) {                                                         \\\n+    if (PrintContainerInfo) {                                             \\\n+      tty->print_cr(logstring, (return_type) OSCONTAINER_ERROR);          \\\n+    }                                                                     \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+  }                                                                       \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n+                               logstring, scan_fmt, variable, bufsize)    \\\n+  char variable[bufsize];                                                 \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     variable);                           \\\n+  if (err != 0)                                                           \\\n+    return (return_type) NULL;                                            \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n+                           matchline, logstring, scan_fmt, variable)      \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(controller,                          \\\n+                                filename,                                 \\\n+                                matchline,                                \\\n+                                scan_fmt,                                 \\\n+                                &variable);                               \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+\n+class CachedMetric : public CHeapObj<mtInternal>{\n+  private:\n+    volatile jlong _metric;\n+    volatile jlong _next_check_counter;\n+  public:\n+    CachedMetric() {\n+      _metric = -1;\n+      _next_check_counter = min_jlong;\n+    }\n+    bool should_check_metric() {\n+      return os::elapsed_counter() > _next_check_counter;\n+    }\n+    jlong value() { return _metric; }\n+    void set_value(jlong value, jlong timeout) {\n+      _metric = value;\n+      \/\/ Metric is unlikely to change, but we want to remain\n+      \/\/ responsive to configuration changes. A very short grace time\n+      \/\/ between re-read avoids excessive overhead during startup without\n+      \/\/ significantly reducing the VMs ability to promptly react to changed\n+      \/\/ metric config\n+      _next_check_counter = os::elapsed_counter() + timeout;\n+    }\n+};\n+\n+class CachingCgroupController : public CHeapObj<mtInternal> {\n+  private:\n+    CgroupController* _controller;\n+    CachedMetric* _metrics_cache;\n+\n+  public:\n+    CachingCgroupController(CgroupController* cont) {\n+      _controller = cont;\n+      _metrics_cache = new CachedMetric();\n+    }\n+\n+    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CgroupController* controller() { return _controller; }\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual int cpu_quota() = 0;\n+    virtual int cpu_period() = 0;\n+    virtual int cpu_shares() = 0;\n+    virtual jlong memory_usage_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n+    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_max_usage_in_bytes() = 0;\n+    virtual char * cpu_cpuset_cpus() = 0;\n+    virtual char * cpu_cpuset_memory_nodes() = 0;\n+    virtual jlong read_memory_limit_in_bytes() = 0;\n+    virtual const char * container_type() = 0;\n+    virtual CachingCgroupController* memory_controller() = 0;\n+    virtual CachingCgroupController* cpu_controller() = 0;\n+};\n+\n+\/\/ Utility class for storing info retrieved from \/proc\/cgroups,\n+\/\/ \/proc\/self\/cgroup and \/proc\/self\/mountinfo\n+\/\/ For reference see man 7 cgroups and CgroupSubsystemFactory\n+class CgroupInfo : public StackObj {\n+  friend class CgroupSubsystemFactory;\n+  friend class WhiteBox;\n+\n+  private:\n+    char* _name;\n+    int _hierarchy_id;\n+    bool _enabled;\n+    bool _data_complete;    \/\/ indicating cgroup v1 data is complete for this controller\n+    char* _cgroup_path;     \/\/ cgroup controller path from \/proc\/self\/cgroup\n+    char* _root_mount_path; \/\/ root mount path from \/proc\/self\/mountinfo. Unused for cgroup v2\n+    char* _mount_path;      \/\/ mount path from \/proc\/self\/mountinfo.\n+\n+  public:\n+    CgroupInfo() {\n+      _name = NULL;\n+      _hierarchy_id = -1;\n+      _enabled = false;\n+      _data_complete = false;\n+      _cgroup_path = NULL;\n+      _root_mount_path = NULL;\n+      _mount_path = NULL;\n+    }\n+\n+};\n+\n+class CgroupSubsystemFactory: AllStatic {\n+  friend class WhiteBox;\n+\n+  public:\n+    static CgroupSubsystem* create();\n+  private:\n+    static inline bool is_cgroup_v2(u1* flags) {\n+       return *flags == CGROUPS_V2;\n+    }\n+\n+#ifdef ASSERT\n+    static inline bool is_valid_cgroup(u1* flags) {\n+       return *flags == CGROUPS_V1 || *flags == CGROUPS_V2;\n+    }\n+    static inline bool is_cgroup_v1(u1* flags) {\n+       return *flags == CGROUPS_V1;\n+    }\n+#endif\n+\n+    \/\/ Determine the cgroup type (version 1 or version 2), given\n+    \/\/ relevant paths to files. Sets 'flags' accordingly.\n+    static bool determine_type(CgroupInfo* cg_infos,\n+                               const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* flags);\n+    static void cleanup(CgroupInfo* cg_infos);\n+};\n+\n+#endif \/\/ CGROUP_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  if (_root != NULL && cgroup_path != NULL) {\n+    if (strcmp(_root, \"\/\") == 0) {\n+      int buflen;\n+      strncpy(buf, _mount_point, MAXPATHLEN);\n+      buf[MAXPATHLEN-1] = '\\0';\n+      if (strcmp(cgroup_path,\"\/\") != 0) {\n+        buflen = strlen(buf);\n+        if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n+          return;\n+        }\n+        strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+        buf[MAXPATHLEN-1] = '\\0';\n+      }\n+      _path = os::strdup(buf);\n+    } else {\n+      if (strcmp(_root, cgroup_path) == 0) {\n+        strncpy(buf, _mount_point, MAXPATHLEN);\n+        buf[MAXPATHLEN-1] = '\\0';\n+        _path = os::strdup(buf);\n+      } else {\n+        char *p = strstr(cgroup_path, _root);\n+        if (p != NULL && p == _root) {\n+          if (strlen(cgroup_path) > strlen(_root)) {\n+            int buflen;\n+            strncpy(buf, _mount_point, MAXPATHLEN);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            buflen = strlen(buf);\n+            if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n+              return;\n+            }\n+            strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            _path = os::strdup(buf);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/* uses_mem_hierarchy\n+ *\n+ * Return whether or not hierarchical cgroup accounting is being\n+ * done.\n+ *\n+ * return:\n+ *    A number > 0 if true, or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n+  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n+                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n+  return use_hierarchy;\n+}\n+\n+void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n+  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  jlong hierarchy = uses_mem_hierarchy();\n+  if (hierarchy > 0) {\n+    set_hierarchical(true);\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n+                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n+\n+  if (memlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Non-Hierarchical Memory Limit is: Unlimited\");\n+    }\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memory_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Hierarchical Memory Limit is: Unlimited\");\n+        }\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  }\n+  else {\n+    return (jlong)memlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n+                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  if (memswlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n+    }\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memsw_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+        }\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memswlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  if (memsoftlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Memory Soft Limit is: Unlimited\");\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memsoftlimit;\n+  }\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory for this process.\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+\/* memory_max_usage_in_bytes\n+ *\n+ * Return the maximum amount of used memory for this process.\n+ *\n+ * return:\n+ *    max memory usage in bytes or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n+                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+  return memmaxusage;\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  return os::strdup(cpus);\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  return os::strdup(mems);\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_quota() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n+                     \"CPU Quota is: %d\", \"%d\", quota);\n+  return quota;\n+}\n+\n+int CgroupV1Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n+                     \"CPU Period is: %d\", \"%d\", period);\n+  return period;\n+}\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n+                     \"CPU Shares is: %d\", \"%d\", shares);\n+  \/\/ Convert 1024 to no shares setup\n+  if (shares == 1024) return -1;\n+\n+  return shares;\n+}\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV1Subsystem_linux.cpp","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+\/\/ Cgroups version 1 specific implementation\n+\n+class CgroupV1Controller: public CgroupController {\n+  private:\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path;\n+\n+  public:\n+    CgroupV1Controller(char *root, char *mountpoint) {\n+      _root = os::strdup(root);\n+      _mount_point = os::strdup(mountpoint);\n+      _path = NULL;\n+    }\n+\n+    virtual void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV1MemoryController: public CgroupV1Controller {\n+\n+  public:\n+    bool is_hierarchical() { return _uses_mem_hierarchy; }\n+    void set_subsystem_path(char *cgroup_path);\n+  private:\n+    \/* Some container runtimes set limits via cgroup\n+     * hierarchy. If set to true consider also memory.stat\n+     * file if everything else seems unlimited *\/\n+    bool _uses_mem_hierarchy;\n+    jlong uses_mem_hierarchy();\n+    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+\n+  public:\n+    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+      _uses_mem_hierarchy = false;\n+    }\n+\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n+\n+  public:\n+    jlong read_memory_limit_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+\n+    int cpu_quota();\n+    int cpu_period();\n+\n+    int cpu_shares();\n+\n+    const char * container_type() {\n+      return \"cgroupv1\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+\n+  private:\n+    julong _unlimited_memory;\n+\n+    \/* controllers *\/\n+    CachingCgroupController* _memory;\n+    CgroupV1Controller* _cpuset;\n+    CachingCgroupController* _cpu;\n+    CgroupV1Controller* _cpuacct;\n+\n+  public:\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1Controller* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1MemoryController* memory) {\n+      _cpuset = cpuset;\n+      _cpu = new CachingCgroupController(cpu);\n+      _cpuacct = cpuacct;\n+      _memory = new CachingCgroupController(memory);\n+      _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n+    }\n+};\n+\n+#endif \/\/ CGROUP_V1_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV1Subsystem_linux.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n+                     \"Raw value for CPU Shares is: %d\", \"%d\", shares);\n+  \/\/ Convert default value of 100 to no shares setup\n+  if (shares == 100) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Shares is: %d\", -1);\n+    }\n+    return -1;\n+  }\n+\n+  \/\/ CPU shares (OCI) value needs to get translated into\n+  \/\/ a proper Cgroups v2 value. See:\n+  \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+  \/\/\n+  \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+  \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+  \/\/\n+  int x = 262142 * shares - 1;\n+  double frac = x\/9999.0;\n+  x = ((int)frac) + 2;\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Scaled CPU shares value is: %d\", x);\n+  }\n+  \/\/ Since the scaled value is not precise, return the closest\n+  \/\/ multiple of PER_CPU_SHARES for a more conservative mapping\n+  if ( x <= PER_CPU_SHARES ) {\n+     \/\/ will always map to 1 CPU\n+     if (PrintContainerInfo) {\n+        tty->print_cr(\"CPU Shares is: %d\", x);\n+     }\n+     return x;\n+  }\n+  int f = x\/PER_CPU_SHARES;\n+  int lower_multiple = f * PER_CPU_SHARES;\n+  int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+  int distance_lower = MAX2(lower_multiple, x) - MIN2(lower_multiple, x);\n+  int distance_upper = MAX2(upper_multiple, x) - MIN2(upper_multiple, x);\n+  x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Closest multiple of %d of the CPU Shares value is: %d\", PER_CPU_SHARES, x);\n+    tty->print_cr(\"CPU Shares is: %d\", x);\n+  }\n+  return x;\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val();\n+  int limit = (int)limit_from_str(cpu_quota_str);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"CPU Quota is: %d\", limit);\n+  }\n+  return limit;\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  if (cpus == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(cpus);\n+}\n+\n+char* CgroupV2Subsystem::cpu_quota_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n+                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n+  if (quota == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(quota);\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  if (mems == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mems);\n+}\n+\n+int CgroupV2Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n+                     \"CPU Period is: %d\", \"%*s %d\", period);\n+  return period;\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory used by this cgroup and decendents\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+  char* mem_soft_limit_str = mem_soft_limit_val();\n+  return limit_from_str(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+  \/\/ Log this string at trace level so as to make tests happy.\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Maximum Memory Usage is not supported.\");\n+  }\n+  return OSCONTAINER_ERROR; \/\/ not supported\n+}\n+\n+char* CgroupV2Subsystem::mem_soft_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n+                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n+  if (mem_soft_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+\/\/ Note that for cgroups v2 the actual limits set for swap and\n+\/\/ memory live in two different files, memory.swap.max and memory.max\n+\/\/ respectively. In order to properly report a cgroup v1 like\n+\/\/ compound value we need to sum the two values. Setting a swap limit\n+\/\/ without also setting a memory limit is not allowed.\n+jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+  char* mem_swp_limit_str = mem_swp_limit_val();\n+  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  if (swap_limit >= 0) {\n+    jlong memory_limit = read_memory_limit_in_bytes();\n+    assert(memory_limit >= 0, \"swap limit without memory limit?\");\n+    return memory_limit + swap_limit;\n+  }\n+  return swap_limit;\n+}\n+\n+char* CgroupV2Subsystem::mem_swp_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n+  if (mem_swp_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_swp_limit_str);\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *\/\n+jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n+  char * mem_limit_str = mem_limit_val();\n+  jlong limit = limit_from_str(mem_limit_str);\n+  if (PrintContainerInfo) {\n+    if (limit == -1) {\n+      tty->print_cr(\"Memory Limit is: Unlimited\");\n+    } else {\n+      tty->print_cr(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  return limit;\n+}\n+\n+jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n+\n+char* CgroupV2Subsystem::mem_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n+  if (mem_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_limit_str);\n+}\n+\n+char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  int buflen;\n+  strncpy(buf, mount_path, MAXPATHLEN);\n+  buf[MAXPATHLEN] = '\\0';\n+  buflen = strlen(buf);\n+  if ((buflen + strlen(cgroup_path)) > MAXPATHLEN) {\n+    return NULL;\n+  }\n+  strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+  buf[MAXPATHLEN] = '\\0';\n+  return os::strdup(buf);\n+}\n+\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.cpp","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupV2Controller: public CgroupController {\n+  private:\n+    \/* the mount path of the cgroup v2 hierarchy *\/\n+    char *_mount_path;\n+    \/* The cgroup path for the controller *\/\n+    char *_cgroup_path;\n+\n+    \/* Constructed full path to the subsystem directory *\/\n+    char *_path;\n+    static char* construct_path(char* mount_path, char *cgroup_path);\n+\n+  public:\n+    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n+      _mount_path = mount_path;\n+      _cgroup_path = os::strdup(cgroup_path);\n+      _path = construct_path(mount_path, cgroup_path);\n+    }\n+\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV2Subsystem: public CgroupSubsystem {\n+  private:\n+    \/* One unified controller *\/\n+    CgroupController* _unified;\n+    \/* Caching wrappers for cpu\/memory metrics *\/\n+    CachingCgroupController* _memory;\n+    CachingCgroupController* _cpu;\n+\n+    char *mem_limit_val();\n+    char *mem_swp_limit_val();\n+    char *mem_soft_limit_val();\n+    char *cpu_quota_val();\n+    jlong limit_from_str(char* limit_str);\n+\n+  public:\n+    CgroupV2Subsystem(CgroupController * unified) {\n+      _unified = unified;\n+      _memory = new CachingCgroupController(unified);\n+      _cpu = new CachingCgroupController(unified);\n+    }\n+\n+    jlong read_memory_limit_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+    const char * container_type() {\n+      return \"cgroupv2\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+};\n+\n+#endif \/\/ CGROUP_V2_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -33,1 +33,0 @@\n-#define PER_CPU_SHARES 1024\n@@ -37,239 +36,0 @@\n-int   OSContainer::_active_processor_count = 1;\n-julong _unlimited_memory;\n-\n-class CgroupSubsystem: CHeapObj<mtInternal> {\n- friend class OSContainer;\n-\n- private:\n-    volatile jlong _next_check_counter;\n-\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n- public:\n-    CgroupSubsystem(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = NULL;\n-      _next_check_counter = min_jlong;\n-    }\n-\n-    \/*\n-     * Set directory to subsystem specific files based\n-     * on the contents of the mountinfo and cgroup files.\n-     *\/\n-    void set_subsystem_path(char *cgroup_path) {\n-      char buf[MAXPATHLEN+1];\n-      if (_root != NULL && cgroup_path != NULL) {\n-        if (strcmp(_root, \"\/\") == 0) {\n-          int buflen;\n-          strncpy(buf, _mount_point, MAXPATHLEN);\n-          buf[MAXPATHLEN-1] = '\\0';\n-          if (strcmp(cgroup_path,\"\/\") != 0) {\n-            buflen = strlen(buf);\n-            if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n-              return;\n-            }\n-            strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n-            buf[MAXPATHLEN-1] = '\\0';\n-          }\n-          _path = os::strdup(buf);\n-        } else {\n-          if (strcmp(_root, cgroup_path) == 0) {\n-            strncpy(buf, _mount_point, MAXPATHLEN);\n-            buf[MAXPATHLEN-1] = '\\0';\n-            _path = os::strdup(buf);\n-          } else {\n-            char *p = strstr(cgroup_path, _root);\n-            if (p != NULL && p == _root) {\n-              if (strlen(cgroup_path) > strlen(_root)) {\n-                int buflen;\n-                strncpy(buf, _mount_point, MAXPATHLEN);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                buflen = strlen(buf);\n-                if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n-                  return;\n-                }\n-                strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                _path = os::strdup(buf);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    char *subsystem_path() { return _path; }\n-\n-    bool cache_has_expired() {\n-      return os::elapsed_counter() > _next_check_counter;\n-    }\n-\n-    void set_cache_expiry_time(jlong timeout) {\n-      _next_check_counter = os::elapsed_counter() + timeout;\n-    }\n-};\n-\n-class CgroupMemorySubsystem: CgroupSubsystem {\n- friend class OSContainer;\n-\n- private:\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-\n- public:\n-    CgroupMemorySubsystem(char *root, char *mountpoint) : CgroupSubsystem::CgroupSubsystem(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-    }\n-\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n-};\n-\n-CgroupMemorySubsystem* memory = NULL;\n-CgroupSubsystem* cpuset = NULL;\n-CgroupSubsystem* cpu = NULL;\n-CgroupSubsystem* cpuacct = NULL;\n-\n-typedef char * cptr;\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int subsystem_file_line_contents(CgroupSubsystem* c,\n-                                              const char *filename,\n-                                              const char *matchline,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n-\n-  if (c == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"subsystem_file_line_contents: CgroupSubsytem* is NULL\");\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"subsystem_file_line_contents: subsystem path is NULL\");\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"File path too long %s, %s\", file, filename);\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  if (PrintContainerInfo) {\n-    tty->print_cr(\"Path to %s is %s\", filename, file);\n-  }\n-  fp = fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n-        }\n-      }\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Type %s not found in file %s\", scan_fmt, file);\n-        }\n-      }\n-      if (err == 0 && PrintContainerInfo) {\n-        tty->print_cr(\"Empty file %s\", file);\n-      }\n-    }\n-  } else {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Open of file %s failed, %s\", file, strerror(errno));\n-    }\n-  }\n-  if (fp != NULL)\n-    fclose(fp);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, scan_fmt, variable)                 \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n-\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) NULL;                                            \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n-\n-#define GET_CONTAINER_INFO_LINE(return_type, subsystem, filename,         \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n@@ -277,0 +37,1 @@\n+CgroupSubsystem* cgroup_subsystem;\n@@ -284,6 +45,0 @@\n-  FILE *mntinfo = NULL;\n-  FILE *cgroup = NULL;\n-  char buf[MAXPATHLEN+1];\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n-  char *p;\n@@ -297,2 +52,0 @@\n-  _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n-\n@@ -309,17 +62,3 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      if (PrintContainerInfo) {\n-        tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                       strerror(errno));\n-      }\n-      return;\n+  cgroup_subsystem = CgroupSubsystemFactory::create();\n+  if (cgroup_subsystem == NULL) {\n+    return; \/\/ Required subsystem files not found or other error\n@@ -327,115 +66,0 @@\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupMemorySubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupSubsystem(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup memory subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpuset == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpuset subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpu == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpu subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpuacct == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpuacct subsystem not found\");\n-    }\n-    return;\n-  }\n-\n-  \/*\n-   * Read \/proc\/self\/cgroup and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n-  if (cgroup == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Can't open \/proc\/self\/cgroup, %s\",\n-                     strerror(errno));\n-      }\n-    return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n-    char *controllers;\n-    char *token;\n-    char *base;\n-\n-    \/* Skip cgroup number *\/\n-    strsep(&p, \":\");\n-    \/* Get controllers and base *\/\n-    controllers = strsep(&p, \":\");\n-    base = strsep(&p, \"\\n\");\n-\n-    if (controllers == NULL) {\n-      continue;\n-    }\n-\n-    while ((token = strsep(&controllers, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory->set_subsystem_path(base);\n-        jlong hierarchy = uses_mem_hierarchy();\n-        if (hierarchy > 0) {\n-          memory->set_hierarchical(true);\n-        }\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct->set_subsystem_path(base);\n-      }\n-    }\n-  }\n-\n-  fclose(cgroup);\n-\n@@ -443,2 +67,2 @@\n-  \/\/ command line arguments have been processed.\n-  if ((mem_limit = memory_limit_in_bytes()) > 0) {\n+  \/\/ cgroup subsystem files have been processed.\n+  if ((mem_limit = cgroup_subsystem->memory_limit_in_bytes()) > 0) {\n@@ -456,20 +80,2 @@\n-  if (is_containerized()) {\n-    return \"cgroupv1\";\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong OSContainer::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->container_type();\n@@ -478,10 +84,0 @@\n-\n-\/* memory_limit_in_bytes\n- *\n- * Return the limit of available memory for this process.\n- *\n- * return:\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -489,25 +85,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    }\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Hierarchical Memory Limit is: Unlimited\");\n-        }\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  }\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_limit_in_bytes();\n@@ -517,23 +90,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  if (memswlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    }\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-        }\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n@@ -543,10 +95,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Memory Soft Limit is: Unlimited\");\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memsoftlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_soft_limit_in_bytes();\n@@ -565,3 +109,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_usage_in_bytes();\n@@ -570,8 +113,0 @@\n-\/* memory_max_usage_in_bytes\n- *\n- * Return the maximum amount of used memory for this process.\n- *\n- * return:\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -579,101 +114,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n-}\n-\n-\/* active_processor_count\n- *\n- * Calculate an appropriate number of active processors for the\n- * VM to use based on these three inputs.\n- *\n- * cpu affinity\n- * cgroup cpu quota & cpu period\n- * cgroup cpu shares\n- *\n- * Algorithm:\n- *\n- * Determine the number of available CPUs from sched_getaffinity\n- *\n- * If user specified a quota (quota != -1), calculate the number of\n- * required CPUs by dividing quota by period.\n- *\n- * If shares are in effect (shares != -1), calculate the number\n- * of CPUs required for the shares by dividing the share value\n- * by PER_CPU_SHARES.\n- *\n- * All results of division are rounded up to the next whole number.\n- *\n- * If neither shares or quotas have been specified, return the\n- * number of active processors in the system.\n- *\n- * If both shares and quotas have been specified, the results are\n- * based on the flag PreferContainerQuotaForCPUCount.  If true,\n- * return the quota value.  If false return the smallest value\n- * between shares or quotas.\n- *\n- * If shares and\/or quotas have been specified, the resulting number\n- * returned will never exceed the number of active processors.\n- *\n- * return:\n- *    number of CPUs\n- *\/\n-int OSContainer::active_processor_count() {\n-  int quota_count = 0, share_count = 0;\n-  int cpu_count, limit_count;\n-  int result;\n-\n-  \/\/ We use a cache with a timeout to avoid performing expensive\n-  \/\/ computations in the event this function is called frequently.\n-  \/\/ [See 8227006].\n-  if (!cpu->cache_has_expired()) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n-    }\n-\n-    return OSContainer::_active_processor_count;\n-  }\n-\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-  int share  = cpu_shares();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-    }\n-  }\n-  if (share > -1) {\n-    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n-    }\n-  }\n-\n-  \/\/ If both shares and quotas are setup results depend\n-  \/\/ on flag PreferContainerQuotaForCPUCount.\n-  \/\/ If true, limit CPU count to quota\n-  \/\/ If false, use minimum of shares and quotas\n-  if (quota_count !=0 && share_count != 0) {\n-    if (PreferContainerQuotaForCPUCount) {\n-      limit_count = quota_count;\n-    } else {\n-      limit_count = MIN2(quota_count, share_count);\n-    }\n-  } else if (quota_count != 0) {\n-    limit_count = quota_count;\n-  } else if (share_count != 0) {\n-    limit_count = share_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  if (PrintContainerInfo) {\n-    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n-  }\n-\n-  \/\/ Update the value and reset the cache timeout\n-  OSContainer::_active_processor_count = result;\n-  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-\n-  return result;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_max_usage_in_bytes();\n@@ -683,3 +119,2 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_cpus();\n@@ -689,3 +124,7 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_memory_nodes();\n+}\n+\n+int OSContainer::active_processor_count() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->active_processor_count();\n@@ -694,10 +133,0 @@\n-\/* cpu_quota\n- *\n- * Return the number of milliseconds per period\n- * process is guaranteed to run.\n- *\n- * return:\n- *    quota time in milliseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -705,3 +134,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: %d\", \"%d\", quota);\n-  return quota;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_quota();\n@@ -711,3 +139,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: %d\", \"%d\", period);\n-  return period;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_period();\n@@ -716,10 +143,0 @@\n-\/* cpu_shares\n- *\n- * Return the amount of cpu shares available to the process\n- *\n- * return:\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -727,6 +144,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.shares\",\n-                     \"CPU Shares is: %d\", \"%d\", shares);\n-  \/\/ Convert 1024 to no shares setup\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_shares();\n@@ -734,1 +147,0 @@\n-\n","filename":"hotspot\/src\/os\/linux\/vm\/osContainer_linux.cpp","additions":36,"deletions":624,"binary":false,"changes":660,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-  static jlong uses_mem_hierarchy();\n@@ -69,1 +68,0 @@\n-  assert(_is_initialized, \"OSContainer not initialized\");\n@@ -73,1 +71,1 @@\n-#endif \/\/ OS_LINUX_VM_OSCONTAINER_LINUX_HPP\n+#endif \/\/ OS_LINUX_OSCONTAINER_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/osContainer_linux.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2287,1 +2287,1 @@\n-if (!OSContainer::is_containerized()) {\n+  if (!OSContainer::is_containerized()) {\n","filename":"hotspot\/src\/os\/linux\/vm\/os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  friend class CgroupSubsystem;\n","filename":"hotspot\/src\/os\/linux\/vm\/os_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,3 +108,1 @@\n-  this->record_stack_base_and_size();\n-  this->initialize_thread_local_storage();\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n+  initialize_in_thread();\n@@ -226,6 +224,0 @@\n-void ConcurrentMarkSweepThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/concurrentMarkSweep\/concurrentMarkSweepThread.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -97,2 +97,0 @@\n-  void print_on(outputStream* st) const;\n-  void print() const                                  { print_on(tty); }\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/concurrentMarkSweep\/concurrentMarkSweepThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+\n+  \/\/ set name\n+  set_name(\"G1 Concurrent Refinement Thread#%d\", worker_id);\n@@ -250,9 +253,0 @@\n-void ConcurrentG1RefineThread::print() const {\n-  print_on(tty);\n-}\n-\n-void ConcurrentG1RefineThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"G1 Concurrent Refinement Thread#%d\\\" \", _worker_id);\n-  Thread::print_on(st);\n-  st->cr();\n-}\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/concurrentG1RefineThread.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,4 +80,0 @@\n-  \/\/ Printing\n-  void print() const;\n-  void print_on(outputStream* st) const;\n-\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/concurrentG1RefineThread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+  set_name(\"G1 Main Concurrent Mark GC Thread\");\n@@ -321,10 +323,0 @@\n-void ConcurrentMarkThread::print() const {\n-  print_on(tty);\n-}\n-\n-void ConcurrentMarkThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"G1 Main Concurrent Mark GC Thread\\\" \");\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/concurrentMarkThread.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,4 +69,0 @@\n-  \/\/ Printing\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/concurrentMarkThread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,6 +56,0 @@\n-void G1StringDedupThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/g1StringDedupThread.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  virtual void print_on(outputStream* st) const;\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/g1StringDedupThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,6 +92,0 @@\n-void GCTaskThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n@@ -107,0 +101,1 @@\n+  this->initialize_named_thread();\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/parallelScavenge\/gcTaskThread.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-  void print_on(outputStream* st) const;\n-  void print() const                                { print_on(tty); }\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/parallelScavenge\/gcTaskThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+  this->initialize_named_thread();\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/shared\/concurrentGCThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1441,1 +1441,1 @@\n-    new_value = align_size_down(max_uintx, Metaspace::commit_alignment());\n+    new_value = align_size_down(max_uintx, Metaspace::reserve_alignment());\n","filename":"hotspot\/src\/share\/vm\/memory\/metaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-      record_method_not_compilable_all_tiers(\"cannot parse method\");\n+      record_method_not_compilable(\"cannot parse method\");\n","filename":"hotspot\/src\/share\/vm\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -736,4 +736,3 @@\n-  void record_method_not_compilable(const char* reason, bool all_tiers = false) {\n-    \/\/ All bailouts cover \"all_tiers\" when TieredCompilation is off.\n-    if (!TieredCompilation) all_tiers = true;\n-    env()->record_method_not_compilable(reason, all_tiers);\n+  void record_method_not_compilable(const char* reason) {\n+    \/\/ Bailouts cover \"all_tiers\" when TieredCompilation is off.\n+    env()->record_method_not_compilable(reason, !TieredCompilation);\n@@ -743,3 +742,0 @@\n-  void record_method_not_compilable_all_tiers(const char* reason) {\n-    record_method_not_compilable(reason, true);\n-  }\n","filename":"hotspot\/src\/share\/vm\/opto\/compile.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-      C->record_method_not_compilable_all_tiers(\"unsupported incoming calling sequence\");\n+      C->record_method_not_compilable(\"unsupported incoming calling sequence\");\n@@ -1142,1 +1142,1 @@\n-      C->record_method_not_compilable_all_tiers(\"unsupported calling sequence\");\n+      C->record_method_not_compilable(\"unsupported calling sequence\");\n@@ -1321,1 +1321,1 @@\n-      C->record_method_not_compilable_all_tiers(\"unsupported outgoing calling sequence\");\n+      C->record_method_not_compilable(\"unsupported outgoing calling sequence\");\n@@ -1509,1 +1509,1 @@\n-    C->record_method_not_compilable_all_tiers(\"Out of stack space, increase MaxLabelRootDepth\");\n+    C->record_method_not_compilable(\"Out of stack space, increase MaxLabelRootDepth\");\n","filename":"hotspot\/src\/share\/vm\/opto\/matcher.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-    C->record_method_not_compilable_all_tiers(_flow->failure_reason());\n+    C->record_method_not_compilable(_flow->failure_reason());\n@@ -1083,1 +1083,1 @@\n-    C->record_method_not_compilable_all_tiers(\"too many local variables\");\n+    C->record_method_not_compilable(\"too many local variables\");\n","filename":"hotspot\/src\/share\/vm\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#endif\n+\n@@ -165,1 +170,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -587,0 +591,12 @@\n+#ifdef LINUX\n+bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* cg_flags) {\n+  CgroupInfo cg_infos[4];\n+  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+                                                    proc_self_cgroup,\n+                                                    proc_self_mountinfo, cg_flags);\n+}\n+#endif\n+\n@@ -1205,0 +1221,25 @@\n+WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,\n+                                    jobject o,\n+                                    jstring proc_cgroups,\n+                                    jstring proc_self_cgroup,\n+                                    jstring proc_self_mountinfo))\n+  jint ret = 0;\n+#ifdef LINUX\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  u1 cg_type_flags = 0;\n+  \/\/ This sets cg_type_flags\n+  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  ret = (jint)cg_type_flags;\n+  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);\n+  env->ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);\n+#endif\n+  return ret;\n+WB_END\n+\n@@ -1335,0 +1376,3 @@\n+  {CC\"validateCgroup\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_ValidateCgroup },\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+#ifdef LINUX\n+  static bool validate_cgroup(const char* proc_cgroups, const char* proc_self_cgroup, const char* proc_self_mountinfo, u1* cg_flags);\n+#endif\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1234,0 +1234,11 @@\n+void NamedThread::initialize_named_thread() {\n+  set_native_thread_name(name());\n+}\n+\n+void NamedThread::print_on(outputStream* st) const {\n+  st->print(\"\\\"%s\\\" \", name());\n+  Thread::print_on(st);\n+  st->cr();\n+}\n+\n+\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-  void print_on(outputStream* st) const;\n+  virtual void print_on(outputStream* st) const;\n@@ -712,0 +712,1 @@\n+  void initialize_named_thread();\n@@ -716,0 +717,1 @@\n+  virtual void print_on(outputStream* st) const;\n@@ -760,1 +762,0 @@\n-  void print() const { print_on(tty); }\n@@ -1467,1 +1468,0 @@\n-  void print() const { print_on(tty); }\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  this->set_native_thread_name(this->name());\n+  this->initialize_named_thread();\n@@ -358,6 +358,0 @@\n-void VMThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n","filename":"hotspot\/src\/share\/vm\/runtime\/vmThread.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,3 +134,0 @@\n-  \/\/ Debugging\n-  void print_on(outputStream* st) const;\n-  void print() const                              { print_on(tty); }\n","filename":"hotspot\/src\/share\/vm\/runtime\/vmThread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+# include <stdint.h>\n@@ -45,0 +46,3 @@\n+#if _MSC_VER >= 1800\n+# include <inttypes.h>\n+#endif\n@@ -80,24 +84,0 @@\n-\/\/ Some MS Visual Studio versions do not seem to have INT64_C and UINT64_C\n-\/\/ even with __STDC_CONSTANT_MACROS defined.\n-#ifndef INT64_C\n-#define INT64_C(c)  (c ## i64)\n-#endif\n-#ifndef UINT64_C\n-#define UINT64_C(c) (c ## ui64)\n-#endif\n-\n-\/\/ Compiler-specific primitive types\n-typedef unsigned __int8  uint8_t;\n-typedef unsigned __int16 uint16_t;\n-typedef unsigned __int32 uint32_t;\n-typedef unsigned __int64 uint64_t;\n-\n-#ifdef _WIN64\n-typedef unsigned __int64 uintptr_t;\n-#else\n-typedef unsigned int uintptr_t;\n-#endif\n-typedef signed   __int8  int8_t;\n-typedef signed   __int16 int16_t;\n-typedef signed   __int32 int32_t;\n-typedef signed   __int64 int64_t;\n@@ -105,2 +85,1 @@\n-typedef signed   __int64 intptr_t;\n-typedef signed   __int64 ssize_t;\n+typedef int64_t ssize_t;\n@@ -108,10 +87,1 @@\n-typedef signed   int intptr_t;\n-typedef signed   int ssize_t;\n-#endif\n-\n-#ifndef UINTPTR_MAX\n-#ifdef _WIN64\n-#define UINTPTR_MAX _UI64_MAX\n-#else\n-#define UINTPTR_MAX _UI32_MAX\n-#endif\n+typedef int32_t ssize_t;\n@@ -123,4 +93,4 @@\n-typedef unsigned char    jubyte;\n-typedef unsigned short   jushort;\n-typedef unsigned int     juint;\n-typedef unsigned __int64 julong;\n+typedef uint8_t  jubyte;\n+typedef uint16_t jushort;\n+typedef uint32_t juint;\n+typedef uint64_t julong;\n@@ -213,1 +183,1 @@\n-\/\/ Visual Studio doesn't provide inttypes.h so provide appropriate definitions here.\n+\/\/ Visual Studio 2010-2012 doesn't provide inttypes.h so provide appropriate definitions here.\n@@ -215,0 +185,1 @@\n+#if _MSC_VER < 1800\n@@ -232,0 +203,1 @@\n+#endif\n","filename":"hotspot\/src\/share\/vm\/utilities\/globalDefinitions_visCPP.hpp","additions":13,"deletions":41,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,0 +248,1 @@\n+  this->initialize_named_thread();\n","filename":"hotspot\/src\/share\/vm\/utilities\/workgroup.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,11 +56,16 @@\n-compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64\n+compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMTotalCountIncrRate.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMAfterLockInflation.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMForInflatedLocks.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMForStackLocks.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/method_options\/TestUseRTMLockElidingOption.java 8183263 generic-x64,generic-i586\n","filename":"hotspot\/test\/ProblemList.txt","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8271459\n+ * @summary C2 applies string opts to StringBuilder object created with a negative size and misses the NegativeArraySizeException.\n+ * @run testng TestNegativeStringBuilderCapacity\n+ *\/\n+public class TestNegativeStringBuilderCapacity {\n+\n+    static final int pass_count = 10000;\n+\n+    static final String doIdenticalPositiveConst() throws Throwable {\n+        \/\/ C2 knows that argument is 5 and applies string opts without runtime check.\n+        StringBuilder sb = new StringBuilder(5); \/\/ StringBuilder object optimized away by string opts.\n+        return sb.toString(); \/\/ Call optimized away by string opts.\n+    }\n+\n+    @Test\n+    public static final void testIdenticalPositiveConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doIdenticalPositiveConst();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    static final String doIdenticalNegativeConst() throws Throwable {\n+        \/\/ C2 knows that we always have a negative int -> bail out of string opts\n+        StringBuilder sb = new StringBuilder(-5);\n+        return sb.toString(); \/\/ Call stays due to bailout.\n+    }\n+\n+    @Test\n+    public static final void testIdenticalNegativeConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doIdenticalNegativeConst();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count));\n+    }\n+\n+    static int aField;\n+\n+    static final String doField() throws Throwable {\n+        \/\/ C2 does not know if iFld is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter\n+        StringBuilder sb = new StringBuilder(aField);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    public static final void testPositiveField() {\n+        aField = 4;\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doField();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    @Test\n+    public static final void testNegativeField() {\n+        aField = -4;\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doField();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count));\n+    }\n+\n+    static final String doPossiblyNegativeConst(boolean flag) throws Throwable {\n+        \/\/ C2 knows that cap is between -5 and 5. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is sometimes taken and sometimes not.\n+        final int capacity = flag ? 5 : -5;\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    public static final void testPossiblyNegativeConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doPossiblyNegativeConst((pass % 2) == 0);\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count\/2, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count\/2));\n+    }\n+\n+    static final String doPositiveConst(boolean flag) throws Throwable {\n+        \/\/ C2 knows that cap is between 1 and 100 and applies string opts without runtime check.\n+        final int capacity = flag ? 1 : 100;\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    public static final void testPositiveConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doPositiveConst((pass % 2) == 0);\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    static final String doArg(int capacity) throws Throwable {\n+        \/\/ C2 does not know if cap is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is always taken because cap is always negative.\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    public static final void testArg() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doArg((pass % 2) == 0 ? 3 : -3 );\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count\/2, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count\/2));\n+    }\n+}\n","filename":"hotspot\/test\/compiler\/c2\/TestNegativeStringBuilderCapacity.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -76,1 +76,1 @@\n-$cc_cmd -fPIC -shared -o libCNCheckLongArgs.so \\\n+$cc_cmd ${CFLAGBITS} -fPIC -shared -o libCNCheckLongArgs.so \\\n","filename":"hotspot\/test\/compiler\/criticalnatives\/argumentcorruption\/Test8167409.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-$gcc_cmd -fPIC -shared -c -o test.o \\\n+$gcc_cmd ${CFLAGBITS} -fPIC -shared -c -o test.o \\\n","filename":"hotspot\/test\/runtime\/7107135\/Test7107135.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-CFLAGS=\"-m${VM_BITS}\"\n-\n@@ -62,1 +60,0 @@\n-echo \"Compilation flag: ${COMP_FLAG}\"\n@@ -67,1 +64,1 @@\n-$gcc_cmd -DLINUX ${CFLAGS} -o invoke \\\n+$gcc_cmd -DLINUX ${CFLAGBITS} -o invoke \\\n","filename":"hotspot\/test\/runtime\/InitialThreadOverflow\/testme.sh","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2020, Red Hat, Inc. All rights reserved.\n@@ -41,0 +41,4 @@\n+    if (!Platform.is64bit()) {\n+        System.out.println(\"Test requires 64-bit JVM. Skipping...\");\n+        return;\n+    }\n","filename":"hotspot\/test\/runtime\/NMT\/HugeArenaTracking.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main DefaultUseWithClient\n+ * @run main\/othervm -client DefaultUseWithClient\n@@ -41,3 +41,3 @@\n-        boolean is32BitWindows = (Platform.isWindows() && Platform.is32bit());\n-        if (!is32BitWindows) {\n-            System.out.println(\"Test only applicable on 32-bit Windows. Skipping\");\n+        boolean is32BitWindowsClient = (Platform.isWindows() && Platform.is32bit() && Platform.isClient());\n+        if (!is32BitWindowsClient) {\n+            System.out.println(\"Test only applicable on 32-bit Windows Client VM. Skipping\");\n","filename":"hotspot\/test\/runtime\/SharedArchiveFile\/DefaultUseWithClient.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,5 +52,0 @@\n-if [ \"x${VM_CPU}\" != \"xaarch64\" ];\n-then\n-    CFLAGS=\"-m${VM_BITS}\"\n-fi\n-\n@@ -65,1 +60,0 @@\n-echo \"Compilation flag: ${COMP_FLAG}\"\n@@ -70,1 +64,1 @@\n-$gcc_cmd -DLINUX ${CFLAGS} -o stack-gap \\\n+$gcc_cmd -DLINUX ${CFLAGBITS} -o stack-gap \\\n","filename":"hotspot\/test\/runtime\/StackGap\/testme.sh","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CgroupSubsystemFactory\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build CgroupSubsystemFactory\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import com.oracle.java.testlibrary.Asserts;\n+import com.oracle.java.testlibrary.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * Verify hotspot's detection heuristics of CgroupSubsystemFactory::create()\n+ *\/\n+public class CgroupSubsystemFactory {\n+\n+    \/\/ Mirrored from hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp\n+    private static final int CGROUPS_V1 = 1;\n+    private static final int CGROUPS_V2 = 2;\n+    private static final int INVALID_CGROUPS_V2 = 3;\n+    private static final int INVALID_CGROUPS_V1 = 4;\n+    private static final int INVALID_CGROUPS_NO_MOUNT = 5;\n+    private Path existingDirectory;\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1SelfCgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoDoubleCpuset;\n+    private Path cgroupv1MntInfoDoubleCpuset2;\n+    private Path cgroupv1MntInfoSystemdOnly;\n+    private String mntInfoEmpty = \"\";\n+    private Path cgroupV1SelfCgroup;\n+    private Path cgroupV2SelfCgroup;\n+    private Path cgroupV2MntInfoMissingCgroupv2;\n+    private Path cgroupv1MntInfoMissingMemoryController;\n+    private String procSelfCgroupHybridContent = \"11:hugetlb:\/\\n\" +\n+            \"10:devices:\/user.slice\\n\" +\n+            \"9:pids:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"8:cpu,cpuacct:\/\\n\" +\n+            \"7:perf_event:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/\\n\" +\n+            \"4:net_cls,net_prio:\/\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:memory:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\\n\" +\n+            \"0::\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\";\n+    private String procSelfCgroupV2UnifiedContent = \"0::\/user.slice\/user-1000.slice\/session-3.scope\";\n+    private String procSelfCgroupV1JoinControllers =\n+            \"9:freezer:\/\\n\" +\n+            \"8:rdma:\/\\n\" +\n+            \"7:blkio:\/user.slice\\n\" +\n+            \"6:devices:\/user.slice\\n\" +\n+            \"5:pids:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"4:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:perf_event:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-2.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-2.scope\\n\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\";\n+    private String mntInfoHybridStub =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+    private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;\n+    private String mntInfoHybridMissingMemory = mntInfoHybridStub;\n+    private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;\n+    private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpusets rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupv1DoubleCpuset = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n+    private String mntInfoCgroupv1DoubleCpuset2 =  mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  3   1   1\\n\" +\n+            \"cpu 8   1   1\\n\" +\n+            \"cpuacct 8   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n+\n+    private void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero_cgroupv2_last\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder.getBytes());\n+\n+            cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_hybrid\");\n+            Files.write(cgroupV1SelfCgroup, procSelfCgroupHybridContent.getBytes());\n+\n+            cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_v2\");\n+            Files.write(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent.getBytes());\n+\n+            cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), \"mnt_info_missing_memory\");\n+            Files.write(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory.getBytes());\n+\n+            cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), \"mnt_info_missing_cgroup2\");\n+            Files.write(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpuset = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_double_cpuset\");\n+            Files.write(cgroupv1MntInfoDoubleCpuset, mntInfoCgroupv1DoubleCpuset.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpuset2 = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_double_cpuset2\");\n+            Files.write(cgroupv1MntInfoDoubleCpuset2, mntInfoCgroupv1DoubleCpuset2.getBytes());\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_systemd_only\");\n+            Files.write(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly.getBytes());\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.write(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers.getBytes());\n+\n+            cgroupv1SelfCgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.write(cgroupv1SelfCgroupsJoinControllers, procSelfCgroupV1JoinControllers.getBytes());\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.write(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void teardown() {\n+        try {\n+            deleteFileTree(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    private static void deleteFileTree(Path dir) throws IOException {\n+        java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private boolean isValidCgroup(int value) {\n+        return value == CGROUPS_V1 || value == CGROUPS_V2;\n+    }\n+\n+    public void testCgroupv1JoinControllerCombo(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String procSelfCgroup = cgroupv1SelfCgroupsJoinControllers.toString();\n+        String procSelfMountinfo = cgroupv1MountInfoJoinControllers.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Join controllers should be properly detected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1JoinControllerMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv1MultipleCpusetMounts(WhiteBox wb, Path mountInfo) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = mountInfo.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Multiple cpuset controllers, but only one in \/sys\/fs\/cgroup\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MultipleCpusetMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv1SystemdOnly(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoSystemdOnly.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"Only systemd mounted. Invalid\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1SystemdOnly PASSED!\");\n+    }\n+\n+    public void testCgroupv1NoMounts(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"No cgroups mounted in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1NoMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V2, retval, \"No cgroup2 filesystem in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2NoCgroup2Fs PASSED!\");\n+    }\n+\n+    public void testCgroupv1MissingMemoryController(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V1, retval, \"Required memory controller path missing in mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MissingMemoryController PASSED!\");\n+    }\n+\n+    public void testCgroupv2(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"Expected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2 PASSED!\");\n+    }\n+\n+    public void testCgroupV1Hybrid(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1Hybrid PASSED!\");\n+    }\n+\n+    public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1HybridMntInfoOrder PASSED!\");\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        CgroupSubsystemFactory test = new CgroupSubsystemFactory();\n+        test.setup();\n+        try {\n+            test.testCgroupv1SystemdOnly(wb);\n+            test.testCgroupv1NoMounts(wb);\n+            test.testCgroupv2(wb);\n+            test.testCgroupV1Hybrid(wb);\n+            test.testCgroupV1HybridMntInfoOrder(wb);\n+            test.testCgroupv1MissingMemoryController(wb);\n+            test.testCgroupv2NoCgroup2Fs(wb);\n+            test.testCgroupv1MultipleCpusetMounts(wb, test.cgroupv1MntInfoDoubleCpuset);\n+            test.testCgroupv1MultipleCpusetMounts(wb, test.cgroupv1MntInfoDoubleCpuset2);\n+            test.testCgroupv1JoinControllerCombo(wb);\n+        } finally {\n+            test.teardown();\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test PlainRead\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build PlainRead\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n+ *\/\n+\n+import com.oracle.java.testlibrary.ProcessTools;\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n+import com.oracle.java.testlibrary.Platform;\n+import sun.hotspot.WhiteBox;\n+\n+public class PlainRead {\n+\n+    static public void match(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static final String good_value = \"(\\\\d+|-1|-2|Unlimited)\";\n+    static final String bad_value = \"(failed)\";\n+\n+    static final String[] variables = {\"Memory Limit is:\", \"CPU Shares is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n+\n+    static public void isContainer(OutputAnalyzer oa) {\n+        for (String v: variables) {\n+            match(oa, v, good_value);\n+        }\n+        for (String v: variables) {\n+            noMatch(oa, v, bad_value);\n+        }\n+    }\n+\n+    static public void isNotContainer(OutputAnalyzer oa) {\n+       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintContainerInfo\", \"-version\");\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        if (wb.isContainerized()) {\n+            System.out.println(\"Inside a cgroup, testing...\");\n+            isContainer(output);\n+        } else {\n+            System.out.println(\"Not in a cgroup, testing...\");\n+            isNotContainer(output);\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/PlainRead.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -32,0 +33,8 @@\n+        Metrics metrics = jdk.internal.platform.Container.metrics();\n+        System.out.println(\"Metrics instance: \" + (metrics == null ? \"null\" : \"non-null\"));\n+        if (metrics != null) {\n+            System.out.println(\"Metrics.getMemoryAndSwapLimit() == \" + metrics.getMemoryAndSwapLimit());\n+            System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n+            System.out.println(\"Metrics.getMemoryAndSwapUsage() == \" + metrics.getMemoryAndSwapUsage());\n+            System.out.println(\"Metrics.getMemoryUsage() == \" + metrics.getMemoryUsage());\n+        }\n","filename":"hotspot\/test\/runtime\/containers\/docker\/CheckOperatingSystemMXBean.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n@@ -211,3 +212,15 @@\n-        Common.run(opts)\n-            .shouldMatch(\"CPU Shares is.*\" + shares)\n-            .shouldMatch(\"active_processor_count.*\" + expectedAPC);\n+        OutputAnalyzer out = Common.run(opts);\n+        \/\/ Cgroups v2 needs to do some scaling of raw shares values. Hence,\n+        \/\/ 256 CPU shares come back as 264. Raw value written to cpu.weight\n+        \/\/ is 10. The reason this works for >= 1024 shares value is because\n+        \/\/ post-scaling the closest multiple of 1024 is found and returned.\n+        \/\/\n+        \/\/ For values < 1024, this doesn't happen so loosen the match to a\n+        \/\/ 3-digit number and ensure the active_processor_count is as\n+        \/\/ expected.\n+        if (shares < 1024) {\n+            out.shouldMatch(\"CPU Shares is.*\\\\d{3}\");\n+        } else {\n+            out.shouldMatch(\"CPU Shares is.*\" + shares);\n+        }\n+        out.shouldMatch(\"active_processor_count.*\" + expectedAPC);\n","filename":"hotspot\/test\/runtime\/containers\/docker\/TestCPUAwareness.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-$cc_cmd -fPIC -shared -o libCallWithJNIWeak.so \\\n+$cc_cmd ${CFLAGBITS} -fPIC -shared -o libCallWithJNIWeak.so \\\n","filename":"hotspot\/test\/runtime\/jni\/CallWithJNIWeak\/test.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-$cc_cmd -fPIC -shared -o libReturnJNIWeak.so \\\n+$cc_cmd ${CFLAGBITS} -fPIC -shared -o libReturnJNIWeak.so \\\n","filename":"hotspot\/test\/runtime\/jni\/ReturnJNIWeak\/test.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-$gcc_cmd -DLINUX -fPIC -shared \\\n+$gcc_cmd -DLINUX ${CFLAGBITS} -fPIC -shared \\\n","filename":"hotspot\/test\/runtime\/jsig\/Test8017498.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+CFLAGBITS=\"\"\n@@ -167,0 +168,2 @@\n+  else\n+    CFLAGBITS=\"-m32\"\n@@ -173,0 +176,1 @@\n+  CFLAGBITS=\"-m32\"\n@@ -196,0 +200,2 @@\n+  else\n+    CFLAGBITS=\"-m32\"\n","filename":"hotspot\/test\/test_env.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                return \"aarch64\/ubuntu\";\n+                return \"arm64v8\/ubuntu\";\n","filename":"hotspot\/test\/testlibrary\/com\/oracle\/java\/testlibrary\/DockerfileConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n@@ -373,0 +377,21 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n+\n","filename":"hotspot\/test\/testlibrary\/com\/oracle\/java\/testlibrary\/Utils.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -259,0 +259,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"hotspot\/test\/testlibrary\/whitebox\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"hotspot\/test\/testlibrary_tests\/whitebox\/vm_flags\/BooleanTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"hotspot\/test\/testlibrary_tests\/whitebox\/vm_flags\/DoubleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"hotspot\/test\/testlibrary_tests\/whitebox\/vm_flags\/StringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"hotspot\/test\/testlibrary_tests\/whitebox\/vm_flags\/Uint64Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"hotspot\/test\/testlibrary_tests\/whitebox\/vm_flags\/UintxTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,0 +266,5 @@\n+  $(eval $(call SetupCopyFiles,COPY_VCRUNTIME_1, \\\n+      DEST := $(JDK_OUTPUTDIR)\/bin, \\\n+      FILES := $(VCRUNTIME_1_DLL), \\\n+      MACRO := copy-and-chmod))\n+\n@@ -271,1 +276,1 @@\n-  COPY_FILES += $(COPY_MSVCR) $(COPY_MSVCP)\n+  COPY_FILES += $(COPY_MSVCR) $(COPY_VCRUNTIME_1) $(COPY_MSVCP)\n","filename":"jdk\/make\/CopyFiles.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022c\n+tzdata2022e\n","filename":"jdk\/make\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2257,0 +2257,11 @@\n+# From Issam Al-Zuwairi (2022-10-05):\n+# The Council of Ministers in Jordan decided Wednesday 5th October 2022,\n+# that daylight saving time (DST) will be throughout the year....\n+#\n+# From Brian Inglis (2022-10-06):\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=45567&lang=en&name=en_news\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Syria, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n+\n@@ -2288,2 +2299,2 @@\n-Rule\tJordan\t2014\tmax\t-\tOct\tlastFri\t0:00s\t0\t-\n-Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\t2022\t-\tOct\tlastFri\t0:00s\t0\t-\n+Rule\tJordan\t2022\tonly\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2292,1 +2303,2 @@\n-\t\t\t2:00\tJordan\tEE%sT\n+\t\t\t2:00\tJordan\tEE%sT\t2022 Oct 28 0:00s\n+\t\t\t3:00\t-\t+03\n@@ -3401,4 +3413,0 @@\n-#\n-# From Paul Eggert (2019-04-10):\n-# For now, guess spring-ahead transitions are at 00:00 on the Saturday\n-# preceding March's last Sunday (i.e., Sat>=24).\n@@ -3421,0 +3429,12 @@\n+# From Heba Hamad (2022-08-30):\n+# winter time will begin in Palestine from Saturday 10-29, 02:00 AM by\n+# 60 minutes backwards.  Also the state of Palestine adopted the summer\n+# and winter time for the years: 2023,2024,2025,2026 ...\n+# https:\/\/mm.icann.org\/pipermail\/tz\/attachments\/20220830\/9f024566\/Time-0001.pdf\n+# (2022-08-31): ... the Saturday before the last Sunday in March and October\n+# at 2:00 AM ,for the years from 2023 to 2026.\n+# (2022-09-05): https:\/\/mtit.pna.ps\/Site\/New\/1453\n+#\n+# From Paul Eggert (2022-08-31):\n+# For now, assume that this rule will also be used after 2026.\n+\n@@ -3451,2 +3471,2 @@\n-Rule Palestine\t2016\t2018\t-\tMar\tSat>=24\t1:00\t1:00\tS\n-Rule Palestine\t2016\t2018\t-\tOct\tSat>=24\t1:00\t0\t-\n+Rule Palestine\t2016\t2018\t-\tMar\tSat<=30\t1:00\t1:00\tS\n+Rule Palestine\t2016\t2018\t-\tOct\tSat<=30\t1:00\t0\t-\n@@ -3454,2 +3474,2 @@\n-Rule Palestine\t2019\tonly\t-\tOct\tSat>=24\t0:00\t0\t-\n-Rule Palestine\t2020\t2021\t-\tMar\tSat>=24\t0:00\t1:00\tS\n+Rule Palestine\t2019\tonly\t-\tOct\tSat<=30\t0:00\t0\t-\n+Rule Palestine\t2020\t2021\t-\tMar\tSat<=30\t0:00\t1:00\tS\n@@ -3457,2 +3477,4 @@\n-Rule Palestine\t2021\tmax\t-\tOct\tFri>=23\t1:00\t0\t-\n-Rule Palestine\t2022\tmax\t-\tMar\tSun>=25\t0:00\t1:00\tS\n+Rule Palestine\t2021\tonly\t-\tOct\t29\t1:00\t0\t-\n+Rule Palestine\t2022\tonly\t-\tMar\t27\t0:00\t1:00\tS\n+Rule Palestine\t2022\tmax\t-\tOct\tSat<=30\t2:00\t0\t-\n+Rule Palestine\t2023\tmax\t-\tMar\tSat<=30\t2:00\t1:00\tS\n@@ -3831,2 +3853,9 @@\n-# From Arthur David Olson (2012-03-27):\n-# Assume last Friday in March going forward XXX.\n+# From Steffen Thorsen (2022-10-05):\n+# Syria is adopting year-round DST, starting this autumn....\n+# From https:\/\/www.enabbaladi.net\/archives\/607812\n+# \"This [the decision] came after the weekly government meeting today,\n+# Tuesday 4 October ...\"\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Jordan, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n@@ -3838,2 +3867,2 @@\n-Rule\tSyria\t2012\tmax\t-\tMar\tlastFri\t0:00\t1:00\tS\n-Rule\tSyria\t2009\tmax\t-\tOct\tlastFri\t0:00\t0\t-\n+Rule\tSyria\t2012\t2022\t-\tMar\tlastFri\t0:00\t1:00\tS\n+Rule\tSyria\t2009\t2022\t-\tOct\tlastFri\t0:00\t0\t-\n@@ -3843,1 +3872,2 @@\n-\t\t\t2:00\tSyria\tEE%sT\n+\t\t\t2:00\tSyria\tEE%sT\t2022 Oct 28 0:00\n+\t\t\t3:00\t-\t+03\n","filename":"jdk\/make\/data\/tzdata\/asia","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Uzhgorod\n+Link\tEurope\/Kyiv\t\tEurope\/Zaporozhye\n","filename":"jdk\/make\/data\/tzdata\/backward","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2641,4 +2641,8 @@\n-# From Paul Eggert (2014-03-30):\n-# Simferopol and Sevastopol reportedly changed their central town clocks\n-# late the previous day, but this appears to have been ceremonial\n-# and the discrepancies are small enough to not worry about.\n+# From Tim Parenti (2022-07-01), per Paul Eggert (2014-03-30):\n+# The clocks at the railway station in Simferopol were put forward from 22:00\n+# to 24:00 the previous day in a \"symbolic ceremony\"; however, per\n+# contemporaneous news reports, \"ordinary Crimeans [made] the daylight savings\n+# time switch at 2am\" on Sunday.\n+# https:\/\/www.business-standard.com\/article\/pti-stories\/crimea-to-set-clocks-to-russia-time-114033000014_1.html\n+# https:\/\/www.reuters.com\/article\/us-ukraine-crisis-crimea-time\/crimea-switches-to-moscow-time-amid-incorporation-frenzy-idUKBREA2S0LT20140329\n+# https:\/\/www.bbc.com\/news\/av\/world-europe-26806583\n@@ -3416,1 +3420,1 @@\n-Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1900 Dec 31 23:38:44\n+Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1901 Jan  1  0:00u\n@@ -3777,2 +3781,2 @@\n-# From Paul Eggert (2022-02-08):\n-# For now, assume that Ukraine's other three zones followed the same rules,\n+# From Paul Eggert (2022-08-27):\n+# For now, assume that Ukraine's zones all followed the same rules,\n@@ -3848,13 +3852,0 @@\n-# From Paul Eggert (2022-04-12):\n-# As is usual in tzdb, Ukrainian zones use the most common English spellings.\n-# In particular, tzdb's name Europe\/Kyiv uses the most common spelling in\n-# English for Ukraine's capital.  Although tzdb's former name was Europe\/Kiev,\n-# \"Kyiv\" is now more common due to widespread reporting of the current conflict.\n-# Conversely, tzdb continues to use the names Europe\/Uzhgorod and\n-# Europe\/Zaporozhye; this is similar to tzdb's use of Europe\/Prague, which is\n-# certainly wrong as a transliteration of the Czech \"Praha\".\n-# English-language spelling of Ukrainian names is in flux, and\n-# some day \"Uzhhorod\" or \"Zaporizhzhia\" may become substantially more\n-# common in English; in the meantime, do not change these\n-# English spellings as that means less disruption for our users.\n-\n@@ -3862,1 +3853,0 @@\n-# This represents most of Ukraine.  See above for the spelling of \"Kyiv\".\n@@ -3871,28 +3861,0 @@\n-\t\t\t2:00\tEU\tEE%sT\n-# Transcarpathia used CET 1990\/1991.\n-# \"Uzhhorod\" is the transliteration of the Rusyn\/Ukrainian pronunciation, but\n-# \"Uzhgorod\" is more common in English.\n-Zone Europe\/Uzhgorod\t1:29:12 -\tLMT\t1890 Oct\n-\t\t\t1:00\t-\tCET\t1940\n-\t\t\t1:00\tC-Eur\tCE%sT\t1944 Oct\n-\t\t\t1:00\t1:00\tCEST\t1944 Oct 26\n-\t\t\t1:00\t-\tCET\t1945 Jun 29\n-\t\t\t3:00\tRussia\tMSK\/MSD\t1990\n-\t\t\t3:00\t-\tMSK\t1990 Jul  1  2:00\n-\t\t\t1:00\t-\tCET\t1991 Mar 31  3:00\n-\t\t\t2:00\t-\tEET\t1992 Mar 20\n-\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n-\t\t\t2:00\tEU\tEE%sT\n-# Zaporozh'ye and eastern Lugansk oblasts observed DST 1990\/1991.\n-# \"Zaporizhzhia\" is the transliteration of the Ukrainian name, but\n-# \"Zaporozh'ye\" is more common in English.  Use the common English\n-# spelling, except omit the apostrophe as it is not allowed in\n-# portable Posix file names.\n-Zone Europe\/Zaporozhye\t2:20:40 -\tLMT\t1880\n-\t\t\t2:20\t-\t+0220\t1924 May  2\n-\t\t\t2:00\t-\tEET\t1930 Jun 21\n-\t\t\t3:00\t-\tMSK\t1941 Aug 25\n-\t\t\t1:00\tC-Eur\tCE%sT\t1943 Oct 25\n-\t\t\t3:00\tRussia\tMSK\/MSD\t1991 Mar 31  2:00\n-\t\t\t2:00\tE-Eur\tEE%sT\t1992 Mar 20\n-\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n","filename":"jdk\/make\/data\/tzdata\/europe","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 12:09:24\n+Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 18:00u\n@@ -474,1 +474,1 @@\n-Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 12:14:48\n+Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 19:00u\n@@ -484,1 +484,1 @@\n-Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT\t1883 Nov 18 12:14:21\n+Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT 1883 Nov 18 19:00u\n@@ -501,1 +501,1 @@\n-Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 12:12:53\n+Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 19:00u\n@@ -533,1 +533,1 @@\n-Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 12:00:04\n+Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 19:00u\n@@ -586,1 +586,1 @@\n-Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 12:07:02\n+Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 20:00u\n@@ -848,1 +848,1 @@\n-Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 11:31:42\n+Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 19:00u\n@@ -876,1 +876,1 @@\n-Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 12:15:11\n+Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 20:00u\n@@ -948,1 +948,1 @@\n-Zone America\/Indiana\/Indianapolis -5:44:38 - LMT\t1883 Nov 18 12:15:22\n+Zone America\/Indiana\/Indianapolis -5:44:38 - LMT 1883 Nov 18 18:00u\n@@ -968,1 +968,1 @@\n-Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 12:14:37\n+Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 18:00u\n@@ -992,1 +992,1 @@\n-Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 12:09:53\n+Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 18:00u\n@@ -1012,1 +1012,1 @@\n-Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 12:12:57\n+Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 18:00u\n@@ -1029,1 +1029,1 @@\n-Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 12:10:53\n+Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 18:00u\n@@ -1051,1 +1051,1 @@\n-Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 12:13:30\n+Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 18:00u\n@@ -1067,1 +1067,1 @@\n-Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 12:13:35\n+Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 18:00u\n@@ -1078,1 +1078,1 @@\n-Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 12:19:44\n+Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 18:00u\n@@ -1114,1 +1114,1 @@\n-Zone America\/Kentucky\/Louisville -5:43:02 -\tLMT\t1883 Nov 18 12:16:58\n+Zone America\/Kentucky\/Louisville -5:43:02 - LMT\t1883 Nov 18 18:00u\n@@ -1148,1 +1148,1 @@\n-Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 12:20:36\n+Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 18:00u\n@@ -2643,0 +2643,2 @@\n+Rule\tMexico\t1931\tonly\t-\tMay\t1\t23:00\t1:00\tD\n+Rule\tMexico\t1931\tonly\t-\tOct\t1\t0:00\t0\tS\n@@ -2659,1 +2661,1 @@\n-Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  0:12:56\n+Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  6:00u\n@@ -2665,1 +2667,1 @@\n-Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  0:01:32\n+Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  6:00u\n@@ -2679,1 +2681,1 @@\n-Zone America\/Matamoros\t-6:40:00 -\tLMT\t1921 Dec 31 23:20:00\n+Zone America\/Matamoros\t-6:30:00 -\tLMT\t1922 Jan  1  6:00u\n@@ -2685,1 +2687,1 @@\n-Zone America\/Monterrey\t-6:41:16 -\tLMT\t1921 Dec 31 23:18:44\n+Zone America\/Monterrey\t-6:41:16 -\tLMT\t1922 Jan  1  6:00u\n@@ -2690,1 +2692,1 @@\n-Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  0:23:24\n+Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  7:00u\n@@ -2693,3 +2695,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2703,1 +2703,1 @@\n-Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  0:02:20\n+Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2706,3 +2706,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2715,1 +2713,1 @@\n-Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1921 Dec 31 23:55:40\n+Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1922 Jan  1  7:00u\n@@ -2718,3 +2716,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2726,1 +2722,1 @@\n-Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1921 Dec 31 23:36:08\n+Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1922 Jan  1  7:00u\n@@ -2729,3 +2725,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2766,1 +2760,1 @@\n-Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1921 Dec 31 23:54:20\n+Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2769,3 +2763,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2778,1 +2770,1 @@\n-Zone America\/Bahia_Banderas\t-7:01:00 -\tLMT\t1921 Dec 31 23:59:00\n+Zone America\/Bahia_Banderas -7:01:00 -\tLMT\t1922 Jan  1  7:00u\n@@ -2781,3 +2773,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2791,1 +2781,1 @@\n-Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  0:11:56\n+Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  7:00u\n","filename":"jdk\/make\/data\/tzdata\/northamerica","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1335,2 +1335,8 @@\n-# we will have a voting whether to approve a new Constitution....\n-# https:\/\/www.interior.gob.cl\/noticias\/2022\/08\/09\/comunicado-el-proximo-sabado-10-de-septiembre-los-relojes-se-deben-adelantar-una-hora\/\n+# we will have a voting whether to approve a new Constitution.\n+#\n+# From Eduardo Romero Urra (2022-08-17):\n+# https:\/\/www.diariooficial.interior.gob.cl\/publicaciones\/2022\/08\/13\/43327\/01\/2172567.pdf\n+#\n+# From Paul Eggert (2022-08-17):\n+# Although the presidential decree stops at fall 2026, assume that\n+# similar DST rules will continue thereafter.\n","filename":"jdk\/make\/data\/tzdata\/southamerica","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -427,2 +427,0 @@\n-UA\t+4837+02218\tEurope\/Uzhgorod\tTranscarpathia\n-UA\t+4750+03510\tEurope\/Zaporozhye\tZaporozhye and east Lugansk\n","filename":"jdk\/make\/data\/tzdata\/zone.tab","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  # Linux-only symbol Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport\n+  # Linux-only symbol Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport\n@@ -269,0 +269,3 @@\n+  ifeq ($(OPENJDK_TARGET_OS), macosx)\n+    ZLIB_CPPFLAGS += -DHAVE_UNISTD_H\n+  endif\n@@ -388,0 +391,3 @@\n+  ifneq ($(VCRUNTIME_1_DLL), )\n+    LIBJLI_CFLAGS += -DVCRUNTIME_1_DLL_NAME='\"$(notdir $(VCRUNTIME_1_DLL))\"'\n+  endif\n","filename":"jdk\/make\/lib\/CoreLibraries.gmk","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-\t\tJava_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport;\n+\t\tJava_jdk_internal_platform_CgroupMetrics_isUseContainerSupport;\n","filename":"jdk\/make\/mapfiles\/libjava\/mapfile-linux","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Data structure to hold info from \/proc\/self\/cgroup,\n+ * \/proc\/cgroups and \/proc\/self\/mountinfo\n+ *\n+ * man 7 cgroups\n+ *\n+ * @see CgroupSubsystemFactory\n+ *\/\n+public class CgroupInfo {\n+\n+    private final String name;\n+    private final int hierarchyId;\n+    private final boolean enabled;\n+    private String mountPoint;\n+    private String mountRoot;\n+    private String cgroupPath;\n+\n+    private CgroupInfo(String name, int hierarchyId, boolean enabled) {\n+        this.name = name;\n+        this.hierarchyId = hierarchyId;\n+        this.enabled = enabled;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getHierarchyId() {\n+        return hierarchyId;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public String getMountPoint() {\n+        return mountPoint;\n+    }\n+\n+    public void setMountPoint(String mountPoint) {\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public String getMountRoot() {\n+        return mountRoot;\n+    }\n+\n+    public void setMountRoot(String mountRoot) {\n+        this.mountRoot = mountRoot;\n+    }\n+\n+    public String getCgroupPath() {\n+        return cgroupPath;\n+    }\n+\n+    public void setCgroupPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+    }\n+\n+    \/*\n+     * Creates a CgroupInfo instance from a line in \/proc\/cgroups.\n+     * Comment token (hash) is handled by the caller.\n+     *\n+     * Example (annotated):\n+     *\n+     * #subsys_name     hierarchy       num_cgroups     enabled\n+     * cpuset           10              1               1         (a)\n+     * cpu              7               8               1         (b)\n+     * [...]\n+     *\n+     * Line (a) would yield:\n+     *   info = new CgroupInfo(\"cpuset\", 10, true);\n+     *   return info;\n+     * Line (b) results in:\n+     *   info = new CgroupInfo(\"cpu\", 7, true);\n+     *   return info;\n+     *\n+     *\n+     * See CgroupSubsystemFactory.determineType()\n+     *\n+     *\/\n+    static CgroupInfo fromCgroupsLine(String line) {\n+        String[] tokens = line.split(\"\\\\s+\");\n+        if (tokens.length != 4) {\n+            return null;\n+        }\n+        \/\/ discard 3'rd field, num_cgroups\n+        return new CgroupInfo(tokens[0] \/* name *\/,\n+                              Integer.parseInt(tokens[1]) \/* hierarchyId *\/,\n+                              (Integer.parseInt(tokens[3]) == 1) \/* enabled *\/);\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.util.Objects;\n+\n+public class CgroupMetrics implements Metrics {\n+\n+    private final CgroupSubsystem subsystem;\n+\n+    CgroupMetrics(CgroupSubsystem subsystem) {\n+        this.subsystem = Objects.requireNonNull(subsystem);\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return subsystem.getProvider();\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        return subsystem.getCpuUsage();\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return subsystem.getPerCpuUsage();\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        return subsystem.getCpuUserUsage();\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        return subsystem.getCpuSystemUsage();\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return subsystem.getCpuPeriod();\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return subsystem.getCpuQuota();\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        return subsystem.getCpuShares();\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return subsystem.getCpuNumPeriods();\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return subsystem.getCpuNumThrottled();\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return subsystem.getCpuThrottledTime();\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return subsystem.getEffectiveCpuCount();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        return subsystem.getCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        return subsystem.getEffectiveCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        return subsystem.getCpuSetMems();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        return subsystem.getEffectiveCpuSetMems();\n+    }\n+\n+    public long getMemoryFailCount() {\n+        return subsystem.getMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        return subsystem.getMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return subsystem.getMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return subsystem.getTcpMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        return subsystem.getMemoryAndSwapLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return subsystem.getMemoryAndSwapUsage();\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        return subsystem.getMemorySoftLimit();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return subsystem.getBlkIOServiceCount();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return subsystem.getBlkIOServiced();\n+    }\n+\n+    public static Metrics getInstance() {\n+        if (!isUseContainerSupport()) {\n+            \/\/ Return null on -XX:-UseContainerSupport\n+            return null;\n+        }\n+        return CgroupSubsystemFactory.create();\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Marker interface for cgroup-based metrics\n+ *\n+ *\/\n+public interface CgroupSubsystem extends Metrics {\n+\n+    \/**\n+     * Returned for metrics of type long if the underlying implementation\n+     * has determined that no limit is being imposed.\n+     *\/\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Cgroup version agnostic controller logic\n+ *\n+ *\/\n+public interface CgroupSubsystemController {\n+\n+    public static final String EMPTY_STR = \"\";\n+\n+    public String path();\n+\n+    \/**\n+     * getStringValue\n+     *\n+     * Return the first line of the file \"param\" argument from the controller.\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @return Returns the contents of the file specified by param or null if\n+     *         an error occurs.\n+     *\/\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        if (controller == null) return null;\n+\n+        try {\n+            return CgroupUtil.readStringValue(controller, param);\n+        }\n+        catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Get an entry from file \"param\" within the \"controller\" directory path\n+     * which matches string \"match\". Applies \"conversion\" to the matching line.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param match\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The long value as derived by applying \"conversion\" to the matching\n+     *         line or \"defaultRetval\" if there was an error or no match found.\n+     *\/\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                     String param,\n+                                                     String match,\n+                                                     Function<String, Long> conversion,\n+                                                     long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (controller == null) {\n+            return retval;\n+        }\n+        try {\n+            Path filePath = Paths.get(controller.path(), param);\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            for (String line : lines) {\n+                if (line.startsWith(match)) {\n+                    retval = conversion.apply(line);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore. Default is unlimited.\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * Get a long value from directory \"controller\" and file \"param\", by\n+     * applying \"conversion\" to the string value within the file.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The converted long value or \"defaultRetval\" if there was an\n+     *         error.\n+     *\/\n+    public static long getLongValue(CgroupSubsystemController controller,\n+                                    String param,\n+                                    Function<String, Long> conversion,\n+                                    long defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+        if (strval == null) return defaultRetval;\n+        return conversion.apply(strval);\n+    }\n+\n+    \/**\n+     * Get a double value from file \"param\" within \"controller\".\n+     *\n+     * @param controller\n+     * @param param\n+     * @param defaultRetval\n+     * @return The double value or \"defaultRetval\" if there was an error.\n+     *\/\n+    public static double getDoubleValue(CgroupSubsystemController controller, String param, double defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+\n+        if (strval == null) return defaultRetval;\n+\n+        double retval = Double.parseDouble(strval);\n+\n+        return retval;\n+    }\n+\n+    \/**\n+     * getLongEntry\n+     *\n+     * Return the long value from the line containing the string \"entryname\"\n+     * within file \"param\" in the \"controller\".\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param entryname\n+     * @return long value or \"defaultRetval\" if there was an error or no match\n+     *         was found.\n+     *\/\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname, long defaultRetval) {\n+        if (controller == null) return defaultRetval;\n+\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+\n+            Optional<String> result = lines.map(line -> line.split(\" \"))\n+                                           .filter(line -> (line.length == 2 &&\n+                                                   line[0].equals(entryname)))\n+                                           .map(line -> line[1])\n+                                           .findFirst();\n+\n+            return result.isPresent() ? Long.parseLong(result.get()) : defaultRetval;\n+        } catch (UncheckedIOException e) {\n+            return defaultRetval;\n+        } catch (IOException e) {\n+            return defaultRetval;\n+        }\n+    }\n+\n+    \/**\n+     * stringRangeToIntArray\n+     *\n+     * Convert a string in the form of  1,3-4,6 to an array of\n+     * integers containing all the numbers in the range.\n+     *\n+     * @param range\n+     * @return int[] containing a sorted list of numbers as represented by\n+     *         the string range. Returns null if there was an error or the input\n+     *         was an empty string.\n+     *\/\n+    public static int[] stringRangeToIntArray(String range) {\n+        if (range == null || EMPTY_STR.equals(range)) return null;\n+\n+        ArrayList<Integer> results = new ArrayList<>();\n+        String strs[] = range.split(\",\");\n+        for (String str : strs) {\n+            if (str.contains(\"-\")) {\n+                String lohi[] = str.split(\"-\");\n+                \/\/ validate format\n+                if (lohi.length != 2) {\n+                    continue;\n+                }\n+                int lo = Integer.parseInt(lohi[0]);\n+                int hi = Integer.parseInt(lohi[1]);\n+                for (int i = lo; i <= hi; i++) {\n+                    results.add(i);\n+                }\n+            }\n+            else {\n+                results.add(Integer.parseInt(str));\n+            }\n+        }\n+\n+        \/\/ sort results\n+        results.sort(null);\n+\n+        \/\/ convert ArrayList to primitive int array\n+        int[] ints = new int[results.size()];\n+        int i = 0;\n+        for (Integer n : results) {\n+            ints[i++] = n;\n+        }\n+\n+        return ints;\n+    }\n+\n+    \/**\n+     * Convert a number from its string representation to a long.\n+     *\n+     * @param strval\n+     * @param overflowRetval\n+     * @param defaultRetval\n+     * @return The converted long value. \"overflowRetval\" is returned if the\n+     *         string representation exceeds the range of type long.\n+     *         \"defaultRetval\" is returned if another type of error occurred\n+     *         during conversion.\n+     *\/\n+    public static long convertStringToLong(String strval, long overflowRetval, long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes, cgroups v1) we may overflow\n+            \/\/ the range of signed long. In this case, return overflowRetval\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.cgroupv2.CgroupV2Subsystem;\n+\n+public class CgroupSubsystemFactory {\n+\n+    private static final String CPU_CTRL = \"cpu\";\n+    private static final String CPUACCT_CTRL = \"cpuacct\";\n+    private static final String CPUSET_CTRL = \"cpuset\";\n+    private static final String BLKIO_CTRL = \"blkio\";\n+    private static final String MEMORY_CTRL = \"memory\";\n+\n+    \/*\n+     * From https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+     *\n+     *  36 35 98:0 \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+     *  (1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)\n+     *\n+     *  (1) mount ID:  unique identifier of the mount (may be reused after umount)\n+     *  (2) parent ID:  ID of parent (or of self for the top of the mount tree)\n+     *  (3) major:minor:  value of st_dev for files on filesystem\n+     *  (4) root:  root of the mount within the filesystem\n+     *  (5) mount point:  mount point relative to the process's root\n+     *  (6) mount options:  per mount options\n+     *  (7) optional fields:  zero or more fields of the form \"tag[:value]\"\n+     *  (8) separator:  marks the end of the optional fields\n+     *  (9) filesystem type:  name of filesystem of the form \"type[.subtype]\"\n+     *  (10) mount source:  filesystem specific information or \"none\"\n+     *  (11) super options:  per super block options\n+     *\/\n+    private static final Pattern MOUNTINFO_PATTERN = Pattern.compile(\n+        \"^[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+\" + \/\/ (1), (2), (3)\n+        \"([^\\\\s]+)\\\\s+([^\\\\s]+)\\\\s+\" +         \/\/ (4), (5)     - group 1, 2: root, mount point\n+        \"[^-]+-\\\\s+\" +                         \/\/ (6), (7), (8)\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 3: filesystem type\n+        \".*$\");                                \/\/ (10), (11)\n+\n+    static CgroupMetrics create() {\n+        Optional<CgroupTypeResult> optResult = null;\n+        try {\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\", \"\/proc\/self\/cgroup\");\n+        } catch (IOException e) {\n+            return null;\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        }\n+\n+        if (optResult.equals(Optional.empty())) {\n+            return null;\n+        }\n+        CgroupTypeResult result = optResult.get();\n+\n+        \/\/ If no controller is enabled, return no metrics.\n+        if (!result.isAnyControllersEnabled()) {\n+            return null;\n+        }\n+        \/\/ The code is not ready to deal with mixed cgroups v1 and cgroups v2\n+        \/\/ controllers on a per-controller basis. Return no metrics in that\n+        \/\/ case\n+        if (result.isAnyCgroupV1Controllers() && result.isAnyCgroupV2Controllers()) {\n+            return null;\n+        }\n+\n+        Map<String, CgroupInfo> infos = result.getInfos();\n+        if (result.isCgroupV2()) {\n+            \/\/ For unified it doesn't matter which controller we pick.\n+            CgroupInfo anyController = infos.get(MEMORY_CTRL);\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(anyController);\n+            return subsystem != null ? new CgroupMetrics(subsystem) : null;\n+        } else {\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n+            return subsystem != null ? new CgroupV1MetricsImpl(subsystem) : null;\n+        }\n+    }\n+\n+    \/*\n+     * Determine the type of the cgroup system (v1 - legacy or hybrid - or, v2 - unified)\n+     * based on three files:\n+     *\n+     *  (1) mountInfo  (i.e. \/proc\/self\/mountinfo)\n+     *  (2) cgroups    (i.e. \/proc\/cgroups)\n+     *  (3) selfCgroup (i.e. \/proc\/self\/cgroup)\n+     *\n+     * File 'cgroups' is inspected for the hierarchy ID of the mounted cgroup pseudo\n+     * filesystem. The hierarchy ID, in turn, helps us distinguish cgroups v2 and\n+     * cgroup v1. For a system with zero hierarchy ID, but with >= 1 relevant cgroup\n+     * controllers mounted in 'mountInfo' we can infer it's cgroups v2. Anything else\n+     * will be cgroup v1 (hybrid or legacy). File 'selfCgroup' is being used for\n+     * figuring out the mount path of the controller in the cgroup hierarchy.\n+     *\/\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo,\n+                                                           String cgroups,\n+                                                           String selfCgroup) throws IOException {\n+        final Map<String, CgroupInfo> infos = new HashMap<>();\n+        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        for (String line : lines) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+            switch (info.getName()) {\n+            case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+            case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+            case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+            case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+            case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+            }\n+        }\n+\n+        \/\/ For cgroups v2 all controllers need to have zero hierarchy id\n+        \/\/ and \/proc\/self\/mountinfo needs to have at least one cgroup filesystem\n+        \/\/ mounted. Note that hybrid hierarchy has controllers mounted via\n+        \/\/ cgroup v1. In that case hierarchy id's will be non-zero.\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If there are no mounted, relevant cgroup controllers in 'mountinfo' and only\n+        \/\/ 0 hierarchy IDs in file 'cgroups' have been seen, we are on a cgroups v1 system.\n+        \/\/ However, continuing in that case does not make sense as we'd need\n+        \/\/ information from mountinfo for the mounted controller paths which we wouldn't\n+        \/\/ find anyway in that case.\n+        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n+        boolean anyCgroupMounted = false;\n+        for (String line: lines) {\n+            boolean cgroupsControllerFound = amendCgroupInfos(line, infos, isCgroupsV2);\n+            anyCgroupMounted = anyCgroupMounted || cgroupsControllerFound;\n+        }\n+        if (!anyCgroupMounted) {\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Map a cgroup version specific 'action' to a line in 'selfCgroup' (i.e.\n+        \/\/ \/proc\/self\/cgroups) , split on the ':' token, so as to set the appropriate\n+        \/\/ path to the cgroup controller in cgroup data structures 'infos'.\n+        \/\/ See:\n+        \/\/   setCgroupV1Path() for the action run for cgroups v1 systems\n+        \/\/   setCgroupV2Path() for the action run for cgroups v2 systems\n+        try (Stream<String> selfCgroupLines =\n+             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n+            Consumer<String[]> action = (tokens -> setCgroupV1Path(infos, tokens));\n+            if (isCgroupsV2) {\n+                action = (tokens -> setCgroupV2Path(infos, tokens));\n+            }\n+            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n+            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n+            \/\/ contain a ':'.\n+            selfCgroupLines.map(line -> line.split(\":\", 3)).forEach(action);\n+        }\n+\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2,\n+                                                       anyControllersEnabled,\n+                                                       anyCgroupsV2Controller,\n+                                                       anyCgroupsV1Controller,\n+                                                       Collections.unmodifiableMap(infos));\n+        return Optional.of(result);\n+    }\n+\n+    \/*\n+     * Sets the path to the cgroup controller for cgroups v2 based on a line\n+     * in \/proc\/self\/cgroup file (represented as the 'tokens' array).\n+     *\n+     * Example:\n+     *\n+     * 0::\/\n+     *\n+     * => tokens = [ \"0\", \"\", \"\/\" ]\n+     *\/\n+    private static void setCgroupV2Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        int hierarchyId = Integer.parseInt(tokens[0]);\n+        String cgroupPath = tokens[2];\n+        for (CgroupInfo info: infos.values()) {\n+            assert hierarchyId == info.getHierarchyId() && hierarchyId == 0;\n+            info.setCgroupPath(cgroupPath);\n+        }\n+    }\n+\n+    \/*\n+     * Sets the path to the cgroup controller for cgroups v1 based on a line\n+     * in \/proc\/self\/cgroup file (represented as the 'tokens' array).\n+     *\n+     * Note that multiple controllers might be joined at a single path.\n+     *\n+     * Example:\n+     *\n+     * 7:cpu,cpuacct:\/system.slice\/docker-74ad896fb40bbefe0f181069e4417505fffa19052098f27edf7133f31423bc0b.scope\n+     *\n+     * => tokens = [ \"7\", \"cpu,cpuacct\", \"\/system.slice\/docker-74ad896fb40bbefe0f181069e4417505fffa19052098f27edf7133f31423bc0b.scope\" ]\n+     *\/\n+    private static void setCgroupV1Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        String controllerName = tokens[1];\n+        String cgroupPath = tokens[2];\n+        if (controllerName != null && cgroupPath != null) {\n+            for (String cName: controllerName.split(\",\")) {\n+                switch (cName) {\n+                    case MEMORY_CTRL: \/\/ fall through\n+                    case CPUSET_CTRL:\n+                    case CPUACCT_CTRL:\n+                    case CPU_CTRL:\n+                    case BLKIO_CTRL:\n+                        CgroupInfo info = infos.get(cName);\n+                        info.setCgroupPath(cgroupPath);\n+                        break;\n+                    \/\/ Ignore not recognized controllers\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Amends cgroup infos with mount path and mount root. The passed in\n+     * 'mntInfoLine' represents a single line in, for example,\n+     * \/proc\/self\/mountinfo. Each line is matched with MOUNTINFO_PATTERN\n+     * (see above), so as to extract the relevant tokens from the line.\n+     *\n+     * Host example cgroups v1:\n+     *\n+     * 44 30 0:41 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,devices\n+     *\n+     * Container example cgroups v1:\n+     *\n+     * 1901 1894 0:37 \/system.slice\/docker-2291eeb92093f9d761aaf971782b575e9be56bd5930d4b5759b51017df3c1387.scope \/sys\/fs\/cgroup\/cpu,cpuacct ro,nosuid,nodev,noexec,relatime master:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\n+     *\n+     * Container example cgroups v2:\n+     *\n+     * 1043 1034 0:27 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec,relatime - cgroup2 cgroup2 rw,seclabel,nsdelegate\n+     *\n+     *\n+     * @return {@code true} iff a relevant controller has been found at the\n+     * given line\n+     *\/\n+    private static boolean amendCgroupInfos(String mntInfoLine,\n+                                            Map<String, CgroupInfo> infos,\n+                                            boolean isCgroupsV2) {\n+        Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(mntInfoLine.trim());\n+        boolean cgroupv1ControllerFound = false;\n+        boolean cgroupv2ControllerFound = false;\n+        if (lineMatcher.matches()) {\n+            String mountRoot = lineMatcher.group(1);\n+            String mountPath = lineMatcher.group(2);\n+            String fsType = lineMatcher.group(3);\n+            if (fsType.equals(\"cgroup\")) {\n+                Path p = Paths.get(mountPath);\n+                String[] controllerNames = p.getFileName().toString().split(\",\");\n+                for (String controllerName: controllerNames) {\n+                    switch (controllerName) {\n+                        case MEMORY_CTRL: \/\/ fall-through\n+                        case CPU_CTRL:\n+                        case CPUACCT_CTRL:\n+                        case BLKIO_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            assert info.getMountPoint() == null;\n+                            assert info.getMountRoot() == null;\n+                            info.setMountPoint(mountPath);\n+                            info.setMountRoot(mountRoot);\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        case CPUSET_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            if (info.getMountPoint() != null) {\n+                                \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+                                \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+                                \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+                                if (!info.getMountPoint().startsWith(\"\/sys\/fs\/cgroup\")) {\n+                                    info.setMountPoint(mountPath);\n+                                    info.setMountRoot(mountRoot);\n+                                }\n+                            } else {\n+                                info.setMountPoint(mountPath);\n+                                info.setMountRoot(mountRoot);\n+                            }\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ Ignore controllers which we don't recognize\n+                            break;\n+                    }\n+                }\n+            } else if (fsType.equals(\"cgroup2\")) {\n+                if (isCgroupsV2) { \/\/ will be false for hybrid\n+                    \/\/ All controllers have the same mount point and root mount\n+                    \/\/ for unified hierarchy.\n+                    for (CgroupInfo info: infos.values()) {\n+                        assert info.getMountPoint() == null;\n+                        assert info.getMountRoot() == null;\n+                        info.setMountPoint(mountPath);\n+                        info.setMountRoot(mountRoot);\n+                    }\n+                }\n+                cgroupv2ControllerFound = true;\n+            }\n+        }\n+        return cgroupv1ControllerFound || cgroupv2ControllerFound;\n+    }\n+\n+    public static final class CgroupTypeResult {\n+        private final boolean isCgroupV2;\n+        private final boolean anyControllersEnabled;\n+        private final boolean anyCgroupV2Controllers;\n+        private final boolean anyCgroupV1Controllers;\n+        private final Map<String, CgroupInfo> infos;\n+\n+        private CgroupTypeResult(boolean isCgroupV2,\n+                                 boolean anyControllersEnabled,\n+                                 boolean anyCgroupV2Controllers,\n+                                 boolean anyCgroupV1Controllers,\n+                                 Map<String, CgroupInfo> infos) {\n+            this.isCgroupV2 = isCgroupV2;\n+            this.anyControllersEnabled = anyControllersEnabled;\n+            this.anyCgroupV1Controllers = anyCgroupV1Controllers;\n+            this.anyCgroupV2Controllers = anyCgroupV2Controllers;\n+            this.infos = infos;\n+        }\n+\n+        public boolean isCgroupV2() {\n+            return isCgroupV2;\n+        }\n+\n+        public boolean isAnyControllersEnabled() {\n+            return anyControllersEnabled;\n+        }\n+\n+        public boolean isAnyCgroupV2Controllers() {\n+            return anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isAnyCgroupV1Controllers() {\n+            return anyCgroupV1Controllers;\n+        }\n+\n+        public Map<String, CgroupInfo> getInfos() {\n+            return infos;\n+        }\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public final class CgroupUtil {\n+\n+    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n+\n+    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(controller.path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ *\n+ * Cgroup v1 extensions to the Metrics interface. Linux, only.\n+ *\n+ *\/\n+public interface CgroupV1Metrics extends Metrics {\n+\n+    \/**\n+     * Returns the largest amount of physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available. Returns -2 if this metric is not\n+     *         supported.\n+     *\n+     *\/\n+    public long getMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that kernel memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of kernel physical memory, in bytes, that\n+     * can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set.\n+     *\n+     *\/\n+    public long getKernelMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of kernel physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the amount of kernel physical memory, in bytes, that\n+     * is currently allocated in the current Isolation Group.\n+     *\n+     * @return The amount of memory in bytes allocated or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryUsage();\n+\n+    \/**\n+     * Returns the number of times that networking memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of networking physical memory, in bytes,\n+     * that can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit.\n+     *\n+     *\/\n+    public long getTcpMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of networking physical memory, in bytes,\n+     * that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that user memory requests in the\n+     * Isolation Group have exceeded the memory + swap limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapFailCount();\n+\n+    \/**\n+     * Returns the largest amount of physical memory and swap space,\n+     * in bytes, that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapMaxUsage();\n+\n+    \/**\n+     * Returns the state of the Operating System Out of Memory termination\n+     * policy.\n+     *\n+     * @return Returns true if operating system will terminate processes\n+     *         in the Isolation Group that exceed the amount of available\n+     *         memory, otherwise false. null will be returned if this\n+     *         capability is not available on the current operating system.\n+     *\n+     *\/\n+    public Boolean isMemoryOOMKillEnabled();\n+\n+    \/**\n+     * Returns the (attempts per second * 1000), if enabled, that the\n+     * operating system tries to satisfy a memory request for any\n+     * process in the current Isolation Group when no free memory is\n+     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n+     * determine if this support is enabled.\n+     *\n+     * @return Memory pressure or 0 if not enabled or -1 if metric is not\n+     *         available.\n+     *\n+     *\/\n+    public double getCpuSetMemoryPressure();\n+\n+    \/**\n+     * Returns the state of the memory pressure detection support.\n+     *\n+     * @return true if support is available and enabled. false otherwise.\n+     *\n+     *\/\n+    public Boolean isCpuSetMemoryPressureEnabled();\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupV1Metrics.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Cgroup v1 Metrics extensions\n+ *\n+ *\/\n+public class CgroupV1MetricsImpl extends CgroupMetrics implements CgroupV1Metrics {\n+\n+    private final CgroupV1Metrics metrics;\n+\n+    CgroupV1MetricsImpl(CgroupV1Metrics metrics) {\n+        super((CgroupSubsystem)metrics);\n+        this.metrics = metrics;\n+    }\n+\n+    @Override\n+    public long getMemoryMaxUsage() {\n+        return metrics.getMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return metrics.getKernelMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryLimit() {\n+        return metrics.getKernelMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return metrics.getKernelMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return metrics.getKernelMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return metrics.getTcpMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryLimit() {\n+        return metrics.getTcpMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return metrics.getTcpMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return metrics.getMemoryAndSwapFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return metrics.getMemoryAndSwapMaxUsage();\n+    }\n+\n+    @Override\n+    public Boolean isMemoryOOMKillEnabled() {\n+        return metrics.isMemoryOOMKillEnabled();\n+    }\n+\n+    @Override\n+    public double getCpuSetMemoryPressure() {\n+        return metrics.getCpuSetMemoryPressure();\n+    }\n+\n+    @Override\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        return metrics.isCpuSetMemoryPressureEnabled();\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupV1MetricsImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+\n+    private boolean hierarchical;\n+    private boolean swapenabled;\n+\n+    public CgroupV1MemorySubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n+    boolean isSwapEnabled() {\n+        return swapenabled;\n+    }\n+\n+    void setSwapEnabled(boolean swapenabled) {\n+        this.swapenabled = swapenabled;\n+    }\n+}\n\\ No newline at end of file\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import java.util.Map;\n+\n+import jdk.internal.platform.CgroupInfo;\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class CgroupV1Subsystem implements CgroupSubsystem, CgroupV1Metrics {\n+    private CgroupV1MemorySubSystemController memory;\n+    private CgroupV1SubsystemController cpu;\n+    private CgroupV1SubsystemController cpuacct;\n+    private CgroupV1SubsystemController cpuset;\n+    private CgroupV1SubsystemController blkio;\n+\n+    private static volatile CgroupV1Subsystem INSTANCE;\n+\n+    private static final String PROVIDER_NAME = \"cgroupv1\";\n+\n+    private CgroupV1Subsystem() {}\n+\n+    \/**\n+     * Get a singleton instance of CgroupV1Subsystem. Initially, it creates a new\n+     * object by retrieving the pre-parsed information from cgroup interface\n+     * files from the provided 'infos' map.\n+     *\n+     * See CgroupSubsystemFactory.determineType() where the actual parsing of\n+     * cgroup interface files happens.\n+     *\n+     * @return A singleton CgroupV1Subsystem instance, never null\n+     *\/\n+    public static CgroupV1Subsystem getInstance(Map<String, CgroupInfo> infos) {\n+        if (INSTANCE == null) {\n+            CgroupV1Subsystem tmpSubsystem = initSubSystem(infos);\n+            synchronized (CgroupV1Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = tmpSubsystem;\n+                }\n+            }\n+        }\n+        return INSTANCE;\n+    }\n+\n+    private static CgroupV1Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n+        CgroupV1Subsystem subsystem = new CgroupV1Subsystem();\n+\n+        boolean anyActiveControllers = false;\n+        \/*\n+         * Find the cgroup mount points for subsystem controllers\n+         * by looking up relevant data in the infos map\n+         *\/\n+        for (CgroupInfo info: infos.values()) {\n+            switch (info.getName()) {\n+            case \"memory\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    boolean isHierarchial = getHierarchical(controller);\n+                    controller.setHierarchical(isHierarchial);\n+                    boolean isSwapEnabled = getSwapEnabled(controller);\n+                    controller.setSwapEnabled(isSwapEnabled);\n+                    subsystem.setMemorySubSystem(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuset\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuSetController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuacct\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuAcctController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpu\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"blkio\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setBlkIOController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            default:\n+                throw new AssertionError(\"Unrecognized controller in infos: \" + info.getName());\n+            }\n+        }\n+\n+        \/\/ Return Metrics object if we found any subsystems.\n+        if (anyActiveControllers) {\n+            return subsystem;\n+        }\n+\n+        return null;\n+    }\n+\n+    private static boolean getSwapEnabled(CgroupV1MemorySubSystemController controller) {\n+         long retval = getLongValue(controller, \"memory.memsw.limit_in_bytes\");\n+         return retval > 0;\n+     }\n+\n+\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n+    private void setMemorySubSystem(CgroupV1MemorySubSystemController memory) {\n+        this.memory = memory;\n+    }\n+\n+    private void setCpuController(CgroupV1SubsystemController cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    private void setCpuAcctController(CgroupV1SubsystemController cpuacct) {\n+        this.cpuacct = cpuacct;\n+    }\n+\n+    private void setCpuSetController(CgroupV1SubsystemController cpuset) {\n+        this.cpuset = cpuset;\n+    }\n+\n+    private void setBlkIOController(CgroupV1SubsystemController blkio) {\n+        this.blkio = blkio;\n+    }\n+\n+    private static long getLongValue(CgroupSubsystemController controller,\n+                              String parm) {\n+        return CgroupSubsystemController.getLongValue(controller,\n+                                                      parm,\n+                                                      CgroupV1SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    \/*****************************************************************\n+     * CPU Accounting Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuUsage() {\n+        return getLongValue(cpuacct, \"cpuacct.usage\");\n+    }\n+\n+    public long[] getPerCpuUsage() {\n+        String usagelist = CgroupSubsystemController.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n+        if (usagelist == null) {\n+            return null;\n+        }\n+\n+        String list[] = usagelist.split(\" \");\n+        long percpu[] = new long[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            percpu[i] = Long.parseLong(list[i]);\n+        }\n+        return percpu;\n+    }\n+\n+    public long getCpuUserUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPU Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuPeriod() {\n+        return getLongValue(cpuacct, \"cpu.cfs_period_us\");\n+    }\n+\n+    public long getCpuQuota() {\n+        return getLongValue(cpuacct, \"cpu.cfs_quota_us\");\n+    }\n+\n+    public long getCpuShares() {\n+        long retval = getLongValue(cpuacct, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024)\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        else\n+            return retval;\n+    }\n+\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPUSet Subsystem\n+     ****************************************************************\/\n+\n+    public int[] getCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.cpus\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n+    }\n+\n+    public int[] getCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.mems\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_mems\"));\n+    }\n+\n+    public double getCpuSetMemoryPressure() {\n+        return CgroupV1SubsystemController.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n+    }\n+\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        long val = getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n+        return (val == 1);\n+    }\n+\n+\n+    \/*****************************************************************\n+     * Memory Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getMemoryFailCount() {\n+        return getLongValue(memory, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryLimit() {\n+        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryUsage() {\n+        return getLongValue(memory, \"memory.usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.limit_in_bytes\"));\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\"));\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryFailCount();\n+        }\n+        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getMemoryAndSwapLimit() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryLimit();\n+        }\n+        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryMaxUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n+    }\n+\n+    public long getMemorySoftLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+    }\n+\n+\n+    \/*****************************************************************\n+     * BlKIO Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getBlkIOServiceCount() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n+    }\n+\n+    public long getBlkIOServiced() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n+\n+    public CgroupV1SubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static double getDoubleValue(CgroupSubsystemController controller, String parm) {\n+        return CgroupSubsystemController.getDoubleValue(controller,\n+                                                        parm,\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             Long.MAX_VALUE \/* overflow value *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long longValOrUnlimited(long value) {\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+    }\n+\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                String param,\n+                                                String match) {\n+        return CgroupSubsystemController.getLongValueMatchingLine(controller,\n+                                                                  param,\n+                                                                  match,\n+                                                                  CgroupV1SubsystemController::convertHierachicalLimitLine,\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public static long convertHierachicalLimitLine(String line) {\n+        String[] tokens = line.split(\"\\\\s\");\n+        if (tokens.length == 2) {\n+            String strVal = tokens[1];\n+            return CgroupV1SubsystemController.convertStringToLong(strVal);\n+        }\n+        return CgroupV1SubsystemController.UNLIMITED_MIN + 1; \/\/ unlimited\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,545 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.platform.cgroupv1.SubSystem.MemorySubSystem;\n-\n-public class Metrics implements jdk.internal.platform.Metrics {\n-    private MemorySubSystem memory;\n-    private SubSystem cpu;\n-    private SubSystem cpuacct;\n-    private SubSystem cpuset;\n-    private SubSystem blkio;\n-    private boolean activeSubSystems;\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-\n-    private static final Metrics INSTANCE = initContainerSubSystems();\n-\n-    private static final String PROVIDER_NAME = \"cgroupv1\";\n-\n-    private Metrics() {\n-        activeSubSystems = false;\n-    }\n-\n-    public static Metrics getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private static Metrics initContainerSubSystems() {\n-        if (!isUseContainerSupport()) {\n-            return null;\n-        }\n-        Metrics metrics = new Metrics();\n-\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystem(metrics, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemPath(metrics, line));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/\/ Return Metrics object if we found any subsystems.\n-        if (metrics.activeSubSystems()) {\n-            return metrics;\n-        }\n-\n-        return null;\n-    }\n-\n-    static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystem(Metrics metric, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    metric.setMemorySubSystem(new MemorySubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    metric.setCpuSetSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    metric.setCpuAcctSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    metric.setCpuSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    metric.setBlkIOSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemPath(Metrics metric, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(metric, metric.MemorySubSystem(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(metric, metric.CpuSetSubSystem(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(metric, metric.CpuAcctSubSystem(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(metric, metric.CpuSubSystem(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(metric, metric.BlkIOSubSystem(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(Metrics metric, SubSystem subsystem, String base) {\n-        if (subsystem != null) {\n-            subsystem.setPath(base);\n-            if (subsystem instanceof MemorySubSystem) {\n-                MemorySubSystem memorySubSystem = (MemorySubSystem)subsystem;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            metric.setActiveSubSystems();\n-        }\n-    }\n-\n-\n-    private static boolean getHierarchical(MemorySubSystem subsystem) {\n-        long hierarchical = SubSystem.getLongValue(subsystem, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n-    private static boolean getSwapEnabled(MemorySubSystem subsystem) {\n-        long retval = SubSystem.getLongValue(subsystem, \"memory.memsw.limit_in_bytes\");\n-        return retval > 0;\n-    }\n-\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n-    private void setMemorySubSystem(MemorySubSystem memory) {\n-        this.memory = memory;\n-    }\n-\n-    private void setCpuSubSystem(SubSystem cpu) {\n-        this.cpu = cpu;\n-    }\n-\n-    private void setCpuAcctSubSystem(SubSystem cpuacct) {\n-        this.cpuacct = cpuacct;\n-    }\n-\n-    private void setCpuSetSubSystem(SubSystem cpuset) {\n-        this.cpuset = cpuset;\n-    }\n-\n-    private void setBlkIOSubSystem(SubSystem blkio) {\n-        this.blkio = blkio;\n-    }\n-\n-    private SubSystem MemorySubSystem() {\n-        return memory;\n-    }\n-\n-    private SubSystem CpuSubSystem() {\n-        return cpu;\n-    }\n-\n-    private SubSystem CpuAcctSubSystem() {\n-        return cpuacct;\n-    }\n-\n-    private SubSystem CpuSetSubSystem() {\n-        return cpuset;\n-    }\n-\n-    private SubSystem BlkIOSubSystem() {\n-        return blkio;\n-    }\n-\n-    public String getProvider() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    \/*****************************************************************\n-     * CPU Accounting Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuUsage() {\n-        return SubSystem.getLongValue(cpuacct, \"cpuacct.usage\");\n-    }\n-\n-    public long[] getPerCpuUsage() {\n-        String usagelist = SubSystem.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n-        if (usagelist == null) {\n-            return new long[0];\n-        }\n-\n-        String list[] = usagelist.split(\" \");\n-        long percpu[] = new long[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            percpu[i] = Long.parseLong(list[i]);\n-        }\n-        return percpu;\n-    }\n-\n-    public long getCpuUserUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n-    }\n-\n-    public long getCpuSystemUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPU Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuPeriod() {\n-        return SubSystem.getLongValue(cpuacct, \"cpu.cfs_period_us\");\n-    }\n-\n-    public long getCpuQuota() {\n-        return SubSystem.getLongValue(cpuacct, \"cpu.cfs_quota_us\");\n-    }\n-\n-    public long getCpuShares() {\n-        long retval = SubSystem.getLongValue(cpuacct, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return -1;\n-        else\n-            return retval;\n-    }\n-\n-    public long getCpuNumPeriods() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"nr_periods\");\n-    }\n-\n-    public long getCpuNumThrottled() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"nr_throttled\");\n-    }\n-\n-    public long getCpuThrottledTime() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"throttled_time\");\n-    }\n-\n-    public long getEffectiveCpuCount() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPUSet Subsystem\n-     ****************************************************************\/\n-\n-    public int[] getCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.cpus\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n-    }\n-\n-    public int[] getCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.mems\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_mems\"));\n-    }\n-\n-    public double getCpuSetMemoryPressure() {\n-        return SubSystem.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n-    }\n-\n-    public boolean isCpuSetMemoryPressureEnabled() {\n-        long val = SubSystem.getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n-        return (val == 1);\n-    }\n-\n-\n-    \/*****************************************************************\n-     * Memory Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.failcnt\");\n-    }\n-\n-    public long getMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public static long convertHierachicalLimitLine(String line) {\n-        String[] tokens = line.split(\"\\\\s\");\n-        if (tokens.length == 2) {\n-            String strVal = tokens[1];\n-            return SubSystem.convertStringToLong(strVal);\n-        }\n-        return unlimited_minimum + 1; \/\/ unlimited\n-    }\n-\n-    public long getMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.failcnt\");\n-    }\n-\n-    public long getKernelMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.kmem.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getKernelMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n-    }\n-\n-    public long getTcpMemoryLimit() {\n-        long retval =  SubSystem.getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getTcpMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.failcnt\");\n-    }\n-\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = SubSystem.getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n-    }\n-\n-    public boolean isMemoryOOMKillEnabled() {\n-        long val = SubSystem.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n-    }\n-\n-    public long getMemorySoftLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.soft_limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-\n-    \/*****************************************************************\n-     * BlKIO Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getBlkIOServiceCount() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n-    }\n-\n-    public long getBlkIOServiced() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n-    }\n-\n-    private static native boolean isUseContainerSupport();\n-\n-}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":0,"deletions":545,"binary":false,"changes":545,"status":"deleted"},{"patch":"@@ -1,301 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class SubSystem {\n-    String root;\n-    String mountPoint;\n-    String path;\n-\n-    public SubSystem(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    \/**\n-     * getSubSystemStringValue\n-     *\n-     * Return the first line of the file \"parm\" argument from the subsystem.\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @return Returns the contents of the file specified by param.\n-     *\/\n-    public static String getStringValue(SubSystem subsystem, String parm) {\n-        if (subsystem == null) return null;\n-\n-        try {\n-            return subsystem.readStringValue(parm);\n-        } catch (IOException e) {\n-            return null;\n-        }\n-    }\n-\n-    private String readStringValue(String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(path(), param));\n-        try (BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValueMatchingLine(SubSystem subsystem,\n-                                                     String param,\n-                                                     String match,\n-                                                     Function<String, Long> conversion) {\n-        long retval = Metrics.unlimited_minimum + 1; \/\/ default unlimited\n-        try {\n-            List<String> lines = subsystem.readMatchingLines(param);\n-            for (String line: lines) {\n-                if (line.contains(match)) {\n-                    retval = conversion.apply(line);\n-                    break;\n-                }\n-            }\n-        } catch (IOException e) {\n-            \/\/ Ignore. Default is unlimited.\n-        }\n-        return retval;\n-    }\n-\n-    private List<String> readMatchingLines(String param) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () ->\n-                    Files.readAllLines(Paths.get(path(), param));\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-        return convertStringToLong(strval);\n-    }\n-\n-    public static long convertStringToLong(String strval) {\n-        if (strval == null) return 0L;\n-\n-        long retval = 0;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.max\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-\n-        return retval;\n-    }\n-\n-    public static double getDoubleValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-\n-        if (strval == null) return 0L;\n-\n-        double retval = Double.parseDouble(strval);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * getSubSystemlongEntry\n-     *\n-     * Return the long value from the line containing the string \"entryname\"\n-     * within file \"parm\" in the \"subsystem\".\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @param entryname\n-     * @return long value\n-     *\/\n-    public static long getLongEntry(SubSystem subsystem, String parm, String entryname) {\n-        String val = null;\n-\n-        if (subsystem == null) return 0L;\n-\n-        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n-\n-            Optional<String> result = lines.map(line -> line.split(\" \"))\n-                                           .filter(line -> (line.length == 2 &&\n-                                                   line[0].equals(entryname)))\n-                                           .map(line -> line[1])\n-                                           .findFirst();\n-\n-            return result.isPresent() ? Long.parseLong(result.get()) : 0L;\n-        } catch (IOException e) {\n-            return 0L;\n-        } catch (UncheckedIOException e) {\n-            return 0L;\n-        }\n-    }\n-\n-    public static int getIntValue(SubSystem subsystem, String parm) {\n-        String val = getStringValue(subsystem, parm);\n-\n-        if (val == null) return 0;\n-\n-        return Integer.parseInt(val);\n-    }\n-\n-    \/**\n-     * StringRangeToIntArray\n-     *\n-     * Convert a string in the form of  1,3-4,6 to an array of\n-     * integers containing all the numbers in the range.\n-     *\n-     * @param range\n-     * @return int[] containing a sorted list of processors or memory nodes\n-     *\/\n-    public static int[] StringRangeToIntArray(String range) {\n-        int[] ints = new int[0];\n-\n-        if (range == null) return ints;\n-\n-        ArrayList<Integer> results = new ArrayList<>();\n-        String strs[] = range.split(\",\");\n-        for (String str : strs) {\n-            if (str.contains(\"-\")) {\n-                String lohi[] = str.split(\"-\");\n-                \/\/ validate format\n-                if (lohi.length != 2) {\n-                    continue;\n-                }\n-                int lo = Integer.parseInt(lohi[0]);\n-                int hi = Integer.parseInt(lohi[1]);\n-                for (int i = lo; i <= hi; i++) {\n-                    results.add(i);\n-                }\n-            }\n-            else {\n-                results.add(Integer.parseInt(str));\n-            }\n-        }\n-\n-        \/\/ sort results\n-        results.sort(null);\n-\n-        \/\/ convert ArrayList to primitive int array\n-        ints = new int[results.size()];\n-        int i = 0;\n-        for (Integer n : results) {\n-            ints[i++] = n;\n-        }\n-\n-        return ints;\n-    }\n-\n-    public static class MemorySubSystem extends SubSystem {\n-\n-        private boolean hierarchical;\n-        private boolean swapenabled;\n-\n-        public MemorySubSystem(String root, String mountPoint) {\n-            super(root, mountPoint);\n-        }\n-\n-        boolean isHierarchical() {\n-            return hierarchical;\n-        }\n-\n-        void setHierarchical(boolean hierarchical) {\n-            this.hierarchical = hierarchical;\n-        }\n-\n-        boolean isSwapEnabled() {\n-            return swapenabled;\n-        }\n-\n-        void setSwapEnabled(boolean swapenabled) {\n-            this.swapenabled = swapenabled;\n-        }\n-\n-    }\n-}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":0,"deletions":301,"binary":false,"changes":301,"status":"deleted"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.CgroupInfo;\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupV2Subsystem implements CgroupSubsystem {\n+\n+    private static volatile CgroupV2Subsystem INSTANCE;\n+    private static final long[] LONG_ARRAY_NOT_SUPPORTED = null;\n+    private static final int[] INT_ARRAY_UNAVAILABLE = null;\n+    private final CgroupSubsystemController unified;\n+    private static final String PROVIDER_NAME = \"cgroupv2\";\n+    private static final int PER_CPU_SHARES = 1024;\n+    private static final String MAX_VAL = \"max\";\n+    private static final Object EMPTY_STR = \"\";\n+    private static final long NO_SWAP = 0;\n+\n+    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+        this.unified = unified;\n+    }\n+\n+    private long getLongVal(String file, long defaultValue) {\n+        return CgroupSubsystemController.getLongValue(unified,\n+                                                      file,\n+                                                      CgroupV2SubsystemController::convertStringToLong,\n+                                                      defaultValue);\n+    }\n+\n+    private long getLongVal(String file) {\n+        return getLongVal(file, CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    \/**\n+     * Get the singleton instance of a cgroups v2 subsystem. On initialization,\n+     * a new object from the given cgroup information 'anyController' is being\n+     * created. Note that the cgroup information has been parsed from cgroup\n+     * interface files ahead of time.\n+     *\n+     * See CgroupSubsystemFactory.determineType() for the cgroup interface\n+     * files parsing logic.\n+     *\n+     * @return A singleton CgroupSubsystem instance, never null.\n+     *\/\n+    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n+        if (INSTANCE == null) {\n+            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountPoint(),\n+                    anyController.getCgroupPath());\n+            CgroupV2Subsystem tmpCgroupSystem = new CgroupV2Subsystem(unified);\n+            synchronized (CgroupV2Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = tmpCgroupSystem;\n+                }\n+            }\n+        }\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return LONG_ARRAY_NOT_SUPPORTED;\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return limitFromString(quota);\n+    }\n+\n+    private long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = getLongVal(\"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        String cpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus\");\n+        return getCpuSet(cpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        String effCpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus.effective\");\n+        return getCpuSet(effCpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        String cpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems\");\n+        return getCpuSet(cpuSetMems);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        String effCpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems.effective\");\n+        return getCpuSet(effCpuSetMems);\n+    }\n+\n+    private int[] getCpuSet(String cpuSetVal) {\n+        if (cpuSetVal == null || EMPTY_STR.equals(cpuSetVal)) {\n+            return INT_ARRAY_UNAVAILABLE;\n+        }\n+        return CgroupSubsystemController.stringRangeToIntArray(cpuSetVal);\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return getLongVal(\"memory.current\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+    }\n+\n+    \/**\n+     * Note that for cgroups v2 the actual limits set for swap and\n+     * memory live in two different files, memory.swap.max and memory.max\n+     * respectively. In order to properly report a cgroup v1 like\n+     * compound value we need to sum the two values. Setting a swap limit\n+     * without also setting a memory limit is not allowed.\n+     *\/\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        \/\/ We only get a null string when file memory.swap.max doesn't exist.\n+        \/\/ In that case we return the memory limit without any swap.\n+        if (strVal == null) {\n+            return getMemoryLimit();\n+        }\n+        long swapLimit = limitFromString(strVal);\n+        if (swapLimit >= 0) {\n+            long memoryLimit = getMemoryLimit();\n+            assert memoryLimit >= 0;\n+            return memoryLimit + swapLimit;\n+        }\n+        return swapLimit;\n+    }\n+\n+    \/**\n+     * Note that for cgroups v2 the actual values set for swap usage and\n+     * memory usage live in two different files, memory.current and memory.swap.current\n+     * respectively. In order to properly report a cgroup v1 like\n+     * compound value we need to sum the two values. Setting a swap limit\n+     * without also setting a memory limit is not allowed.\n+     *\/\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        long memoryUsage = getMemoryUsage();\n+        if (memoryUsage >= 0) {\n+            \/\/ If file memory.swap.current doesn't exist, only return the regular\n+            \/\/ memory usage (without swap). Thus, use default value of NO_SWAP.\n+            long swapUsage = getLongVal(\"memory.swap.current\", NO_SWAP);\n+            return memoryUsage + swapUsage;\n+        }\n+        return memoryUsage; \/\/ case of no memory limits\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.low\");\n+        return limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRandWIOs);\n+    }\n+\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRBytesAndWBytesIO);\n+    }\n+\n+    private long sumTokensIOStat(Function<String, Long> mapFunc) {\n+        try {\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+                                .map(mapFunc)\n+                                .collect(Collectors.summingLong(e -> e));\n+        } catch (UncheckedIOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+\n+    private static String[] getRWIOMatchTokenNames() {\n+        return new String[] { \"rios\", \"wios\" };\n+    }\n+\n+    private static String[] getRWBytesIOMatchTokenNames() {\n+        return new String[] { \"rbytes\", \"wbytes\" };\n+    }\n+\n+    public static Long lineToRandWIOs(String line) {\n+        String[] matchNames = getRWIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    public static Long lineToRBytesAndWBytesIO(String line) {\n+        String[] matchNames = getRWBytesIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    private static Long ioStatLineToLong(String line, String[] matchNames) {\n+        if (line == null || EMPTY_STR.equals(line)) {\n+            return Long.valueOf(0);\n+        }\n+        String[] tokens = line.split(\"\\\\s+\");\n+        long retval = 0;\n+        for (String t: tokens) {\n+            String[] valKeys = t.split(\"=\");\n+            if (valKeys.length != 2) {\n+                \/\/ ignore device ids $MAJ:$MIN\n+                continue;\n+            }\n+            for (String match: matchNames) {\n+                if (match.equals(valKeys[0])) {\n+                    retval += longOrZero(valKeys[1]);\n+                }\n+            }\n+        }\n+        return Long.valueOf(retval);\n+    }\n+\n+    private static long longOrZero(String val) {\n+        long lVal = 0;\n+        try {\n+            lVal = Long.parseLong(val);\n+        } catch (NumberFormatException e) {\n+            \/\/ keep at 0\n+        }\n+        return lVal;\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.nio.file.Paths;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_platform_CgroupMetrics.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsUseContainerSupport();\n+}\n","filename":"jdk\/src\/linux\/native\/jdk\/internal\/platform\/cgroupv1\/CgroupMetrics.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jvm.h\"\n-\n-#include \"jdk_internal_platform_cgroupv1_Metrics.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n-{\n-    return JVM_IsUseContainerSupport();\n-}\n","filename":"jdk\/src\/linux\/native\/jdk\/internal\/platform\/cgroupv1\/Metrics.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,3 @@\n-                return aet.getTextRange(location, location + length);\n+                int currentLength = aet.getCharCount();\n+                return aet.getTextRange(Math.min(currentLength, location),\n+                        Math.min(currentLength, location + length));\n","filename":"jdk\/src\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibleText.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,3 +58,1 @@\n-            \/\/ We currently only support cgroupv1\n-            Class<?> c = Class.forName(\"jdk.internal.platform.cgroupv1.Metrics\");\n-            @SuppressWarnings(\"unchecked\")\n+            Class<?> c = Class.forName(\"jdk.internal.platform.CgroupMetrics\");\n@@ -76,1 +74,1 @@\n-     * The provider for Linux is cgroupsv1.\n+     * The provider for Linux is cgroups (version 1 or 2).\n@@ -92,1 +90,2 @@\n-     * @return Time in nanoseconds or 0L if metric is not available.\n+     * @return Time in nanoseconds, -1 if unknown or\n+     *         -2 if the metric is not supported.\n@@ -108,1 +107,1 @@\n-     *         this metric is not available, a zero length array will be\n+     *         this metric is not supported or not available, null will be\n@@ -118,1 +117,2 @@\n-     * @return User time in nanoseconds or 0L if metric is not available.\n+     * @return User time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -127,1 +127,2 @@\n-     * @return System time in nanoseconds or 0L if metric is not available.\n+     * @return System time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -140,1 +141,2 @@\n-     * @return time in microseconds or 0L if metric is not available.\n+     * @return time in microseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -150,1 +152,2 @@\n-     * @return time in microseconds or -1 if the quota is unlimited.\n+     * @return time in microseconds, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n@@ -169,1 +172,2 @@\n-     * @return shares value or -1 if no share set.\n+     * @return shares value, -1 if the metric is not available or\n+     *         -2 if cpu shares are not supported.\n@@ -176,2 +180,1 @@\n-     * a CPU quota has been setup for the Isolation Group; otherwise\n-     * returns 0.\n+     * a CPU quota has been setup for the Isolation Group\n@@ -179,1 +182,2 @@\n-     * @return count of elapsed periods or 0 if the quota is unlimited.\n+     * @return count of elapsed periods, -1 if the metric is not available\n+     *         or -2 if the metric is not supported.\n@@ -189,1 +193,2 @@\n-     * @return count of throttled periods or 0 if the quota is unlimited.\n+     * @return count of throttled periods, -1 if the metric is not available or\n+     *         -2 if it is not supported.\n@@ -199,1 +204,2 @@\n-     * @return Throttled time in nanoseconds or 0 if the quota is unlimited.\n+     * @return Throttled time in nanoseconds, -1 if the metric is not available\n+     *         or -2 if it is not supported.\n@@ -231,2 +237,2 @@\n-     * @return An array of available CPUs or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available CPUs. Returns null if the metric is not\n+     *         available or the metric is not supported.\n@@ -243,2 +249,2 @@\n-     * @return An array of available and online CPUs or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online CPUs. Returns null\n+     *         if the metric is not available or the metric is not supported.\n@@ -257,2 +263,2 @@\n-     * @return An array of available memory nodes or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available memory nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -269,2 +275,2 @@\n-     * @return An array of available and online nodes or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -275,21 +281,0 @@\n-    \/**\n-     * Returns the (attempts per second * 1000), if enabled, that the\n-     * operating system tries to satisfy a memory request for any\n-     * process in the current Isolation Group when no free memory is\n-     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n-     * to determine if this support is enabled.\n-     *\n-     * @return Memory pressure or 0 if not enabled or metric is not\n-     *         available.\n-     *\n-     *\/\n-    public double getCpuSetMemoryPressure();\n-\n-    \/**\n-     * Returns the state of the memory pressure detection support.\n-     *\n-     * @return true if the support is available and enabled, otherwise false.\n-     *\n-     *\/\n-    public boolean isCpuSetMemoryPressureEnabled();\n-\n@@ -304,2 +289,3 @@\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available. Returns -2 if the metric is not\n+     *         supported.\n@@ -314,2 +300,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit or -2 if this metric is not supported.\n@@ -320,10 +306,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryMaxUsage();\n-\n@@ -334,2 +310,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available or -2 if the metric is not\n+     *         supported.\n@@ -340,70 +317,0 @@\n-    \/**\n-     * Returns the number of times that kernel memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of kernel physical memory, in bytes, that\n-     * can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of kernel physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryMaxUsage();\n-\n-    \/**\n-     * Returns the amount of kernel physical memory, in bytes, that\n-     * is currently allocated in the current Isolation Group.\n-     *\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryUsage();\n-\n-    \/**\n-     * Returns the number of times that networking memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of networking physical memory, in bytes,\n-     * that can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of networking physical memory, in bytes,\n-     * that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryMaxUsage();\n-\n@@ -414,2 +321,2 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if the metric\n+     *         is not available. Returns -2 if this metric is not supported.\n@@ -420,10 +327,0 @@\n-    \/**\n-     * Returns the number of times that user memory requests in the\n-     * Isolation Group have exceeded the memory + swap limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapFailCount();\n-\n@@ -434,2 +331,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set or -2 if this metric is not supported.\n@@ -440,10 +337,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory and swap space,\n-     * in bytes, that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapMaxUsage();\n-\n@@ -454,2 +341,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available. Returns -2 if this metric is not\n+     *         supported.\n@@ -460,12 +348,0 @@\n-    \/**\n-     * Returns the state of the Operating System Out of Memory termination\n-     * policy.\n-     *\n-     * @return Returns true if operating system will terminate processes\n-     *         in the Isolation Group that exceed the amount of available\n-     *         memory, otherwise false.  Flase will be returned if this\n-     *         capability is not available on the current operating system.\n-     *\n-     *\/\n-    public boolean isMemoryOOMKillEnabled();\n-\n@@ -480,2 +356,2 @@\n-     *         conditions.  If this metric is not available, 0 will be\n-     *         returned.\n+     *         conditions.  If this metric is not available, -1 will be\n+     *         returned. Returns -2 if the metric is not supported.\n@@ -494,1 +370,2 @@\n-     * @return The count of requests or 0 if this metric is not available.\n+     * @return The count of requests or -1 if the metric is not available.\n+     *         Returns -2 if this metric is not supported.\n@@ -503,1 +380,2 @@\n-     * @return The number of bytes transferred or 0 if this metric is not available.\n+     * @return The number of bytes transferred or -1 if the metric is not\n+     *         available. Returns -2 if this metric is not supported.\n","filename":"jdk\/src\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":52,"deletions":174,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -503,10 +503,6 @@\n-                xi.setSecureValidation(secVal);\n-                if (context instanceof XMLSignContext && c14n11\n-                    && !xi.isOctetStream() && !xi.isOutputStreamSet()) {\n-                    TransformService spi = null;\n-                    if (provider == null) {\n-                        spi = TransformService.getInstance(c14nalg, \"DOM\");\n-                    } else {\n-                        try {\n-                            spi = TransformService.getInstance(c14nalg, \"DOM\", provider);\n-                        } catch (NoSuchAlgorithmException nsae) {\n+                try {\n+                    xi.setSecureValidation(secVal);\n+                    if (context instanceof XMLSignContext && c14n11\n+                            && !xi.isOctetStream() && !xi.isOutputStreamSet()) {\n+                        TransformService spi = null;\n+                        if (provider == null) {\n@@ -514,0 +510,6 @@\n+                        } else {\n+                            try {\n+                                spi = TransformService.getInstance(c14nalg, \"DOM\", provider);\n+                            } catch (NoSuchAlgorithmException nsae) {\n+                                spi = TransformService.getInstance(c14nalg, \"DOM\");\n+                            }\n@@ -515,1 +517,0 @@\n-                    }\n@@ -517,9 +518,16 @@\n-                    DOMTransform t = new DOMTransform(spi);\n-                    Element transformsElem = null;\n-                    String dsPrefix = DOMUtils.getSignaturePrefix(context);\n-                    if (allTransforms.isEmpty()) {\n-                        transformsElem = DOMUtils.createElement(\n-                            refElem.getOwnerDocument(),\n-                            \"Transforms\", XMLSignature.XMLNS, dsPrefix);\n-                        refElem.insertBefore(transformsElem,\n-                            DOMUtils.getFirstChildElement(refElem));\n+                        DOMTransform t = new DOMTransform(spi);\n+                        Element transformsElem = null;\n+                        String dsPrefix = DOMUtils.getSignaturePrefix(context);\n+                        if (allTransforms.isEmpty()) {\n+                            transformsElem = DOMUtils.createElement(\n+                                    refElem.getOwnerDocument(),\n+                                    \"Transforms\", XMLSignature.XMLNS, dsPrefix);\n+                            refElem.insertBefore(transformsElem,\n+                                    DOMUtils.getFirstChildElement(refElem));\n+                        } else {\n+                            transformsElem = DOMUtils.getFirstChildElement(refElem);\n+                        }\n+                        t.marshal(transformsElem, dsPrefix,\n+                                (DOMCryptoContext) context);\n+                        allTransforms.add(t);\n+                        xi.updateOutputStream(os, true);\n@@ -527,1 +535,5 @@\n-                        transformsElem = DOMUtils.getFirstChildElement(refElem);\n+                        xi.updateOutputStream(os);\n+                    }\n+                } finally {\n+                    if(xi.getOctetStreamReal() != null) {\n+                        xi.getOctetStreamReal().close();\n@@ -529,6 +541,0 @@\n-                    t.marshal(transformsElem, dsPrefix,\n-                              (DOMCryptoContext)context);\n-                    allTransforms.add(t);\n-                    xi.updateOutputStream(os, true);\n-                } else {\n-                    xi.updateOutputStream(os);\n","filename":"jdk\/src\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMReference.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-import java.text.Normalizer;\n@@ -57,0 +56,1 @@\n+import java.text.Normalizer;\n@@ -89,0 +89,1 @@\n+\n@@ -299,0 +300,2 @@\n+        final long longRetvalNotSupported = -2;\n+\n@@ -301,5 +304,3 @@\n-        ostream.println(INDENT + \"CPU Period: \" + c.getCpuPeriod() +\n-               (c.getCpuPeriod() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Quota: \" + c.getCpuQuota() +\n-               (c.getCpuQuota() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Shares: \" + c.getCpuShares());\n+        ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + \"CPU Period: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + \"CPU Quota: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuShares(), INDENT + \"CPU Shares: \", longRetvalNotSupported));\n@@ -308,2 +309,3 @@\n-        ostream.println(INDENT + \"List of Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -311,6 +313,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Processors: N\/A\");\n@@ -320,2 +325,3 @@\n-        ostream.println(INDENT + \"List of Effective Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Effective Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -323,6 +329,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Effective Processors: N\/A\");\n@@ -332,2 +341,3 @@\n-        ostream.println(INDENT + \"List of Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -335,6 +345,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Memory Nodes: N\/A\");\n@@ -344,2 +357,3 @@\n-        ostream.println(INDENT + \"List of Available Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Available Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -347,6 +361,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Available Memory Nodes: N\/A\");\n@@ -355,3 +372,0 @@\n-        ostream.println(INDENT + \"CPUSet Memory Pressure Enabled: \"\n-                + c.isCpuSetMemoryPressureEnabled());\n-\n@@ -359,2 +373,1 @@\n-        ostream.println(INDENT + \"Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Limit: \", longRetvalNotSupported));\n@@ -363,2 +376,1 @@\n-        ostream.println(INDENT + \"Memory Soft Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Soft Limit: \", longRetvalNotSupported));\n@@ -367,2 +379,1 @@\n-        ostream.println(INDENT + \"Memory & Swap Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory & Swap Limit: \", longRetvalNotSupported));\n@@ -370,7 +381,2 @@\n-        limit = c.getKernelMemoryLimit();\n-        ostream.println(INDENT + \"Kernel Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n-\n-        limit = c.getTcpMemoryLimit();\n-        ostream.println(INDENT + \"TCP Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(\"\");\n+    }\n@@ -378,2 +384,9 @@\n-        ostream.println(INDENT + \"Out Of Memory Killer Enabled: \"\n-                + c.isMemoryOOMKillEnabled());\n+    private static String formatLimitString(long limit, String prefix, long unavailable) {\n+        if (limit >= 0) {\n+            return prefix + SizePrefix.scaleValue(limit);\n+        } else if (limit == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + \"Unlimited\";\n+        }\n+    }\n@@ -381,1 +394,8 @@\n-        ostream.println(\"\");\n+    private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {\n+        if (cpuVal >= 0) {\n+            return prefix + cpuVal + \"us\";\n+        } else if (cpuVal == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + cpuVal;\n+        }\n","filename":"jdk\/src\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":78,"deletions":58,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-     *             JAR timestamp if jar files are being validated and the\n+     *             timestamp if JAR files are being validated and the\n@@ -163,1 +163,1 @@\n-     * {@code PKIXParameter} date, and {@code varient}\n+     * {@code PKIXParameter} date, and {@code variant}.\n@@ -167,2 +167,4 @@\n-     * @param pkixdate Date the constraints are checked against. The value is\n-     *             either the PKIXParameters date or null for the current date.\n+     * @param date the date specified by the PKIXParameters date, or the\n+     *             timestamp if JAR files are being validated and the\n+     *             JAR is timestamped. May be null if no timestamp or\n+     *             PKIXParameter date is set.\n@@ -172,2 +174,2 @@\n-    public AlgorithmChecker(TrustAnchor anchor, Date pkixdate, String variant) {\n-        this(anchor, certPathDefaultConstraints, pkixdate, variant);\n+    public AlgorithmChecker(TrustAnchor anchor, Date date, String variant) {\n+        this(anchor, certPathDefaultConstraints, date, variant);\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-class CertPathConstraintsParameters implements ConstraintsParameters {\n+public class CertPathConstraintsParameters implements ConstraintsParameters {\n@@ -108,1 +108,1 @@\n-        sb.append(\"\\n  Variant: \").append(variant);\n+        sb.append(\"  Variant: \").append(variant);\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/CertPathConstraintsParameters.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+        private Date timestampDate;\n@@ -157,0 +158,5 @@\n+        \/\/ The date() param is used when enforcing the validity period\n+        \/\/ of certificates and when checking the time period of revocation data.\n+        \/\/ The main difference between the date() and timestamp() method is\n+        \/\/ that the date() method only uses the timestamp (if specified)\n+        \/\/ for certificates in a code signer's chain.\n@@ -159,2 +165,7 @@\n-                \/\/ use timestamp if checking signed code that is\n-                \/\/ timestamped, otherwise use date parameter\n+                \/\/ Use timestamp if checking signed code that is\n+                \/\/ timestamped, otherwise use date parameter.\n+                \/\/ Note that TSA server certificates do not use the\n+                \/\/ timestamp, which means that an expired TSA certificate\n+                \/\/ is considered a validation failure. This policy means\n+                \/\/ that signed and timestamped code is valid until the TSA\n+                \/\/ certificate expires (assuming all other checks are valid).\n@@ -213,0 +224,11 @@\n+        \/\/ The timestamp() param is passed as the date param when creating an\n+        \/\/ AlgorithmChecker. An AlgorithmChecker always uses the timestamp\n+        \/\/ if specified in order to enforce the denyAfter constraint.\n+        Date timestamp() {\n+            \/\/ return timestamp date if set, otherwise use date parameter\n+            if (timestampDate == null) {\n+                timestampDate = (timestamp != null)\n+                    ? timestamp.getTimestamp() : date();\n+            }\n+            return timestampDate;\n+        }\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/PKIX.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,2 +175,2 @@\n-        certPathCheckers.add(new AlgorithmChecker(anchor, null, params.date(),\n-                params.variant()));\n+        certPathCheckers.add(new AlgorithmChecker(anchor, null,\n+                params.timestamp(), params.variant()));\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/PKIXCertPathValidator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,1 +347,1 @@\n-                        buildParams.date(), buildParams.variant()));\n+                        buildParams.timestamp(), buildParams.variant()));\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/SunCertPathBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,3 +332,0 @@\n-            \/\/ the max protocol version this client is supporting.\n-            ProtocolVersion maxProtocolVersion = chc.maximumActiveProtocol;\n-\n@@ -468,8 +465,0 @@\n-                if (!maxProtocolVersion.equals(sessionVersion)) {\n-                    maxProtocolVersion = sessionVersion;\n-\n-                    \/\/ Update protocol version number in underlying socket and\n-                    \/\/ handshake output stream, so that the output records\n-                    \/\/ (at the record layer) have the correct version\n-                    chc.setVersion(sessionVersion);\n-                }\n@@ -510,1 +499,1 @@\n-                if (maxProtocolVersion.useTLS13PlusSpec() &&\n+                if (chc.maximumActiveProtocol.useTLS13PlusSpec() &&\n@@ -553,1 +542,1 @@\n-            ProtocolVersion clientHelloVersion = maxProtocolVersion;\n+            ProtocolVersion clientHelloVersion = chc.maximumActiveProtocol;\n","filename":"jdk\/src\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -501,9 +501,0 @@\n-    \/**\n-     * Set the active protocol version and propagate it to the SSLSocket\n-     * and our handshake streams. Called from ClientHandshaker\n-     * and ServerHandshaker with the negotiated protocol version.\n-     *\/\n-    void setVersion(ProtocolVersion protocolVersion) {\n-        this.conContext.protocolVersion = protocolVersion;\n-    }\n-\n","filename":"jdk\/src\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import sun.security.provider.certpath.CertPathConstraintsParameters;\n@@ -884,1 +885,2 @@\n-                            X509Certificate signer = si.getCertificate(p7);\n+                            ArrayList<X509Certificate> chain = si.getCertificateChain(p7);\n+                            X509Certificate signer = chain.get(0);\n@@ -906,0 +908,2 @@\n+                                JarConstraintsParameters jcp =\n+                                    new JarConstraintsParameters(chain, si.getTimestamp());\n@@ -909,3 +913,3 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),\n-                                        verifyWithWeak(key),\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(key, jcp),\n@@ -914,3 +918,3 @@\n-                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true),\n-                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true),\n-                                        verifyWithWeak(tsKey));\n+                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcp),\n+                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcp),\n+                                        verifyWithWeak(tsKey, jcp));\n@@ -918,0 +922,2 @@\n+                                JarConstraintsParameters jcp =\n+                                    new JarConstraintsParameters(chain, null);\n@@ -921,3 +927,3 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),\n-                                        verifyWithWeak(key));\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(key, jcp));\n@@ -926,0 +932,1 @@\n+                            e.printStackTrace();\n@@ -1259,4 +1266,16 @@\n-    private String verifyWithWeak(String alg, Set<CryptoPrimitive> primitiveSet, boolean tsa) {\n-        if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {\n-            if (LEGACY_CHECK.permits(primitiveSet, alg, null)) {\n-                return alg;\n+    private String verifyWithWeak(String alg, Set<CryptoPrimitive> primitiveSet,\n+        boolean tsa, JarConstraintsParameters jcp) {\n+\n+        try {\n+            DISABLED_CHECK.permits(alg, jcp);\n+        } catch (CertPathValidatorException e) {\n+            disabledAlgFound = true;\n+            return String.format(rb.getString(\"with.disabled\"), alg);\n+        }\n+        try {\n+            LEGACY_CHECK.permits(alg, jcp);\n+            return alg;\n+        } catch (CertPathValidatorException e) {\n+            if (primitiveSet == SIG_PRIMITIVE_SET) {\n+                legacyAlg |= 2;\n+                legacySigAlg = alg;\n@@ -1264,3 +1283,3 @@\n-                if (primitiveSet == SIG_PRIMITIVE_SET) {\n-                   legacyAlg |= 2;\n-                   legacySigAlg = alg;\n+                if (tsa) {\n+                    legacyAlg |= 4;\n+                    legacyTsaDigestAlg = alg;\n@@ -1268,7 +1287,2 @@\n-                    if (tsa) {\n-                        legacyAlg |= 4;\n-                        legacyTsaDigestAlg = alg;\n-                    } else {\n-                        legacyAlg |= 1;\n-                        legacyDigestAlg = alg;\n-                    }\n+                    legacyAlg |= 1;\n+                    legacyDigestAlg = alg;\n@@ -1276,1 +1290,0 @@\n-                return String.format(rb.getString(\"with.weak\"), alg);\n@@ -1278,3 +1291,1 @@\n-        } else {\n-            disabledAlgFound = true;\n-            return String.format(rb.getString(\"with.disabled\"), alg);\n+            return String.format(rb.getString(\"with.weak\"), alg);\n@@ -1284,1 +1295,1 @@\n-    private String verifyWithWeak(PublicKey key) {\n+    private String verifyWithWeak(PublicKey key, JarConstraintsParameters jcp) {\n@@ -1286,7 +1297,10 @@\n-        if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {\n-            if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {\n-                if (kLen >= 0) {\n-                    return String.format(rb.getString(\"key.bit\"), kLen);\n-                } else {\n-                    return rb.getString(\"unknown.size\");\n-                }\n+        try {\n+            DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+        } catch (CertPathValidatorException e) {\n+            disabledAlgFound = true;\n+            return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+        }\n+        try {\n+            LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+            if (kLen >= 0) {\n+                return String.format(rb.getString(\"key.bit\"), kLen);\n@@ -1294,3 +1308,1 @@\n-                weakPublicKey = key;\n-                legacyAlg |= 8;\n-                return String.format(rb.getString(\"key.bit.weak\"), kLen);\n+                return rb.getString(\"unknown.size\");\n@@ -1298,3 +1310,4 @@\n-        } else {\n-           disabledAlgFound = true;\n-           return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+        } catch (CertPathValidatorException e) {\n+            weakPublicKey = key;\n+            legacyAlg |= 8;\n+            return String.format(rb.getString(\"key.bit.weak\"), kLen);\n@@ -1304,3 +1317,8 @@\n-    private void checkWeakSign(String alg, Set<CryptoPrimitive> primitiveSet, boolean tsa) {\n-        if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {\n-            if (!LEGACY_CHECK.permits(primitiveSet, alg, null)) {\n+    private void checkWeakSign(String alg, Set<CryptoPrimitive> primitiveSet,\n+        boolean tsa, JarConstraintsParameters jcp) {\n+\n+        try {\n+            DISABLED_CHECK.permits(alg, jcp);\n+            try {\n+                LEGACY_CHECK.permits(alg, jcp);\n+            } catch (CertPathValidatorException e) {\n@@ -1308,1 +1326,1 @@\n-                   legacyAlg |= 2;\n+                    legacyAlg |= 2;\n@@ -1317,1 +1335,1 @@\n-        } else {\n+        } catch (CertPathValidatorException e) {\n@@ -1330,3 +1348,6 @@\n-    private void checkWeakSign(PrivateKey key) {\n-        if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {\n-            if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {\n+    private void checkWeakSign(PrivateKey key, JarConstraintsParameters jcp) {\n+        try {\n+            DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+            try {\n+                LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+            } catch (CertPathValidatorException e) {\n@@ -1335,1 +1356,1 @@\n-        } else {\n+        } catch (CertPathValidatorException e) {\n@@ -1362,1 +1383,1 @@\n-        Date timestamp, boolean checkUsage) throws Exception {\n+        Date timestamp, boolean checkUsage, CertPathConstraintsParameters cpcp) throws Exception {\n@@ -1561,2 +1582,5 @@\n-        checkWeakSign(digestalg, DIGEST_PRIMITIVE_SET, false);\n-        checkWeakSign(tSADigestAlg, DIGEST_PRIMITIVE_SET, true);\n+        JarConstraintsParameters jcp =\n+            new JarConstraintsParameters(Arrays.asList(certChain), null);\n+        checkWeakSign(digestalg, DIGEST_PRIMITIVE_SET, false, jcp);\n+\n+        checkWeakSign(tSADigestAlg, DIGEST_PRIMITIVE_SET, true, jcp);\n@@ -1570,1 +1594,1 @@\n-        checkWeakSign(sigalg, SIG_PRIMITIVE_SET, false);\n+        checkWeakSign(sigalg, SIG_PRIMITIVE_SET, false, jcp);\n@@ -1572,1 +1596,1 @@\n-        checkWeakSign(privateKey);\n+        checkWeakSign(privateKey, jcp);\n@@ -1848,0 +1872,2 @@\n+                    CertPathConstraintsParameters cpcp =\n+                        new CertPathConstraintsParameters(tsaCert, Validator.VAR_TSA_SERVER, null, null);\n@@ -1849,1 +1875,1 @@\n-                            printCert(true, \"\", tsaCert, null, false));\n+                            printCert(true, \"\", tsaCert, null, false, cpcp));\n@@ -2074,0 +2100,3 @@\n+        @SuppressWarnings(\"unchecked\")\n+        List<X509Certificate> chain = (List<X509Certificate>)certs;\n+        TrustAnchor anchor = findTrustAnchor(chain);\n@@ -2075,1 +2104,3 @@\n-            sb.append(printCert(false, tab2, c, timestamp, first));\n+            CertPathConstraintsParameters cpcp =\n+                new CertPathConstraintsParameters((X509Certificate)c, Validator.VAR_CODE_SIGNING, anchor, timestamp);\n+            sb.append(printCert(false, tab2, c, timestamp, first, cpcp));\n@@ -2088,0 +2119,4 @@\n+            List<? extends Certificate> tscerts = ts.getSignerCertPath().getCertificates();\n+            @SuppressWarnings(\"unchecked\")\n+            List<X509Certificate> tschain = (List<X509Certificate>)tscerts;\n+            anchor = findTrustAnchor(chain);\n@@ -2089,2 +2124,4 @@\n-            for (Certificate c : ts.getSignerCertPath().getCertificates()) {\n-                sb.append(printCert(true, tab2, c, null, false));\n+            for (Certificate c : tschain) {\n+                CertPathConstraintsParameters cpcp =\n+                    new CertPathConstraintsParameters((X509Certificate)c, Validator.VAR_TSA_SERVER, anchor, timestamp);\n+                sb.append(printCert(true, tab2, c, null, false, cpcp));\n@@ -2150,0 +2187,9 @@\n+    private TrustAnchor findTrustAnchor(List<X509Certificate> chain) {\n+        X509Certificate last = chain.get(chain.size() - 1);\n+        Optional<X509Certificate> trusted =\n+            trustedCerts.stream()\n+                        .filter(c -> c.getSubjectX500Principal().equals(last.getIssuerX500Principal()))\n+                        .findFirst();\n+        return trusted.isPresent() ? new TrustAnchor(trusted.get(), null) : null;\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":106,"deletions":60,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.text.SimpleDateFormat;\n@@ -684,2 +683,0 @@\n-        private static final SimpleDateFormat dateFormat =\n-                new SimpleDateFormat(\"EEE, MMM d HH:mm:ss z yyyy\");\n@@ -719,1 +716,1 @@\n-                        dateFormat.format(denyAfterDate));\n+                        denyAfterDate);\n@@ -750,2 +747,2 @@\n-                        dateFormat.format(denyAfterDate) + \"; params date: \" +\n-                        dateFormat.format(currentDate) + cp.extendedExceptionMsg(),\n+                        denyAfterDate + \"; params date: \" +\n+                        currentDate + cp.extendedExceptionMsg(),\n","filename":"jdk\/src\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    \/\/ The keys of the signers\n+    \/\/ The keys of the signers and TSA\n@@ -55,1 +55,1 @@\n-    \/\/ The certs in the signers' chains that are issued by the trust anchor\n+    \/\/ The certs in the signers and TSA chain that are issued by the trust anchor\n@@ -76,1 +76,1 @@\n-            init(signer.getSignerCertPath());\n+            addToCertsAndKeys(signer.getSignerCertPath());\n@@ -85,1 +85,1 @@\n-                init(timestamp.getSignerCertPath());\n+                addToCertsAndKeys(timestamp.getSignerCertPath());\n@@ -101,2 +101,14 @@\n-    \/\/ extract last certificate and key from chain\n-    private void init(CertPath cp) {\n+    public JarConstraintsParameters(List<X509Certificate> chain, Timestamp timestamp) {\n+        this.keys = new HashSet<>();\n+        this.certsIssuedByAnchor = new HashSet<>();\n+        addToCertsAndKeys(chain);\n+        if (timestamp != null) {\n+            addToCertsAndKeys(timestamp.getSignerCertPath());\n+            this.timestamp = timestamp.getTimestamp();\n+        } else {\n+            this.timestamp = null;\n+        }\n+    }\n+\n+    \/\/ extract last certificate and signer's public key from chain\n+    private void addToCertsAndKeys(CertPath cp) {\n@@ -106,0 +118,4 @@\n+        addToCertsAndKeys(chain);\n+    }\n+\n+    private void addToCertsAndKeys(List<X509Certificate> chain) {\n@@ -171,1 +187,1 @@\n-        sb.append(\"\\n  Variant: \").append(getVariant());\n+        sb.append(\"  Variant: \").append(getVariant());\n","filename":"jdk\/src\/share\/classes\/sun\/security\/util\/JarConstraintsParameters.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -576,6 +576,2 @@\n-                    \/\/ \"last\", it works for now. From tzdata2020d this hacking\n-                    \/\/ will not work for Asia\/Gaza and Asia\/Hebron which follow\n-                    \/\/ Palestine DST rules.\n-                    if (dom < 0 || dom >= 24 &&\n-                                   !(zoneId.equals(\"Asia\/Gaza\") ||\n-                                     zoneId.equals(\"Asia\/Hebron\"))) {\n+                    \/\/ \"last\", it works for now.\n+                    if (dom < 0 || dom >= 24) {\n@@ -603,1 +599,0 @@\n-                    \/\/ No need of hacking for Asia\/Gaza and Asia\/Hebron from tz2021e\n","filename":"jdk\/src\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-# There is one defined security property:  jdk.disabled.NamedCurves\n+# There is one defined security property:  jdk.disabled.namedCurves\n@@ -607,0 +607,1 @@\n+    SHA1 usage SignedJAR & denyAfter 2019-01-01, \\\n@@ -671,1 +672,2 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024, SHA1 denyAfter 2019-01-01, \\\n+      include jdk.disabled.namedCurves\n","filename":"jdk\/src\/share\/lib\/security\/java.security-aix","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-# There is one defined security property:  jdk.disabled.NamedCurves\n+# There is one defined security property:  jdk.disabled.namedCurves\n@@ -607,0 +607,1 @@\n+    SHA1 usage SignedJAR & denyAfter 2019-01-01, \\\n@@ -671,1 +672,2 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024, SHA1 denyAfter 2019-01-01, \\\n+      include jdk.disabled.namedCurves\n","filename":"jdk\/src\/share\/lib\/security\/java.security-linux","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-# There is one defined security property:  jdk.disabled.NamedCurves\n+# There is one defined security property:  jdk.disabled.namedCurves\n@@ -610,0 +610,1 @@\n+    SHA1 usage SignedJAR & denyAfter 2019-01-01, \\\n@@ -674,1 +675,2 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024, SHA1 denyAfter 2019-01-01, \\\n+      include jdk.disabled.namedCurves\n","filename":"jdk\/src\/share\/lib\/security\/java.security-macosx","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-# There is one defined security property:  jdk.disabled.NamedCurves\n+# There is one defined security property:  jdk.disabled.namedCurves\n@@ -608,0 +608,1 @@\n+    SHA1 usage SignedJAR & denyAfter 2019-01-01, \\\n@@ -672,1 +673,2 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024, SHA1 denyAfter 2019-01-01, \\\n+      include jdk.disabled.namedCurves\n","filename":"jdk\/src\/share\/lib\/security\/java.security-solaris","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-# There is one defined security property:  jdk.disabled.NamedCurves\n+# There is one defined security property:  jdk.disabled.namedCurves\n@@ -610,0 +610,1 @@\n+    SHA1 usage SignedJAR & denyAfter 2019-01-01, \\\n@@ -674,1 +675,2 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024, SHA1 denyAfter 2019-01-01, \\\n+      include jdk.disabled.namedCurves\n","filename":"jdk\/src\/share\/lib\/security\/java.security-windows","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-#define IS_MUL_OVERFLOW(m, n) \\\n-        ((m) != 0 && (n) != 0 && (((size_t)((m)*(n))) != (((size_t)(m)) * ((size_t)(n)))))\n-\n@@ -54,2 +51,1 @@\n-     ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))) && \\\n-     !IS_MUL_OVERFLOW(m, n))\n+     ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))))\n@@ -78,1 +74,1 @@\n-    (IS_SAFE_SIZE_MUL((m), (n)) ? ((func)((m) * (n))) : FAILURE_RESULT)\n+    (IS_SAFE_SIZE_MUL((m), (n)) ? ((func)((size_t)(m) * (size_t)(n))) : FAILURE_RESULT)\n@@ -81,1 +77,1 @@\n-    (IS_SAFE_SIZE_MUL((m), (n)) ? ((func)((p), (m) * (n))) : FAILURE_RESULT)\n+    (IS_SAFE_SIZE_MUL((m), (n)) ? ((func)((p), (size_t)(m) * (size_t)(n))) : FAILURE_RESULT)\n@@ -95,1 +91,1 @@\n-    (IS_SAFE_SIZE_MUL(sizeof(type), (n)) ? (new type[(n)]) : throw std::bad_alloc())\n+    (IS_SAFE_SIZE_MUL(sizeof(type), (n)) ? (new type[(size_t)(n)]) : throw std::bad_alloc())\n@@ -98,2 +94,2 @@\n-    (IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_MUL(sizeof(type), (n) * (m)) ? \\\n-     (new type[(n) * (m)]) : throw std::bad_alloc())\n+    (IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_MUL(sizeof(type), (size_t)(n) * (size_t)(m)) ? \\\n+     (new type[(size_t)(n) * (size_t)(m)]) : throw std::bad_alloc())\n@@ -107,1 +103,1 @@\n-      IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_ADD((m) * (n), (a)) \\\n+      IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_ADD((size_t)(m) * (size_t)(n), (a)) \\\n@@ -119,1 +115,1 @@\n-    (IS_SAFE_STRUCT_SIZE((a), (m), (n)) ? ((func)((a) + (m) * (n))) : FAILURE_RESULT)\n+    (IS_SAFE_STRUCT_SIZE((a), (m), (n)) ? ((func)((size_t)(a) + (size_t)(m) * (size_t)(n))) : FAILURE_RESULT)\n","filename":"jdk\/src\/share\/native\/common\/sizecalc.h","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-        if (containerMetrics != null) {\n+        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n","filename":"jdk\/src\/solaris\/classes\/sun\/management\/OperatingSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-    \/\/ but it's not in the 10.9 SDK.  So, call it via objc_msgSend_stret.\n+    \/\/ but it's not in the 10.9 SDK.  So, call it via NSInvocation.\n@@ -191,3 +191,7 @@\n-        OSVerStruct (*procInfoFn)(id rec, SEL sel) = (OSVerStruct(*)(id, SEL))objc_msgSend_stret;\n-        OSVerStruct osVer = procInfoFn([NSProcessInfo processInfo],\n-                                       @selector(operatingSystemVersion));\n+        OSVerStruct osVer;\n+        NSMethodSignature *sig = [[NSProcessInfo processInfo] methodSignatureForSelector:\n+                @selector(operatingSystemVersion)];\n+        NSInvocation *invoke = [NSInvocation invocationWithMethodSignature:sig];\n+        invoke.selector = @selector(operatingSystemVersion);\n+        [invoke invokeWithTarget:[NSProcessInfo processInfo]];\n+        [invoke getReturnValue:&osVer];\n","filename":"jdk\/src\/solaris\/native\/java\/lang\/java_props_macosx.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -289,0 +289,17 @@\n+#ifdef VCRUNTIME_1_DLL_NAME\n+        if (GetJREPath(crtpath, MAXPATHLEN)) {\n+            if (JLI_StrLen(crtpath) + JLI_StrLen(\"\\\\bin\\\\\") +\n+                    JLI_StrLen(VCRUNTIME_1_DLL_NAME) >= MAXPATHLEN) {\n+                JLI_ReportErrorMessage(JRE_ERROR11);\n+                return JNI_FALSE;\n+            }\n+            (void)JLI_StrCat(crtpath, \"\\\\bin\\\\\" VCRUNTIME_1_DLL_NAME);   \/* Add crt dll *\/\n+            JLI_TraceLauncher(\"CRT path is %s\\n\", crtpath);\n+            if (_access(crtpath, 0) == 0) {\n+                if (LoadLibrary(crtpath) == 0) {\n+                    JLI_ReportErrorMessage(DLL_ERROR4, crtpath);\n+                    return JNI_FALSE;\n+                }\n+            }\n+        }\n+#endif \/* VCRUNTIME_1_DLL_NAME *\/\n","filename":"jdk\/src\/windows\/bin\/java_md.c","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"awt.h\"\n","filename":"jdk\/src\/windows\/native\/sun\/windows\/awt_DCHolder.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"awt.h\"\n@@ -32,1 +31,0 @@\n-#include \"awt_Toolkit.h\"\n@@ -36,1 +34,0 @@\n-#include \"alloc.h\"\n@@ -38,0 +35,1 @@\n+#include \"awt_Toolkit.h\"\n","filename":"jdk\/src\/windows\/native\/sun\/windows\/awt_DnDDT.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"awt.h\"\n@@ -33,0 +32,1 @@\n+#include \"awt.h\"\n","filename":"jdk\/src\/windows\/native\/sun\/windows\/awt_ole.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n- * @library   ..\/..\/regtesthelpers\n- * @build     Util\n@@ -33,5 +31,16 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.concurrent.Callable;\n-import javax.swing.SwingUtilities;\n-import test.java.awt.regtesthelpers.Util;\n+\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowEvent;\n@@ -67,0 +76,1 @@\n+        robot.delay(500);\n@@ -70,0 +80,1 @@\n+        robot.delay(500);\n@@ -138,2 +149,2 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n","filename":"jdk\/test\/java\/awt\/Focus\/SimpleWindowActivationTest\/SimpleWindowActivationTest.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import jdk.testlibrary.OSInfo;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test 1.2 98\/08\/05\n+ * @bug 4373478 8079255\n+ * @summary Test mouse wheel functionality of Robot\n+ * @author bchristi: area=Robot\n+ * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @build jdk.testlibrary.OSInfo\n+ * @run main RobotWheelTest\n+ *\/\n+public class RobotWheelTest {\n+\n+    private static final int NUMTESTS = 20;\n+\n+    private static AtomicInteger wheelRotation = new AtomicInteger();\n+    private static int wheelSign = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ? -1 : 1;\n+\n+    static Robot robot;\n+\n+    static void waitTillSuccess(int i) {\n+        boolean success = false;\n+\n+        for (int t = 0; t < 5; t++) {\n+            if (i == wheelSign * wheelRotation.get()) {\n+                success = true;\n+                break;\n+            }\n+            System.out.printf(\n+                    \"attempt #%d failed. wheelRotation = %d, expected value = %d\\n\",\n+                    t, wheelRotation.get(), i\n+            );\n+            robot.delay(100);\n+        }\n+\n+        if (!success) {\n+            throw new RuntimeException(\"wheelRotation = \" + wheelRotation.get()\n+                    + \", expected value = \" + i);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        Frame frame = null;\n+        try {\n+            frame = new Frame();\n+            frame.setSize(200, 200);\n+            Button button = new Button(\"WheelButton\");\n+            button.addMouseWheelListener(e -> wheelRotation.addAndGet(e.getWheelRotation()));\n+            frame.add(button);\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+\n+            Rectangle bounds = frame.getBounds();\n+            int centerX = bounds.x + bounds.width \/ 2;\n+            int centerY = bounds.y + bounds.height \/ 2;\n+            robot.mouseMove(centerX, centerY);\n+            robot.waitForIdle();\n+\n+            for (int i = -NUMTESTS; i <= NUMTESTS; i++) {\n+                if (i == 0) {\n+                    continue;\n+                }\n+\n+                wheelRotation.set(0);\n+\n+                robot.mouseWheel(i);\n+                robot.waitForIdle();\n+\n+                waitTillSuccess(i);\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"jdk\/test\/java\/awt\/Robot\/RobotWheelTest\/RobotWheelTest.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-\n@@ -102,1 +101,7 @@\n-            if (!expected.equals(gcInsets))\n+            \/\/ On Windows 10 and up system allows undecorated maximized windows\n+            \/\/ to be placed over the taskbar so calculated insets might\n+            \/\/ be smaller than reported ones depending on the taskbar position\n+            if (gcInsets.top < expected.top\n+                    || gcInsets.bottom < expected.bottom\n+                    || gcInsets.left < expected.left\n+                    || gcInsets.right < expected.right)\n","filename":"jdk\/test\/java\/awt\/Toolkit\/ScreenInsetsTest\/ScreenInsetsTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8296632\n+ * @summary Verify the content changes of a TextArea via TextListener.\n+ * @run main TextAreaTextEventTest\n+ *\/\n+public class TextAreaTextEventTest {\n+\n+    private static Frame frame;\n+    private volatile static TextArea textArea;\n+    private volatile static boolean textChanged = false;\n+    private volatile static Point textAreaAt;\n+    private volatile static Dimension textAreaSize;\n+    private static Robot robot = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(TextAreaTextEventTest::initializeGUI);\n+\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            robot.waitForIdle();\n+            EventQueue.invokeAndWait(() -> {\n+                textAreaAt = textArea.getLocationOnScreen();\n+                textAreaSize = textArea.getSize();\n+            });\n+            robot.mouseMove(textAreaAt.x + textAreaSize.width \/ 2,\n+                textAreaAt.y + textAreaSize.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            typeKey(KeyEvent.VK_T);\n+\n+            robot.waitForIdle();\n+            if (!textChanged) {\n+                throw new RuntimeException(\n+                    \"FAIL: TextEvent not triggered when key 'T' typed on TextArea\");\n+            }\n+\n+            typeKey(KeyEvent.VK_E);\n+            typeKey(KeyEvent.VK_S);\n+            typeKey(KeyEvent.VK_T);\n+\n+            textChanged = false;\n+            typeKey(KeyEvent.VK_ENTER);\n+\n+            robot.waitForIdle();\n+            if (!textChanged) {\n+                throw new RuntimeException(\n+                    \"FAIL: TextEvent not triggered when Enter pressed on TextArea\");\n+            }\n+\n+            textChanged = false;\n+            robot.mouseMove(textAreaAt.x + 4, textAreaAt.y + 10);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (int i = 0; i < textAreaSize.width \/ 2; i++) {\n+                robot.mouseMove(textAreaAt.x + 4 + i, textAreaAt.y + 10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            robot.waitForIdle();\n+            if (textChanged) {\n+                throw new RuntimeException(\n+                    \"FAIL: TextEvent triggered when text is selected on TextArea!\");\n+            }\n+\n+            textChanged = false;\n+            typeKey(KeyEvent.VK_F3);\n+\n+            robot.waitForIdle();\n+            if (textChanged) {\n+                throw new RuntimeException(\n+                    \"FAIL: TextEvent triggered when special key F3 is pressed on TextArea!\");\n+            }\n+            System.out.println(\"Test passed!\");\n+        } finally {\n+            EventQueue.invokeAndWait(TextAreaTextEventTest::disposeFrame);\n+        }\n+    }\n+\n+    private static void initializeGUI() {\n+        frame = new Frame(\"Test Frame\");\n+        frame.setLayout(new FlowLayout());\n+        textArea = new TextArea(5, 15);\n+        textArea.addTextListener((event) -> {\n+            System.out.println(\"Got a text event: \" + event);\n+            textChanged = true;\n+        });\n+        frame.add(textArea);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    private static void typeKey(int key) throws Exception {\n+        robot.keyPress(key);\n+        robot.keyRelease(key);\n+    }\n+}\n","filename":"jdk\/test\/java\/awt\/event\/ComponentEvent\/TextAreaTextEventTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-#\n-# Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 4504355\n-# @summary problems if signed crypto provider is the most preferred provider\n-#\n-# @run shell Dyn.sh\n-\n-# set a few environment variables so that the shell-script can run stand-alone\n-# in the source directory\n-if [ \"${TESTSRC}\" = \"\" ] ; then\n-   TESTSRC=\".\"\n-fi\n-\n-if [ \"${TESTCLASSES}\" = \"\" ] ; then\n-   TESTCLASSES=\".\"\n-fi\n-\n-if [ \"${TESTJAVA}\" = \"\" ] ; then\n-   echo \"TESTJAVA not set.  Test cannot execute.\"\n-   echo \"FAILED!!!\"\n-   exit 1\n-fi\n-\n-if [ \"${COMPILEJAVA}\" = \"\" ]; then\n-   COMPILEJAVA=\"${TESTJAVA}\"\n-fi\n-\n-# set platform-dependent variables\n-OS=`uname -s`\n-case \"$OS\" in\n-  SunOS )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Linux )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Darwin )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  AIX )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  CYGWIN* )\n-    PATHSEP=\";\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Windows* )\n-    PATHSEP=\";\"\n-    FILESEP=\"\\\\\"\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n-# remove old class files\n-cd ${TESTCLASSES}${FILESEP}\n-rm DynSignedProvFirst.class\n-\n-# compile the test program\n-${COMPILEJAVA}${FILESEP}bin${FILESEP}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \\\n-        -classpath ${TESTSRC}${FILESEP}exp.jar \\\n-        -d ${TESTCLASSES}${FILESEP} \\\n-        ${TESTSRC}${FILESEP}DynSignedProvFirst.java\n-\n-# run the test\n-${TESTJAVA}${FILESEP}bin${FILESEP}java ${TESTVMOPTS} \\\n-        -classpath \"${TESTCLASSES}${PATHSEP}${TESTSRC}${FILESEP}exp.jar\" \\\n-        DynSignedProvFirst\n-\n-exit $?\n","filename":"jdk\/test\/java\/security\/Security\/signedfirst\/Dyn.sh","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 4504355 4744260\n+ * @summary problems if signed crypto provider is the most preferred provider\n+ * @library \/lib\/testlibrary\n+ * @run main\/othervm DynStatic\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import jdk.testlibrary.ProcessTools;\n+import jdk.testlibrary.JarUtils;\n+\n+public class DynStatic {\n+\n+    private static final String TEST_SRC =\n+        Paths.get(System.getProperty(\"test.src\")).toString();\n+    private static final Path TEST_CLASSES =\n+        Paths.get(System.getProperty(\"test.classes\"));\n+\n+    private static final Path EXP_SRC_DIR = Paths.get(TEST_SRC, \"com\");\n+    private static final Path EXP_DEST_DIR = Paths.get(\"build\");\n+    private static final Path DYN_SRC =\n+        Paths.get(TEST_SRC, \"DynSignedProvFirst.java\");\n+    private static final Path STATIC_SRC =\n+        Paths.get(TEST_SRC, \"StaticSignedProvFirst.java\");\n+\n+    private static final String STATIC_PROPS =\n+        Paths.get(TEST_SRC, \"Static.props\").toString();\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        \/\/ Compile the provider\n+        CompilerUtils.compile(EXP_SRC_DIR, EXP_DEST_DIR);\n+\n+        \/\/ Create a jar file containing the provider\n+        JarUtils.createJarFile(Paths.get(\"exp.jar\"), EXP_DEST_DIR, Paths.get(\"com\"));\n+\n+        \/\/ Create a keystore\n+        sun.security.tools.keytool.Main.main(\n+            (\"-genkeypair -dname CN=Signer -keystore exp.ks -storepass \"\n+                + \"changeit -keypass changeit -keyalg rsa\").split(\" \"));\n+\n+        \/\/ Sign jar\n+        sun.security.tools.jarsigner.Main.main(\n+                \"-storepass changeit -keystore exp.ks exp.jar mykey\"\n+                        .split(\" \"));\n+\n+        \/\/ Compile the DynSignedProvFirst test program\n+        CompilerUtils.compile(DYN_SRC, TEST_CLASSES, \"-classpath\", \"exp.jar\");\n+\n+        \/\/ Run the DynSignedProvFirst test program\n+        ProcessTools.executeTestJvm(\"-classpath\",\n+            TEST_CLASSES.toString() + File.pathSeparator + \"exp.jar\",\n+            \"DynSignedProvFirst\")\n+            .shouldContain(\"test passed\");\n+\n+        \/\/ Compile the StaticSignedProvFirst test program\n+        CompilerUtils.compile(STATIC_SRC, TEST_CLASSES, \"-classpath\", \"exp.jar\");\n+\n+        \/\/ Run the StaticSignedProvFirst test program\n+        ProcessTools.executeTestJvm(\"-classpath\",\n+            TEST_CLASSES.toString() + File.pathSeparator + \"exp.jar\",\n+            \"-Djava.security.properties=file:\" + STATIC_PROPS,\n+            \"StaticSignedProvFirst\")\n+            .shouldContain(\"test passed\");\n+    }\n+}\n","filename":"jdk\/test\/java\/security\/Security\/signedfirst\/DynStatic.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -1,100 +0,0 @@\n-#\n-# Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 4504355 4744260\n-# @summary problems if signed crypto provider is the most preferred provider\n-#\n-# @run shell Static.sh\n-\n-# set a few environment variables so that the shell-script can run stand-alone\n-# in the source directory\n-if [ \"${TESTSRC}\" = \"\" ] ; then\n-   TESTSRC=\".\"\n-fi\n-\n-if [ \"${TESTCLASSES}\" = \"\" ] ; then\n-   TESTCLASSES=\".\"\n-fi\n-\n-if [ \"${TESTJAVA}\" = \"\" ] ; then\n-   echo \"TESTJAVA not set.  Test cannot execute.\"\n-   echo \"FAILED!!!\"\n-   exit 1\n-fi\n-\n-if [ \"${COMPILEJAVA}\" = \"\" ]; then\n-   COMPILEJAVA=\"${TESTJAVA}\"\n-fi\n-\n-# set platform-dependent variables\n-OS=`uname -s`\n-case \"$OS\" in\n-  SunOS )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Linux )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Darwin )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  AIX )\n-    PATHSEP=\":\"\n-    FILESEP=\"\/\"\n-    ;;\n-  CYGWIN* )\n-    PATHSEP=\";\"\n-    FILESEP=\"\/\"\n-    ;;\n-  Windows* )\n-    PATHSEP=\";\"\n-    FILESEP=\"\\\\\"\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n-# remove old class files\n-cd ${TESTCLASSES}${FILESEP}\n-rm StaticSignedProvFirst.class\n-\n-# compile the test program\n-${COMPILEJAVA}${FILESEP}bin${FILESEP}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \\\n-        -classpath \"${TESTCLASSES}${PATHSEP}${TESTSRC}${FILESEP}exp.jar\" \\\n-        -d ${TESTCLASSES}${FILESEP} \\\n-        ${TESTSRC}${FILESEP}StaticSignedProvFirst.java\n-\n-# run the test\n-cd ${TESTSRC}${FILESEP}\n-${TESTJAVA}${FILESEP}bin${FILESEP}java ${TESTVMOPTS} \\\n-        -classpath \"${TESTCLASSES}${PATHSEP}${TESTSRC}${FILESEP}exp.jar\" \\\n-        -Djava.security.properties=file:${TESTSRC}${FILESEP}Static.props \\\n-        StaticSignedProvFirst\n-\n-exit $?\n","filename":"jdk\/test\/java\/security\/Security\/signedfirst\/Static.sh","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.exp.provider;\n+\n+import java.security.Provider;\n+\n+public class EXP extends Provider {\n+\n+    public EXP() {\n+        super(\"EXP\", 0.0d, \"Test provider\");\n+        put(\"MessageDigest.SHA1\", \"com.sun.exp.provider.SHA\");\n+    }\n+}\n","filename":"jdk\/test\/java\/security\/Security\/signedfirst\/com\/sun\/exp\/provider\/EXP.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.exp.provider;\n+\n+import java.security.MessageDigestSpi;\n+\n+public class SHA extends MessageDigestSpi {\n+    protected void engineReset() {}\n+    protected void engineUpdate(byte input) {}\n+    protected void engineUpdate(byte[] input, int offset, int len) {}\n+    protected byte[] engineDigest() { return null; }\n+}\n","filename":"jdk\/test\/java\/security\/Security\/signedfirst\/com\/sun\/exp\/provider\/SHA.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"filename":"jdk\/test\/java\/security\/Security\/signedfirst\/exp.jar","binary":true,"status":"deleted"},{"filename":"jdk\/test\/java\/security\/Security\/signedfirst\/keystore.jks","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.text.DateFormat;\n@@ -52,0 +53,1 @@\n+import java.util.Locale;\n@@ -68,0 +70,5 @@\n+\n+        \/\/ Certs expired on 7th Nov 2022\n+        params.setDate(DateFormat.getDateInstance(DateFormat.MEDIUM,\n+                Locale.US).parse(\"June 01, 2022\"));\n+\n","filename":"jdk\/test\/java\/security\/cert\/CertPathBuilder\/targetConstraints\/BuildEEBasicConstraints.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.text.DateFormat;\n@@ -100,0 +101,4 @@\n+            \/\/ Certs expired on 7th Nov 2022\n+            params.setDate(DateFormat.getDateInstance(DateFormat.MEDIUM,\n+                    Locale.US).parse(\"June 01, 2022\"));\n+\n","filename":"jdk\/test\/java\/security\/cert\/pkix\/policyChanges\/TestPolicy.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2022c\n+tzdata2022e\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,0 +186,2 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Uzhgorod\n+Link\tEurope\/Kyiv\t\tEurope\/Zaporozhye\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-Asia\/Amman EET EEST\n@@ -102,1 +101,0 @@\n-Asia\/Damascus EET EEST\n@@ -166,1 +164,0 @@\n-Europe\/Uzhgorod EET EEST\n@@ -170,1 +167,0 @@\n-Europe\/Zaporozhye EET EEST\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"filename":"jdk\/test\/java\/util\/jar\/JarFile\/Signed.jar","binary":true,"status":"modified"},{"filename":"jdk\/test\/java\/util\/jar\/JarFile\/test.jar","binary":true,"status":"modified"},{"filename":"jdk\/test\/java\/util\/jar\/JarInputStream\/signed.jar","binary":true,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 7124218\n+ * @summary verifies different behaviour of SPACE and ENTER in JTable\n+ * @library ..\/..\/regtesthelpers\n+ * @build Util\n+ * @run main SelectEditTableCell\n+ *\/\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.DefaultListSelectionModel;\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.LookAndFeel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class SelectEditTableCell {\n+\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        UIManager.LookAndFeelInfo[] lookAndFeelArray\n+                = UIManager.getInstalledLookAndFeels();\n+        for (UIManager.LookAndFeelInfo lookAndFeelItem : lookAndFeelArray) {\n+            executeCase(lookAndFeelItem.getClassName());\n+        }\n+    }\n+\n+    private static void executeCase(String lookAndFeelString) throws Exception {\n+        try {\n+            if (tryLookAndFeel(lookAndFeelString)) {\n+                createUI(lookAndFeelString);\n+                robot.delay(2000);\n+                runTestCase();\n+                robot.delay(2000);\n+                cleanUp();\n+                robot.delay(2000);\n+            }\n+        } finally {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+    }\n+\n+    private static void createUI(final String lookAndFeelString)\n+            throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                String[][] data = {{\"Foo\"}};\n+                String[] cols = {\"One\"};\n+                table = new JTable(data, cols);\n+                table.setSelectionMode(\n+                        DefaultListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+                frame = new JFrame(lookAndFeelString);\n+                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                frame.getContentPane().add(table);\n+                frame.pack();\n+                frame.setSize(500, frame.getSize().height);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                frame.toFront();\n+            }\n+        });\n+    }\n+\n+    private static void runTestCase() throws Exception {\n+        Point centerPoint;\n+        centerPoint = Util.getCenterPoint(table);\n+        LookAndFeel lookAndFeel = UIManager.getLookAndFeel();\n+        robot.mouseMove(centerPoint.x, centerPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.waitForIdle();\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                table.clearSelection();\n+                if (table.isEditing() || table.isCellSelected(0, 0)) {\n+                    \/\/ assumption is bad, bail\n+                    frame.dispose();\n+                    throw new AssertionError(\"Failed assumption: assumed no\"\n+                            + \"editing and no selection.\");\n+                }\n+            }\n+        });\n+\n+        int fetchKeyCode;\n+        keyTap(fetchKeyCode = isMac(lookAndFeel)\n+                ? KeyEvent.VK_ENTER : KeyEvent.VK_SPACE);\n+        final int keyCode = fetchKeyCode;\n+        robot.waitForIdle();\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (!table.isCellSelected(0, 0)) {\n+                    frame.dispose();\n+                    throw new RuntimeException(((keyCode == KeyEvent.VK_ENTER)\n+                            ? \"Enter\" : \"Space\")\n+                            + \" should select cell\");\n+                }\n+            }\n+        });\n+\n+        keyTap(KeyEvent.VK_SPACE);\n+        robot.waitForIdle();\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (!table.isEditing()) {\n+                    frame.dispose();\n+                    throw new RuntimeException(\"Space should start editing\");\n+                }\n+                table.getCellEditor().cancelCellEditing();\n+                table.clearSelection();\n+                if (table.isEditing() || table.isCellSelected(0, 0)) {\n+                    \/\/ assumption is bad, bail\n+                    frame.dispose();\n+                    throw new AssertionError(\"Failed assumption: assumed no \"\n+                            + \"editing and no selection.\");\n+                }\n+            }\n+        });\n+\n+        \/\/ hitting a letter key will start editing\n+        keyTap(KeyEvent.VK_A);\n+        robot.waitForIdle();\n+        keyTap(KeyEvent.VK_SPACE);\n+        robot.waitForIdle();\n+        keyTap(KeyEvent.VK_A);\n+        robot.waitForIdle();\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (table.isCellSelected(0, 0)) {\n+                    frame.dispose();\n+                    throw new RuntimeException(\"Space should not select when \"\n+                            + \"already editing.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    private static void cleanUp() throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                frame.dispose();\n+            }\n+        });\n+    }\n+\n+    private static boolean isMac(LookAndFeel lookAndFeel) {\n+\n+        return lookAndFeel.toString().toLowerCase().contains(\"mac\");\n+    }\n+\n+    private static void keyTap(int keyCode) {\n+        robot.keyPress(keyCode);\n+        robot.keyRelease(keyCode);\n+    }\n+\n+    private static boolean tryLookAndFeel(String lookAndFeelString)\n+            throws Exception {\n+        try {\n+            UIManager.setLookAndFeel(\n+                    lookAndFeelString);\n+\n+        } catch (UnsupportedLookAndFeelException\n+                | ClassNotFoundException\n+                | InstantiationException\n+                | IllegalAccessException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n","filename":"jdk\/test\/javax\/swing\/JTable\/7124218\/SelectEditTableCell.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -44,8 +44,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(metrics);\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.test.lib.Utils;\n+import jdk.testlibrary.FileUtils;\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/lib\n+ * @library \/lib\/testlibrary\n+ * @run junit\/othervm TestCgroupSubsystemController\n+ *\/\n+\n+\/**\n+ *\n+ * Basic unit test for CgroupSubsystemController\n+ *\n+ *\/\n+public class TestCgroupSubsystemController {\n+\n+    private static final double DELTA = 0.01;\n+    private Path existingDirectory;\n+    private Path existingFile;\n+    private String existingFileName = \"test-controller-file\";\n+    private String existingFileContents = \"foobar\";\n+    private String doubleValueContents = \"1.5\";\n+    private String longValueContents = \"3000000000\";\n+    private String longValueMatchingLineContents = \"testme\\n\" +\n+                                                   \"itemfoo 25\";\n+    private String longEntryContents = \"s 1\\n\" +\n+                                       \"t 2\";\n+    private String longEntryName = \"longEntry\";\n+    private String longEntryMatchingLineName = \"longMatchingLine\";\n+    private String doubleValueName = \"doubleValue\";\n+    private String longValueName = \"longValue\";\n+    private CgroupSubsystemController mockController;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemController.class.getSimpleName());\n+            existingFile = Paths.get(existingDirectory.toString(), existingFileName);\n+            Files.write(existingFile, existingFileContents.getBytes(StandardCharsets.UTF_8));\n+            Path longFile = Paths.get(existingDirectory.toString(), longValueName);\n+            Files.write(longFile, longValueContents.getBytes());\n+            Path doubleFile = Paths.get(existingDirectory.toString(), doubleValueName);\n+            Files.write(doubleFile, doubleValueContents.getBytes());\n+            Path longEntryFile = Paths.get(existingDirectory.toString(), longEntryName);\n+            Files.write(longEntryFile, longEntryContents.getBytes());\n+            Path longMatchingLine = Paths.get(existingDirectory.toString(), longEntryMatchingLineName);\n+            Files.write(longMatchingLine, longValueMatchingLineContents.getBytes());\n+            mockController = new MockCgroupSubsystemController(existingDirectory.toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void getStringValueNullController() {\n+        String val = CgroupSubsystemController.getStringValue(null, \"ignore\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueIOException() throws IOException {\n+        String val = CgroupSubsystemController.getStringValue(mockController, \"don-t-exist.txt\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueSuccess() {\n+        String actual = CgroupSubsystemController.getStringValue(mockController, existingFileName);\n+        assertEquals(existingFileContents, actual);\n+    }\n+\n+    @Test\n+    public void convertStringToLong() {\n+        String strVal = \"1230\";\n+        long longVal = Long.parseLong(strVal);\n+        long actual = CgroupSubsystemController.convertStringToLong(strVal, -1L, 0);\n+        assertEquals(longVal, actual);\n+\n+        String overflowVal = \"9223372036854775808\"; \/\/ Long.MAX_VALUE + 1\n+        long overflowDefault = -1;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+        overflowDefault = Long.MAX_VALUE;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+    }\n+\n+    @Test\n+    public void convertStringRangeToIntArray() {\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(null));\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(\"\"));\n+        String strRange = \"2,4,6\";\n+        int[] actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        int[] expected = new int[] { 2, 4, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+        strRange = \"6,1-3\";\n+        actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        expected = new int[] { 1, 2, 3, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void getDoubleValue() {\n+        double defaultValue = -3;\n+        double actual = CgroupSubsystemController.getDoubleValue(null, null, defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+        double expected = Double.parseDouble(doubleValueContents);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, doubleValueName, defaultValue);\n+        assertEquals(expected, actual, DELTA);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, \"don't-exist\", defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+    }\n+\n+    @Test\n+    public void getLongValue() {\n+        long defaultValue = -4;\n+        long actual = CgroupSubsystemController.getLongValue(null, null, Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValue(mockController, \"dont-exist\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        long expected = Long.parseLong(longValueContents);\n+        actual = CgroupSubsystemController.getLongValue(mockController, longValueName, Long::parseLong, defaultValue);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void getLongEntry() {\n+        long defaultValue = -5;\n+        long actual = CgroupSubsystemController.getLongEntry(null, null, \"no-matter\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, \"dont-exist\", \"foo-bar\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, longEntryName, \"t\", defaultValue);\n+        assertEquals(2, actual);\n+    }\n+\n+    @Test\n+    public void getLongMatchingLine() {\n+        long defaultValue = -6;\n+        long actual = CgroupSubsystemController.getLongValueMatchingLine(null, null, \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, \"dont-exist\", \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, longEntryMatchingLineName, \"item\", TestCgroupSubsystemController::convertLong, defaultValue);\n+        assertEquals(25, actual);\n+    }\n+\n+    public static long convertLong(String line) {\n+        return Long.parseLong(line.split(\"\\\\s+\")[1]);\n+    }\n+\n+    static class MockCgroupSubsystemController implements CgroupSubsystemController {\n+\n+        private final String path;\n+\n+        public MockCgroupSubsystemController(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String path() {\n+            return path;\n+        }\n+\n+    }\n+\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Map;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupInfo;\n+import jdk.internal.platform.CgroupSubsystemFactory;\n+import jdk.internal.platform.CgroupSubsystemFactory.CgroupTypeResult;\n+import jdk.internal.platform.CgroupV1MetricsImpl;\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.Metrics;\n+import jdk.testlibrary.Utils;\n+import jdk.testlibrary.FileUtils;\n+\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/lib\/testlibrary\n+ * @run junit\/othervm TestCgroupSubsystemFactory\n+ *\/\n+public class TestCgroupSubsystemFactory {\n+\n+    private Path existingDirectory;\n+    private Path cgroupv1CgroupsJoinControllers;\n+    private Path cgroupv1MountInfoJoinControllers;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoSystemdOnly;\n+    private Path cgroupv1MntInfoDoubleCpusets;\n+    private Path cgroupv1MntInfoDoubleCpusets2;\n+    private Path cgroupv1SelfCgroup;\n+    private Path cgroupv2SelfCgroup;\n+    private Path cgroupv1SelfCgroupJoinCtrl;\n+    private Path cgroupv1CgroupsOnlyCPUCtrl;\n+    private Path cgroupv1SelfCgroupsOnlyCPUCtrl;\n+    private Path cgroupv1MountInfoCgroupsOnlyCPUCtrl;\n+    private String mntInfoEmpty = \"\";\n+    private String cgroupsNonZeroJoinControllers =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset\\t3\\t1\\t1\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\" +\n+            \"blkio\\t7\\t87\\t1\\n\" +\n+            \"memory\\t4\\t153\\t1\\n\" +\n+            \"devices\\t6\\t87\\t1\\n\" +\n+            \"freezer\\t9\\t1\\t1\\n\" +\n+            \"net_cls\\t4\\t153\\t1\\n\" +\n+            \"perf_event\\t2\\t1\\t1\\n\" +\n+            \"net_prio\\t4\\t153\\t1\\n\" +\n+            \"hugetlb\\t4\\t153\\t1\\n\" +\n+            \"pids\\t5\\t95\\t1\\n\" +\n+            \"rdma\\t8\\t1\\t1\\n\";\n+    private String cgroupsNonZeroCpuControllerOnly =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpu\\t4\\t153\\t1\\n\" +\n+            \"cpuacct\\t4\\t153\\t1\\n\";\n+    private String selfCgroupNonZeroCpuControllerOnly =\n+            \"4:cpu,cpuacct:\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n+    private String selfCgroupNonZeroJoinControllers =\n+            \"9:cpuset:\/\\n\" +\n+            \"8:perf_event:\/\\n\" +\n+            \"7:rdma:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/user.slice\\n\" +\n+            \"4:pids:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"3:devices:\/user.slice\\n\" +\n+            \"2:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String mntInfoHybrid =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+    private String mntInfoCpuOnly =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\";\n+    private String mntInfoCgroupv1JoinControllers =\n+            \"31 22 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755\\n\" +\n+            \"32 31 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:10 - cgroup2 cgroup2 rw,nsdelegate\\n\" +\n+            \"33 31 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,xattr,name=systemd\\n\" +\n+            \"36 31 0:31 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,perf_event\\n\" +\n+            \"37 31 0:32 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,cpuset\\n\" +\n+            \"38 31 0:33 \/ \/sys\/fs\/cgroup\/cpu,cpuacct,net_cls,net_prio,hugetlb,memory rw,nosuid,nodev,noexec,relatime shared:17 - cgroup cgroup rw,cpu,cpuacct,memory,net_cls,net_prio,hugetlb\\n\" +\n+            \"39 31 0:34 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:18 - cgroup cgroup rw,pids\\n\" +\n+            \"40 31 0:35 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:19 - cgroup cgroup rw,devices\\n\" +\n+            \"41 31 0:36 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:20 - cgroup cgroup rw,blkio\\n\" +\n+            \"42 31 0:37 \/ \/sys\/fs\/cgroup\/rdma rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,rdma\\n\" +\n+            \"43 31 0:38 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:22 - cgroup cgroup rw,freezer\\n\";\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  9   1   1\\n\" +\n+            \"cpu 7   1   1\\n\" +\n+            \"cpuacct 7   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpuset rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupsV1DoubleCpuset = mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String mntInfoCgroupsV1DoubleCpuset2 = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n+    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"10:hugetlb:\/\\n\" +\n+            \"9:cpuset:\/\\n\" +\n+            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"7:freezer:\/\\n\" +\n+            \"6:blkio:\/\\n\" +\n+            \"5:net_cls,net_prio:\/\\n\" +\n+            \"4:devices:\/user.slice\\n\" +\n+            \"3:perf_event:\/\\n\" +\n+            \"2:cpu,cpuacct:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n+    private String cgroupv2SelfCgroupContent = \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_systemd_only\");\n+            Files.write(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpusets = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset\");\n+            Files.write(cgroupv1MntInfoDoubleCpusets, mntInfoCgroupsV1DoubleCpuset.getBytes());\n+\n+            cgroupv1MntInfoDoubleCpusets2 = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset2\");\n+            Files.write(cgroupv1MntInfoDoubleCpusets2, mntInfoCgroupsV1DoubleCpuset2.getBytes());\n+\n+            cgroupv1CgroupsJoinControllers = Paths.get(existingDirectory.toString(), \"cgroups_cgv1_join_controllers\");\n+            Files.write(cgroupv1CgroupsJoinControllers, cgroupsNonZeroJoinControllers.getBytes());\n+\n+            cgroupv1MountInfoJoinControllers = Paths.get(existingDirectory.toString(), \"mntinfo_cgv1_join_controllers\");\n+            Files.write(cgroupv1MountInfoJoinControllers, mntInfoCgroupv1JoinControllers.getBytes());\n+\n+            cgroupv1SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1\");\n+            Files.write(cgroupv1SelfCgroup, cgroupv1SelfCgroupContent.getBytes());\n+\n+            cgroupv2SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv2\");\n+            Files.write(cgroupv2SelfCgroup, cgroupv2SelfCgroupContent.getBytes());\n+\n+            cgroupv1SelfCgroupJoinCtrl = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.write(cgroupv1SelfCgroupJoinCtrl, selfCgroupNonZeroJoinControllers.getBytes());\n+\n+            cgroupv1CgroupsOnlyCPUCtrl = Paths.get(existingDirectory.toString(), \"cgroups_cpu_only_controller\");\n+            Files.write(cgroupv1CgroupsOnlyCPUCtrl, cgroupsNonZeroCpuControllerOnly.getBytes());\n+\n+            cgroupv1SelfCgroupsOnlyCPUCtrl = Paths.get(existingDirectory.toString(), \"self_cgroup_cpu_only_controller\");\n+            Files.write(cgroupv1SelfCgroupsOnlyCPUCtrl, selfCgroupNonZeroCpuControllerOnly.getBytes());\n+\n+            cgroupv1MountInfoCgroupsOnlyCPUCtrl = Paths.get(existingDirectory.toString(), \"self_mountinfo_cpu_only_controller\");\n+            Files.write(cgroupv1MountInfoCgroupsOnlyCPUCtrl, mntInfoCpuOnly.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testCgroupv1CpuControllerOnly() throws IOException {\n+        String cgroups = cgroupv1CgroupsOnlyCPUCtrl.toString();\n+        String mountInfo = cgroupv1MountInfoCgroupsOnlyCPUCtrl.toString();\n+        String selfCgroup = cgroupv1SelfCgroupsOnlyCPUCtrl.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Expected cgroup v1\", res.isCgroupV2());\n+        Map<String, CgroupInfo> infos = res.getInfos();\n+        assertNull(\"Memory controller expected null\", infos.get(\"memory\"));\n+        assertNotNull(\"Cpu controller expected non-null\", infos.get(\"cpu\"));\n+\n+        \/\/ cgroup v1 tests only as this isn't possible with unified hierarchy\n+        \/\/ where all controllers have the same mount point\n+        CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n+        \/\/ This throws NPEs prior JDK-8257746\n+        long val = subsystem.getMemoryAndSwapLimit();\n+        assertEquals(\"expected unlimited, and no NPE\", -1, val);\n+        val = subsystem.getMemoryAndSwapFailCount();\n+        assertEquals(\"expected unlimited, and no NPE\", -1, val);\n+        val = subsystem.getMemoryAndSwapMaxUsage();\n+        assertEquals(\"expected unlimited, and no NPE\", -1, val);\n+        val = subsystem.getMemoryAndSwapUsage();\n+        assertEquals(\"expected unlimited, and no NPE\", -1, val);\n+    }\n+\n+    @Test\n+    public void testCgroupv1JoinControllerCombo() throws IOException {\n+        String cgroups = cgroupv1CgroupsJoinControllers.toString();\n+        String mountInfo = cgroupv1MountInfoJoinControllers.toString();\n+        String selfCgroup = cgroupv1SelfCgroupJoinCtrl.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Join controller combination expected as cgroups v1\", res.isCgroupV2());\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-3.scope\", memoryInfo.getCgroupPath());\n+    }\n+\n+    @Test\n+    public void testCgroupv1SystemdOnly() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoSystemdOnly.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"zero hierarchy ids with no *relevant* controllers mounted\", Optional.empty().equals(result));\n+    }\n+\n+    @Test\n+    public void testCgroupv1MultipleCpusetMounts() throws IOException {\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets);\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets2);\n+    }\n+\n+    private void doMultipleCpusetMountsTest(Path info) throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = info.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Duplicate cpusets should not influence detection heuristic\", res.isCgroupV2());\n+        CgroupInfo cpuSetInfo = res.getInfos().get(\"cpuset\");\n+        assertEquals(\"\/sys\/fs\/cgroup\/cpuset\", cpuSetInfo.getMountPoint());\n+        assertEquals(\"\/\", cpuSetInfo.getMountRoot());\n+    }\n+\n+    @Test\n+    public void testHybridCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"hybrid hierarchy expected as cgroups v1\", res.isCgroupV2());\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n+        assertEquals(\"\/\", memoryInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\/memory\", memoryInfo.getMountPoint());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"zero hierarchy ids with no mounted controllers => empty result\", Optional.empty().equals(result));\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV2() throws IOException {\n+        String cgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        String selfCgroup = cgroupv2SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"zero hierarchy ids with mounted controllers expected cgroups v2\", res.isCgroupV2());\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n+        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n+        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void mountInfoFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ any existing file\n+        String mountInfo = Paths.get(existingDirectory.toString(), \"not-existing-mountinfo\").toString();\n+\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void cgroupsFileNotFound() throws IOException {\n+        String cgroups = Paths.get(existingDirectory.toString(), \"not-existing-cgroups\").toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String selfCgroup = cgroupv2SelfCgroup.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void selfCgroupsFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String selfCgroup = Paths.get(existingDirectory.toString(), \"not-existing-self-cgroups\").toString();\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+    }\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -99,1 +100,1 @@\n-        if (effectiveCpus.length != 0) {\n+        if (effectiveCpus != null) {\n@@ -134,1 +135,1 @@\n-        if (effectiveMems.length != 0) {\n+        if (effectiveMems != null) {\n@@ -146,0 +147,5 @@\n+        if (\"cgroupv2\".equals(metrics.getProvider()) && shares < 1024) {\n+            \/\/ Adjust input shares for < 1024 cpu shares as the\n+            \/\/ impl. rounds up to the next multiple of 1024\n+            shares = 1024;\n+        }\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+import jdk.internal.platform.CgroupV1Metrics;\n@@ -28,0 +30,3 @@\n+\n+    private static final long UNLIMITED = -1;\n+\n@@ -75,0 +80,1 @@\n+            boolean atLeastOneAllocationWorked = false;\n@@ -78,0 +84,1 @@\n+                    atLeastOneAllocationWorked = true;\n@@ -87,0 +94,6 @@\n+            if (!atLeastOneAllocationWorked) {\n+                System.out.println(\"Allocation failed immediately. Ignoring test!\");\n+                return;\n+            }\n+            \/\/ Be sure bytes allocations don't get optimized out\n+            System.out.println(\"DEBUG: Bytes allocation length 1: \" + bytes[0].length);\n@@ -110,5 +123,16 @@\n-        long limit = getMemoryValue(value);\n-        if (limit != Metrics.systemMetrics().getKernelMemoryLimit()) {\n-            throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n-                    + limit + \"]\" + \", got : [\"\n-                    + Metrics.systemMetrics().getKernelMemoryLimit() + \"]\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            System.out.println(\"TEST PASSED!!!\");\n+            long limit = getMemoryValue(value);\n+            long kmemlimit = mCgroupV1.getKernelMemoryLimit();\n+            \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n+            \/\/ This feature is deprecated. Only perform the check if we get an actual\n+            \/\/ limit back.\n+            if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n+                throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n+                            + limit + \"]\" + \", got : [\"\n+                            + kmemlimit + \"]\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"kernel memory limit test not supported for cgroups v2\");\n@@ -116,1 +140,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n@@ -150,2 +173,11 @@\n-        if (!(oomKillFlag ^ Metrics.systemMetrics().isMemoryOOMKillEnabled())) {\n-            throw new RuntimeException(\"oomKillFlag error\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            Boolean expected = Boolean.valueOf(oomKillFlag);\n+            Boolean actual = mCgroupV1.isMemoryOOMKillEnabled();\n+            if (!(expected.equals(actual))) {\n+                throw new RuntimeException(\"oomKillFlag error\");\n+            }\n+            System.out.println(\"TEST PASSED!!!\");\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -153,1 +185,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-            if (cpuSetMems.length > 1) {\n+            if (cpuSetMems != null && cpuSetMems.length > 1) {\n@@ -82,1 +82,1 @@\n-            } else if (cpuSetMems.length == 1) {\n+            } else if (cpuSetMems != null && cpuSetMems.length == 1) {\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -58,4 +60,15 @@\n-            testKernelMemoryLimit(\"100m\");\n-            testKernelMemoryLimit(\"1g\");\n-\n-            testOomKillFlag(\"100m\", false);\n+            Metrics m = Metrics.systemMetrics();\n+            \/\/ kernel memory, '--kernel-memory' switch, and OOM killer,\n+            \/\/ '--oom-kill-disable' switch, tests not supported by cgroupv2\n+            \/\/ runtimes\n+            if (m != null) {\n+                if (\"cgroupv1\".equals(m.getProvider())) {\n+                    testKernelMemoryLimit(\"100m\");\n+                    testKernelMemoryLimit(\"1g\");\n+\n+                    testOomKillFlag(\"100m\", false);\n+                } else {\n+                    System.out.println(\"kernel memory tests and OOM Kill flag tests not \" +\n+                                       \"possible with cgroupv2.\");\n+                }\n+            }\n@@ -64,1 +77,1 @@\n-            testMemoryFailCount(\"20m\");\n+            testMemoryFailCount(\"64m\");\n@@ -69,1 +82,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -130,1 +145,2 @@\n-        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+        OutputAnalyzer oa = DockerTestUtils.dockerRunJava(opts);\n+        oa.shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -57,2 +58,1 @@\n-        try {\n-            Stream<String> stream = Files.lines(Paths.get(path));\n+        try (Stream<String> stream = Files.lines(Paths.get(path))) {\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CPUSetsReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+interface CgroupMetricsTester {\n+\n+    public static final double ERROR_MARGIN = 0.1;\n+    public static final String EMPTY_STR = \"\";\n+\n+    public void testMemorySubsystem();\n+    public void testCpuAccounting();\n+    public void testCpuSchedulingMetrics();\n+    public void testCpuSets();\n+    public void testCpuConsumption() throws IOException, InterruptedException;\n+    public void testMemoryUsage() throws Exception;\n+    public void testMisc();\n+\n+    public static long convertStringToLong(String strval, long initialVal, long overflowRetval) {\n+        long retval = initialVal;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n+            \/\/ In this case, return Long.MAX_VALUE\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static boolean compareWithErrorMargin(long oldVal, long newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static boolean compareWithErrorMargin(double oldVal, double newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static void fail(String controller, String metric, long oldVal, long testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, String oldVal, String testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, double oldVal, double testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, boolean oldVal, boolean testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void warn(String controller, String metric, long oldVal, long testVal) {\n+        System.err.println(\"Warning - \" + controller + \":\" + metric\n+                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static Integer[] convertCpuSetsToArray(String cpusstr) {\n+        if (cpusstr == null || EMPTY_STR.equals(cpusstr)) {\n+            return null;\n+        }\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] cpuSets = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n+            if (a.contains(\"-\")) {\n+                String[] range = a.split(\"-\");\n+                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n+                        Integer.parseInt(range[1])).boxed();\n+            } else {\n+                return Stream.of(Integer.parseInt(a));\n+            }\n+        }).toArray(Integer[]::new);\n+        return cpuSets;\n+    }\n+\n+    public static Integer[] boxedArrayOrNull(int[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return Arrays.stream(primitiveArray).boxed().toArray(Integer[]::new);\n+    }\n+\n+    public static Integer[] sortAllowNull(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc.\n@@ -24,0 +24,1 @@\n+\n@@ -26,16 +27,2 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n+import java.util.Objects;\n+\n@@ -44,0 +31,4 @@\n+\/**\n+ * Cgroup version agnostic metrics tester\n+ *\n+ *\/\n@@ -46,312 +37,2 @@\n-    private static final double ERROR_MARGIN = 0.1;\n-    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-    long startSysVal;\n-    long startUserVal;\n-    long startUsage;\n-    long startPerCpu[];\n-\n-    enum SubSystem {\n-        MEMORY(\"memory\"),\n-        CPUSET(\"cpuset\"),\n-        CPU(\"cpu\"),\n-        CPUACCT(\"cpuacct\"),\n-        BLKIO(\"blkio\");\n-\n-        private String value;\n-\n-        SubSystem(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private static final Set<String> allowedSubSystems =\n-            Stream.of(SubSystem.values()).map(SubSystem::value).collect(Collectors.toSet());\n-\n-    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n-\n-    private static void setPath(String[] line) {\n-        String cgroupPath = line[2];\n-        String[] subSystems = line[1].split(\",\");\n-\n-        for (String subSystem : subSystems) {\n-            if (allowedSubSystems.contains(subSystem)) {\n-                String[] paths = subSystemPaths.get(subSystem);\n-                String finalPath = \"\";\n-                String root = paths[0];\n-                String mountPoint = paths[1];\n-                if (root != null && cgroupPath != null) {\n-                    if (root.equals(\"\/\")) {\n-                        if (!cgroupPath.equals(\"\/\")) {\n-                            finalPath = mountPoint + cgroupPath;\n-                        } else {\n-                            finalPath = mountPoint;\n-                        }\n-                    } else {\n-                        if (root.equals(cgroupPath)) {\n-                            finalPath = mountPoint;\n-                        } else {\n-                            if (cgroupPath.startsWith(root)) {\n-                                if (cgroupPath.length() > root.length()) {\n-                                    String cgroupSubstr = cgroupPath.substring(root.length());\n-                                    finalPath = mountPoint + cgroupSubstr;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n-            }\n-        }\n-    }\n-\n-    private static void createSubsystems(String[] line) {\n-        if (line.length < 5) return;\n-        Path p = Paths.get(line[4]);\n-        String subsystemName = p.getFileName().toString();\n-        if (subsystemName != null) {\n-            for (String subSystem : subsystemName.split(\",\")) {\n-                if (allowedSubSystems.contains(subSystem)) {\n-                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n-                }\n-            }\n-        }\n-    }\n-\n-    public void setup() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ Initialize CPU usage metrics before we do any testing.\n-        startSysVal = metrics.getCpuSystemUsage();\n-        startUserVal = metrics.getCpuUserUsage();\n-        startUsage = metrics.getCpuUsage();\n-        startPerCpu = metrics.getPerCpuUsage();\n-\n-        try {\n-            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n-            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n-                    .map(line -> line.split(\" \"))\n-                    .forEach(MetricsTester::createSubsystems);\n-            lines.close();\n-\n-            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n-            lines.map(line -> line.split(\":\"))\n-                    .filter(line -> (line.length >= 3))\n-                    .forEach(MetricsTester::setPath);\n-            lines.close();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    private static String getFileContents(SubSystem subSystem, String fileName) {\n-        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n-        try {\n-            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n-        } catch (FileNotFoundException e) {\n-            System.err.println(\"Unable to open : \" + fname);\n-            return \"\";\n-        }\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0L : Long.parseLong(data);\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String metric, String subMetric) {\n-        String stats = getFileContents(subSystem, metric);\n-        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n-        for (int i = 0; i < tokens.length; i++) {\n-            if (tokens[i].startsWith(subMetric)) {\n-                return Long.parseLong(tokens[i].split(\"\\\\s+\")[1]);\n-            }\n-        }\n-        return 0L;\n-    }\n-\n-    private static double getDoubleValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n-    }\n-\n-    private boolean compareWithErrorMargin(long oldVal, long newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private boolean compareWithErrorMargin(double oldVal, double newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private static void fail(SubSystem system, String metric, long oldVal, long testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, String oldVal, String testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, double oldVal, double testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, boolean oldVal, boolean testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void warn(SubSystem system, String metric, long oldVal, long testVal) {\n-        System.err.println(\"Warning - \" + system.value + \":\" + metric\n-                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    public void testMemorySubsystem() {\n-        Metrics metrics = Metrics.systemMetrics();\n-\n-        \/\/ User Memory\n-        long oldVal = metrics.getMemoryFailCount();\n-        long newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/ Kernel memory\n-        oldVal = metrics.getKernelMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/TCP Memory\n-        oldVal = metrics.getTcpMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/  Memory and Swap\n-        \/\/ Skip swap tests if no swap is configured.\n-        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n-            oldVal = metrics.getMemoryAndSwapFailCount();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.failcnt\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapLimit();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\");\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapMaxUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n-            }\n-        }\n-\n-        oldVal = metrics.getMemorySoftLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n-        boolean newOomKillEnabled = getLongValueFromFile(SubSystem.MEMORY,\n-                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n-        if (oomKillEnabled != newOomKillEnabled) {\n-            throw new RuntimeException(\"Test failed for - \" + SubSystem.MEMORY.value + \":\"\n-                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n-                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n-        }\n-    }\n-\n-    public void testCpuAccounting() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuUsage();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.usage\");\n-\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n-        }\n-\n-        Long[] newVals = Stream.of(getFileContents(SubSystem.CPUACCT, \"cpuacct.usage_percpu\")\n-                .split(\"\\\\s+\"))\n-                .map(Long::parseLong)\n-                .toArray(Long[]::new);\n-        Long[] oldVals = LongStream.of(metrics.getPerCpuUsage()).boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(SubSystem.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n-            }\n-        }\n+    private static final String CGROUP_V1 = \"cgroupv1\";\n+    private static final String CGROUP_V2 = \"cgroupv2\";\n@@ -359,50 +40,12 @@\n-        oldVal = metrics.getCpuUserUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"user\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuSystemUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"system\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSchedulingMetrics() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuPeriod();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_period_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuQuota();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_quota_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuShares();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.shares\");\n-        if (newVal == 0 || newVal == 1024) newVal = -1;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.shares\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumPeriods();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_periods\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumThrottled();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuThrottledTime();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"throttled_time\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+    private static CgroupMetricsTester createInstance(Metrics m) {\n+        Objects.requireNonNull(m);\n+        if (CGROUP_V1.equals(m.getProvider())) {\n+            MetricsTesterCgroupV1 t = new MetricsTesterCgroupV1();\n+            t.setup();\n+            return t;\n+        } else if (CGROUP_V2.equals(m.getProvider())) {\n+            return new MetricsTesterCgroupV2();\n+        } else {\n+            System.err.println(\"WARNING: Metrics provider, '\" + m.getProvider()\n+                                                              + \"' is unknown!\");\n+            return null;\n@@ -412,180 +55,9 @@\n-    public void testCpuSets() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-\n-        String cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.cpus\");\n-        \/\/ Parse range string in the format 1,2-6,7\n-        Integer[] newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (!Arrays.equals(oldVal, newVal)) {\n-            fail(SubSystem.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n-                Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-        cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.mems\");\n-        newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (!Arrays.equals(oldVal, newVal)) {\n-            fail(SubSystem.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n-                    Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_mems\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        double oldValue = metrics.getCpuSetMemoryPressure();\n-        double newValue = getDoubleValueFromFile(SubSystem.CPUSET, \"cpuset.memory_pressure\");\n-        if (!compareWithErrorMargin(oldValue, newValue)) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n-        }\n-\n-        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n-        boolean newV = getLongValueFromFile(SubSystem.CPUSET,\n-                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n-        if (oldV != newV) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n-        }\n-    }\n-\n-    public void testBlkIO() {\n-        Metrics metrics = Metrics.systemMetrics();\n-            long oldVal = metrics.getBlkIOServiceCount();\n-        long newVal = getLongValueFromFile(SubSystem.BLKIO,\n-                \"blkio.throttle.io_service_bytes\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n-                    oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getBlkIOServiced();\n-        newVal = getLongValueFromFile(SubSystem.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuConsumption() throws IOException, InterruptedException {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ make system call\n-        long newSysVal = metrics.getCpuSystemUsage();\n-        long newUserVal = metrics.getCpuUserUsage();\n-        long newUsage = metrics.getCpuUsage();\n-        long[] newPerCpu = metrics.getPerCpuUsage();\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newSysVal < startSysVal) {\n-            fail(SubSystem.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n-        }\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newUserVal < startUserVal) {\n-            fail(SubSystem.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n-        }\n-\n-        if (newUsage <= startUsage) {\n-            fail(SubSystem.CPU, \"getCpuUsage\", newUsage, startUsage);\n-        }\n-\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n-            }\n-        }\n-\n-        if(!success) fail(SubSystem.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n-    }\n-\n-    public void testMemoryUsage() throws Exception {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n-        long memoryUsage = metrics.getMemoryUsage();\n-        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n-\n-        \/\/ allocate memory in a loop and check more than once for new values\n-        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n-        \/\/ e.g. because the system could free up memory\n-        byte[][] bytes = new byte[32][];\n-        for (int i = 0; i < 32; i++) {\n-            bytes[i] = new byte[8*1024*1024];\n-            newMemoryUsage = metrics.getMemoryUsage();\n-            if (newMemoryUsage > memoryUsage) {\n-                break;\n-            }\n-        }\n-        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n-\n-        if (newMemoryMaxUsage < memoryMaxUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n-                    newMemoryMaxUsage);\n-        }\n-\n-        if (newMemoryUsage < memoryUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n-        }\n+    public void testAll(Metrics m) throws Exception {\n+        CgroupMetricsTester tester =  createInstance(m);\n+        tester.testCpuAccounting();\n+        tester.testCpuConsumption();\n+        tester.testCpuSchedulingMetrics();\n+        tester.testCpuSets();\n+        tester.testMemorySubsystem();\n+        tester.testMemoryUsage();\n+        tester.testMisc();\n@@ -595,0 +67,1 @@\n+        Metrics m = Metrics.systemMetrics();\n@@ -596,2 +69,1 @@\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n+        if (m == null) {\n@@ -603,8 +75,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(m);\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":34,"deletions":569,"binary":false,"changes":603,"status":"modified"},{"patch":"@@ -0,0 +1,579 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupV1Metrics;\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Asserts;\n+\n+public class MetricsTesterCgroupV1 implements CgroupMetricsTester {\n+\n+    \/\/ Aliased for readability\n+    private static final long RETVAL_UNAVAILABLE = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n+    long startSysVal;\n+    long startUserVal;\n+    long startUsage;\n+    long startPerCpu[];\n+\n+    enum Controller {\n+        MEMORY(\"memory\"),\n+        CPUSET(\"cpuset\"),\n+        CPU(\"cpu\"),\n+        CPUACCT(\"cpuacct\"),\n+        BLKIO(\"blkio\");\n+\n+        private String value;\n+\n+        Controller(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private static final Set<String> allowedSubSystems =\n+            Stream.of(Controller.values()).map(Controller::value).collect(Collectors.toSet());\n+\n+    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n+\n+    private static void setPath(String[] line) {\n+        String cgroupPath = line[2];\n+        String[] subSystems = line[1].split(\",\");\n+\n+        for (String subSystem : subSystems) {\n+            if (allowedSubSystems.contains(subSystem)) {\n+                String[] paths = subSystemPaths.get(subSystem);\n+                String finalPath = \"\";\n+                String root = paths[0];\n+                String mountPoint = paths[1];\n+                if (root != null && cgroupPath != null) {\n+                    if (root.equals(\"\/\")) {\n+                        if (!cgroupPath.equals(\"\/\")) {\n+                            finalPath = mountPoint + cgroupPath;\n+                        } else {\n+                            finalPath = mountPoint;\n+                        }\n+                    } else {\n+                        if (root.equals(cgroupPath)) {\n+                            finalPath = mountPoint;\n+                        } else {\n+                            if (cgroupPath.startsWith(root)) {\n+                                if (cgroupPath.length() > root.length()) {\n+                                    String cgroupSubstr = cgroupPath.substring(root.length());\n+                                    finalPath = mountPoint + cgroupSubstr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n+            }\n+        }\n+    }\n+\n+    private static void createSubsystems(String[] line) {\n+        if (line.length < 5) return;\n+        Path p = Paths.get(line[4]);\n+        String subsystemName = p.getFileName().toString();\n+        if (subsystemName != null) {\n+            for (String subSystem : subsystemName.split(\",\")) {\n+                if (allowedSubSystems.contains(subSystem)) {\n+                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setup() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+        startPerCpu = metrics.getPerCpuUsage();\n+\n+        try {\n+            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n+            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n+                    .map(line -> line.split(\" \"))\n+                    .forEach(MetricsTesterCgroupV1::createSubsystems);\n+            lines.close();\n+\n+            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n+            lines.map(line -> line.split(\":\"))\n+                    .filter(line -> (line.length >= 3))\n+                    .forEach(MetricsTesterCgroupV1::setPath);\n+            lines.close();\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private static String getFileContents(Controller subSystem, String fileName) {\n+        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n+        try {\n+            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n+        } catch (FileNotFoundException e) {\n+            System.err.println(\"Unable to open : \" + fname);\n+            return null;\n+        }\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return (data == null || data.isEmpty()) ? RETVAL_UNAVAILABLE : convertStringToLong(data);\n+    }\n+\n+    private static long convertStringToLong(String strval) {\n+        return CgroupMetricsTester.convertStringToLong(strval, RETVAL_UNAVAILABLE, Long.MAX_VALUE);\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String metric, String subMetric) {\n+        String stats = getFileContents(subSystem, metric);\n+        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n+        for (int i = 0; i < tokens.length; i++) {\n+            if (tokens[i].startsWith(subMetric)) {\n+                String strval = tokens[i].split(\"\\\\s+\")[1];\n+                return convertStringToLong(strval);\n+            }\n+        }\n+        return RETVAL_UNAVAILABLE;\n+    }\n+\n+    private static double getDoubleValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return data == null || data.isEmpty() ? RETVAL_UNAVAILABLE : Double.parseDouble(data);\n+    }\n+\n+    private static void fail(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, String oldVal, String testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, double oldVal, double testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, boolean oldVal, boolean testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void warn(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.warn(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private Long[] boxedArrayOrNull(long[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return LongStream.of(primitiveArray).boxed().toArray(Long[]::new);\n+    }\n+\n+    public void testMemorySubsystem() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueFromFile(Controller.MEMORY, \"memory.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/ Kernel memory\n+        oldVal = metrics.getKernelMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/TCP Memory\n+        oldVal = metrics.getTcpMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED: newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/  Memory and Swap\n+        \/\/ Skip swap tests if no swap is configured.\n+        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n+            oldVal = metrics.getMemoryAndSwapFailCount();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.failcnt\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapLimit();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.limit_in_bytes\");\n+            newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapMaxUsage();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n+            }\n+\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                oldVal = metrics.getMemoryAndSwapUsage();\n+                newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.usage_in_bytes\");\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                    fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                }\n+            }\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.soft_limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n+        boolean newOomKillEnabled = getLongValueFromFile(Controller.MEMORY,\n+                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n+        if (oomKillEnabled != newOomKillEnabled) {\n+            throw new RuntimeException(\"Test failed for - \" + Controller.MEMORY.value + \":\"\n+                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n+                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+        }\n+    }\n+\n+    public void testCpuAccounting() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.usage\");\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n+        }\n+\n+        String newValsStr = getFileContents(Controller.CPUACCT, \"cpuacct.usage_percpu\");\n+        Long[] newVals = null;\n+        if (newValsStr != null) {\n+            newVals = Stream.of(newValsStr\n+                .split(\"\\\\s+\"))\n+                .map(Long::parseLong)\n+                .toArray(Long[]::new);\n+        }\n+        Long[] oldVals = boxedArrayOrNull(metrics.getPerCpuUsage());\n+        if (oldVals != null) {\n+            for (int i = 0; i < oldVals.length; i++) {\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                    warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+                }\n+            }\n+        } else {\n+            Asserts.assertNull(newVals, Controller.CPUACCT.value() + \"cpuacct.usage_percpu not both null\");\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"user\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"system\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSchedulingMetrics() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_period_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_quota_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.shares\");\n+        if (newVal == 0 || newVal == 1024) newVal = -1;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.shares\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"throttled_time\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSets() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+\n+        String cpusstr = getFileContents(Controller.CPUSET, \"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n+                Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSets);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSetMems);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        double oldValue = metrics.getCpuSetMemoryPressure();\n+        double newValue = getDoubleValueFromFile(Controller.CPUSET, \"cpuset.memory_pressure\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldValue, newValue)) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n+        }\n+\n+        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n+        boolean newV = getLongValueFromFile(Controller.CPUSET,\n+                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n+        if (oldV != newV) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n+        }\n+    }\n+\n+    private void testBlkIO() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+            long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getLongValueFromFile(Controller.BLKIO,\n+                \"blkio.throttle.io_service_bytes\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n+                    oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getLongValueFromFile(Controller.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuConsumption() throws IOException, InterruptedException {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+        long[] newPerCpu = metrics.getPerCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(Controller.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(Controller.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(Controller.CPU, \"getCpuUsage\", newUsage, startUsage);\n+        }\n+\n+        if (startPerCpu != null) {\n+            boolean success = false;\n+            for (int i = 0; i < startPerCpu.length; i++) {\n+                if (newPerCpu[i] > startPerCpu[i]) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+            if (!success) {\n+                fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                                                       Arrays.toString(startPerCpu));\n+            }\n+        } else {\n+            Asserts.assertNull(newPerCpu, Controller.CPU.value() + \" getPerCpuUsage not both null\");\n+        }\n+\n+    }\n+\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testBlkIO();\n+    }\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":579,"deletions":0,"binary":false,"changes":579,"status":"added"},{"patch":"@@ -0,0 +1,479 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.Metrics;\n+\n+public class MetricsTesterCgroupV2 implements CgroupMetricsTester {\n+\n+    private static final long UNLIMITED = -1;\n+    private static final long NOT_AVAILABLE = -1;\n+    private static final UnifiedController UNIFIED = new UnifiedController();\n+    private static final String MAX = \"max\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    private final long startSysVal;\n+    private final long startUserVal;\n+    private final long startUsage;\n+\n+    static class UnifiedController {\n+\n+        private static final String NAME = \"unified\";\n+        private final String path;\n+\n+        UnifiedController() {\n+            path = constructPath();\n+        }\n+\n+        String getPath() {\n+            return path;\n+        }\n+\n+        private static String constructPath() {\n+            String mountPath;\n+            String cgroupPath;\n+            try {\n+                List<String> fifthTokens = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))\n+                        .filter( l -> l.contains(\"- cgroup2\"))\n+                        .map(UnifiedController::splitAndMountPath)\n+                        .collect(Collectors.toList());\n+                if (fifthTokens.size() != 1) {\n+                    throw new AssertionError(\"Expected only one cgroup2 line\");\n+                }\n+                mountPath = fifthTokens.get(0);\n+\n+                List<String> cgroupPaths = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))\n+                        .filter( l -> l.startsWith(\"0:\"))\n+                        .map(UnifiedController::splitAndCgroupPath)\n+                        .collect(Collectors.toList());\n+                if (cgroupPaths.size() != 1) {\n+                    throw new AssertionError(\"Expected only one unified controller line\");\n+                }\n+                cgroupPath = cgroupPaths.get(0);\n+                return Paths.get(mountPath, cgroupPath).toString();\n+            } catch (IOException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static String splitAndMountPath(String input) {\n+            String[] tokens = input.split(\"\\\\s+\");\n+            return tokens[4]; \/\/ fifth entry is the mount path\n+        }\n+\n+        public static String splitAndCgroupPath(String input) {\n+            String[] tokens = input.split(\":\");\n+            return tokens[2];\n+        }\n+    }\n+\n+    private long getLongLimitValueFromFile(String file) {\n+        String strVal = getStringVal(file);\n+        if (MAX.equals(strVal)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(strVal);\n+    }\n+\n+    public MetricsTesterCgroupV2() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+    }\n+\n+    private long getLongValueFromFile(String file) {\n+        return convertStringToLong(getStringVal(file));\n+    }\n+\n+    private long getLongValueEntryFromFile(String file, String metric) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            String strVal = Files.lines(filePath).filter(l -> l.startsWith(metric)).collect(Collectors.joining());\n+            String[] keyValues = strVal.split(\"\\\\s+\");\n+            String value = keyValues[1];\n+            return convertStringToLong(value);\n+        } catch (IOException e) {\n+            return NOT_AVAILABLE;\n+        }\n+    }\n+\n+    private String getStringVal(String file) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            return Files.lines(filePath).collect(Collectors.joining());\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private void fail(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void fail(String metric, String oldVal, String newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void warn(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.warn(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private long getCpuShares(String file) {\n+        long rawVal = getLongValueFromFile(file);\n+        if (rawVal == NOT_AVAILABLE || rawVal == 100) {\n+            return UNLIMITED;\n+        }\n+        int shares = (int)rawVal;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    private long getCpuMaxValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 0 \/* $MAX index *\/);\n+    }\n+\n+    private long getCpuPeriodValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 1 \/* $PERIOD index *\/);\n+    }\n+\n+    private long getCpuValueFromFile(String file, int index) {\n+        String maxPeriod = getStringVal(file);\n+        if (maxPeriod == null) {\n+            return UNLIMITED;\n+        }\n+        String[] tokens = maxPeriod.split(\"\\\\s+\");\n+        String val = tokens[index];\n+        if (MAX.equals(val)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(val);\n+    }\n+\n+    private long convertStringToLong(String val) {\n+        return CgroupMetricsTester.convertStringToLong(val, NOT_AVAILABLE, UNLIMITED);\n+    }\n+\n+    private long nanosOrUnlimited(long micros) {\n+        if (micros < 0) {\n+            return UNLIMITED;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public void testMemorySubsystem() {\n+        Metrics metrics = Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueEntryFromFile(\"memory.events\", \"max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.events[max]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(\"memory.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueEntryFromFile(\"memory.stat\", \"sock\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.stat[sock]\", oldVal, newVal);\n+        }\n+\n+        long memAndSwapLimit = metrics.getMemoryAndSwapLimit();\n+        long memLimit = metrics.getMemoryLimit();\n+        \/\/ Only test swap memory limits if we can. On systems with swapaccount=0\n+        \/\/ we cannot, as swap limits are disabled.\n+        if (memAndSwapLimit <= memLimit) {\n+            System.out.println(\"No swap memory limits, test case(s) skipped\");\n+        } else {\n+            oldVal = memAndSwapLimit;\n+            long valSwap = getLongLimitValueFromFile(\"memory.swap.max\");\n+            long valMemory = getLongLimitValueFromFile(\"memory.max\");\n+            if (valSwap == UNLIMITED) {\n+                newVal = valSwap;\n+            } else {\n+                assert valMemory >= 0;\n+                newVal = valSwap + valMemory;\n+            }\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(\"memory.swap.max\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapUsage();\n+            long swapUsage = getLongValueFromFile(\"memory.swap.current\");\n+            long memUsage = getLongValueFromFile(\"memory.current\");\n+            newVal = swapUsage + memUsage;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(\"memory.swap.current\", oldVal, newVal);\n+            }\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.low\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.low\", oldVal, newVal);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testCpuAccounting() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[usage_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[user_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[system_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSchedulingMetrics() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getCpuPeriodValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$PERIOD]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getCpuMaxValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$MAX]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getCpuShares(\"cpu.weight\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.weight\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_periods]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_throttled]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[throttled_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSets() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+\n+        String cpusstr = getStringVal(\"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.cpus\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.cpus.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.cpus.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.mems\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.mems.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuConsumption() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(\"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(\"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(\"getCpuUsage\", newUsage, startUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testIOStat();\n+    }\n+\n+    private void testIOStat() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getIoStatAccumulate(new String[] { \"rios\", \"wios\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rios\/wios: \", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getIoStatAccumulate(new String[] { \"rbytes\", \"wbytes\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rbytes\/wbytes: \", oldVal, newVal);\n+        }\n+    }\n+\n+    private long getIoStatAccumulate(String[] matchNames) {\n+        try {\n+            return Files.lines(Paths.get(UNIFIED.getPath(), \"io.stat\"))\n+                    .map(line -> {\n+                        long accumulator = 0;\n+                        String[] tokens = line.split(\"\\\\s+\");\n+                        for (String t: tokens) {\n+                            String[] keyVal = t.split(\"=\");\n+                            if (keyVal.length != 2) {\n+                                continue;\n+                            }\n+                            for (String match: matchNames) {\n+                                if (match.equals(keyVal[0])) {\n+                                    accumulator += Long.parseLong(keyVal[1]);\n+                                }\n+                            }\n+                        }\n+                        return accumulator;\n+                    }).collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return NOT_AVAILABLE;\n+        }\n+    }\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":479,"deletions":0,"binary":false,"changes":479,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-                return \"aarch64\/ubuntu\";\n+                return \"arm64v8\/ubuntu\";\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,276 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.util;\n-\n-import jdk.test.lib.Platform;\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.io.UncheckedIOException;\n-import java.lang.ProcessBuilder.Redirect;\n-import java.nio.file.DirectoryNotEmptyException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.time.Instant;\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.ArrayDeque;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Common library for various test file utility functions.\n- *\/\n-public final class FileUtils {\n-    private static final boolean IS_WINDOWS = Platform.isWindows();\n-    private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;\n-    private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;\n-\n-    \/**\n-     * Deletes a file, retrying if necessary.\n-     *\n-     * @param path  the file to delete\n-     *\n-     * @throws NoSuchFileException\n-     *         if the file does not exist (optional specific exception)\n-     * @throws DirectoryNotEmptyException\n-     *         if the file is a directory and could not otherwise be deleted\n-     *         because the directory is not empty (optional specific exception)\n-     * @throws IOException\n-     *         if an I\/O error occurs\n-     *\/\n-    public static void deleteFileWithRetry(Path path) throws IOException {\n-        try {\n-            deleteFileWithRetry0(path);\n-        } catch (InterruptedException x) {\n-            throw new IOException(\"Interrupted while deleting.\", x);\n-        }\n-    }\n-\n-    \/**\n-     * Deletes a file, retrying if necessary.\n-     * No exception thrown if file doesn't exist.\n-     *\n-     * @param path  the file to delete\n-     *\n-     * @throws NoSuchFileException\n-     *         if the file does not exist (optional specific exception)\n-     * @throws DirectoryNotEmptyException\n-     *         if the file is a directory and could not otherwise be deleted\n-     *         because the directory is not empty (optional specific exception)\n-     * @throws IOException\n-     *         if an I\/O error occurs\n-     *\/\n-    public static void deleteFileIfExistsWithRetry(Path path) throws IOException {\n-        try {\n-            if (Files.exists(path)) {\n-                deleteFileWithRetry0(path);\n-            }\n-        } catch (InterruptedException x) {\n-            throw new IOException(\"Interrupted while deleting.\", x);\n-        }\n-    }\n-\n-    private static void deleteFileWithRetry0(Path path)\n-            throws IOException, InterruptedException {\n-        int times = 0;\n-        IOException ioe = null;\n-        while (true) {\n-            try {\n-                Files.delete(path);\n-                \/\/ Checks for absence of the file. Semantics of Files.exists() is not the same.\n-                while (!Files.notExists(path)) {\n-                    times++;\n-                    if (times > MAX_RETRY_DELETE_TIMES) {\n-                        throw new IOException(\"File still exists after \" + times + \" waits.\");\n-                    }\n-                    Thread.sleep(RETRY_DELETE_MILLIS);\n-                }\n-                break;\n-            } catch (NoSuchFileException | DirectoryNotEmptyException x) {\n-                throw x;\n-            } catch (IOException x) {\n-                \/\/ Backoff\/retry in case another process is accessing the file\n-                times++;\n-                if (ioe == null) {\n-                    ioe = x;\n-                } else {\n-                    ioe.addSuppressed(x);\n-                }\n-\n-                if (times > MAX_RETRY_DELETE_TIMES) {\n-                    throw ioe;\n-                }\n-                Thread.sleep(RETRY_DELETE_MILLIS);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Deletes a directory and its subdirectories, retrying if necessary.\n-     *\n-     * @param dir  the directory to delete\n-     *\n-     * @throws  IOException\n-     *          If an I\/O error occurs. Any such exceptions are caught\n-     *          internally. If only one is caught, then it is re-thrown.\n-     *          If more than one exception is caught, then the second and\n-     *          following exceptions are added as suppressed exceptions of the\n-     *          first one caught, which is then re-thrown.\n-     *\/\n-    public static void deleteFileTreeWithRetry(Path dir) throws IOException {\n-        IOException ioe = null;\n-        final List<IOException> excs = deleteFileTreeUnchecked(dir);\n-        if (!excs.isEmpty()) {\n-            ioe = excs.remove(0);\n-            for (IOException x : excs) {\n-                ioe.addSuppressed(x);\n-            }\n-        }\n-        if (ioe != null) {\n-            throw ioe;\n-        }\n-    }\n-\n-    public static List<IOException> deleteFileTreeUnchecked(Path dir) {\n-        final List<IOException> excs = new ArrayList<>();\n-        try {\n-            java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<>() {\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n-                    try {\n-                        deleteFileWithRetry0(file);\n-                    } catch (IOException x) {\n-                        excs.add(x);\n-                    } catch (InterruptedException x) {\n-                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n-                        return FileVisitResult.TERMINATE;\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n-                    try {\n-                        deleteFileWithRetry0(dir);\n-                    } catch (IOException x) {\n-                        excs.add(x);\n-                    } catch (InterruptedException x) {\n-                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n-                        return FileVisitResult.TERMINATE;\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n-                    excs.add(exc);\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-        } catch (IOException x) {\n-            excs.add(x);\n-        }\n-        return excs;\n-    }\n-\n-    \/**\n-     * Checks whether all file systems are accessible. This is performed\n-     * by checking free disk space on all mounted file systems via a\n-     * separate, spawned process. File systems are considered to be\n-     * accessible if this process completes successfully before a given\n-     * fixed duration has elapsed.\n-     *\n-     * @implNote On Unix this executes the {@code df} command in a separate\n-     * process and on Windows always returns {@code true}.\n-     *\/\n-    public static boolean areFileSystemsAccessible() throws IOException {\n-        boolean areFileSystemsAccessible = true;\n-        if (!IS_WINDOWS) {\n-            \/\/ try to check whether 'df' hangs\n-            System.out.println(\"\\n--- df output ---\");\n-            System.out.flush();\n-            Process proc = new ProcessBuilder(\"df\").inheritIO().start();\n-            try {\n-                proc.waitFor(90, TimeUnit.SECONDS);\n-            } catch (InterruptedException ignored) {\n-            }\n-            try {\n-                int exitValue = proc.exitValue();\n-                if (exitValue != 0) {\n-                    System.err.printf(\"df process exited with %d != 0%n\",\n-                        exitValue);\n-                    areFileSystemsAccessible = false;\n-                }\n-            } catch (IllegalThreadStateException ignored) {\n-                System.err.println(\"df command apparently hung\");\n-                areFileSystemsAccessible = false;\n-            }\n-        }\n-        return areFileSystemsAccessible;\n-    }\n-\n-    \/**\n-     * List the open file descriptors (if supported by the 'lsof' command).\n-     * @param ps a printStream to send the output to\n-     * @throws UncheckedIOException if an error occurs\n-     *\/\n-    public static void listFileDescriptors(PrintStream ps) {\n-        List<String> lsofDirs = List.of(\"\/usr\/bin\", \"\/usr\/sbin\");\n-        Optional<Path> lsof = lsofDirs.stream()\n-                .map(s -> Paths.get(s, \"lsof\"))\n-                .filter(f -> Files.isExecutable(f))\n-                .findFirst();\n-        lsof.ifPresent(exe -> {\n-            try {\n-                ps.printf(\"Open File Descriptors:%n\");\n-                long pid = ProcessHandle.current().pid();\n-                ProcessBuilder pb = new ProcessBuilder(exe.toString(), \"-p\", Integer.toString((int) pid));\n-                pb.redirectErrorStream(true);   \/\/ combine stderr and stdout\n-                pb.redirectOutput(Redirect.PIPE);\n-\n-                Process p = pb.start();\n-                Instant start = Instant.now();\n-                p.getInputStream().transferTo(ps);\n-\n-                try {\n-                    int timeout = 10;\n-                    if (!p.waitFor(timeout, TimeUnit.SECONDS)) {\n-                        System.out.printf(\"waitFor timed out: %d%n\", timeout);\n-                    }\n-                } catch (InterruptedException ie) {\n-                    throw new IOException(\"interrupted\", ie);\n-                }\n-                ps.println();\n-            } catch (IOException ioe) {\n-                throw new UncheckedIOException(\"error listing file descriptors\", ioe);\n-            }\n-        });\n-    }\n-}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":0,"deletions":276,"binary":false,"changes":276,"status":"deleted"},{"patch":"@@ -71,1 +71,7 @@\n-    private static void removeFromDisabledAlgs(String prop, List<String> algs) {\n+    \/**\n+     * Removes constraints that contain the specified constraint from the\n+     * specified security property. For example, List.of(\"SHA1\") will remove\n+     * any constraint containing \"SHA1\".\n+     *\/\n+    public static void removeFromDisabledAlgs(String prop,\n+            List<String> constraints) {\n@@ -75,1 +81,2 @@\n-                      .filter(s -> !algs.contains(s))\n+                      .filter(s -> constraints.stream()\n+                          .allMatch(constraint -> !s.contains(constraint)))\n","filename":"jdk\/test\/lib\/security\/SecurityUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,0 +44,2 @@\n+import java.nio.file.attribute.FileAttribute;\n+\n@@ -443,0 +447,20 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n","filename":"jdk\/test\/lib\/testlibrary\/jdk\/testlibrary\/Utils.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4975116 7040022 8023577 8025447 8286624\n+ * @key headful\n+ * @summary verify the rounding of negative coordinates in Shape objects\n+ * @run main\/othervm CoordinateTruncationBug\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Canvas;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Robot;\n+import java.awt.Rectangle;\n+import java.awt.Point;\n+import java.awt.Dimension;\n+import java.awt.Color;\n+import java.awt.AWTException;\n+import java.awt.geom.Line2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+\n+public class CoordinateTruncationBug {\n+    static boolean failure;\n+    static boolean verbose;\n+\n+    static final int W = 80;\n+    static final int H = 80;\n+\n+    static final Line2D vertline = new Line2D.Float(-0.7f, 0f, -0.7f, H);\n+    static final Line2D horizline = new Line2D.Float(0f, -0.7f, W, -0.7f);\n+\n+    public static void main(String argv[]) {\n+        verbose = (argv.length > 0);\n+        new Screen().test();\n+        new BufImg().test();\n+        new VolImg().test();\n+        if (failure) {\n+            throw new RuntimeException(\"Test failed due to 1 or more failures\");\n+        }\n+    }\n+\n+    public static abstract class Test {\n+        public abstract String getName();\n+        public abstract void makeDest();\n+        public abstract void runTest();\n+        public abstract void dispose();\n+        public abstract BufferedImage getSnapshot();\n+\n+        public void test() {\n+            makeDest();\n+            runTest();\n+            dispose();\n+        }\n+\n+        public void runTest(Graphics2D g2d) {\n+            g2d.setColor(Color.white);\n+            g2d.fillRect(0, 0, W, H);\n+\n+            if (!checkAllWhite()) {\n+                System.err.println(\"Aborting test of \"+getName()+\n+                                   \" due to readback failure!\");\n+                return;\n+            }\n+\n+            g2d.setColor(Color.red);\n+            g2d.draw(vertline);\n+            g2d.draw(horizline);\n+            if (!checkAllWhite()) {\n+                System.err.println(getName()+\" failed!\");\n+                failure = true;\n+            }\n+        }\n+\n+        public boolean checkAllWhite() {\n+            BufferedImage bimg = getSnapshot();\n+            if (bimg == null) {\n+                System.err.println(getName()+\" returned null snapshot!\");\n+                return false;\n+            }\n+            boolean ret = true;\n+            for (int y = 0; y < H; y++) {\n+                for (int x = 0; x < W; x++) {\n+                    int rgb = bimg.getRGB(x, y);\n+                    if (rgb != -1) {\n+                        System.err.println(getName()+\"(\"+x+\", \"+y+\") == \"+\n+                                           Integer.toHexString(rgb));\n+                        if (verbose) {\n+                            ret = false;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+            return ret;\n+        }\n+    }\n+\n+    public static class Screen extends Test {\n+        Frame frame;\n+        TestCanvas canvas;\n+\n+        public String getName() {\n+            return \"Screen\";\n+        }\n+\n+        public void makeDest() {\n+            frame = new Frame(\"Screen test\");\n+            frame.setUndecorated(true);\n+            canvas = new TestCanvas(this);\n+            frame.add(canvas);\n+            frame.pack();\n+            frame.setLocationRelativeTo(null);\n+        }\n+\n+        public void runTest() {\n+            frame.show();\n+            canvas.waitForTest();\n+        }\n+\n+        public Graphics2D createGraphics() {\n+            return null;\n+        }\n+\n+        public BufferedImage getSnapshot() {\n+            \/\/ bypass window animation\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+            };\n+\n+            try {\n+                Robot r = new Robot();\n+                Point p = canvas.getLocationOnScreen();\n+                return r.createScreenCapture(new Rectangle(p.x, p.y, W, H));\n+            } catch (AWTException e) {\n+                return null;\n+            }\n+        }\n+\n+        public void dispose() {\n+            frame.hide();\n+            frame.dispose();\n+        }\n+\n+        public static class TestCanvas extends Canvas {\n+            Test test;\n+            boolean done;\n+\n+            public TestCanvas(Test test) {\n+                this.test = test;\n+            }\n+\n+            public Dimension getPreferredSize() {\n+                return new Dimension(W, H);\n+            }\n+\n+            public synchronized void waitForTest() {\n+                while (!done) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        System.err.println(getName()+\" interrupted!\");\n+                        failure = true;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            public void paint(Graphics g) {\n+                if (!done) {\n+                    test.runTest((Graphics2D) g);\n+                    notifyDone();\n+                }\n+            }\n+\n+            public synchronized void notifyDone() {\n+                done = true;\n+                notifyAll();\n+            }\n+        }\n+    }\n+\n+    public abstract static class Standalone extends Test {\n+        public abstract Graphics2D createGraphics();\n+\n+        public void runTest() {\n+            Graphics2D g2d = createGraphics();\n+            runTest(g2d);\n+            g2d.dispose();\n+        }\n+    }\n+\n+    public static class BufImg extends Standalone {\n+        public BufferedImage bimg;\n+\n+        public String getName() {\n+            return \"BufferedImage\";\n+        }\n+\n+        public void makeDest() {\n+            bimg = new BufferedImage(W, H, BufferedImage.TYPE_INT_RGB);\n+        }\n+\n+        public Graphics2D createGraphics() {\n+            return bimg.createGraphics();\n+        }\n+\n+        public BufferedImage getSnapshot() {\n+            return bimg;\n+        }\n+\n+        public void dispose() {\n+        }\n+    }\n+\n+    public static class VolImg extends Standalone {\n+        Frame frame;\n+        VolatileImage vimg;\n+\n+        public String getName() {\n+            return \"VolatileImage\";\n+        }\n+\n+        public void makeDest() {\n+            frame = new Frame();\n+            frame.setSize(W, H);\n+            frame.setLocationRelativeTo(null);\n+            frame.show();\n+            vimg = frame.createVolatileImage(W, H);\n+        }\n+\n+        public Graphics2D createGraphics() {\n+            return vimg.createGraphics();\n+        }\n+\n+        public BufferedImage getSnapshot() {\n+            return vimg.getSnapshot();\n+        }\n+\n+        public void dispose() {\n+            vimg.flush();\n+            frame.hide();\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/java2d\/SunGraphics2D\/CoordinateTruncationBug.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270344\n+ * @library \/lib\/security \/javax\/net\/ssl\/templates\n+ * @summary Session resumption errors\n+ * @run main\/othervm InvalidateSession\n+ *\/\n+\n+import javax.net.*;\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+public class InvalidateSession implements SSLContextTemplate {\n+\n+    static ServerSocketFactory serverSsf = null;\n+    static SSLSocketFactory clientSsf = null;\n+\n+    static Server server;\n+    static SSLSession cacheSession;\n+    static final String[] CLIENT_VERSIONS = {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"};\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ drop the supported_versions extension to force test to use the legacy\n+        \/\/ TLS protocol version field during handshakes\n+        System.setProperty(\"jdk.tls.client.disableExtensions\", \"supported_versions\");\n+        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1\", \"TLSv1.1\");\n+\n+        InvalidateSession test = new InvalidateSession();\n+        test.sessionTest();\n+        server.go = false;\n+    }\n+\n+    \/**\n+     * 3 test iterations\n+     * 1) Server configured with TLSv1, client with TLSv1, v1.1, v1.2\n+     * - Handshake should succeed\n+     * - Session \"A\" established\n+     * 2) 2nd iteration, server configured with TLSv1.2 only\n+     * - Connection should succeed but with a new session due to TLS protocol version change\n+     * - Session \"A\" should be invalidated\n+     * - Session \"B\" is created\n+     * 3) 3rd iteration, same server\/client config\n+     * - Session \"B\" should continue to be in use\n+     *\/\n+    private void sessionTest() throws Exception {\n+        serverSsf = createServerSSLContext().getServerSocketFactory();\n+        clientSsf = createClientSSLContext().getSocketFactory();\n+        server = startServer();\n+        while (!server.started) {\n+            Thread.yield();\n+        }\n+\n+        for (int i = 1; i <= 3; i++) {\n+            clientConnect(i);\n+            Thread.sleep(1000);\n+        }\n+    }\n+\n+    public void clientConnect(int testIterationCount) throws Exception {\n+        System.out.printf(\"Connecting to: localhost: %s, iteration count %d%n\",\n+                \"localhost:\" + server.port, testIterationCount);\n+        SSLSocket sslSocket = (SSLSocket) clientSsf.createSocket(\"localhost\", server.port);\n+        sslSocket.setEnabledProtocols(CLIENT_VERSIONS);\n+        sslSocket.startHandshake();\n+\n+        System.out.println(\"Got session: \" + sslSocket.getSession());\n+\n+        if (testIterationCount == 2 && Objects.equals(cacheSession, sslSocket.getSession())) {\n+            throw new RuntimeException(\"Same session should not have resumed\");\n+        }\n+        if (testIterationCount == 3 && !Objects.equals(cacheSession, sslSocket.getSession())) {\n+            throw new RuntimeException(\"Same session should have resumed\");\n+        }\n+\n+        cacheSession = sslSocket.getSession();\n+\n+        try (\n+        ObjectOutputStream oos = new ObjectOutputStream(sslSocket.getOutputStream());\n+        ObjectInputStream ois = new ObjectInputStream(sslSocket.getInputStream())) {\n+            oos.writeObject(\"Hello\");\n+            String serverMsg = (String) ois.readObject();\n+            System.out.println(\"Server message : \" + serverMsg);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        } finally {\n+            sslSocket.close();\n+        }\n+    }\n+\n+    private static Server startServer() {\n+        Server server = new Server();\n+        new Thread(server).start();\n+        return server;\n+    }\n+\n+    private static class Server implements Runnable {\n+        public volatile boolean go = true;\n+        public volatile int port = 0;\n+        public volatile boolean started = false;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                SSLServerSocket ssock = (SSLServerSocket)\n+                        serverSsf.createServerSocket(0);\n+                this.port = ssock.getLocalPort();\n+                ssock.setEnabledProtocols(new String[]{\"TLSv1\"});\n+                started = true;\n+                while (go) {\n+                    try {\n+                        System.out.println(\"Waiting for connection\");\n+                        Socket sock = ssock.accept();\n+                        \/\/ now flip server to TLSv1.2 mode for successive connections\n+                        ssock.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n+                        try (\n+                        ObjectInputStream ois = new ObjectInputStream(sock.getInputStream());\n+                        ObjectOutputStream oos = new ObjectOutputStream(sock.getOutputStream())) {\n+                            String recv = (String) ois.readObject();\n+                            oos.writeObject(\"Received: \" + recv);\n+                        } catch (SSLHandshakeException she) {\n+                            System.out.println(\"Server caught :\" + she);\n+                        } finally {\n+                            sock.close();\n+                        }\n+                    } catch (Exception ex) {\n+                        throw new RuntimeException(ex);\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"jdk\/test\/sun\/security\/ssl\/SSLSessionImpl\/InvalidateSession.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+# Re-enable SHA-1 since OldSig.java test uses it\n+jdk.jar.disabledAlgorithms=MD2,MD5,RSA keySize < 1024,DSA keySize < 1024\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/OldSig.props","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @library \/lib\/security\n+ * @run main\/othervm Test4431684\n@@ -33,0 +35,1 @@\n+import java.security.*;\n@@ -38,0 +41,3 @@\n+        \/\/ Re-enable SHA1 since JavaApplication1.jar uses it\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.jar.disabledAlgorithms\",\n+            Arrays.asList(new String[]{\"SHA1\"}));\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/Test4431684.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n- *      8180289 8172404\n+ *      8180289 8172404 8269039\n@@ -205,0 +205,3 @@\n+            } else if (path.equals(\"tsbefore2019\")) {\n+                \/\/ Saturday, August 18, 2018 7:04:58 PM\n+                instant = Instant.ofEpochSecond(1534619098l);\n@@ -352,0 +355,11 @@\n+                \/\/ should not be disabled because timestamped before 2019\n+                signVerbose(\"tsbefore2019\", \"unsigned.jar\", \"tsbefore2019.jar\", \"pre2019signer\",\n+                        \"-digestalg\", \"SHA-1\")\n+                        .shouldHaveExitValue(4);\n+\n+                verify(\"tsbefore2019.jar\", \"-verbose\")\n+                        .shouldHaveExitValue(0)\n+                        .shouldMatch(\"Digest.*SHA-1.*(weak)\")\n+                        .shouldMatch(\"signer certificate expired on .*. \"\n+                                + \"However, the JAR will be valid\");\n+\n@@ -425,1 +439,1 @@\n-                \/\/ Legacy algorithms\n+                \/\/ Disabled algorithms\n@@ -427,10 +441,9 @@\n-                        \"-strict\", \"-digestalg\", \"SHA-1\")\n-                        .shouldHaveExitValue(0)\n-                        .shouldContain(\"jar signed, with signer errors\")\n-                        .shouldMatch(\"SHA-1.*-digestalg.*will be disabled\");\n-                verify(\"sha1alg.jar\", \"-strict\")\n-                        .shouldHaveExitValue(0)\n-                        .shouldContain(\"jar verified, with signer errors\")\n-                        .shouldContain(\"SHA-1 digest algorithm is considered a security risk\")\n-                        .shouldContain(\"This algorithm will be disabled in a future update\")\n-                        .shouldNotContain(\"is disabled\");\n+                        \"-digestalg\", \"SHA-1\")\n+                        .shouldHaveExitValue(4)\n+                        .shouldContain(\"jar signed\")\n+                        .shouldContain(\"with signer errors\")\n+                        .shouldMatch(\"SHA-1.*-digestalg.*is disabled\");\n+                verify(\"sha1alg.jar\", \"-verbose\")\n+                        .shouldHaveExitValue(16)\n+                        .shouldContain(\"treated as unsigned\")\n+                        .shouldMatch(\"Digest.*SHA-1.*(disabled)\");\n@@ -439,9 +452,8 @@\n-                        .shouldHaveExitValue(0)\n-                        .shouldContain(\"jar signed, with signer errors\")\n-                        .shouldMatch(\"SHA-1.*-tsadigestalg.*will be disabled\")\n-                        .shouldNotContain(\"is disabled\");\n-                verify(\"sha1tsaalg.jar\", \"-strict\")\n-                        .shouldHaveExitValue(0)\n-                        .shouldContain(\"jar verified, with signer errors\")\n-                        .shouldContain(\"SHA-1 digest algorithm is considered a security risk\")\n-                        .shouldNotContain(\"is disabled\");\n+                        .shouldHaveExitValue(4)\n+                        .shouldContain(\"jar signed\")\n+                        .shouldContain(\"with signer errors\")\n+                        .shouldMatch(\"SHA-1.*-tsadigestalg.*is disabled\");\n+                verify(\"sha1tsaalg.jar\", \"-verbose\")\n+                        .shouldHaveExitValue(16)\n+                        .shouldContain(\"treated as unsigned\")\n+                        .shouldMatch(\"Timestamp.*digest.*SHA-1.*(disabled)\");\n@@ -449,1 +461,0 @@\n-                \/\/ Disabled algorithms\n@@ -486,1 +497,1 @@\n-                \/\/ Legacy algorithms\n+                \/\/ Disabled algorithms\n@@ -489,5 +500,10 @@\n-                        .shouldHaveExitValue(0)\n-                        .shouldMatch(\"SHA1.*-digestalg.*will be disabled\")\n-                        .shouldMatch(\"SHA1.*-tsadigestalg.*will be disabled\")\n-                        .shouldMatch(\"SHA1withRSA.*-sigalg.*will be disabled\");\n-                checkWeak(\"tsweak.jar\");\n+                        .shouldHaveExitValue(4)\n+                        .shouldMatch(\"SHA1.*-digestalg.*is disabled\")\n+                        .shouldMatch(\"SHA1.*-tsadigestalg.*is disabled\")\n+                        .shouldMatch(\"SHA1withRSA.*-sigalg.*is disabled\");\n+                verify(\"tsweak.jar\", \"-verbose\")\n+                        .shouldHaveExitValue(16)\n+                        .shouldContain(\"treated as unsigned\")\n+                        .shouldMatch(\"Digest algorithm: .*(disabled)\")\n+                        .shouldMatch(\"Signature algorithm: .*(disabled)\")\n+                        .shouldMatch(\"Timestamp digest algorithm: .*(disabled)\");\n@@ -495,0 +511,1 @@\n+                \/\/ Legacy algorithms (1024-bit key)\n@@ -503,1 +520,1 @@\n-                \/\/ Algorithm used in signing is weak\n+                \/\/ Algorithm used in signing is disabled\n@@ -506,4 +523,6 @@\n-                        .shouldContain(\"-digestalg option is considered a security risk.\")\n-                        .shouldContain(\"This algorithm will be disabled in a future update.\")\n-                        .shouldHaveExitValue(0);\n-                checkHalfWeak(\"halfWeak.jar\");\n+                        .shouldContain(\"-digestalg option is considered a security risk and is disabled.\")\n+                        .shouldHaveExitValue(4);\n+                verify(\"halfWeak.jar\", \"-verbose\")\n+                        .shouldHaveExitValue(16)\n+                        .shouldContain(\"treated as unsigned\")\n+                        .shouldMatch(\"Digest algorithm: .*(disabled)\");\n@@ -942,0 +961,1 @@\n+        keytool(\"-alias pre2019signer -genkeypair -dname CN=pre2019signer\");\n@@ -948,0 +968,1 @@\n+        keytool(\"-alias tsbefore2019 -genkeypair -dname CN=tsbefore2019\");\n@@ -971,0 +992,1 @@\n+        gencert(\"pre2019signer\", \"-startdate 2018\/06\/01 -validity 365\");\n@@ -1004,0 +1026,1 @@\n+        gencert(\"tsbefore2019\", \"-ext eku:critical=ts -startdate 2018\/01\/01 -validity 3000\");\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":57,"deletions":34,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    -digestalg SHA1 \\\n+    -digestalg SHA-256 \\\n@@ -105,1 +105,1 @@\n-    -digestalg SHA1 \\\n+    -digestalg SHA-256 \\\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/diffend.sh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+PROP_ARGS=\" -J-Djava.security.properties=${TESTSRC}${FS}OldSig.props\"\n+KS_ARGS=\"-keystore ${TESTSRC}${FS}JarSigning.keystore -storepass bbbbbb\"\n+\n@@ -75,2 +78,1 @@\n-    -keystore ${TESTSRC}${FS}JarSigning.keystore \\\n-    -storepass bbbbbb \\\n+    ${KS_ARGS} \\\n@@ -79,1 +81,6 @@\n-${TESTJAVA}${FS}bin${FS}jarsigner -verify B.jar\n+\n+JAR_VERIFY_CMD=\"${TESTJAVA}${FS}bin${FS}jarsigner -verify ${KS_ARGS} ${PROP_ARGS} -verbose B.jar\"\n+echo ${JAR_VERIFY_CMD}\n+LINES=`${JAR_VERIFY_CMD} | grep smk | grep B.class | wc -l`\n+[ $LINES = 1 ] || exit 1\n+\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/oldsig.sh","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -332,1 +332,2 @@\n-        test_ks.load(new FileInputStream(new File(\"ks\")),\n+        FileInputStream inputStream = new FileInputStream(new File(\"ks\"));\n+        test_ks.load(inputStream,\n@@ -336,0 +337,1 @@\n+        inputStream.close();\n@@ -343,1 +345,2 @@\n-        test_ks.load(new FileInputStream(new File(\"ks\")),\n+        inputStream = new FileInputStream(new File(\"ks\"));\n+        test_ks.load(inputStream,\n@@ -347,0 +350,1 @@\n+        inputStream.close();\n@@ -349,1 +353,2 @@\n-        test_ks.load(new FileInputStream(new File(\"ks.old6\")),\n+        inputStream = new FileInputStream(new File(\"ks.old6\"));\n+        test_ks.load(inputStream,\n@@ -353,0 +358,1 @@\n+        inputStream.close();\n","filename":"jdk\/test\/sun\/security\/tools\/keytool\/WeakAlg.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -176,0 +176,5 @@\n+             *\n+             * Tehran\/Iran rule has rules beyond 2037, in which javazic assumes\n+             * to be the last year. Thus javazic's rule is based on year 2037\n+             * (Mar 20th\/Sep 20th are the cutover dates), while the real rule\n+             * has year 2087 where Mar 21st\/Sep 21st are the cutover dates.\n@@ -177,3 +182,7 @@\n-            if (zid.equals(\"Africa\/Casablanca\") || zid.equals(\"Africa\/El_Aaiun\")\n-                || zid.equals(\"Asia\/Tehran\") || zid.equals(\"Iran\")) {\n-                continue;\n+            if (zid.equals(\"Africa\/Casablanca\") || \/\/ uses \"Morocco\" rule\n+                zid.equals(\"Africa\/El_Aaiun\") || \/\/ uses \"Morocco\" rule\n+                zid.equals(\"Asia\/Tehran\") || \/\/ last rule mismatch\n+                zid.equals(\"Asia\/Gaza\") || \/\/ uses \"Palestine\" rule\n+                zid.equals(\"Asia\/Hebron\") || \/\/ uses \"Palestine\" rule\n+                zid.equals(\"Iran\")) { \/\/ last rule mismatch\n+                    continue;\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/TestZoneInfo310.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022c\n+tzdata2022e\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2257,0 +2257,11 @@\n+# From Issam Al-Zuwairi (2022-10-05):\n+# The Council of Ministers in Jordan decided Wednesday 5th October 2022,\n+# that daylight saving time (DST) will be throughout the year....\n+#\n+# From Brian Inglis (2022-10-06):\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=45567&lang=en&name=en_news\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Syria, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n+\n@@ -2288,2 +2299,2 @@\n-Rule\tJordan\t2014\tmax\t-\tOct\tlastFri\t0:00s\t0\t-\n-Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\t2022\t-\tOct\tlastFri\t0:00s\t0\t-\n+Rule\tJordan\t2022\tonly\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2292,1 +2303,2 @@\n-\t\t\t2:00\tJordan\tEE%sT\n+\t\t\t2:00\tJordan\tEE%sT\t2022 Oct 28 0:00s\n+\t\t\t3:00\t-\t+03\n@@ -3401,4 +3413,0 @@\n-#\n-# From Paul Eggert (2019-04-10):\n-# For now, guess spring-ahead transitions are at 00:00 on the Saturday\n-# preceding March's last Sunday (i.e., Sat>=24).\n@@ -3421,0 +3429,12 @@\n+# From Heba Hamad (2022-08-30):\n+# winter time will begin in Palestine from Saturday 10-29, 02:00 AM by\n+# 60 minutes backwards.  Also the state of Palestine adopted the summer\n+# and winter time for the years: 2023,2024,2025,2026 ...\n+# https:\/\/mm.icann.org\/pipermail\/tz\/attachments\/20220830\/9f024566\/Time-0001.pdf\n+# (2022-08-31): ... the Saturday before the last Sunday in March and October\n+# at 2:00 AM ,for the years from 2023 to 2026.\n+# (2022-09-05): https:\/\/mtit.pna.ps\/Site\/New\/1453\n+#\n+# From Paul Eggert (2022-08-31):\n+# For now, assume that this rule will also be used after 2026.\n+\n@@ -3451,2 +3471,2 @@\n-Rule Palestine\t2016\t2018\t-\tMar\tSat>=24\t1:00\t1:00\tS\n-Rule Palestine\t2016\t2018\t-\tOct\tSat>=24\t1:00\t0\t-\n+Rule Palestine\t2016\t2018\t-\tMar\tSat<=30\t1:00\t1:00\tS\n+Rule Palestine\t2016\t2018\t-\tOct\tSat<=30\t1:00\t0\t-\n@@ -3454,2 +3474,2 @@\n-Rule Palestine\t2019\tonly\t-\tOct\tSat>=24\t0:00\t0\t-\n-Rule Palestine\t2020\t2021\t-\tMar\tSat>=24\t0:00\t1:00\tS\n+Rule Palestine\t2019\tonly\t-\tOct\tSat<=30\t0:00\t0\t-\n+Rule Palestine\t2020\t2021\t-\tMar\tSat<=30\t0:00\t1:00\tS\n@@ -3457,2 +3477,4 @@\n-Rule Palestine\t2021\tmax\t-\tOct\tFri>=23\t1:00\t0\t-\n-Rule Palestine\t2022\tmax\t-\tMar\tSun>=25\t0:00\t1:00\tS\n+Rule Palestine\t2021\tonly\t-\tOct\t29\t1:00\t0\t-\n+Rule Palestine\t2022\tonly\t-\tMar\t27\t0:00\t1:00\tS\n+Rule Palestine\t2022\tmax\t-\tOct\tSat<=30\t2:00\t0\t-\n+Rule Palestine\t2023\tmax\t-\tMar\tSat<=30\t2:00\t1:00\tS\n@@ -3831,2 +3853,9 @@\n-# From Arthur David Olson (2012-03-27):\n-# Assume last Friday in March going forward XXX.\n+# From Steffen Thorsen (2022-10-05):\n+# Syria is adopting year-round DST, starting this autumn....\n+# From https:\/\/www.enabbaladi.net\/archives\/607812\n+# \"This [the decision] came after the weekly government meeting today,\n+# Tuesday 4 October ...\"\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Jordan, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n@@ -3838,2 +3867,2 @@\n-Rule\tSyria\t2012\tmax\t-\tMar\tlastFri\t0:00\t1:00\tS\n-Rule\tSyria\t2009\tmax\t-\tOct\tlastFri\t0:00\t0\t-\n+Rule\tSyria\t2012\t2022\t-\tMar\tlastFri\t0:00\t1:00\tS\n+Rule\tSyria\t2009\t2022\t-\tOct\tlastFri\t0:00\t0\t-\n@@ -3843,1 +3872,2 @@\n-\t\t\t2:00\tSyria\tEE%sT\n+\t\t\t2:00\tSyria\tEE%sT\t2022 Oct 28 0:00\n+\t\t\t3:00\t-\t+03\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/asia","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Uzhgorod\n+Link\tEurope\/Kyiv\t\tEurope\/Zaporozhye\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/backward","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2641,4 +2641,8 @@\n-# From Paul Eggert (2014-03-30):\n-# Simferopol and Sevastopol reportedly changed their central town clocks\n-# late the previous day, but this appears to have been ceremonial\n-# and the discrepancies are small enough to not worry about.\n+# From Tim Parenti (2022-07-01), per Paul Eggert (2014-03-30):\n+# The clocks at the railway station in Simferopol were put forward from 22:00\n+# to 24:00 the previous day in a \"symbolic ceremony\"; however, per\n+# contemporaneous news reports, \"ordinary Crimeans [made] the daylight savings\n+# time switch at 2am\" on Sunday.\n+# https:\/\/www.business-standard.com\/article\/pti-stories\/crimea-to-set-clocks-to-russia-time-114033000014_1.html\n+# https:\/\/www.reuters.com\/article\/us-ukraine-crisis-crimea-time\/crimea-switches-to-moscow-time-amid-incorporation-frenzy-idUKBREA2S0LT20140329\n+# https:\/\/www.bbc.com\/news\/av\/world-europe-26806583\n@@ -3416,1 +3420,1 @@\n-Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1900 Dec 31 23:38:44\n+Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1901 Jan  1  0:00u\n@@ -3777,2 +3781,2 @@\n-# From Paul Eggert (2022-02-08):\n-# For now, assume that Ukraine's other three zones followed the same rules,\n+# From Paul Eggert (2022-08-27):\n+# For now, assume that Ukraine's zones all followed the same rules,\n@@ -3848,13 +3852,0 @@\n-# From Paul Eggert (2022-04-12):\n-# As is usual in tzdb, Ukrainian zones use the most common English spellings.\n-# In particular, tzdb's name Europe\/Kyiv uses the most common spelling in\n-# English for Ukraine's capital.  Although tzdb's former name was Europe\/Kiev,\n-# \"Kyiv\" is now more common due to widespread reporting of the current conflict.\n-# Conversely, tzdb continues to use the names Europe\/Uzhgorod and\n-# Europe\/Zaporozhye; this is similar to tzdb's use of Europe\/Prague, which is\n-# certainly wrong as a transliteration of the Czech \"Praha\".\n-# English-language spelling of Ukrainian names is in flux, and\n-# some day \"Uzhhorod\" or \"Zaporizhzhia\" may become substantially more\n-# common in English; in the meantime, do not change these\n-# English spellings as that means less disruption for our users.\n-\n@@ -3862,1 +3853,0 @@\n-# This represents most of Ukraine.  See above for the spelling of \"Kyiv\".\n@@ -3871,28 +3861,0 @@\n-\t\t\t2:00\tEU\tEE%sT\n-# Transcarpathia used CET 1990\/1991.\n-# \"Uzhhorod\" is the transliteration of the Rusyn\/Ukrainian pronunciation, but\n-# \"Uzhgorod\" is more common in English.\n-Zone Europe\/Uzhgorod\t1:29:12 -\tLMT\t1890 Oct\n-\t\t\t1:00\t-\tCET\t1940\n-\t\t\t1:00\tC-Eur\tCE%sT\t1944 Oct\n-\t\t\t1:00\t1:00\tCEST\t1944 Oct 26\n-\t\t\t1:00\t-\tCET\t1945 Jun 29\n-\t\t\t3:00\tRussia\tMSK\/MSD\t1990\n-\t\t\t3:00\t-\tMSK\t1990 Jul  1  2:00\n-\t\t\t1:00\t-\tCET\t1991 Mar 31  3:00\n-\t\t\t2:00\t-\tEET\t1992 Mar 20\n-\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n-\t\t\t2:00\tEU\tEE%sT\n-# Zaporozh'ye and eastern Lugansk oblasts observed DST 1990\/1991.\n-# \"Zaporizhzhia\" is the transliteration of the Ukrainian name, but\n-# \"Zaporozh'ye\" is more common in English.  Use the common English\n-# spelling, except omit the apostrophe as it is not allowed in\n-# portable Posix file names.\n-Zone Europe\/Zaporozhye\t2:20:40 -\tLMT\t1880\n-\t\t\t2:20\t-\t+0220\t1924 May  2\n-\t\t\t2:00\t-\tEET\t1930 Jun 21\n-\t\t\t3:00\t-\tMSK\t1941 Aug 25\n-\t\t\t1:00\tC-Eur\tCE%sT\t1943 Oct 25\n-\t\t\t3:00\tRussia\tMSK\/MSD\t1991 Mar 31  2:00\n-\t\t\t2:00\tE-Eur\tEE%sT\t1992 Mar 20\n-\t\t\t2:00\tC-Eur\tEE%sT\t1996 May 13\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/europe","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 12:09:24\n+Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 18:00u\n@@ -474,1 +474,1 @@\n-Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 12:14:48\n+Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 19:00u\n@@ -484,1 +484,1 @@\n-Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT\t1883 Nov 18 12:14:21\n+Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT 1883 Nov 18 19:00u\n@@ -501,1 +501,1 @@\n-Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 12:12:53\n+Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 19:00u\n@@ -533,1 +533,1 @@\n-Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 12:00:04\n+Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 19:00u\n@@ -586,1 +586,1 @@\n-Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 12:07:02\n+Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 20:00u\n@@ -848,1 +848,1 @@\n-Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 11:31:42\n+Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 19:00u\n@@ -876,1 +876,1 @@\n-Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 12:15:11\n+Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 20:00u\n@@ -948,1 +948,1 @@\n-Zone America\/Indiana\/Indianapolis -5:44:38 - LMT\t1883 Nov 18 12:15:22\n+Zone America\/Indiana\/Indianapolis -5:44:38 - LMT 1883 Nov 18 18:00u\n@@ -968,1 +968,1 @@\n-Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 12:14:37\n+Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 18:00u\n@@ -992,1 +992,1 @@\n-Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 12:09:53\n+Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 18:00u\n@@ -1012,1 +1012,1 @@\n-Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 12:12:57\n+Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 18:00u\n@@ -1029,1 +1029,1 @@\n-Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 12:10:53\n+Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 18:00u\n@@ -1051,1 +1051,1 @@\n-Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 12:13:30\n+Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 18:00u\n@@ -1067,1 +1067,1 @@\n-Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 12:13:35\n+Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 18:00u\n@@ -1078,1 +1078,1 @@\n-Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 12:19:44\n+Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 18:00u\n@@ -1114,1 +1114,1 @@\n-Zone America\/Kentucky\/Louisville -5:43:02 -\tLMT\t1883 Nov 18 12:16:58\n+Zone America\/Kentucky\/Louisville -5:43:02 - LMT\t1883 Nov 18 18:00u\n@@ -1148,1 +1148,1 @@\n-Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 12:20:36\n+Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 18:00u\n@@ -2643,0 +2643,2 @@\n+Rule\tMexico\t1931\tonly\t-\tMay\t1\t23:00\t1:00\tD\n+Rule\tMexico\t1931\tonly\t-\tOct\t1\t0:00\t0\tS\n@@ -2659,1 +2661,1 @@\n-Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  0:12:56\n+Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  6:00u\n@@ -2665,1 +2667,1 @@\n-Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  0:01:32\n+Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  6:00u\n@@ -2679,1 +2681,1 @@\n-Zone America\/Matamoros\t-6:40:00 -\tLMT\t1921 Dec 31 23:20:00\n+Zone America\/Matamoros\t-6:30:00 -\tLMT\t1922 Jan  1  6:00u\n@@ -2685,1 +2687,1 @@\n-Zone America\/Monterrey\t-6:41:16 -\tLMT\t1921 Dec 31 23:18:44\n+Zone America\/Monterrey\t-6:41:16 -\tLMT\t1922 Jan  1  6:00u\n@@ -2690,1 +2692,1 @@\n-Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  0:23:24\n+Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  7:00u\n@@ -2693,3 +2695,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2703,1 +2703,1 @@\n-Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  0:02:20\n+Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2706,3 +2706,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2715,1 +2713,1 @@\n-Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1921 Dec 31 23:55:40\n+Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1922 Jan  1  7:00u\n@@ -2718,3 +2716,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2726,1 +2722,1 @@\n-Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1921 Dec 31 23:36:08\n+Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1922 Jan  1  7:00u\n@@ -2729,3 +2725,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2766,1 +2760,1 @@\n-Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1921 Dec 31 23:54:20\n+Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2769,3 +2763,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2778,1 +2770,1 @@\n-Zone America\/Bahia_Banderas\t-7:01:00 -\tLMT\t1921 Dec 31 23:59:00\n+Zone America\/Bahia_Banderas -7:01:00 -\tLMT\t1922 Jan  1  7:00u\n@@ -2781,3 +2773,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2791,1 +2781,1 @@\n-Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  0:11:56\n+Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  7:00u\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/northamerica","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1335,2 +1335,8 @@\n-# we will have a voting whether to approve a new Constitution....\n-# https:\/\/www.interior.gob.cl\/noticias\/2022\/08\/09\/comunicado-el-proximo-sabado-10-de-septiembre-los-relojes-se-deben-adelantar-una-hora\/\n+# we will have a voting whether to approve a new Constitution.\n+#\n+# From Eduardo Romero Urra (2022-08-17):\n+# https:\/\/www.diariooficial.interior.gob.cl\/publicaciones\/2022\/08\/13\/43327\/01\/2172567.pdf\n+#\n+# From Paul Eggert (2022-08-17):\n+# Although the presidential decree stops at fall 2026, assume that\n+# similar DST rules will continue thereafter.\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/southamerica","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -427,2 +427,0 @@\n-UA\t+4837+02218\tEurope\/Uzhgorod\tTranscarpathia\n-UA\t+4750+03510\tEurope\/Zaporozhye\tZaporozhye and east Lugansk\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/zone.tab","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-MSVC_DIR=\"Microsoft.VC141.CRT\"\n+MSVC_DIR=\"Microsoft.VC142.CRT\"\n@@ -105,0 +105,1 @@\n+VCRUNTIME_1_DLL=${MSVC_DIR}\/vcruntime${VS_DLL_VERSION}_1.dll\n@@ -191,0 +192,1 @@\n+echo-info \"DEVKIT_VCRUNTIME_1_DLL_x86_64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/x64\/$VCRUNTIME_1_DLL\\\"\"\n","filename":"make\/devkit\/createWindowsDevkit2019.sh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}