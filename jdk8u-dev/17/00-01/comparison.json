{"files":[{"patch":"@@ -51,2 +51,2 @@\n-  private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-  private static final String ZIP_FILE_NAME = \"8190753-test-compressed-size.zip\";\n+    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+    private static final String ZIP_FILE_NAME = \"8190753-test-compressed-size.zip\";\n@@ -54,1 +54,1 @@\n-  @BeforeMethod\n+    @BeforeMethod\n@@ -56,2 +56,2 @@\n-    deleteFiles();\n-  }\n+        deleteFiles();\n+    }\n@@ -59,1 +59,1 @@\n-  @AfterMethod\n+    @AfterMethod\n@@ -61,2 +61,2 @@\n-    deleteFiles();\n-  }\n+        deleteFiles();\n+    }\n@@ -64,8 +64,8 @@\n-  \/**\n-   * Delete the files created for use by the test\n-   *\n-   * @throws IOException if an error occurs deleting the files\n-   *\/\n-  private static void deleteFiles() throws IOException {\n-    Files.deleteIfExists(Paths.get(ZIP_FILE_NAME));\n-  }\n+    \/**\n+     * Delete the files created for use by the test\n+     *\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(Paths.get(ZIP_FILE_NAME));\n+    }\n@@ -74,21 +74,25 @@\n-  \/**\n-   * Using zip filesystem, creates a zip file and writes out a zip entry whose compressed size is\n-   * expected to be greater than 2gb.\n-   *\/\n-  @Test\n-  public void testLargeCompressedSizeWithZipFS() throws Exception {\n-    final Path zipFile = Paths.get(ZIP_FILE_NAME);\n-    final URI uri = URI.create(\"jar:\" + zipFile.toUri());\n-    final long largeEntrySize = 6L * 1024L * 1024L * 1024L; \/\/ large value which exceeds Integer.MAX_VALUE\n-    try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.singletonMap(\"create\", \"true\"))) {\n-      try (OutputStream os = Files.newOutputStream(fs.getPath(LARGE_FILE_NAME))) {\n-        long remaining = largeEntrySize;\n-        \/\/ create a chunk of random bytes which we keep writing out\n-        final int chunkSize = 102400;\n-        final byte[] chunk = new byte[chunkSize];\n-        new Random().nextBytes(chunk);\n-        final long start = System.currentTimeMillis();\n-        for (long l = 0; l < largeEntrySize; l += chunkSize) {\n-          final int numToWrite = (int)Math.min(remaining, chunkSize);\n-          os.write(chunk, 0, numToWrite);\n-          remaining -= numToWrite;\n+    \/**\n+     * Using zip filesystem, creates a zip file and writes out a zip entry whose compressed size is\n+     * expected to be greater than 2gb.\n+     *\/\n+    @Test\n+    public void testLargeCompressedSizeWithZipFS() throws Exception {\n+        final Path zipFile = Paths.get(ZIP_FILE_NAME);\n+        final URI uri = URI.create(\"jar:\" + zipFile.toUri());\n+        final long largeEntrySize = 6L * 1024L * 1024L * 1024L; \/\/ large value which exceeds Integer.MAX_VALUE\n+        try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.singletonMap(\"create\", \"true\"))) {\n+            try (OutputStream os = Files.newOutputStream(fs.getPath(LARGE_FILE_NAME))) {\n+                long remaining = largeEntrySize;\n+                \/\/ create a chunk of random bytes which we keep writing out\n+                final int chunkSize = 102400;\n+                final byte[] chunk = new byte[chunkSize];\n+                new Random().nextBytes(chunk);\n+                final long start = System.currentTimeMillis();\n+                for (long l = 0; l < largeEntrySize; l += chunkSize) {\n+                    final int numToWrite = (int)Math.min(remaining, chunkSize);\n+                    os.write(chunk, 0, numToWrite);\n+                    remaining -= numToWrite;\n+                }\n+                System.out.println(\"Took \" + TimeUnit.SECONDS.toSeconds(System.currentTimeMillis() - start)\n+                        + \" seconds to generate entry of size \" + largeEntrySize);\n+            }\n@@ -96,3 +100,0 @@\n-        System.out.println(\"Took \" + TimeUnit.SECONDS.toSeconds(System.currentTimeMillis() - start)\n-          + \" seconds to generate entry of size \" + largeEntrySize);\n-      }\n@@ -100,1 +101,0 @@\n-  }\n","filename":"jdk\/test\/demo\/zipfs\/LargeCompressedEntrySizeTest.java","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -55,7 +55,7 @@\n-  \/\/ List of files to be added to the ZIP file along with their sizes in bytes\n-  private static final Map<String, Long> ZIP_ENTRIES = Collections.unmodifiableMap(new HashMap<String, Long>() {{\n-    put(\"f1\", Integer.MAX_VALUE + 1L); \/\/ a value which when cast to an integer, becomes a negative value\n-    put(\"f2\", 25L * 1024L * 1024L); \/\/ 25 MB\n-    put(\"d1\/f3\", 1234L);\n-    put(\"d1\/d2\/f4\", 0L);\n-  }});\n+    \/\/ List of files to be added to the ZIP file along with their sizes in bytes\n+    private static final Map<String, Long> ZIP_ENTRIES = Collections.unmodifiableMap(new HashMap<String, Long>() {{\n+            put(\"f1\", Integer.MAX_VALUE + 1L); \/\/ a value which when cast to an integer, becomes a negative value\n+            put(\"f2\", 25L * 1024L * 1024L); \/\/ 25 MB\n+            put(\"d1\/f3\", 1234L);\n+            put(\"d1\/d2\/f4\", 0L);\n+    }});\n@@ -63,1 +63,1 @@\n-  private static final Path ZIP_FILE = Paths.get(\"zipfs-outputstream-test.zip\");\n+    private static final Path ZIP_FILE = Paths.get(\"zipfs-outputstream-test.zip\");\n@@ -65,1 +65,1 @@\n-  @BeforeMethod\n+    @BeforeMethod\n@@ -67,2 +67,2 @@\n-    deleteFiles();\n-  }\n+        deleteFiles();\n+    }\n@@ -70,1 +70,1 @@\n-  @AfterMethod\n+    @AfterMethod\n@@ -72,2 +72,2 @@\n-    deleteFiles();\n-  }\n+        deleteFiles();\n+    }\n@@ -75,3 +75,3 @@\n-  private static void deleteFiles() throws IOException {\n-    Files.deleteIfExists(ZIP_FILE);\n-  }\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n@@ -79,7 +79,7 @@\n-  @DataProvider(name = \"zipFSCreationEnv\")\n-  private Object[][] zipFSCreationEnv() {\n-    return new Object[][] {\n-      { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"true\"); }}) },\n-      { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"false\"); }}) }\n-    };\n-  }\n+    @DataProvider(name = \"zipFSCreationEnv\")\n+    private Object[][] zipFSCreationEnv() {\n+        return new Object[][] {\n+                { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"true\"); }}) },\n+                { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"false\"); }}) }\n+        };\n+    }\n@@ -87,19 +87,21 @@\n-  \/**\n-   * Create a zip filesystem and write out entries of varying sizes using the outputstream returned\n-   * by the ZipFileSystem. Then verify that the generated zip file entries are as expected,\n-   * both in size and content\n-   *\/\n-  @Test(dataProvider = \"zipFSCreationEnv\")\n-  public void testOutputStream(final Map<String, ? > env) throws Exception {\n-    final URI uri = URI.create(\"jar:\" + ZIP_FILE.toUri());\n-    final byte[] chunk = new byte[1024];\n-    new Random().nextBytes(chunk);\n-    try (final FileSystem zipfs = FileSystems.newFileSystem(uri, env)) {\n-      \/\/ create the zip with varying sized entries\n-      for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n-        final Path entryPath = zipfs.getPath(entry.getKey());\n-        if (entryPath.getParent() != null) {\n-          Files.createDirectories(entryPath.getParent());\n-        }\n-        try (final OutputStream os = Files.newOutputStream(entryPath)) {\n-          writeAsChunks(os, chunk, entry.getValue());\n+    \/**\n+     * Create a zip filesystem and write out entries of varying sizes using the outputstream returned\n+     * by the ZipFileSystem. Then verify that the generated zip file entries are as expected,\n+     * both in size and content\n+     *\/\n+    @Test(dataProvider = \"zipFSCreationEnv\")\n+    public void testOutputStream(final Map<String, ? > env) throws Exception {\n+        final URI uri = URI.create(\"jar:\" + ZIP_FILE.toUri());\n+        final byte[] chunk = new byte[1024];\n+        new Random().nextBytes(chunk);\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(uri, env)) {\n+            \/\/ create the zip with varying sized entries\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                if (entryPath.getParent() != null) {\n+                    Files.createDirectories(entryPath.getParent());\n+                }\n+                try (final OutputStream os = Files.newOutputStream(entryPath)) {\n+                    writeAsChunks(os, chunk, entry.getValue());\n+                }\n+            }\n@@ -107,17 +109,20 @@\n-      }\n-    }\n-    \/\/ now verify the written content\n-    try (final FileSystem zipfs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n-      for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n-        final Path entryPath = zipfs.getPath(entry.getKey());\n-        try (final InputStream is = Files.newInputStream(entryPath)) {\n-          final byte[] buf = new byte[chunk.length];\n-          int numRead;\n-          long totalRead = 0;\n-          while ((numRead = is.read(buf)) != -1) {\n-            totalRead += numRead;\n-            \/\/ verify the content\n-            for (int i = 0, chunkoffset = (int)((totalRead - numRead) % chunk.length);\n-              i < numRead; i++, chunkoffset++) {\n-              Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n-                \"Unexpected content in \" + entryPath);\n+        \/\/ now verify the written content\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                try (final InputStream is = Files.newInputStream(entryPath)) {\n+                    final byte[] buf = new byte[chunk.length];\n+                    int numRead;\n+                    long totalRead = 0;\n+                    while ((numRead = is.read(buf)) != -1) {\n+                        totalRead += numRead;\n+                        \/\/ verify the content\n+                        for (int i = 0, chunkoffset = (int)((totalRead - numRead) % chunk.length);\n+                             i < numRead; i++, chunkoffset++) {\n+                            Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n+                                    \"Unexpected content in \" + entryPath);\n+                        }\n+                    }\n+                    Assert.assertEquals(totalRead, (long)entry.getValue(),\n+                            \"Unexpected number of bytes read from zip entry \" + entryPath);\n+                }\n@@ -125,3 +130,0 @@\n-          }\n-          Assert.assertEquals(totalRead, (long)entry.getValue(),\n-            \"Unexpected number of bytes read from zip entry \" + entryPath);\n@@ -129,1 +131,0 @@\n-      }\n@@ -131,1 +132,0 @@\n-  }\n@@ -133,11 +133,12 @@\n-  \/**\n-   * Repeatedly writes out to the outputstream, the chunk of data, till the number of bytes\n-   * written to the stream equals the totalSize\n-   *\/\n-  private static void writeAsChunks(final OutputStream os, final byte[] chunk,\n-    final long totalSize) throws IOException {\n-    long remaining = totalSize;\n-    for (long l = 0; l < totalSize; l += chunk.length) {\n-      final int numToWrite = (int)Math.min(remaining, chunk.length);\n-      os.write(chunk, 0, numToWrite);\n-      remaining -= numToWrite;\n+    \/**\n+     * Repeatedly writes out to the outputstream, the chunk of data, till the number of bytes\n+     * written to the stream equals the totalSize\n+     *\/\n+    private static void writeAsChunks(final OutputStream os, final byte[] chunk,\n+                                      final long totalSize) throws IOException {\n+        long remaining = totalSize;\n+        for (long l = 0; l < totalSize; l += chunk.length) {\n+            final int numToWrite = (int)Math.min(remaining, chunk.length);\n+            os.write(chunk, 0, numToWrite);\n+            remaining -= numToWrite;\n+        }\n@@ -145,1 +146,0 @@\n-  }\n","filename":"jdk\/test\/demo\/zipfs\/ZipFSOutputStreamTest.java","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"}]}