{"files":[{"patch":"@@ -40,1 +40,0 @@\n-\n@@ -97,0 +96,4 @@\n+    \/\/ a threshold, in bytes, to decide whether to create a temp file\n+    \/\/ for outputstream of a zip entry\n+    private final int tempFileCreationThreshold = 10 * 1024 * 1024; \/\/ 10 MB\n+\n@@ -1420,1 +1423,1 @@\n-        if (useTempFile) {\n+        if (useTempFile || e.size >= tempFileCreationThreshold) {\n@@ -1424,1 +1427,1 @@\n-            os = new ByteArrayOutputStream((e.size > 0)? (int)e.size : 8192);\n+            os = new FileRolloverOutputStream(e);\n@@ -1429,0 +1432,105 @@\n+    \/\/ A wrapper around the ByteArrayOutputStream. This FileRolloverOutputStream\n+    \/\/ uses a threshold size to decide if the contents being written need to be\n+    \/\/ rolled over into a temporary file. Until the threshold is reached, writes\n+    \/\/ on this outputstream just write it to the internal in-memory byte array\n+    \/\/ held by the ByteArrayOutputStream. Once the threshold is reached, the\n+    \/\/ write operation on this outputstream first (and only once) creates a temporary file\n+    \/\/ and transfers the data that has so far been written in the internal\n+    \/\/ byte array, to that newly created file. The temp file is then opened\n+    \/\/ in append mode and any subsequent writes, including the one which triggered\n+    \/\/ the temporary file creation, will be written to the file.\n+    \/\/ Implementation note: the \"write\" and the \"close\" methods of this implementation\n+    \/\/ aren't \"synchronized\" because this FileRolloverOutputStream gets called\n+    \/\/ only from either DeflatingEntryOutputStream or EntryOutputStream, both of which\n+    \/\/ already have the necessary \"synchronized\" before calling these methods.\n+    private class FileRolloverOutputStream extends OutputStream {\n+        private ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);\n+        private final Entry entry;\n+        private OutputStream tmpFileOS;\n+        private long totalWritten = 0;\n+\n+        private FileRolloverOutputStream(final Entry e) {\n+            this.entry = e;\n+        }\n+\n+        @Override\n+        public void write(final int b) throws IOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b);\n+                return;\n+            }\n+            if (totalWritten + 1 < tempFileCreationThreshold) {\n+                \/\/ write to our in-memory byte array\n+                baos.write(b);\n+                totalWritten++;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            transferToFile();\n+            writeToFile(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            write(b, 0, b.length);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len) throws IOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b, off, len);\n+                return;\n+            }\n+            if (totalWritten + len < tempFileCreationThreshold) {\n+                \/\/ write to our in-memory byte array\n+                baos.write(b, off, len);\n+                totalWritten += len;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            transferToFile();\n+            writeToFile(b, off, len);\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            if (tmpFileOS != null) {\n+                tmpFileOS.flush();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            baos = null;\n+            if (tmpFileOS != null) {\n+                tmpFileOS.close();\n+            }\n+        }\n+\n+        private void writeToFile(int b) throws IOException {\n+            tmpFileOS.write(b);\n+            totalWritten++;\n+        }\n+\n+        private void writeToFile(byte[] b, int off, int len) throws IOException {\n+            tmpFileOS.write(b, off, len);\n+            totalWritten += len;\n+        }\n+\n+        private void transferToFile() throws IOException {\n+            \/\/ create a tempfile\n+            entry.file = getTempPathForEntry(null);\n+            tmpFileOS = new BufferedOutputStream(Files.newOutputStream(entry.file));\n+            \/\/ transfer the already written data from the byte array buffer into this tempfile\n+            baos.writeTo(tmpFileOS);\n+            \/\/ release the underlying byte array\n+            baos = null;\n+        }\n+\n+        private byte[] toByteArray() {\n+            return baos == null ? null : baos.toByteArray();\n+        }\n+    }\n+\n@@ -1647,2 +1755,6 @@\n-            if (out instanceof ByteArrayOutputStream)\n-                e.bytes = ((ByteArrayOutputStream)out).toByteArray();\n+            if (out instanceof FileRolloverOutputStream) {\n+                FileRolloverOutputStream fros = (FileRolloverOutputStream) out;\n+                if (fros.tmpFileOS == null) {\n+                    e.bytes = fros.toByteArray();\n+                }\n+            }\n","filename":"jdk\/src\/share\/demo\/nio\/zipfs\/src\/com\/sun\/nio\/zipfs\/ZipFileSystem.java","additions":117,"deletions":5,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.net.URI;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8190753 8011146\n+ * @summary Verify that using zip filesystem for opening an outputstream for a zip entry whose\n+ * compressed size is large, doesn't run into \"Negative initial size\" exception\n+ * @run testng\/manual\/othervm LargeCompressedEntrySizeTest\n+ *\/\n+public class LargeCompressedEntrySizeTest {\n+\n+  private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+  private static final String ZIP_FILE_NAME = \"8190753-test-compressed-size.zip\";\n+\n+  @BeforeMethod\n+    public void setUp() throws IOException {\n+    deleteFiles();\n+  }\n+\n+  @AfterMethod\n+    public void tearDown() throws IOException {\n+    deleteFiles();\n+  }\n+\n+  \/**\n+   * Delete the files created for use by the test\n+   *\n+   * @throws IOException if an error occurs deleting the files\n+   *\/\n+  private static void deleteFiles() throws IOException {\n+    Files.deleteIfExists(Paths.get(ZIP_FILE_NAME));\n+  }\n+\n+\n+  \/**\n+   * Using zip filesystem, creates a zip file and writes out a zip entry whose compressed size is\n+   * expected to be greater than 2gb.\n+   *\/\n+  @Test\n+  public void testLargeCompressedSizeWithZipFS() throws Exception {\n+    final Path zipFile = Paths.get(ZIP_FILE_NAME);\n+    final URI uri = URI.create(\"jar:\" + zipFile.toUri());\n+    final long largeEntrySize = 6L * 1024L * 1024L * 1024L; \/\/ large value which exceeds Integer.MAX_VALUE\n+    try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.singletonMap(\"create\", \"true\"))) {\n+      try (OutputStream os = Files.newOutputStream(fs.getPath(LARGE_FILE_NAME))) {\n+        long remaining = largeEntrySize;\n+        \/\/ create a chunk of random bytes which we keep writing out\n+        final int chunkSize = 102400;\n+        final byte[] chunk = new byte[chunkSize];\n+        new Random().nextBytes(chunk);\n+        final long start = System.currentTimeMillis();\n+        for (long l = 0; l < largeEntrySize; l += chunkSize) {\n+          final int numToWrite = (int)Math.min(remaining, chunkSize);\n+          os.write(chunk, 0, numToWrite);\n+          remaining -= numToWrite;\n+        }\n+        System.out.println(\"Took \" + TimeUnit.SECONDS.toSeconds(System.currentTimeMillis() - start)\n+          + \" seconds to generate entry of size \" + largeEntrySize);\n+      }\n+    }\n+  }\n+}\n","filename":"jdk\/test\/demo\/zipfs\/LargeCompressedEntrySizeTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.File;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\n+\/**\n+ * @test\n+ * @summary Verify that the outputstream created for zip file entries, through the ZipFileSystem\n+ * works fine for varying sizes of the zip file entries\n+ * @bug 8190753 8011146\n+ * @run testng\/timeout=3600 ZipFSOutputStreamTest\n+ *\/\n+public class ZipFSOutputStreamTest {\n+  \/\/ List of files to be added to the ZIP file along with their sizes in bytes\n+  private static final Map<String, Long> ZIP_ENTRIES = Collections.unmodifiableMap(new HashMap<String, Long>() {{\n+    put(\"f1\", Integer.MAX_VALUE + 1L); \/\/ a value which when cast to an integer, becomes a negative value\n+    put(\"f2\", 25L * 1024L * 1024L); \/\/ 25 MB\n+    put(\"d1\/f3\", 1234L);\n+    put(\"d1\/d2\/f4\", 0L);\n+  }});\n+\n+  private static final Path ZIP_FILE = Paths.get(\"zipfs-outputstream-test.zip\");\n+\n+  @BeforeMethod\n+    public void setUp() throws IOException {\n+    deleteFiles();\n+  }\n+\n+  @AfterMethod\n+    public void tearDown() throws IOException {\n+    deleteFiles();\n+  }\n+\n+  private static void deleteFiles() throws IOException {\n+    Files.deleteIfExists(ZIP_FILE);\n+  }\n+\n+  @DataProvider(name = \"zipFSCreationEnv\")\n+  private Object[][] zipFSCreationEnv() {\n+    return new Object[][] {\n+      { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"true\"); }}) },\n+      { Collections.unmodifiableMap(new HashMap<String,String>() {{ put(\"create\", \"true\"); put(\"noCompression\", \"false\"); }}) }\n+    };\n+  }\n+\n+  \/**\n+   * Create a zip filesystem and write out entries of varying sizes using the outputstream returned\n+   * by the ZipFileSystem. Then verify that the generated zip file entries are as expected,\n+   * both in size and content\n+   *\/\n+  @Test(dataProvider = \"zipFSCreationEnv\")\n+  public void testOutputStream(final Map<String, ? > env) throws Exception {\n+    final URI uri = URI.create(\"jar:\" + ZIP_FILE.toUri());\n+    final byte[] chunk = new byte[1024];\n+    new Random().nextBytes(chunk);\n+    try (final FileSystem zipfs = FileSystems.newFileSystem(uri, env)) {\n+      \/\/ create the zip with varying sized entries\n+      for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+        final Path entryPath = zipfs.getPath(entry.getKey());\n+        if (entryPath.getParent() != null) {\n+          Files.createDirectories(entryPath.getParent());\n+        }\n+        try (final OutputStream os = Files.newOutputStream(entryPath)) {\n+          writeAsChunks(os, chunk, entry.getValue());\n+        }\n+      }\n+    }\n+    \/\/ now verify the written content\n+    try (final FileSystem zipfs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n+      for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+        final Path entryPath = zipfs.getPath(entry.getKey());\n+        try (final InputStream is = Files.newInputStream(entryPath)) {\n+          final byte[] buf = new byte[chunk.length];\n+          int numRead;\n+          long totalRead = 0;\n+          while ((numRead = is.read(buf)) != -1) {\n+            totalRead += numRead;\n+            \/\/ verify the content\n+            for (int i = 0, chunkoffset = (int)((totalRead - numRead) % chunk.length);\n+              i < numRead; i++, chunkoffset++) {\n+              Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n+                \"Unexpected content in \" + entryPath);\n+            }\n+          }\n+          Assert.assertEquals(totalRead, (long)entry.getValue(),\n+            \"Unexpected number of bytes read from zip entry \" + entryPath);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/**\n+   * Repeatedly writes out to the outputstream, the chunk of data, till the number of bytes\n+   * written to the stream equals the totalSize\n+   *\/\n+  private static void writeAsChunks(final OutputStream os, final byte[] chunk,\n+    final long totalSize) throws IOException {\n+    long remaining = totalSize;\n+    for (long l = 0; l < totalSize; l += chunk.length) {\n+      final int numToWrite = (int)Math.min(remaining, chunk.length);\n+      os.write(chunk, 0, numToWrite);\n+      remaining -= numToWrite;\n+    }\n+  }\n+}\n","filename":"jdk\/test\/demo\/zipfs\/ZipFSOutputStreamTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}