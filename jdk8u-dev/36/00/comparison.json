{"files":[{"patch":"@@ -42,0 +42,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -50,0 +51,2 @@\n+static JfrCheckpointWriter* _writer = NULL;\n+static int primitives_count = 9;\n@@ -63,0 +66,41 @@\n+static traceid create_symbol_id(traceid artifact_id) {\n+  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+}\n+\n+static bool is_initial_typeset_for_chunk(bool class_unload) {\n+  return !class_unload;\n+}\n+\n+static traceid mark_symbol(Symbol* symbol, JfrArtifactSet* artifacts) {\n+  return symbol != NULL ? create_symbol_id(artifacts->mark(symbol)) : 0;\n+}\n+\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return NULL;\n+}\n+\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == NULL) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != NULL, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != NULL, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != NULL, \"invariant\");\n+  return primitive_type_sym;\n+}\n+\n@@ -86,0 +130,4 @@\n+static u4 get_primitive_flags() {\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+}\n+\n@@ -468,1 +516,15 @@\n-    return;\n+  } else {\n+    TagLeakpKlassArtifact tagging(_class_unload);\n+    LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);\n+    LeakpKlassArtifactTagging lpkat(&tagging, &lkw);\n+    CompositeKlassWriter ckw(&lpkat, &kw);\n+    CompositeKlassWriterRegistration ckwr(&ckw, &reg);\n+    CompositeKlassCallback callback(&ckwr);\n+    _subsystem_callback = &callback;\n+    do_klasses();\n+  }\n+\n+  if (is_initial_typeset_for_chunk(_class_unload)) {\n+    \/\/ Because the set of primitives is written outside the callback,\n+    \/\/ their count is not automatically incremented.\n+    kw.add(primitives_count);\n@@ -470,8 +532,0 @@\n-  TagLeakpKlassArtifact tagging(_class_unload);\n-  LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);\n-  LeakpKlassArtifactTagging lpkat(&tagging, &lkw);\n-  CompositeKlassWriter ckw(&lpkat, &kw);\n-  CompositeKlassWriterRegistration ckwr(&ckw, &reg);\n-  CompositeKlassCallback callback(&ckwr);\n-  _subsystem_callback = &callback;\n-  do_klasses();\n@@ -656,0 +710,39 @@\n+static traceid primitive_id(KlassPtr array_klass) {\n+  if (array_klass == NULL) {\n+    \/\/ The first klass id is reserved for the void.class.\n+    return MaxJfrEventId + 101;\n+  }\n+  \/\/ Derive the traceid for a primitive mirror from its associated array klass (+1).\n+  return JfrTraceId::get(array_klass) + 1;\n+}\n+\n+static void write_primitive(JfrCheckpointWriter* writer, Klass* type_array_klass, JfrArtifactSet* artifacts) {\n+  assert(writer != NULL, \"invariant\");\n+  assert(artifacts != NULL, \"invariant\");\n+  writer->write(primitive_id(type_array_klass));\n+  writer->write(cld_id(Universe::boolArrayKlassObj()->class_loader_data()));\n+  writer->write(mark_symbol(primitive_symbol(type_array_klass), artifacts));\n+  writer->write(package_id(Universe::boolArrayKlassObj(), artifacts));\n+  writer->write(get_primitive_flags());\n+}\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static void do_primitives(JfrArtifactSet* artifacts, bool class_unload) {\n+  \/\/ Only write the primitive classes once per chunk.\n+  if (is_initial_typeset_for_chunk(class_unload)) {\n+    write_primitive(_writer, Universe::boolArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::byteArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::charArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::shortArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::intArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::longArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::singleArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::doubleArrayKlassObj(), artifacts);\n+    write_primitive(_writer, NULL, artifacts); \/\/ void.class\n+  }\n+}\n+\n@@ -662,0 +755,1 @@\n+  do_primitives(_artifacts, _class_unload);\n@@ -723,0 +817,1 @@\n+  _writer = writer;\n@@ -748,0 +843,1 @@\n+\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":105,"deletions":9,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  static volatile traceid class_id_counter = MaxJfrEventId + 100;\n+  static volatile traceid class_id_counter = MaxJfrEventId + 101; \/\/ + 101 is for the void.class primitive;\n@@ -110,0 +110,4 @@\n+traceid JfrTraceId::assign_primitive_klass_id() {\n+  return next_class_id();\n+}\n+\n@@ -133,0 +137,22 @@\n+  if (k->oop_is_typeArray()) {\n+    \/\/ the next id is reserved for the corresponding primitive class\n+    next_class_id();\n+  }\n+}\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static traceid load_primitive(const oop mirror) {\n+  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n+  const Klass* const tak = java_lang_Class::array_klass(mirror);\n+  traceid id;\n+  if (tak == NULL) {\n+    \/\/ The first klass id is reserved for the void.class\n+    id = MaxJfrEventId + 101;\n+  } else {\n+    id = JfrTraceId::get(tak) + 1;\n+  }\n+  return id;\n@@ -148,1 +174,2 @@\n-  return use(java_lang_Class::as_Klass(my_oop), leakp);\n+  const Klass* const k = java_lang_Class::as_Klass(my_oop);\n+  return k != NULL ? use(k, leakp) : load_primitive(my_oop);\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  static traceid assign_primitive_klass_id();\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#define ASSIGN_PRIMITIVE_CLASS_ID(data) JfrTraceId::assign_primitive_klass_id()\n","filename":"hotspot\/src\/share\/vm\/jfr\/support\/jfrTraceIdExtension.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  JFR_ONLY(ASSIGN_PRIMITIVE_CLASS_ID(ak);)\n","filename":"hotspot\/src\/share\/vm\/oops\/typeArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestPrimitiveClasses\n+ * @key jfr\n+ * @library \/lib \/\n+ * @run main\/othervm jdk.jfr.jvm.TestPrimitiveClasses\n+ *\/\n+public class TestPrimitiveClasses {\n+\n+    private static class MyEvent extends Event {\n+        Class<?> booleanClass = boolean.class;\n+        Class<?> charClass = char.class;\n+        Class<?> floatClass = float.class;\n+        Class<?> doubleClass = double.class;\n+        Class<?> byteClass = byte.class;\n+        Class<?> shortClass = short.class;\n+        Class<?> intClass = int.class;\n+        Class<?> longClass = long.class;\n+        Class<?> voidClass = void.class;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MyEvent.class);\n+            r.start();\n+            MyEvent myEvent = new MyEvent();\n+            myEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent event = events.get(0);\n+            System.out.println(event);\n+            testField(event, \"booleanClass\", boolean.class);\n+            testField(event, \"charClass\", char.class);\n+            testField(event, \"floatClass\", float.class);\n+            testField(event, \"doubleClass\", double.class);\n+            testField(event, \"byteClass\", byte.class);\n+            testField(event, \"shortClass\", short.class);\n+            testField(event, \"intClass\", int.class);\n+            testField(event, \"longClass\", long.class);\n+            testField(event, \"voidClass\", void.class);\n+        }\n+    }\n+\n+    private static void testField(RecordedEvent event, String fieldName, Class<?> expected) {\n+        Asserts.assertTrue(event.hasField(fieldName));\n+        RecordedClass classField = event.getValue(fieldName);\n+        Asserts.assertEquals(classField.getName(), expected.getName());\n+        Asserts.assertEquals(classField.getClassLoader().getName(), \"<bootloader>\");\n+        Asserts.assertEquals(classField.getModifiers(), expected.getModifiers());\n+    }\n+}\n","filename":"jdk\/test\/jdk\/jfr\/jvm\/TestPrimitiveClasses.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}