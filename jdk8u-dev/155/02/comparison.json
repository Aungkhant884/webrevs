{"files":[{"patch":"@@ -172,1 +172,4 @@\n-  if (err != 0)                                                           \\\n+  if (err != 0) {                                                         \\\n+    if (PrintContainerInfo) {                                             \\\n+      tty->print_cr(logstring, (return_type) OSCONTAINER_ERROR);          \\\n+    }                                                                     \\\n@@ -174,0 +177,1 @@\n+  }                                                                       \\\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n@@ -39,1 +39,1 @@\n-                     \"Raw value for CPU shares is: %d\", \"%d\", shares);\n+                     \"Raw value for CPU Shares is: %d\", \"%d\", shares);\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2287,1 +2287,1 @@\n-if (!OSContainer::is_containerized()) {\n+  if (!OSContainer::is_containerized()) {\n","filename":"hotspot\/src\/os\/linux\/vm\/os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n- * @library \/testlibrary \/test\/lib\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build CgroupSubsystemFactory\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n@@ -39,0 +39,3 @@\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -40,3 +43,2 @@\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.FileUtils;\n+import com.oracle.java.testlibrary.Asserts;\n+import com.oracle.java.testlibrary.Utils;\n@@ -50,1 +52,1 @@\n-    \/\/ Mirrored from src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp\n+    \/\/ Mirrored from hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp\n@@ -132,1 +134,1 @@\n-            Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n@@ -136,1 +138,1 @@\n-            Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n@@ -139,1 +141,1 @@\n-            Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n@@ -142,1 +144,1 @@\n-            Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n@@ -145,1 +147,1 @@\n-            Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n@@ -148,1 +150,1 @@\n-            Files.writeString(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder);\n+            Files.write(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder.getBytes());\n@@ -151,1 +153,1 @@\n-            Files.writeString(cgroupV1SelfCgroup, procSelfCgroupHybridContent);\n+            Files.write(cgroupV1SelfCgroup, procSelfCgroupHybridContent.getBytes());\n@@ -154,1 +156,1 @@\n-            Files.writeString(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent);\n+            Files.write(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent.getBytes());\n@@ -157,1 +159,1 @@\n-            Files.writeString(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory);\n+            Files.write(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory.getBytes());\n@@ -160,1 +162,1 @@\n-            Files.writeString(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub);\n+            Files.write(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub.getBytes());\n@@ -168,1 +170,1 @@\n-            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+            deleteFileTree(existingDirectory);\n@@ -174,0 +176,19 @@\n+    private static void deleteFileTree(Path dir) throws IOException {\n+        java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":39,"deletions":18,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test PlainRead\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/testlibrary\/whitebox\n+ * @build PlainRead\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n+ *\/\n+\n+import com.oracle.java.testlibrary.ProcessTools;\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n+import com.oracle.java.testlibrary.Platform;\n+import sun.hotspot.WhiteBox;\n+\n+public class PlainRead {\n+\n+    static public void match(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n+       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n+    }\n+\n+    static final String good_value = \"(\\\\d+|-1|Unlimited)\";\n+    static final String bad_value = \"(failed)\";\n+\n+    static final String[] variables = {\"Memory Limit is:\", \"CPU Shares is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n+\n+    static public void isContainer(OutputAnalyzer oa) {\n+        for (String v: variables) {\n+            match(oa, v, good_value);\n+        }\n+        for (String v: variables) {\n+            noMatch(oa, v, bad_value);\n+        }\n+    }\n+\n+    static public void isNotContainer(OutputAnalyzer oa) {\n+       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintContainerInfo\", \"-version\");\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        if (wb.isContainerized()) {\n+            System.out.println(\"Inside a cgroup, testing...\");\n+            isContainer(output);\n+        } else {\n+            System.out.println(\"Not in a cgroup, testing...\");\n+            isNotContainer(output);\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/PlainRead.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -32,0 +33,8 @@\n+        Metrics metrics = jdk.internal.platform.Container.metrics();\n+        System.out.println(\"Metrics instance: \" + (metrics == null ? \"null\" : \"non-null\"));\n+        if (metrics != null) {\n+            System.out.println(\"Metrics.getMemoryAndSwapLimit() == \" + metrics.getMemoryAndSwapLimit());\n+            System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n+            System.out.println(\"Metrics.getMemoryAndSwapUsage() == \" + metrics.getMemoryAndSwapUsage());\n+            System.out.println(\"Metrics.getMemoryUsage() == \" + metrics.getMemoryUsage());\n+        }\n","filename":"hotspot\/test\/runtime\/containers\/docker\/CheckOperatingSystemMXBean.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n@@ -373,0 +377,21 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n+\n","filename":"hotspot\/test\/testlibrary\/com\/oracle\/java\/testlibrary\/Utils.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -259,0 +259,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"hotspot\/test\/testlibrary\/whitebox\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -37,1 +39,1 @@\n-class CgroupSubsystemFactory {\n+public class CgroupSubsystemFactory {\n@@ -46,1 +48,1 @@\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+        Optional<CgroupTypeResult> optResult = null;\n@@ -48,14 +50,1 @@\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n-            for (String line : lines) {\n-                if (line.startsWith(\"#\")) {\n-                    continue;\n-                }\n-                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n-                switch (info.getName()) {\n-                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n-                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n-                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n-                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n-                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n-                }\n-            }\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n@@ -66,10 +55,2 @@\n-        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n-        boolean isCgroupsV2 = true;\n-        boolean anyControllersEnabled = false;\n-        boolean anyCgroupsV2Controller = false;\n-        boolean anyCgroupsV1Controller = false;\n-        for (CgroupInfo info: infos.values()) {\n-            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n-            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n-            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n-            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        if (optResult.equals(Optional.empty())) {\n+            return null;\n@@ -77,0 +58,1 @@\n+        CgroupTypeResult result = optResult.get();\n@@ -79,1 +61,1 @@\n-        if (!anyControllersEnabled) {\n+        if (!result.isAnyControllersEnabled()) {\n@@ -85,1 +67,1 @@\n-        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+        if (result.isAnyCgroupV1Controllers() && result.isAnyCgroupV2Controllers()) {\n@@ -89,1 +71,1 @@\n-        if (isCgroupsV2) {\n+        if (result.isCgroupV2()) {\n@@ -97,0 +79,79 @@\n+\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        for (String line : lines) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+            switch (info.getName()) {\n+            case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+            case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+            case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+            case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+            case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+            }\n+        }\n+\n+        \/\/ For cgroups v2 all controllers need to have zero hierarchy id\n+        \/\/ and \/proc\/self\/mountinfo needs to have at least one cgroup filesystem\n+        \/\/ mounted. Note that hybrid hierarchy has controllers mounted via\n+        \/\/ cgroup v1. In that case hierarchy id's will be non-zero.\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If there are no mounted controllers in mountinfo, but we've only\n+        \/\/ seen 0 hierarchy IDs in \/proc\/cgroups, we are on a cgroups v1 system.\n+        \/\/ However, continuing in that case does not make sense as we'd need\n+        \/\/ information from mountinfo for the mounted controller paths anyway.\n+        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n+            boolean anyCgroupMounted = mntInfo.anyMatch(line -> line.contains(\"cgroup\"));\n+            if (!anyCgroupMounted && isCgroupsV2) {\n+                return Optional.empty();\n+            }\n+        }\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+        return Optional.of(result);\n+    }\n+\n+    public static final class CgroupTypeResult {\n+        private final boolean isCgroupV2;\n+        private final boolean anyControllersEnabled;\n+        private final boolean anyCgroupV2Controllers;\n+        private final boolean anyCgroupV1Controllers;\n+\n+        private CgroupTypeResult(boolean isCgroupV2,\n+                                 boolean anyControllersEnabled,\n+                                 boolean anyCgroupV2Controllers,\n+                                 boolean anyCgroupV1Controllers) {\n+            this.isCgroupV2 = isCgroupV2;\n+            this.anyControllersEnabled = anyControllersEnabled;\n+            this.anyCgroupV1Controllers = anyCgroupV1Controllers;\n+            this.anyCgroupV2Controllers = anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isCgroupV2() {\n+            return isCgroupV2;\n+        }\n+\n+        public boolean isAnyControllersEnabled() {\n+            return anyControllersEnabled;\n+        }\n+\n+        public boolean isAnyCgroupV2Controllers() {\n+            return anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isAnyCgroupV1Controllers() {\n+            return anyCgroupV1Controllers;\n+        }\n+    }\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":90,"deletions":29,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemFactory;\n+import jdk.internal.platform.CgroupSubsystemFactory.CgroupTypeResult;\n+import jdk.testlibrary.Utils;\n+import jdk.testlibrary.FileUtils;\n+\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/lib\/testlibrary\n+ * @run junit\/othervm TestCgroupSubsystemFactory\n+ *\/\n+public class TestCgroupSubsystemFactory {\n+\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String mntInfoHybrid =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  9   1   1\\n\" +\n+            \"cpu 7   1   1\\n\" +\n+            \"cpuacct 7   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.write(cgroupsZero, cgroupsZeroHierarchy.getBytes(StandardCharsets.UTF_8));\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.write(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty.getBytes());\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.write(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only.getBytes());\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.write(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy.getBytes());\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.write(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid.getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testHybridCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"hybrid hierarchy expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"zero hierarchy ids with no mounted controllers => empty result\", Optional.empty().equals(result));\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV2() throws IOException {\n+        String cgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"zero hierarchy ids with mounted controllers expected cgroups v2\", res.isCgroupV2());\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void mountInfoFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = Paths.get(existingDirectory.toString(), \"not-existing-mountinfo\").toString();\n+\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void cgroupsFileNotFound() throws IOException {\n+        String cgroups = Paths.get(existingDirectory.toString(), \"not-existing-cgroups\").toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -99,1 +100,1 @@\n-        if (effectiveCpus.length != 0) {\n+        if (effectiveCpus != null) {\n@@ -134,1 +135,1 @@\n-        if (effectiveMems.length != 0) {\n+        if (effectiveMems != null) {\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n+            throw new RuntimeException(\"kernel memory limit test not supported for cgroups v2\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -44,3 +45,3 @@\n-    public static long convertStringToLong(String strval, long overflowRetval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n+    public static long convertStringToLong(String strval, long initialVal, long overflowRetval) {\n+        long retval = initialVal;\n+        if (strval == null) return retval;\n@@ -96,1 +97,1 @@\n-            return new Integer[0];\n+            return null;\n@@ -111,0 +112,15 @@\n+    public static Integer[] boxedArrayOrNull(int[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return Arrays.stream(primitiveArray).boxed().toArray(Integer[]::new);\n+    }\n+\n+    public static Integer[] sortAllowNull(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.internal.platform.Metrics;\n+import jdk.internal.platform.CgroupSubsystem;\n@@ -43,0 +43,2 @@\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Asserts;\n@@ -46,0 +48,2 @@\n+    \/\/ Aliased for readability\n+    private static final long RETVAL_UNAVAILABLE = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n@@ -130,3 +134,0 @@\n-        if (startPerCpu == null) {\n-            startPerCpu = new long[0];\n-        }\n@@ -162,1 +163,1 @@\n-        return (data == null || data.isEmpty()) ? 0L : convertStringToLong(data);\n+        return (data == null || data.isEmpty()) ? RETVAL_UNAVAILABLE : convertStringToLong(data);\n@@ -166,1 +167,1 @@\n-        return CgroupMetricsTester.convertStringToLong(strval, Long.MAX_VALUE);\n+        return CgroupMetricsTester.convertStringToLong(strval, RETVAL_UNAVAILABLE, Long.MAX_VALUE);\n@@ -178,1 +179,1 @@\n-        return 0L;\n+        return RETVAL_UNAVAILABLE;\n@@ -183,1 +184,1 @@\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n+        return data == null || data.isEmpty() ? RETVAL_UNAVAILABLE : Double.parseDouble(data);\n@@ -206,0 +207,7 @@\n+    private Long[] boxedArrayOrNull(long[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return LongStream.of(primitiveArray).boxed().toArray(Long[]::new);\n+    }\n+\n@@ -218,1 +226,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -244,1 +252,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -270,1 +278,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED: newVal;\n@@ -298,1 +306,1 @@\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n+            newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -321,1 +329,1 @@\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n@@ -346,1 +354,1 @@\n-        Long[] newVals = new Long[0];\n+        Long[] newVals = null;\n@@ -353,6 +361,6 @@\n-        long[] oldValsPrim = metrics.getPerCpuUsage();\n-        Long[] oldVals = LongStream.of(oldValsPrim == null ? new long[0] : oldValsPrim)\n-                                    .boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+        Long[] oldVals = boxedArrayOrNull(metrics.getPerCpuUsage());\n+        if (oldVals != null) {\n+            for (int i = 0; i < oldVals.length; i++) {\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                    warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+                }\n@@ -360,0 +368,2 @@\n+        } else {\n+            Asserts.assertNull(newVals, Controller.CPUACCT.value() + \"cpuacct.usage_percpu not both null\");\n@@ -417,2 +427,2 @@\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -423,1 +433,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -431,11 +441,8 @@\n-        \/\/ Skip this test if this metric is not supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSets);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n@@ -444,2 +451,2 @@\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -448,1 +455,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -456,11 +463,8 @@\n-        \/\/ Skip this test if this metric is not supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n-            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSetMems);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n@@ -507,3 +511,0 @@\n-        if (newPerCpu == null) {\n-            newPerCpu = new long[0];\n-        }\n@@ -527,5 +528,11 @@\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n+        if (startPerCpu != null) {\n+            boolean success = false;\n+            for (int i = 0; i < startPerCpu.length; i++) {\n+                if (newPerCpu[i] > startPerCpu[i]) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+            if (!success) {\n+                fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                                                       Arrays.toString(startPerCpu));\n@@ -533,0 +540,2 @@\n+        } else {\n+            Asserts.assertNull(newPerCpu, Controller.CPU.value() + \" getPerCpuUsage not both null\");\n@@ -535,2 +544,0 @@\n-        if(!success) fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":65,"deletions":58,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.platform.CgroupSubsystem;\n@@ -41,0 +40,1 @@\n+    private static final long NOT_AVAILABLE = -1;\n@@ -128,1 +128,1 @@\n-            return 0;\n+            return NOT_AVAILABLE;\n@@ -155,1 +155,1 @@\n-        if (rawVal == 0 || rawVal == 100) {\n+        if (rawVal == NOT_AVAILABLE || rawVal == 100) {\n@@ -203,1 +203,8 @@\n-        return CgroupMetricsTester.convertStringToLong(val, UNLIMITED);\n+        return CgroupMetricsTester.convertStringToLong(val, NOT_AVAILABLE, UNLIMITED);\n+    }\n+\n+    private long nanosOrUnlimited(long micros) {\n+        if (micros < 0) {\n+            return UNLIMITED;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n@@ -259,1 +266,1 @@\n-        long newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+        long newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n@@ -266,1 +273,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n@@ -272,1 +279,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n@@ -312,1 +319,1 @@\n-        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n@@ -321,3 +328,2 @@\n-        int[] cpus = mapNullToEmpty(metrics.getCpuSetCpus());\n-        Integer[] oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -328,1 +334,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -334,3 +340,2 @@\n-        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetCpus());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -339,1 +344,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -345,3 +350,2 @@\n-        cpus = mapNullToEmpty(metrics.getCpuSetMems());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -350,1 +354,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -356,3 +360,2 @@\n-        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetMems());\n-        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n@@ -361,1 +364,1 @@\n-        Arrays.sort(newVal);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n@@ -368,9 +371,0 @@\n-    private int[] mapNullToEmpty(int[] cpus) {\n-        if (cpus == null) {\n-            \/\/ Not available. For sake of testing continue with an\n-            \/\/ empty array.\n-            cpus = new int[0];\n-        }\n-        return cpus;\n-    }\n-\n@@ -465,1 +459,1 @@\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+            return NOT_AVAILABLE;\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -446,3 +446,0 @@\n-  public native int validateCgroup(String procCgroups,\n-                                   String procSelfCgroup,\n-                                   String procSelfMountinfo);\n","filename":"jdk\/test\/lib\/sun\/hotspot\/WhiteBox.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,0 +44,2 @@\n+import java.nio.file.attribute.FileAttribute;\n+\n@@ -443,0 +447,20 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n","filename":"jdk\/test\/lib\/testlibrary\/jdk\/testlibrary\/Utils.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}