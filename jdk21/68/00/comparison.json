{"files":[{"patch":"@@ -318,4 +318,0 @@\n-  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-    return false;\n-  }\n-\n@@ -6165,0 +6161,35 @@\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -6187,1 +6218,0 @@\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -308,4 +308,0 @@\n-  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-    return false;\n-  }\n-\n@@ -4431,0 +4427,35 @@\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4453,1 +4484,0 @@\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1028,4 +1028,0 @@\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2192,4 +2192,0 @@\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,3 +93,0 @@\n-  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-    return false;\n-  }\n@@ -4038,1 +4035,1 @@\n-%}\n\\ No newline at end of file\n+%}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1532,4 +1532,0 @@\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2154,13 +2154,0 @@\n-\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  switch (elem_bt) {\n-    case T_BYTE:  return false;\n-    case T_SHORT: return !VM_Version::supports_avx512bw();\n-    case T_INT:   return !VM_Version::supports_avx();\n-    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n-    default:\n-      ShouldNotReachHere();\n-      return false;\n-  }\n-}\n-\n@@ -8343,0 +8330,11 @@\n+\n+instruct loadShuffleB(vec dst) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadShuffle dst));\n+  format %{ \"vector_load_shuffle $dst, $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8409,1 +8407,1 @@\n-            !VM_Version::supports_avx512bw());\n+            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -8420,1 +8418,1 @@\n-      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8435,1 +8433,2 @@\n-      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n+      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -8482,0 +8481,15 @@\n+instruct loadShuffleS_evex(vec dst, vec src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n+            VM_Version::supports_avx512bw());\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    if (!VM_Version::supports_avx512vl()) {\n+      vlen_enc = Assembler::AVX_512bit;\n+    }\n+    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8512,1 +8526,1 @@\n-    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8541,0 +8555,12 @@\n+instruct loadShuffleI_avx(vec dst, vec src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n+            UseAVX > 0);\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8570,1 +8596,2 @@\n-    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n+    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -8596,0 +8623,14 @@\n+instruct loadShuffleL_evex(vec dst, vec src) %{\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    assert(UseAVX > 2, \"required\");\n+\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":59,"deletions":18,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -968,0 +968,18 @@\n+  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n+   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n+                                               \"IIII\"                                                                                          \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n+   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n+                                                                                                                                               \\\n+  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n+   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n+                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n+   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -757,0 +757,2 @@\n+  case vmIntrinsics::_VectorShuffleIota:\n+  case vmIntrinsics::_VectorShuffleToVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -907,1 +907,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -701,0 +701,2 @@\n+  case vmIntrinsics::_VectorShuffleIota:\n+    return inline_vector_shuffle_iota();\n@@ -703,0 +705,2 @@\n+  case vmIntrinsics::_VectorShuffleToVector:\n+    return inline_vector_shuffle_to_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -348,0 +348,2 @@\n+  bool inline_vector_shuffle_to_vector();\n+  bool inline_vector_shuffle_iota();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -343,2 +343,0 @@\n-  static const bool vector_needs_load_shuffle(BasicType elem_bt, int vlen);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+\n@@ -462,0 +467,2 @@\n+    } else if (is_vector_shuffle(from_kls)) {\n+      bt = T_BYTE;\n@@ -506,0 +513,3 @@\n+    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n+      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n+      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n@@ -159,1 +163,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n@@ -170,1 +174,1 @@\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n@@ -581,0 +585,97 @@\n+\/\/ <Sh extends VectorShuffle<E>,  E>\n+\/\/  Sh ShuffleIota(Class<?> E, Class<?> shuffleClass, Vector.Species<E> s, int length,\n+\/\/                  int start, int step, int wrap, ShuffleIotaOperation<Sh, E> defaultImpl)\n+bool LibraryCallKit::inline_vector_shuffle_iota() {\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n+\n+  Node* start = argument(4);\n+  Node* step  = argument(5);\n+\n+  if (shuffle_klass == nullptr || vlen == nullptr || start_val == nullptr || step_val == nullptr || wrap == nullptr) {\n+    return false; \/\/ dead code\n+  }\n+  if (!vlen->is_con() || !is_power_of_2(vlen->get_con()) ||\n+      shuffle_klass->const_oop() == nullptr || !wrap->is_con()) {\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(shuffle_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  int do_wrap = wrap->get_con();\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = T_BYTE;\n+\n+  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n+  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n+  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n+  if (!arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n+    return false;\n+  }\n+  if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskUseStore)) {\n+    return false;\n+  }\n+\n+  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n+\n+  Node* res =  gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+\n+  if(!step_val->is_con() || !is_power_of_2(step_val->get_con())) {\n+    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    res = gvn().transform(VectorNode::make(Op_MulI, res, bcast_step, num_elem, elem_bt));\n+  } else if (step_val->get_con() > 1) {\n+    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n+    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n+    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n+  }\n+\n+  if (!start_val->is_con() || start_val->get_con() != 0) {\n+    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    res = gvn().transform(VectorNode::make(Op_AddI, res, bcast_start, num_elem, elem_bt));\n+  }\n+\n+  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+  if(do_wrap)  {\n+    \/\/ Wrap the indices greater than lane count.\n+    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n+  } else {\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n+    Node * lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n+    Node * bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n+    const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ge, bcast_lane_cnt, res, pred_node, vmask_type));\n+\n+    \/\/ Make the indices greater than lane count as -ve values. This matches the java side implementation.\n+    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n+    Node * biased_val = gvn().transform(VectorNode::make(Op_SubI, res, bcast_lane_cnt, num_elem, elem_bt));\n+    res = gvn().transform(new VectorBlendNode(biased_val, res, mask));\n+  }\n+\n+  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  res = box_vector(res, shuffle_box_type, elem_bt, num_elem);\n+  set_result(res);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -618,1 +719,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n@@ -641,0 +742,65 @@\n+\/\/ public static\n+\/\/ <V,\n+\/\/  Sh extends VectorShuffle<E>,\n+\/\/  E>\n+\/\/ V shuffleToVector(Class<? extends Vector<E>> vclass, Class<E> elementType,\n+\/\/                   Class<? extends Sh> shuffleClass, Sh s, int length,\n+\/\/                   ShuffleToVectorOperation<V, Sh, E> defaultImpl)\n+bool LibraryCallKit::inline_vector_shuffle_to_vector() {\n+  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n+  Node*              shuffle       = argument(3);\n+  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n+    return false; \/\/ dead code\n+  }\n+  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(shuffle_klass) || !is_klass_initialized(vector_klass) ) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (num_elem < 4) {\n+    return false;\n+  }\n+\n+  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n+  \/\/ Make sure that cast is implemented to particular type\/size combination.\n+  if (!arch_supports_vector(cast_vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+        cast_vopc, num_elem, type2name(elem_bt));\n+    }\n+    return false;\n+  }\n+\n+  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n+\n+  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n+  \/\/ shuffle is a byte array\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+\n+  \/\/ cast byte to target element type\n+  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vec_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  \/\/ Box vector\n+  Node* res = box_vector(shuffle_vec, vec_box_type, elem_bt, num_elem);\n+  set_result(res);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -1895,1 +2061,0 @@\n-\n@@ -1898,6 +2063,0 @@\n-  if (shuffle_bt == T_FLOAT) {\n-    shuffle_bt = T_INT;\n-  } else if (shuffle_bt == T_DOUBLE) {\n-    shuffle_bt = T_LONG;\n-  }\n-\n@@ -1905,1 +2064,0 @@\n-  bool need_load_shuffle = Matcher::vector_needs_load_shuffle(shuffle_bt, num_elem);\n@@ -1907,1 +2065,1 @@\n-  if (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, shuffle_bt, VecMaskNotUsed)) {\n+  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -1910,1 +2068,1 @@\n-                    num_elem, type2name(shuffle_bt));\n+                    num_elem, type2name(elem_bt));\n@@ -1947,2 +2105,0 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n@@ -1968,4 +2124,0 @@\n-  if (need_load_shuffle) {\n-    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, st));\n-  }\n-\n@@ -1978,0 +2130,1 @@\n+      const TypeVect* vt = v1->bottom_type()->is_vect();\n@@ -2271,1 +2424,3 @@\n-\n+  if (is_vector_shuffle(vbox_klass_from)) {\n+    return false; \/\/ vector shuffles aren't supported\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":175,"deletions":20,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -1756,1 +1756,2 @@\n-        bool is_vector_mask = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n@@ -1761,0 +1762,5 @@\n+        } else if (is_vector_shuffle) {\n+          if (!is_shuffle_to_vector()) {\n+            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n+            return new VectorLoadShuffleNode(value, out_vt);\n+          }\n@@ -1762,1 +1768,1 @@\n-          \/\/ Vector type mismatch is only supported for masks, but sometimes it happens in pathological cases.\n+          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1485,1 +1485,3 @@\n-    : VectorNode(in, vt) {}\n+    : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n+  }\n@@ -1487,0 +1489,1 @@\n+  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1717,0 +1720,2 @@\n+ private:\n+  bool _shuffle_to_vector;\n@@ -1720,1 +1725,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n@@ -1722,0 +1727,1 @@\n+    _shuffle_to_vector = shuffle_to_vector;\n@@ -1732,0 +1738,1 @@\n+  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,4 @@\n+bool VectorSupport::is_vector_shuffle(Klass* klass) {\n+  return klass->is_subclass_of(vmClasses::vector_VectorShuffle_klass());\n+}\n+\n@@ -86,1 +90,3 @@\n-  if (is_vector_mask(ik)) {\n+  if (is_vector_shuffle(ik)) {\n+    return T_BYTE;\n+  } else if (is_vector_mask(ik)) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,0 +150,1 @@\n+  static bool is_vector_shuffle(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -230,0 +230,36 @@\n+    \/* ============================================================================ *\/\n+    public interface ShuffleIotaOperation<S extends VectorSpecies<?>,\n+                                          SH extends VectorShuffle<?>> {\n+        SH apply(int length, int start, int step, S s);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <E,\n+     S extends VectorSpecies<E>,\n+     SH extends VectorShuffle<E>>\n+    SH shuffleIota(Class<E> eClass, Class<? extends SH> shClass, S s,\n+                   int length,\n+                   int start, int step, int wrap,\n+                   ShuffleIotaOperation<S, SH> defaultImpl) {\n+       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+       return defaultImpl.apply(length, start, step, s);\n+    }\n+\n+    public interface ShuffleToVectorOperation<V extends Vector<?>,\n+                                              SH extends VectorShuffle<?>> {\n+       V apply(SH sh);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     SH extends VectorShuffle<E>,\n+     E>\n+    V shuffleToVector(Class<? extends Vector<E>> vClass, Class<E> eClass, Class<? extends SH> shClass, SH sh,\n+                      int length,\n+                      ShuffleToVectorOperation<V, SH> defaultImpl) {\n+      assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+      return defaultImpl.apply(sh);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.vm.vector.VectorSupport;\n@@ -34,1 +33,1 @@\n-    \/\/ Internal representation allows for a maximum index of E.MAX_VALUE - 1\n+    \/\/ Internal representation allows for a maximum index of 256\n@@ -37,2 +36,40 @@\n-    AbstractShuffle(Object indices) {\n-        super(indices);\n+    AbstractShuffle(int length, byte[] reorder) {\n+        super(reorder);\n+        assert(length == reorder.length);\n+        assert(indexesInRange(reorder));\n+    }\n+\n+    AbstractShuffle(int length, int[] reorder) {\n+        this(length, reorder, 0);\n+    }\n+\n+    AbstractShuffle(int length, int[] reorder, int offset) {\n+        super(prepare(length, reorder, offset));\n+    }\n+\n+    AbstractShuffle(int length, IntUnaryOperator f) {\n+        super(prepare(length, f));\n+    }\n+\n+    private static byte[] prepare(int length, int[] reorder, int offset) {\n+        byte[] a = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            int si = reorder[offset + i];\n+            si = partiallyWrapIndex(si, length);\n+            a[i] = (byte) si;\n+        }\n+        return a;\n+    }\n+\n+    private static byte[] prepare(int length, IntUnaryOperator f) {\n+        byte[] a = new byte[length];\n+        for (int i = 0; i < a.length; i++) {\n+            int si = f.applyAsInt(i);\n+            si = partiallyWrapIndex(si, length);\n+            a[i] = (byte) si;\n+        }\n+        return a;\n+    }\n+\n+    byte[] reorder() {\n+        return (byte[])getPayload();\n@@ -50,16 +87,0 @@\n-    \/*package-private*\/\n-    abstract AbstractVector<?> toBitsVector();\n-\n-    final AbstractVector<?> toBitsVectorTemplate() {\n-        AbstractSpecies<?> dsp = vspecies().asIntegral();\n-        Class<?> etype = dsp.elementType();\n-        Class<?> rvtype = dsp.dummyVector().getClass();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n-                                     getClass(), etype, length(),\n-                                     rvtype, etype, length(),\n-                                     this, dsp,\n-                                     (v, s) -> v.toBitsVector0());\n-    }\n-\n-    abstract AbstractVector<?> toBitsVector0();\n-\n@@ -68,2 +89,8 @@\n-    public final Vector<E> toVector() {\n-        return toBitsVector().castShape(vspecies(), 0);\n+    public void intoArray(int[] a, int offset) {\n+        byte[] reorder = reorder();\n+        int vlen = reorder.length;\n+        for (int i = 0; i < vlen; i++) {\n+            int sourceIndex = reorder[i];\n+            assert(sourceIndex >= -vlen && sourceIndex < vlen);\n+            a[offset + i] = sourceIndex;\n+        }\n@@ -74,4 +101,5 @@\n-    public final int[] toArray() {\n-        int[] res = new int[length()];\n-        intoArray(res, 0);\n-        return res;\n+    public int[] toArray() {\n+        byte[] reorder = reorder();\n+        int[] a = new int[reorder.length];\n+        intoArray(a, 0);\n+        return a;\n@@ -80,1 +108,1 @@\n-    @Override\n+    \/*package-private*\/\n@@ -82,5 +110,9 @@\n-    public final <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-        if (length() != s.length()) {\n-            throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-        }\n-        return toBitsVector().toShuffle((AbstractSpecies<F>) s);\n+    final\n+    AbstractVector<E>\n+    toVectorTemplate() {\n+        \/\/ Note that the values produced by laneSource\n+        \/\/ are already clipped.  At this point we convert\n+        \/\/ them from internal ints (or bytes) into the ETYPE.\n+        \/\/ FIXME: Use a conversion intrinsic for this operation.\n+        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8225740\n+        return (AbstractVector<E>) vspecies().fromIntValues(toArray());\n@@ -89,1 +121,0 @@\n-    @Override\n@@ -95,2 +126,2 @@\n-        Vector<?> shufvec = this.toBitsVector();\n-        VectorMask<?> vecmask = shufvec.compare(VectorOperators.LT, 0);\n+        Vector<E> shufvec = this.toVector();\n+        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n@@ -98,2 +129,2 @@\n-            int[] indices = toArray();\n-            throw checkIndexFailed(indices[vecmask.firstTrue()], length());\n+            byte[] reorder = reorder();\n+            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n@@ -104,1 +135,0 @@\n-    @Override\n@@ -106,4 +136,9 @@\n-    public final VectorMask<E> laneIsValid() {\n-        Vector<?> shufvec = this.toBitsVector();\n-        return shufvec.compare(VectorOperators.GE, 0)\n-                      .cast(vspecies());\n+    public final VectorShuffle<E> wrapIndexes() {\n+        Vector<E> shufvec = this.toVector();\n+        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n+        if (vecmask.anyTrue()) {\n+            \/\/ FIXME: vectorize this\n+            byte[] reorder = reorder();\n+            return wrapAndRebuild(reorder);\n+        }\n+        return this;\n@@ -113,7 +148,16 @@\n-    @Override\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public final VectorShuffle<E> rearrange(VectorShuffle<E> shuffle) {\n-        Vector v = toBitsVector();\n-        return (VectorShuffle<E>) v.rearrange(shuffle.cast(vspecies().asIntegral()))\n-                                   .toShuffle()\n-                                   .cast(vspecies());\n+    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n+        int length = oldReorder.length;\n+        byte[] reorder = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            int si = oldReorder[i];\n+            \/\/ FIXME: This does not work unless it's a power of 2.\n+            if ((length & (length - 1)) == 0) {\n+                si += si & length;  \/\/ power-of-two optimization\n+            } else if (si < 0) {\n+                \/\/ non-POT code requires a conditional add\n+                si += length;\n+            }\n+            assert(si >= 0 && si < length);\n+            reorder[i] = (byte) si;\n+        }\n+        return vspecies().dummyVector().shuffleFromBytes(reorder);\n@@ -123,11 +167,3 @@\n-    @Override\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public final VectorShuffle<E> wrapIndexes() {\n-        Vector v = toBitsVector();\n-        if ((length() & (length() - 1)) == 0) {\n-            v = v.lanewise(VectorOperators.AND, length() - 1);\n-        } else {\n-            v = v.blend(v.lanewise(VectorOperators.ADD, length()),\n-                        v.compare(VectorOperators.LT, 0));\n-        }\n-        return (VectorShuffle<E>) v.toShuffle().cast(vspecies());\n+    public final VectorMask<E> laneIsValid() {\n+        Vector<E> shufvec = this.toVector();\n+        return shufvec.compare(VectorOperators.GE, vspecies().zero());\n@@ -187,0 +223,17 @@\n+\n+    static boolean indexesInRange(byte[] reorder) {\n+        int length = reorder.length;\n+        for (byte si : reorder) {\n+            if (si >= length || si < -length) {\n+                boolean assertsEnabled = false;\n+                assert(assertsEnabled = true);\n+                if (assertsEnabled) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(reorder));\n+                    throw new AssertionError(msg);\n+                }\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":114,"deletions":61,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,0 @@\n-    final Class<? extends AbstractShuffle<E>> shuffleType;\n-    @Stable\n@@ -66,1 +64,0 @@\n-                    Class<? extends AbstractShuffle<E>> shuffleType,\n@@ -72,1 +69,0 @@\n-        this.shuffleType = shuffleType;\n@@ -169,5 +165,0 @@\n-    @ForceInline\n-    final Class<? extends AbstractShuffle<E>> shuffleType() {\n-        return shuffleType;\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,1 +191,1 @@\n-    abstract <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp);\n+    abstract AbstractShuffle<E> iotaShuffle();\n@@ -193,23 +193,1 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final <F> VectorShuffle<F> toShuffleTemplate(AbstractSpecies<F> dsp) {\n-        Class<?> etype = vspecies().elementType();\n-        Class<?> dvtype = dsp.shuffleType();\n-        Class<?> dtype = dsp.asIntegral().elementType();\n-        int dlength = dsp.dummyVector().length();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), etype, length(),\n-                                     dvtype, dtype, dlength,\n-                                     this, dsp,\n-                                     AbstractVector::toShuffle0);\n-    }\n-\n-    abstract <F> VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp);\n-\n-    @ForceInline\n-    public final\n-    VectorShuffle<E> toShuffle() {\n-        return toShuffle(vspecies());\n-    }\n-\n-    abstract VectorShuffle<E> iotaShuffle();\n+    abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n@@ -217,25 +195,2 @@\n-    @ForceInline\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    final VectorShuffle<E> iotaShuffle(int start, int step, boolean wrap) {\n-        if (start == 0 && step == 1) {\n-            return iotaShuffle();\n-        }\n-\n-        if ((length() & (length() - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, length())))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        AbstractSpecies<?> species = vspecies().asIntegral();\n-        Vector iota = species.iota();\n-        iota = iota.lanewise(VectorOperators.MUL, step)\n-                   .lanewise(VectorOperators.ADD, start);\n-        Vector wrapped = iota.lanewise(VectorOperators.AND, length() - 1);\n-\n-        if (!wrap) {\n-            Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n-            VectorMask<?> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return ((AbstractVector) wrapped).toShuffle(vspecies());\n-    }\n+    \/*do not alias this byte array*\/\n+    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":5,"deletions":50,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Byte128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Byte128Shuffle shuffleFromArray(int[] indices, int i) { return new Byte128Shuffle(indices, i); }\n+    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Byte128Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte128Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n@@ -794,4 +807,2 @@\n-        Byte128Shuffle(byte[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Byte128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -800,2 +811,2 @@\n-        Byte128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -804,2 +815,2 @@\n-        Byte128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -808,2 +819,2 @@\n-        byte[] indices() {\n-            return (byte[])getPayload();\n+        public Byte128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -813,1 +824,0 @@\n-        @ForceInline\n@@ -828,2 +838,3 @@\n-        Byte128Vector toBitsVector() {\n-            return (Byte128Vector) super.toBitsVectorTemplate();\n+        public Byte128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte128Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -834,2 +845,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -838,1 +853,0 @@\n-        @Override\n@@ -840,4 +854,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -845,51 +855,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static byte[] prepare(int[] indices, int offset) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static byte[] prepare(IntUnaryOperator f) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(byte[] indices) {\n-            int length = indices.length;\n-            for (byte si : indices) {\n-                if (si >= (byte)length || si < (byte)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte128Shuffle s = (Byte128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -897,1 +864,1 @@\n-            return true;\n+            return new Byte128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Byte256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Byte256Shuffle shuffleFromArray(int[] indices, int i) { return new Byte256Shuffle(indices, i); }\n+    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Byte256Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte256Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n@@ -826,4 +839,2 @@\n-        Byte256Shuffle(byte[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Byte256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -832,2 +843,2 @@\n-        Byte256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -836,2 +847,2 @@\n-        Byte256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -840,2 +851,2 @@\n-        byte[] indices() {\n-            return (byte[])getPayload();\n+        public Byte256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -845,1 +856,0 @@\n-        @ForceInline\n@@ -860,2 +870,3 @@\n-        Byte256Vector toBitsVector() {\n-            return (Byte256Vector) super.toBitsVectorTemplate();\n+        public Byte256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte256Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -866,2 +877,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -870,1 +885,0 @@\n-        @Override\n@@ -872,4 +886,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -877,51 +887,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static byte[] prepare(int[] indices, int offset) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static byte[] prepare(IntUnaryOperator f) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(byte[] indices) {\n-            int length = indices.length;\n-            for (byte si : indices) {\n-                if (si >= (byte)length || si < (byte)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte256Shuffle s = (Byte256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -929,1 +896,1 @@\n-            return true;\n+            return new Byte256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Byte512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Byte512Shuffle shuffleFromArray(int[] indices, int i) { return new Byte512Shuffle(indices, i); }\n+    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Byte512Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte512Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n@@ -890,4 +903,2 @@\n-        Byte512Shuffle(byte[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Byte512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -896,2 +907,2 @@\n-        Byte512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -900,2 +911,2 @@\n-        Byte512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -904,2 +915,2 @@\n-        byte[] indices() {\n-            return (byte[])getPayload();\n+        public Byte512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -909,1 +920,0 @@\n-        @ForceInline\n@@ -924,2 +934,3 @@\n-        Byte512Vector toBitsVector() {\n-            return (Byte512Vector) super.toBitsVectorTemplate();\n+        public Byte512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte512Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -930,2 +941,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -934,1 +949,0 @@\n-        @Override\n@@ -936,4 +950,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -941,51 +951,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static byte[] prepare(int[] indices, int offset) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static byte[] prepare(IntUnaryOperator f) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(byte[] indices) {\n-            int length = indices.length;\n-            for (byte si : indices) {\n-                if (si >= (byte)length || si < (byte)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte512Shuffle s = (Byte512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -993,1 +960,1 @@\n-            return true;\n+            return new Byte512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Byte64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Byte64Shuffle shuffleFromArray(int[] indices, int i) { return new Byte64Shuffle(indices, i); }\n+    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Byte64Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte64Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n@@ -778,4 +791,2 @@\n-        Byte64Shuffle(byte[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Byte64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -784,2 +795,2 @@\n-        Byte64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Byte64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -788,2 +799,2 @@\n-        Byte64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Byte64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -792,2 +803,2 @@\n-        byte[] indices() {\n-            return (byte[])getPayload();\n+        public Byte64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -797,1 +808,0 @@\n-        @ForceInline\n@@ -812,2 +822,3 @@\n-        Byte64Vector toBitsVector() {\n-            return (Byte64Vector) super.toBitsVectorTemplate();\n+        public Byte64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Byte64Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -818,2 +829,6 @@\n-        ByteVector toBitsVector0() {\n-            return Byte64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -822,1 +837,0 @@\n-        @Override\n@@ -824,4 +838,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -829,51 +839,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static byte[] prepare(int[] indices, int offset) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static byte[] prepare(IntUnaryOperator f) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(byte[] indices) {\n-            int length = indices.length;\n-            for (byte si : indices) {\n-                if (si >= (byte)length || si < (byte)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte64Shuffle s = (Byte64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -881,1 +848,1 @@\n-            return true;\n+            return new Byte64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    ByteMaxShuffle shuffleFromArray(int[] indices, int i) { return new ByteMaxShuffle(indices, i); }\n+    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n@@ -764,4 +777,2 @@\n-        ByteMaxShuffle(byte[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        ByteMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -770,2 +781,2 @@\n-        ByteMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public ByteMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -774,2 +785,2 @@\n-        ByteMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public ByteMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -778,2 +789,2 @@\n-        byte[] indices() {\n-            return (byte[])getPayload();\n+        public ByteMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -783,1 +794,0 @@\n-        @ForceInline\n@@ -798,2 +808,3 @@\n-        ByteMaxVector toBitsVector() {\n-            return (ByteMaxVector) super.toBitsVectorTemplate();\n+        public ByteMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n@@ -804,2 +815,6 @@\n-        ByteVector toBitsVector0() {\n-            return ByteMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -808,1 +823,0 @@\n-        @Override\n@@ -810,4 +824,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -815,51 +825,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-        }\n-\n-        private static byte[] prepare(int[] indices, int offset) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static byte[] prepare(IntUnaryOperator f) {\n-            byte[] a = new byte[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (byte)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(byte[] indices) {\n-            int length = indices.length;\n-            for (byte si : indices) {\n-                if (si >= (byte)length || si < (byte)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -867,1 +834,1 @@\n-            return true;\n+            return new ByteMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1074,1 +1074,1 @@\n-    \/**\n+   \/**\n@@ -2483,2 +2483,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n@@ -2493,0 +2493,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), byte.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ByteVector::toShuffle0);\n+    }\n+\n@@ -4087,1 +4099,0 @@\n-                Class<? extends AbstractShuffle<Byte>> shuffleType,\n@@ -4090,1 +4101,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4366,1 +4377,0 @@\n-                            Byte64Vector.Byte64Shuffle.class,\n@@ -4374,1 +4384,0 @@\n-                            Byte128Vector.Byte128Shuffle.class,\n@@ -4382,1 +4391,0 @@\n-                            Byte256Vector.Byte256Shuffle.class,\n@@ -4390,1 +4398,0 @@\n-                            Byte512Vector.Byte512Shuffle.class,\n@@ -4398,1 +4405,0 @@\n-                            ByteMaxVector.ByteMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Double128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Double128Shuffle shuffleFromArray(int[] indices, int i) { return new Double128Shuffle(indices, i); }\n+    Double128Shuffle shuffleFromArray(int[] indexes, int i) { return new Double128Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n@@ -753,1 +766,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -755,4 +768,2 @@\n-        Double128Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Double128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -761,2 +772,2 @@\n-        Double128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -765,2 +776,2 @@\n-        Double128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -769,2 +780,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Double128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -774,1 +785,0 @@\n-        @ForceInline\n@@ -782,2 +792,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -789,2 +799,3 @@\n-        Long128Vector toBitsVector() {\n-            return (Long128Vector) super.toBitsVectorTemplate();\n+        public Double128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double128Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -795,2 +806,6 @@\n-        LongVector toBitsVector0() {\n-            return Long128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -799,1 +814,0 @@\n-        @Override\n@@ -801,4 +815,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -806,62 +816,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double128Shuffle s = (Double128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -869,1 +825,1 @@\n-            return true;\n+            return new Double128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Double256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Double256Shuffle shuffleFromArray(int[] indices, int i) { return new Double256Shuffle(indices, i); }\n+    Double256Shuffle shuffleFromArray(int[] indexes, int i) { return new Double256Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n@@ -757,1 +770,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -759,4 +772,2 @@\n-        Double256Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Double256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -765,2 +776,2 @@\n-        Double256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -769,2 +780,2 @@\n-        Double256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -773,2 +784,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Double256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -778,1 +789,0 @@\n-        @ForceInline\n@@ -786,2 +796,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -793,2 +803,3 @@\n-        Long256Vector toBitsVector() {\n-            return (Long256Vector) super.toBitsVectorTemplate();\n+        public Double256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double256Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -799,2 +810,6 @@\n-        LongVector toBitsVector0() {\n-            return Long256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -803,1 +818,0 @@\n-        @Override\n@@ -805,4 +819,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -810,62 +820,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double256Shuffle s = (Double256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -873,1 +829,1 @@\n-            return true;\n+            return new Double256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Double512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Double512Shuffle shuffleFromArray(int[] indices, int i) { return new Double512Shuffle(indices, i); }\n+    Double512Shuffle shuffleFromArray(int[] indexes, int i) { return new Double512Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n@@ -765,1 +778,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -767,4 +780,2 @@\n-        Double512Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Double512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -773,2 +784,2 @@\n-        Double512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -777,2 +788,2 @@\n-        Double512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -781,2 +792,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Double512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -786,1 +797,0 @@\n-        @ForceInline\n@@ -794,2 +804,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -801,2 +811,3 @@\n-        Long512Vector toBitsVector() {\n-            return (Long512Vector) super.toBitsVectorTemplate();\n+        public Double512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double512Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -807,2 +818,6 @@\n-        LongVector toBitsVector0() {\n-            return Long512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -811,1 +826,0 @@\n-        @Override\n@@ -813,4 +827,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -818,62 +828,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double512Shuffle s = (Double512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -881,1 +837,1 @@\n-            return true;\n+            return new Double512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Double64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Double64Shuffle shuffleFromArray(int[] indices, int i) { return new Double64Shuffle(indices, i); }\n+    Double64Shuffle shuffleFromArray(int[] indexes, int i) { return new Double64Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n@@ -751,1 +764,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -753,4 +766,2 @@\n-        Double64Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Double64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -759,2 +770,2 @@\n-        Double64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Double64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -763,2 +774,2 @@\n-        Double64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Double64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -767,2 +778,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Double64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -772,1 +783,0 @@\n-        @ForceInline\n@@ -780,2 +790,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -787,2 +797,3 @@\n-        Long64Vector toBitsVector() {\n-            return (Long64Vector) super.toBitsVectorTemplate();\n+        public Double64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Double64Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -793,2 +804,6 @@\n-        LongVector toBitsVector0() {\n-            return Long64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -797,1 +812,0 @@\n-        @Override\n@@ -799,4 +813,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -804,62 +814,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double64Shuffle s = (Double64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -867,1 +823,1 @@\n-            return true;\n+            return new Double64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    DoubleMaxShuffle shuffleFromArray(int[] indices, int i) { return new DoubleMaxShuffle(indices, i); }\n+    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n@@ -750,1 +763,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n@@ -752,4 +765,2 @@\n-        DoubleMaxShuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        DoubleMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -758,2 +769,2 @@\n-        DoubleMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public DoubleMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -762,2 +773,2 @@\n-        DoubleMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public DoubleMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -766,2 +777,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public DoubleMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -771,1 +782,0 @@\n-        @ForceInline\n@@ -779,2 +789,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -786,2 +796,3 @@\n-        LongMaxVector toBitsVector() {\n-            return (LongMaxVector) super.toBitsVectorTemplate();\n+        public DoubleMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n@@ -792,2 +803,6 @@\n-        LongVector toBitsVector0() {\n-            return LongMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -796,1 +811,0 @@\n-        @Override\n@@ -798,4 +812,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -803,62 +813,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n+            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -866,1 +822,1 @@\n-            return true;\n+            return new DoubleMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -956,1 +956,1 @@\n-    \/**\n+   \/**\n@@ -2325,2 +2325,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n@@ -2335,0 +2335,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), double.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     DoubleVector::toShuffle0);\n+    }\n+\n@@ -3690,1 +3702,0 @@\n-                Class<? extends AbstractShuffle<Double>> shuffleType,\n@@ -3693,1 +3704,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -3969,1 +3980,0 @@\n-                            Double64Vector.Double64Shuffle.class,\n@@ -3977,1 +3987,0 @@\n-                            Double128Vector.Double128Shuffle.class,\n@@ -3985,1 +3994,0 @@\n-                            Double256Vector.Double256Shuffle.class,\n@@ -3993,1 +4001,0 @@\n-                            Double512Vector.Double512Shuffle.class,\n@@ -4001,1 +4008,0 @@\n-                            DoubleMaxVector.DoubleMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Float128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Float128Shuffle shuffleFromArray(int[] indices, int i) { return new Float128Shuffle(indices, i); }\n+    Float128Shuffle shuffleFromArray(int[] indexes, int i) { return new Float128Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n@@ -757,1 +770,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -759,4 +772,2 @@\n-        Float128Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Float128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -765,2 +776,2 @@\n-        Float128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -769,2 +780,2 @@\n-        Float128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -773,2 +784,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Float128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -778,1 +789,0 @@\n-        @ForceInline\n@@ -786,2 +796,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -793,2 +803,3 @@\n-        Int128Vector toBitsVector() {\n-            return (Int128Vector) super.toBitsVectorTemplate();\n+        public Float128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float128Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -799,2 +810,6 @@\n-        IntVector toBitsVector0() {\n-            return Int128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -803,1 +818,0 @@\n-        @Override\n@@ -805,4 +819,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -810,38 +820,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float128Shuffle s = (Float128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -849,1 +829,1 @@\n-            return true;\n+            return new Float128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":47,"deletions":67,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Float256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Float256Shuffle shuffleFromArray(int[] indices, int i) { return new Float256Shuffle(indices, i); }\n+    Float256Shuffle shuffleFromArray(int[] indexes, int i) { return new Float256Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n@@ -765,1 +778,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -767,4 +780,2 @@\n-        Float256Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Float256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -773,2 +784,2 @@\n-        Float256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -777,2 +788,2 @@\n-        Float256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -781,2 +792,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Float256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -786,1 +797,0 @@\n-        @ForceInline\n@@ -794,2 +804,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -801,2 +811,3 @@\n-        Int256Vector toBitsVector() {\n-            return (Int256Vector) super.toBitsVectorTemplate();\n+        public Float256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float256Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -807,2 +818,6 @@\n-        IntVector toBitsVector0() {\n-            return Int256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -811,1 +826,0 @@\n-        @Override\n@@ -813,4 +827,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -818,38 +828,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float256Shuffle s = (Float256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -857,1 +837,1 @@\n-            return true;\n+            return new Float256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":47,"deletions":67,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Float512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Float512Shuffle shuffleFromArray(int[] indices, int i) { return new Float512Shuffle(indices, i); }\n+    Float512Shuffle shuffleFromArray(int[] indexes, int i) { return new Float512Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n@@ -781,1 +794,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -783,4 +796,2 @@\n-        Float512Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Float512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -789,2 +800,2 @@\n-        Float512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -793,2 +804,2 @@\n-        Float512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -797,2 +808,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Float512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -802,1 +813,0 @@\n-        @ForceInline\n@@ -810,2 +820,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -817,2 +827,3 @@\n-        Int512Vector toBitsVector() {\n-            return (Int512Vector) super.toBitsVectorTemplate();\n+        public Float512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float512Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -823,2 +834,6 @@\n-        IntVector toBitsVector0() {\n-            return Int512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -827,1 +842,0 @@\n-        @Override\n@@ -829,4 +843,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -834,38 +844,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float512Shuffle s = (Float512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -873,1 +853,1 @@\n-            return true;\n+            return new Float512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":47,"deletions":67,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Float64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Float64Shuffle shuffleFromArray(int[] indices, int i) { return new Float64Shuffle(indices, i); }\n+    Float64Shuffle shuffleFromArray(int[] indexes, int i) { return new Float64Shuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n@@ -753,1 +766,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -755,4 +768,2 @@\n-        Float64Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Float64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -761,2 +772,2 @@\n-        Float64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Float64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -765,2 +776,2 @@\n-        Float64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Float64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -769,2 +780,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Float64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -774,1 +785,0 @@\n-        @ForceInline\n@@ -782,2 +792,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -789,2 +799,3 @@\n-        Int64Vector toBitsVector() {\n-            return (Int64Vector) super.toBitsVectorTemplate();\n+        public Float64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Float64Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -795,2 +806,6 @@\n-        IntVector toBitsVector0() {\n-            return Int64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -799,1 +814,0 @@\n-        @Override\n@@ -801,4 +815,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -806,38 +816,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float64Shuffle s = (Float64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -845,1 +825,1 @@\n-            return true;\n+            return new Float64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":47,"deletions":67,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    FloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new FloatMaxShuffle(indices, i); }\n+    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n@@ -332,1 +347,0 @@\n-    @Override\n@@ -334,3 +348,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n@@ -750,1 +763,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n@@ -752,4 +765,2 @@\n-        FloatMaxShuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        FloatMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -758,2 +769,2 @@\n-        FloatMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public FloatMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -762,2 +773,2 @@\n-        FloatMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public FloatMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -766,2 +777,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public FloatMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -771,1 +782,0 @@\n-        @ForceInline\n@@ -779,2 +789,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -786,2 +796,3 @@\n-        IntMaxVector toBitsVector() {\n-            return (IntMaxVector) super.toBitsVectorTemplate();\n+        public FloatMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n@@ -792,2 +803,6 @@\n-        IntVector toBitsVector0() {\n-            return IntMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -796,1 +811,0 @@\n-        @Override\n@@ -798,4 +812,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -803,38 +813,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n+            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -842,1 +822,1 @@\n-            return true;\n+            return new FloatMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":47,"deletions":67,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -956,1 +956,1 @@\n-    \/**\n+   \/**\n@@ -2337,2 +2337,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n@@ -2347,0 +2347,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), float.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     FloatVector::toShuffle0);\n+    }\n+\n@@ -3640,1 +3652,0 @@\n-                Class<? extends AbstractShuffle<Float>> shuffleType,\n@@ -3643,1 +3654,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -3919,1 +3930,0 @@\n-                            Float64Vector.Float64Shuffle.class,\n@@ -3927,1 +3937,0 @@\n-                            Float128Vector.Float128Shuffle.class,\n@@ -3935,1 +3944,0 @@\n-                            Float256Vector.Float256Shuffle.class,\n@@ -3943,1 +3951,0 @@\n-                            Float512Vector.Float512Shuffle.class,\n@@ -3951,1 +3958,0 @@\n-                            FloatMaxVector.FloatMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Int128Shuffle shuffleFromArray(int[] indices, int i) { return new Int128Shuffle(indices, i); }\n+    Int128Shuffle shuffleFromArray(int[] indexes, int i) { return new Int128Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n@@ -770,4 +783,2 @@\n-        Int128Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Int128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -776,2 +787,2 @@\n-        Int128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -780,2 +791,2 @@\n-        Int128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -784,2 +795,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Int128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -789,1 +800,0 @@\n-        @ForceInline\n@@ -797,2 +807,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -804,2 +814,3 @@\n-        Int128Vector toBitsVector() {\n-            return (Int128Vector) super.toBitsVectorTemplate();\n+        public Int128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int128Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -810,2 +821,6 @@\n-        IntVector toBitsVector0() {\n-            return Int128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -814,1 +829,0 @@\n-        @Override\n@@ -816,4 +830,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -821,38 +831,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int128Shuffle s = (Int128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -860,1 +840,1 @@\n-            return true;\n+            return new Int128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Int256Shuffle shuffleFromArray(int[] indices, int i) { return new Int256Shuffle(indices, i); }\n+    Int256Shuffle shuffleFromArray(int[] indexes, int i) { return new Int256Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n@@ -778,4 +791,2 @@\n-        Int256Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Int256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -784,2 +795,2 @@\n-        Int256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -788,2 +799,2 @@\n-        Int256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -792,2 +803,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Int256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -797,1 +808,0 @@\n-        @ForceInline\n@@ -805,2 +815,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -812,2 +822,3 @@\n-        Int256Vector toBitsVector() {\n-            return (Int256Vector) super.toBitsVectorTemplate();\n+        public Int256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int256Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -818,2 +829,6 @@\n-        IntVector toBitsVector0() {\n-            return Int256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -822,1 +837,0 @@\n-        @Override\n@@ -824,4 +838,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -829,38 +839,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int256Shuffle s = (Int256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -868,1 +848,1 @@\n-            return true;\n+            return new Int256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Int512Shuffle shuffleFromArray(int[] indices, int i) { return new Int512Shuffle(indices, i); }\n+    Int512Shuffle shuffleFromArray(int[] indexes, int i) { return new Int512Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n@@ -794,4 +807,2 @@\n-        Int512Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Int512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -800,2 +811,2 @@\n-        Int512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -804,2 +815,2 @@\n-        Int512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -808,2 +819,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Int512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -813,1 +824,0 @@\n-        @ForceInline\n@@ -821,2 +831,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -828,2 +838,3 @@\n-        Int512Vector toBitsVector() {\n-            return (Int512Vector) super.toBitsVectorTemplate();\n+        public Int512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int512Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -834,2 +845,6 @@\n-        IntVector toBitsVector0() {\n-            return Int512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -838,1 +853,0 @@\n-        @Override\n@@ -840,4 +854,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -845,38 +855,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int512Shuffle s = (Int512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -884,1 +864,1 @@\n-            return true;\n+            return new Int512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    Int64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    Int64Shuffle shuffleFromArray(int[] indices, int i) { return new Int64Shuffle(indices, i); }\n+    Int64Shuffle shuffleFromArray(int[] indexes, int i) { return new Int64Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n@@ -766,4 +779,2 @@\n-        Int64Shuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Int64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -772,2 +783,2 @@\n-        Int64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Int64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -776,2 +787,2 @@\n-        Int64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Int64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -780,2 +791,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public Int64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -785,1 +796,0 @@\n-        @ForceInline\n@@ -793,2 +803,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -800,2 +810,3 @@\n-        Int64Vector toBitsVector() {\n-            return (Int64Vector) super.toBitsVectorTemplate();\n+        public Int64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Int64Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -806,2 +817,6 @@\n-        IntVector toBitsVector0() {\n-            return Int64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -810,1 +825,0 @@\n-        @Override\n@@ -812,4 +826,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -817,38 +827,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int64Shuffle s = (Int64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -856,1 +836,1 @@\n-            return true;\n+            return new Int64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -144,0 +144,15 @@\n+    @ForceInline\n+    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n+\n@@ -146,1 +161,1 @@\n-    IntMaxShuffle shuffleFromArray(int[] indices, int i) { return new IntMaxShuffle(indices, i); }\n+    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n@@ -775,4 +788,2 @@\n-        IntMaxShuffle(int[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        IntMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -781,2 +792,2 @@\n-        IntMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public IntMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -785,2 +796,2 @@\n-        IntMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public IntMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -789,2 +800,2 @@\n-        int[] indices() {\n-            return (int[])getPayload();\n+        public IntMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -794,1 +805,0 @@\n-        @ForceInline\n@@ -802,2 +812,2 @@\n-            assert(VLENGTH < Integer.MAX_VALUE);\n-            assert(Integer.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -809,2 +819,3 @@\n-        IntMaxVector toBitsVector() {\n-            return (IntMaxVector) super.toBitsVectorTemplate();\n+        public IntMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n@@ -815,2 +826,6 @@\n-        IntVector toBitsVector0() {\n-            return IntMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -819,1 +834,0 @@\n-        @Override\n@@ -821,4 +835,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -826,38 +836,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            toBitsVector().intoArray(a, offset);\n-        }\n-\n-        private static int[] prepare(int[] indices, int offset) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static int[] prepare(IntUnaryOperator f) {\n-            int[] a = new int[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (int)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(int[] indices) {\n-            int length = indices.length;\n-            for (int si : indices) {\n-                if (si >= (int)length || si < (int)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -865,1 +845,1 @@\n-            return true;\n+            return new IntMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":46,"deletions":66,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1077,1 +1077,1 @@\n-    \/**\n+   \/**\n@@ -2468,2 +2468,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n@@ -2478,0 +2478,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), int.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     IntVector::toShuffle0);\n+    }\n+\n@@ -3796,1 +3808,0 @@\n-                Class<? extends AbstractShuffle<Integer>> shuffleType,\n@@ -3799,1 +3810,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4075,1 +4086,0 @@\n-                            Int64Vector.Int64Shuffle.class,\n@@ -4083,1 +4093,0 @@\n-                            Int128Vector.Int128Shuffle.class,\n@@ -4091,1 +4100,0 @@\n-                            Int256Vector.Int256Shuffle.class,\n@@ -4099,1 +4107,0 @@\n-                            Int512Vector.Int512Shuffle.class,\n@@ -4107,1 +4114,0 @@\n-                            IntMaxVector.IntMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -139,0 +139,15 @@\n+    @ForceInline\n+    Long128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n+\n@@ -141,1 +156,1 @@\n-    Long128Shuffle shuffleFromArray(int[] indices, int i) { return new Long128Shuffle(indices, i); }\n+    Long128Shuffle shuffleFromArray(int[] indexes, int i) { return new Long128Shuffle(indexes, i); }\n@@ -340,1 +355,0 @@\n-    @Override\n@@ -342,3 +356,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n@@ -756,4 +769,2 @@\n-        Long128Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Long128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -762,2 +773,2 @@\n-        Long128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -766,2 +777,2 @@\n-        Long128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -770,2 +781,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Long128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -775,1 +786,0 @@\n-        @ForceInline\n@@ -783,2 +793,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -790,2 +800,3 @@\n-        Long128Vector toBitsVector() {\n-            return (Long128Vector) super.toBitsVectorTemplate();\n+        public Long128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long128Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -796,2 +807,6 @@\n-        LongVector toBitsVector0() {\n-            return Long128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -800,1 +815,0 @@\n-        @Override\n@@ -802,4 +816,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -807,62 +817,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long128Shuffle s = (Long128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -870,1 +826,1 @@\n-            return true;\n+            return new Long128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -139,0 +139,15 @@\n+    @ForceInline\n+    Long256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n+\n@@ -141,1 +156,1 @@\n-    Long256Shuffle shuffleFromArray(int[] indices, int i) { return new Long256Shuffle(indices, i); }\n+    Long256Shuffle shuffleFromArray(int[] indexes, int i) { return new Long256Shuffle(indexes, i); }\n@@ -340,1 +355,0 @@\n-    @Override\n@@ -342,3 +356,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n@@ -760,4 +773,2 @@\n-        Long256Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Long256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -766,2 +777,2 @@\n-        Long256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -770,2 +781,2 @@\n-        Long256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -774,2 +785,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Long256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -779,1 +790,0 @@\n-        @ForceInline\n@@ -787,2 +797,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -794,2 +804,3 @@\n-        Long256Vector toBitsVector() {\n-            return (Long256Vector) super.toBitsVectorTemplate();\n+        public Long256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long256Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -800,2 +811,6 @@\n-        LongVector toBitsVector0() {\n-            return Long256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -804,1 +819,0 @@\n-        @Override\n@@ -806,4 +820,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -811,62 +821,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long256Shuffle s = (Long256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -874,1 +830,1 @@\n-            return true;\n+            return new Long256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -139,0 +139,15 @@\n+    @ForceInline\n+    Long512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n+\n@@ -141,1 +156,1 @@\n-    Long512Shuffle shuffleFromArray(int[] indices, int i) { return new Long512Shuffle(indices, i); }\n+    Long512Shuffle shuffleFromArray(int[] indexes, int i) { return new Long512Shuffle(indexes, i); }\n@@ -340,1 +355,0 @@\n-    @Override\n@@ -342,3 +356,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n@@ -768,4 +781,2 @@\n-        Long512Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Long512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -774,2 +785,2 @@\n-        Long512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -778,2 +789,2 @@\n-        Long512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -782,2 +793,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Long512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -787,1 +798,0 @@\n-        @ForceInline\n@@ -795,2 +805,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -802,2 +812,3 @@\n-        Long512Vector toBitsVector() {\n-            return (Long512Vector) super.toBitsVectorTemplate();\n+        public Long512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long512Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -808,2 +819,6 @@\n-        LongVector toBitsVector0() {\n-            return Long512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -812,1 +827,0 @@\n-        @Override\n@@ -814,4 +828,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -819,62 +829,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long512Shuffle s = (Long512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -882,1 +838,1 @@\n-            return true;\n+            return new Long512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -139,0 +139,15 @@\n+    @ForceInline\n+    Long64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n+\n@@ -141,1 +156,1 @@\n-    Long64Shuffle shuffleFromArray(int[] indices, int i) { return new Long64Shuffle(indices, i); }\n+    Long64Shuffle shuffleFromArray(int[] indexes, int i) { return new Long64Shuffle(indexes, i); }\n@@ -340,1 +355,0 @@\n-    @Override\n@@ -342,3 +356,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n@@ -754,4 +767,2 @@\n-        Long64Shuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Long64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -760,2 +771,2 @@\n-        Long64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Long64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -764,2 +775,2 @@\n-        Long64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Long64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -768,2 +779,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public Long64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -773,1 +784,0 @@\n-        @ForceInline\n@@ -781,2 +791,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -788,2 +798,3 @@\n-        Long64Vector toBitsVector() {\n-            return (Long64Vector) super.toBitsVectorTemplate();\n+        public Long64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Long64Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -794,2 +805,6 @@\n-        LongVector toBitsVector0() {\n-            return Long64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -798,1 +813,0 @@\n-        @Override\n@@ -800,4 +814,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -805,62 +815,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long64Shuffle s = (Long64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -868,1 +824,1 @@\n-            return true;\n+            return new Long64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -139,0 +139,15 @@\n+    @ForceInline\n+    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n+\n@@ -141,1 +156,1 @@\n-    LongMaxShuffle shuffleFromArray(int[] indices, int i) { return new LongMaxShuffle(indices, i); }\n+    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n@@ -340,1 +355,0 @@\n-    @Override\n@@ -342,3 +356,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n@@ -754,4 +767,2 @@\n-        LongMaxShuffle(long[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        LongMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -760,2 +771,2 @@\n-        LongMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public LongMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -764,2 +775,2 @@\n-        LongMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public LongMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -768,2 +779,2 @@\n-        long[] indices() {\n-            return (long[])getPayload();\n+        public LongMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -773,1 +784,0 @@\n-        @ForceInline\n@@ -781,2 +791,2 @@\n-            assert(VLENGTH < Long.MAX_VALUE);\n-            assert(Long.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -788,2 +798,3 @@\n-        LongMaxVector toBitsVector() {\n-            return (LongMaxVector) super.toBitsVectorTemplate();\n+        public LongMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n@@ -794,2 +805,6 @@\n-        LongVector toBitsVector0() {\n-            return LongMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -798,1 +813,0 @@\n-        @Override\n@@ -800,4 +814,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -805,62 +815,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private static long[] prepare(int[] indices, int offset) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static long[] prepare(IntUnaryOperator f) {\n-            long[] a = new long[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (long)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(long[] indices) {\n-            int length = indices.length;\n-            for (long si : indices) {\n-                if (si >= (long)length || si < (long)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n+            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -868,1 +824,1 @@\n-            return true;\n+            return new LongMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":46,"deletions":90,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -990,1 +990,1 @@\n-    \/**\n+   \/**\n@@ -2334,2 +2334,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n@@ -2344,0 +2344,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), long.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     LongVector::toShuffle0);\n+    }\n+\n@@ -3731,1 +3743,0 @@\n-                Class<? extends AbstractShuffle<Long>> shuffleType,\n@@ -3734,1 +3745,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4001,1 +4012,0 @@\n-                            Long64Vector.Long64Shuffle.class,\n@@ -4009,1 +4019,0 @@\n-                            Long128Vector.Long128Shuffle.class,\n@@ -4017,1 +4026,0 @@\n-                            Long256Vector.Long256Shuffle.class,\n@@ -4025,1 +4033,0 @@\n-                            Long512Vector.Long512Shuffle.class,\n@@ -4033,1 +4040,0 @@\n-                            LongMaxVector.LongMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Short128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Short128Shuffle shuffleFromArray(int[] indices, int i) { return new Short128Shuffle(indices, i); }\n+    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Short128Shuffle shuffleFromArray(int[] indexes, int i) { return new Short128Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n@@ -778,4 +791,2 @@\n-        Short128Shuffle(short[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Short128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -784,2 +795,2 @@\n-        Short128Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -788,2 +799,2 @@\n-        Short128Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -792,2 +803,2 @@\n-        short[] indices() {\n-            return (short[])getPayload();\n+        public Short128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -797,1 +808,0 @@\n-        @ForceInline\n@@ -805,2 +815,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -812,2 +822,3 @@\n-        Short128Vector toBitsVector() {\n-            return (Short128Vector) super.toBitsVectorTemplate();\n+        public Short128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short128Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -818,2 +829,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short128Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -822,1 +837,0 @@\n-        @Override\n@@ -824,4 +838,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -829,45 +839,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static short[] prepare(int[] indices, int offset) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static short[] prepare(IntUnaryOperator f) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(short[] indices) {\n-            int length = indices.length;\n-            for (short si : indices) {\n-                if (si >= (short)length || si < (short)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short128Shuffle s = (Short128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -875,1 +848,1 @@\n-            return true;\n+            return new Short128Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":46,"deletions":73,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Short256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Short256Shuffle shuffleFromArray(int[] indices, int i) { return new Short256Shuffle(indices, i); }\n+    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Short256Shuffle shuffleFromArray(int[] indexes, int i) { return new Short256Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n@@ -794,4 +807,2 @@\n-        Short256Shuffle(short[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Short256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -800,2 +811,2 @@\n-        Short256Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -804,2 +815,2 @@\n-        Short256Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -808,2 +819,2 @@\n-        short[] indices() {\n-            return (short[])getPayload();\n+        public Short256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -813,1 +824,0 @@\n-        @ForceInline\n@@ -821,2 +831,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -828,2 +838,3 @@\n-        Short256Vector toBitsVector() {\n-            return (Short256Vector) super.toBitsVectorTemplate();\n+        public Short256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short256Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -834,2 +845,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short256Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -838,1 +853,0 @@\n-        @Override\n@@ -840,4 +854,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -845,45 +855,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static short[] prepare(int[] indices, int offset) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static short[] prepare(IntUnaryOperator f) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(short[] indices) {\n-            int length = indices.length;\n-            for (short si : indices) {\n-                if (si >= (short)length || si < (short)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short256Shuffle s = (Short256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -891,1 +864,1 @@\n-            return true;\n+            return new Short256Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":46,"deletions":73,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Short512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Short512Shuffle shuffleFromArray(int[] indices, int i) { return new Short512Shuffle(indices, i); }\n+    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Short512Shuffle shuffleFromArray(int[] indexes, int i) { return new Short512Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n@@ -826,4 +839,2 @@\n-        Short512Shuffle(short[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Short512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -832,2 +843,2 @@\n-        Short512Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -836,2 +847,2 @@\n-        Short512Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -840,2 +851,2 @@\n-        short[] indices() {\n-            return (short[])getPayload();\n+        public Short512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -845,1 +856,0 @@\n-        @ForceInline\n@@ -853,2 +863,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -860,2 +870,3 @@\n-        Short512Vector toBitsVector() {\n-            return (Short512Vector) super.toBitsVectorTemplate();\n+        public Short512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short512Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -866,2 +877,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short512Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -870,1 +885,0 @@\n-        @Override\n@@ -872,4 +886,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -877,45 +887,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static short[] prepare(int[] indices, int offset) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static short[] prepare(IntUnaryOperator f) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(short[] indices) {\n-            int length = indices.length;\n-            for (short si : indices) {\n-                if (si >= (short)length || si < (short)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short512Shuffle s = (Short512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -923,1 +896,1 @@\n-            return true;\n+            return new Short512Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":46,"deletions":73,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    Short64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    Short64Shuffle shuffleFromArray(int[] indices, int i) { return new Short64Shuffle(indices, i); }\n+    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Short64Shuffle shuffleFromArray(int[] indexes, int i) { return new Short64Shuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n@@ -770,4 +783,2 @@\n-        Short64Shuffle(short[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        Short64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -776,2 +787,2 @@\n-        Short64Shuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public Short64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -780,2 +791,2 @@\n-        Short64Shuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public Short64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -784,2 +795,2 @@\n-        short[] indices() {\n-            return (short[])getPayload();\n+        public Short64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -789,1 +800,0 @@\n-        @ForceInline\n@@ -797,2 +807,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -804,2 +814,3 @@\n-        Short64Vector toBitsVector() {\n-            return (Short64Vector) super.toBitsVectorTemplate();\n+        public Short64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Short64Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -810,2 +821,6 @@\n-        ShortVector toBitsVector0() {\n-            return Short64Vector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -814,1 +829,0 @@\n-        @Override\n@@ -816,4 +830,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -821,45 +831,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static short[] prepare(int[] indices, int offset) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static short[] prepare(IntUnaryOperator f) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(short[] indices) {\n-            int length = indices.length;\n-            for (short si : indices) {\n-                if (si >= (short)length || si < (short)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short64Shuffle s = (Short64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -867,1 +840,1 @@\n-            return true;\n+            return new Short64Shuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":46,"deletions":73,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+    @ForceInline\n+    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -146,1 +157,5 @@\n-    ShortMaxShuffle shuffleFromArray(int[] indices, int i) { return new ShortMaxShuffle(indices, i); }\n+    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n@@ -345,1 +360,0 @@\n-    @Override\n@@ -347,3 +361,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n@@ -764,4 +777,2 @@\n-        ShortMaxShuffle(short[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        ShortMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -770,2 +781,2 @@\n-        ShortMaxShuffle(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public ShortMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -774,2 +785,2 @@\n-        ShortMaxShuffle(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public ShortMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -778,2 +789,2 @@\n-        short[] indices() {\n-            return (short[])getPayload();\n+        public ShortMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -783,1 +794,0 @@\n-        @ForceInline\n@@ -791,2 +801,2 @@\n-            assert(VLENGTH < Short.MAX_VALUE);\n-            assert(Short.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -798,2 +808,3 @@\n-        ShortMaxVector toBitsVector() {\n-            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        public ShortMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n@@ -804,2 +815,6 @@\n-        ShortVector toBitsVector0() {\n-            return ShortMaxVector.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -808,1 +823,0 @@\n-        @Override\n@@ -810,4 +824,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -815,45 +825,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-        }\n-\n-        private static short[] prepare(int[] indices, int offset) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static short[] prepare(IntUnaryOperator f) {\n-            short[] a = new short[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = (short)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange(short[] indices) {\n-            int length = indices.length;\n-            for (short si : indices) {\n-                if (si >= (short)length || si < (short)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n+            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -861,1 +834,1 @@\n-            return true;\n+            return new ShortMaxShuffle(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":46,"deletions":73,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1074,1 +1074,1 @@\n-    \/**\n+   \/**\n@@ -2484,2 +2484,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n@@ -2494,0 +2494,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), short.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ShortVector::toShuffle0);\n+    }\n+\n@@ -4081,1 +4093,0 @@\n-                Class<? extends AbstractShuffle<Short>> shuffleType,\n@@ -4084,1 +4095,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -4360,1 +4371,0 @@\n-                            Short64Vector.Short64Shuffle.class,\n@@ -4368,1 +4378,0 @@\n-                            Short128Vector.Short128Shuffle.class,\n@@ -4376,1 +4385,0 @@\n-                            Short256Vector.Short256Shuffle.class,\n@@ -4384,1 +4392,0 @@\n-                            Short512Vector.Short512Shuffle.class,\n@@ -4392,1 +4399,0 @@\n-                            ShortMaxVector.ShortMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,0 @@\n-    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,2 @@\n-    VectorShuffle(Object indices) {\n-        super(indices);\n+    VectorShuffle(byte[] reorder) {\n+        super(reorder);\n@@ -559,1 +559,1 @@\n-    public abstract int laneSource(int i);\n+    public int laneSource(int i) { return toArray()[i]; }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n-\n@@ -347,1 +345,0 @@\n-    @ForceInline\n@@ -373,1 +370,0 @@\n-    @ForceInline\n@@ -417,1 +413,0 @@\n-    @ForceInline\n@@ -440,1 +435,0 @@\n-    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1207,1 +1207,1 @@\n-    \/**\n+   \/**\n@@ -2860,2 +2860,2 @@\n-    final <F>\n-    VectorShuffle<F> toShuffle0(AbstractSpecies<F> dsp) {\n+    private final\n+    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n@@ -2870,0 +2870,12 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), $type$.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     $Type$Vector::toShuffle0);\n+    }\n+\n@@ -5339,1 +5351,0 @@\n-                Class<? extends AbstractShuffle<$Boxtype$>> shuffleType,\n@@ -5342,1 +5353,1 @@\n-                  vectorType, maskType, shuffleType,\n+                  vectorType, maskType,\n@@ -5625,1 +5636,0 @@\n-                            $Type$64Vector.$Type$64Shuffle.class,\n@@ -5633,1 +5643,0 @@\n-                            $Type$128Vector.$Type$128Shuffle.class,\n@@ -5641,1 +5650,0 @@\n-                            $Type$256Vector.$Type$256Shuffle.class,\n@@ -5649,1 +5657,0 @@\n-                            $Type$512Vector.$Type$512Shuffle.class,\n@@ -5657,1 +5664,0 @@\n-                            $Type$MaxVector.$Type$MaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -146,0 +146,11 @@\n+    @ForceInline\n+    $shuffletype$ iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n@@ -148,1 +159,5 @@\n-    $shuffletype$ shuffleFromArray(int[] indices, int i) { return new $shuffletype$(indices, i); }\n+    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    $shuffletype$ shuffleFromArray(int[] indexes, int i) { return new $shuffletype$(indexes, i); }\n@@ -349,1 +364,0 @@\n-    @Override\n@@ -351,3 +365,2 @@\n-    public final\n-    <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp) {\n-        return super.toShuffleTemplate(dsp);\n+    public VectorShuffle<$Boxtype$> toShuffle() {\n+        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n@@ -1050,1 +1063,1 @@\n-        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n+        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n@@ -1052,4 +1065,2 @@\n-        $shuffletype$($bitstype$[] indices) {\n-            super(indices);\n-            assert(VLENGTH == indices.length);\n-            assert(indicesInRange(indices));\n+        $shuffletype$(byte[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -1058,2 +1069,2 @@\n-        $shuffletype$(int[] indices, int i) {\n-            this(prepare(indices, i));\n+        public $shuffletype$(int[] reorder) {\n+            super(VLENGTH, reorder);\n@@ -1062,2 +1073,2 @@\n-        $shuffletype$(IntUnaryOperator fn) {\n-            this(prepare(fn));\n+        public $shuffletype$(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n@@ -1066,2 +1077,2 @@\n-        $bitstype$[] indices() {\n-            return ($bitstype$[])getPayload();\n+        public $shuffletype$(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n@@ -1071,1 +1082,0 @@\n-        @ForceInline\n@@ -1079,2 +1089,2 @@\n-            assert(VLENGTH < $Boxbitstype$.MAX_VALUE);\n-            assert($Boxbitstype$.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n@@ -1086,2 +1096,3 @@\n-        $bitsvectortype$ toBitsVector() {\n-            return ($bitsvectortype$) super.toBitsVectorTemplate();\n+        public $vectortype$ toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, $shuffletype$.class, this, VLENGTH,\n+                                                    (s) -> (($vectortype$)(((AbstractShuffle<$Boxtype$>)(s)).toVectorTemplate())));\n@@ -1092,2 +1103,6 @@\n-        $Bitstype$Vector toBitsVector0() {\n-            return $bitsvectortype$.VSPECIES.dummyVector().vectorFactory(indices());\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n@@ -1096,1 +1111,0 @@\n-        @Override\n@@ -1098,4 +1112,0 @@\n-        public int laneSource(int i) {\n-            return (int)toBitsVector().lane(i);\n-        }\n-\n@@ -1103,93 +1113,8 @@\n-        @ForceInline\n-        public void intoArray(int[] a, int offset) {\n-#if[byte]\n-            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n-            Vector<Byte> v = toBitsVector();\n-            v.convertShape(VectorOperators.B2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.B2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-            v.convertShape(VectorOperators.B2I, species, 2)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 2);\n-            v.convertShape(VectorOperators.B2I, species, 3)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length() * 3);\n-#end[byte]\n-#if[short]\n-            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n-            Vector<Short> v = toBitsVector();\n-            v.convertShape(VectorOperators.S2I, species, 0)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset);\n-            v.convertShape(VectorOperators.S2I, species, 1)\n-                    .reinterpretAsInts()\n-                    .intoArray(a, offset + species.length());\n-#end[short]\n-#if[intOrFloat]\n-            toBitsVector().intoArray(a, offset);\n-#end[intOrFloat]\n-#if[longOrDouble]\n-            switch (length()) {\n-                case 1 -> a[offset] = laneSource(0);\n-                case 2 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 4 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 8 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                case 16 -> toBitsVector()\n-                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n-                        .reinterpretAsInts()\n-                        .intoArray(a, offset);\n-                default -> {\n-                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n-                    for (int i = 0; i < length(); i++) {\n-                        a[offset + i] = laneSource(i);\n-                    }\n-                }\n-            }\n-#end[longOrDouble]\n-        }\n-\n-        private static $bitstype$[] prepare(int[] indices, int offset) {\n-            $bitstype$[] a = new $bitstype$[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = indices[offset + i];\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = ($bitstype$)si;\n-            }\n-            return a;\n-        }\n-\n-        private static $bitstype$[] prepare(IntUnaryOperator f) {\n-            $bitstype$[] a = new $bitstype$[VLENGTH];\n-            for (int i = 0; i < VLENGTH; i++) {\n-                int si = f.applyAsInt(i);\n-                si = partiallyWrapIndex(si, VLENGTH);\n-                a[i] = ($bitstype$)si;\n-            }\n-            return a;\n-        }\n-\n-        private static boolean indicesInRange($bitstype$[] indices) {\n-            int length = indices.length;\n-            for ($bitstype$ si : indices) {\n-                if (si >= ($bitstype$)length || si < ($bitstype$)(-length)) {\n-                    boolean assertsEnabled = false;\n-                    assert(assertsEnabled = true);\n-                    if (assertsEnabled) {\n-                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(indices));\n-                        throw new AssertionError(msg);\n-                    }\n-                    return false;\n-                }\n+        public $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n+            $shuffletype$ s = ($shuffletype$) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n@@ -1197,1 +1122,1 @@\n-            return true;\n+            return new $shuffletype$(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":47,"deletions":122,"binary":false,"changes":169,"status":"modified"}]}