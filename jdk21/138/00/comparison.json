{"files":[{"patch":"@@ -776,1 +776,1 @@\n-            List<PatternDescription> patterns = List.from(patternSet);\n+            Set<PatternDescription> patterns = patternSet;\n@@ -780,1 +780,1 @@\n-                    List<PatternDescription> updatedPatterns;\n+                    Set<PatternDescription> updatedPatterns;\n@@ -784,1 +784,2 @@\n-                    repeat = updatedPatterns != patterns;\n+                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                    repeat = !updatedPatterns.equals(patterns);\n@@ -797,1 +798,1 @@\n-        private boolean checkCovered(Type seltype, List<PatternDescription> patterns) {\n+        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n@@ -833,1 +834,1 @@\n-        private List<PatternDescription> reduceBindingPatterns(Type selectorType, List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n@@ -841,1 +842,0 @@\n-                    Set<PatternDescription> toRemove = new HashSet<>();\n@@ -874,1 +874,0 @@\n-                                    boolean reduces = false;\n@@ -891,7 +890,0 @@\n-                                            reduces = true;\n-                                        }\n-                                    }\n-\n-                                    if (reduces) {\n-                                        if (!types.isSubtype(types.erasure(clazz.type), types.erasure(bpOther.type))) {\n-                                            bindings.append(pdOther);\n@@ -904,1 +896,0 @@\n-                                toRemove.addAll(bindings);\n@@ -910,8 +901,4 @@\n-                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n-                        for (PatternDescription pd : toRemove) {\n-                            patterns = List.filter(patterns, pd);\n-                        }\n-                        for (PatternDescription pd : toAdd) {\n-                            patterns = patterns.prepend(pd);\n-                        }\n-                        return patterns;\n+                    if (!toAdd.isEmpty()) {\n+                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                        newPatterns.addAll(toAdd);\n+                        return newPatterns;\n@@ -961,1 +948,1 @@\n-        private List<PatternDescription> reduceNestedPatterns(List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n@@ -980,0 +967,1 @@\n+                Set<RecordPattern> current = new HashSet<>(e.getValue());\n@@ -986,1 +974,1 @@\n-                            e.getValue()\n+                            current\n@@ -1021,1 +1009,1 @@\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(List.collector());\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n@@ -1025,0 +1013,1 @@\n+                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n@@ -1027,11 +1016,2 @@\n-                            if (nestedPatterns != updatedPatterns) {\n-                                ListBuffer<PatternDescription> result = new ListBuffer<>();\n-                                Set<PatternDescription> toRemove = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-                                toRemove.addAll(join);\n-\n-                                for (PatternDescription p : patterns) {\n-                                    if (!toRemove.contains(p)) {\n-                                        result.append(p);\n-                                    }\n-                                }\n+                            if (!nestedPatterns.equals(updatedPatterns)) {\n+                                current.removeAll(join);\n@@ -1043,1 +1023,1 @@\n-                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                    current.add(new RecordPattern(rpOne.recordType(),\n@@ -1047,1 +1027,0 @@\n-                                return result.toList();\n@@ -1052,0 +1031,7 @@\n+\n+                if (!current.equals(new HashSet<>(e.getValue()))) {\n+                    Set<PatternDescription> result = new HashSet<>(patterns);\n+                    result.removeAll(e.getValue());\n+                    result.addAll(current);\n+                    return result;\n+                }\n@@ -1061,2 +1047,2 @@\n-        private List<PatternDescription> reduceRecordPatterns(List<PatternDescription> patterns) {\n-            var newPatterns = new ListBuffer<PatternDescription>();\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+            var newPatterns = new HashSet<PatternDescription>();\n@@ -1068,1 +1054,1 @@\n-                        newPatterns.append(reducedPattern);\n+                        newPatterns.add(reducedPattern);\n@@ -1073,1 +1059,1 @@\n-                newPatterns.append(pd);\n+                newPatterns.add(pd);\n@@ -1075,2 +1061,2 @@\n-            return modified ? newPatterns.toList() : patterns;\n-                }\n+            return modified ? newPatterns : patterns;\n+        }\n@@ -1108,0 +1094,17 @@\n+        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+            Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+                PatternDescription pd = it.next();\n+                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                    it.remove();\n+                }\n+            }\n+\n+            return result;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":48,"deletions":45,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815\n@@ -1543,1 +1543,1 @@\n-    private static final int NESTING_CONSTANT = 5;\n+    private static final int NESTING_CONSTANT = 4;\n@@ -1971,0 +1971,28 @@\n+    @Test \/\/JDK-8311815:\n+    public void testAmbiguousRecordUsage(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                 record Pair(I i1, I i2) {}\n+                 sealed interface I {}\n+                 record C() implements I {}\n+                 record D() implements I {}\n+\n+                 void exhaustinvenessWithInterface(Pair pairI) {\n+                   switch (pairI) {\n+                     case Pair(D fst, C snd) -> {\n+                     }\n+                     case Pair(C fst, C snd) -> {\n+                     }\n+                     case Pair(C fst, I snd) -> {\n+                     }\n+                     case Pair(D fst, D snd) -> {\n+                     }\n+                   }\n+                 }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"}]}