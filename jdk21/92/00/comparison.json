{"files":[{"patch":"@@ -41,0 +41,3 @@\n+\/\/ Max virtual memory ranges\n+const size_t      ZMaxVirtualReservations       = 100; \/\/ Each reservation at least 1% of total\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+bool ZMemoryManager::free_is_contiguous() const {\n+  return _freelist.size() == 1;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMemory.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  bool free_is_contiguous() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMemory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/z\/zAddress.inline.hpp\"\n+#include \"gc\/z\/zGlobals.hpp\"\n+#include \"gc\/z\/zNMT.hpp\"\n+#include \"gc\/z\/zVirtualMemory.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+ZNMT::Reservation ZNMT::_reservations[ZMaxVirtualReservations] = {};\n+size_t ZNMT::_num_reservations = 0;\n+\n+size_t ZNMT::reservation_index(zoffset offset, size_t* offset_in_reservation) {\n+  assert(_num_reservations > 0, \"at least one reservation must exist\");\n+\n+  size_t index = 0;\n+  *offset_in_reservation = untype(offset);\n+  for (; index < _num_reservations; ++index) {\n+    const size_t reservation_size = _reservations[index]._size;\n+    if (*offset_in_reservation < reservation_size) {\n+      break;\n+    }\n+    *offset_in_reservation -= reservation_size;\n+  }\n+\n+  assert(index != _num_reservations, \"failed to find reservation index\");\n+  return index;\n+}\n+\n+void ZNMT::process_fake_mapping(zoffset offset, size_t size, bool commit) {\n+  \/\/ In order to satisfy NTM's requirement of an 1:1 mapping between committed\n+  \/\/ and reserved addresses, a fake mapping from the offset into the reservation\n+  \/\/ is used.\n+  \/\/\n+  \/\/ These mappings from\n+  \/\/   [offset, offset + size) -> {[virtual address range], ...}\n+  \/\/ are stable after the heap has been reserved. No commits proceed any\n+  \/\/ reservations. Committing and uncommitting the same [offset, offset + size)\n+  \/\/ range will result in same virtual memory ranges.\n+\n+  size_t left_to_process = size;\n+  size_t offset_in_reservation;\n+  for (size_t i = reservation_index(offset, &offset_in_reservation); i < _num_reservations; ++i) {\n+    const zaddress_unsafe reservation_start = _reservations[i]._start;\n+    const size_t reservation_size = _reservations[i]._size;\n+    const size_t sub_range_size = MIN2(left_to_process, reservation_size - offset_in_reservation);\n+    const uintptr_t sub_range_addr = untype(reservation_start) + offset_in_reservation;\n+\n+    \/\/ commit \/ uncommit memory\n+    if (commit) {\n+      MemTracker::record_virtual_memory_commit((void*)sub_range_addr, sub_range_size, CALLER_PC);\n+    } else {\n+      if (MemTracker::enabled()) {\n+        Tracker tracker(Tracker::uncommit);\n+        tracker.record((address)sub_range_addr, sub_range_size);\n+      }\n+    }\n+\n+    left_to_process -= sub_range_size;\n+    if (left_to_process == 0) {\n+      \/\/ Processed all nmt registrations\n+      return;\n+    }\n+\n+    offset_in_reservation = 0;\n+  }\n+\n+  assert(left_to_process == 0, \"everything was not commited\");\n+}\n+\n+void ZNMT::reserve(zaddress_unsafe start, size_t size) {\n+  assert(_num_reservations < ZMaxVirtualReservations, \"too many reservations\");\n+  \/\/ Keep track of the reservations made in order to create fake mappings\n+  \/\/ between the reserved and commited memory.\n+  \/\/ See details in ZNMT::process_fake_mapping\n+  _reservations[_num_reservations++] = {start, size};\n+\n+  MemTracker::record_virtual_memory_reserve((void*)untype(start), size, CALLER_PC, mtJavaHeap);\n+}\n+\n+void ZNMT::commit(zoffset offset, size_t size) {\n+  \/\/ NMT expects a 1-to-1 mapping between virtual and physical memory.\n+  \/\/ ZGC can temporarily have multiple virtual addresses pointing to\n+  \/\/ the same physical memory.\n+  \/\/\n+  \/\/ When this function is called we don't know where in the virtual memory\n+  \/\/ this physical memory will be mapped. So we fake the virtual memory\n+  \/\/ address by mapping the physical offset into offsets in the reserved\n+  \/\/ memory space.\n+  process_fake_mapping(offset, size, true);\n+}\n+\n+void ZNMT::uncommit(zoffset offset, size_t size) {\n+  \/\/ We fake the virtual memory address by mapping the physical offset\n+  \/\/ into offsets in the reserved memory space.\n+  \/\/ See comment in ZNMT::commit\n+  process_fake_mapping(offset, size, false);\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.cpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZNMT_HPP\n+#define SHARE_GC_Z_ZNMT_HPP\n+\n+#include \"gc\/z\/zAddress.hpp\"\n+#include \"gc\/z\/zGlobals.hpp\"\n+#include \"gc\/z\/zMemory.hpp\"\n+#include \"gc\/z\/zVirtualMemory.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+class ZNMT : public AllStatic {\n+private:\n+  struct Reservation {\n+    zaddress_unsafe _start;\n+    size_t          _size;\n+  };\n+  static Reservation _reservations[ZMaxVirtualReservations];\n+  static size_t      _num_reservations;\n+\n+  static size_t reservation_index(zoffset offset, size_t* offset_in_reservation);\n+  static void process_fake_mapping(zoffset offset, size_t size, bool commit);\n+\n+public:\n+  static void reserve(zaddress_unsafe start, size_t size);\n+  static void commit(zoffset offset, size_t size);\n+  static void uncommit(zoffset offset, size_t size);\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZNMT_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zNMT.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -278,20 +278,0 @@\n-void ZPhysicalMemoryManager::nmt_commit(zoffset offset, size_t size) const {\n-  \/\/ NMT expects a 1-to-1 mapping between virtual and physical memory.\n-  \/\/ ZGC can temporarily have multiple virtual addresses pointing to\n-  \/\/ the same physical memory.\n-  \/\/\n-  \/\/ When this function is called we don't know where in the virtual memory\n-  \/\/ this physical memory will be mapped. So we fake that the virtual memory\n-  \/\/ address is the heap base + the given offset.\n-  const uintptr_t addr = ZAddressHeapBase + untype(offset);\n-  MemTracker::record_virtual_memory_commit((void*)addr, size, CALLER_PC);\n-}\n-\n-void ZPhysicalMemoryManager::nmt_uncommit(zoffset offset, size_t size) const {\n-  if (MemTracker::enabled()) {\n-    const uintptr_t addr = ZAddressHeapBase + untype(offset);\n-    Tracker tracker(Tracker::uncommit);\n-    tracker.record((address)addr, size);\n-  }\n-}\n-\n@@ -332,1 +312,1 @@\n-    nmt_commit(segment.start(), committed);\n+    ZNMT::commit(segment.start(), committed);\n@@ -358,1 +338,1 @@\n-    nmt_uncommit(segment.start(), uncommitted);\n+    ZNMT::uncommit(segment.start(), uncommitted);\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.cpp","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -87,3 +87,0 @@\n-  void nmt_commit(zoffset offset, size_t size) const;\n-  void nmt_uncommit(zoffset offset, size_t size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemory.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/z\/zNMT.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -57,0 +58,33 @@\n+#ifdef ASSERT\n+size_t ZVirtualMemoryManager::force_reserve_discontiguous(size_t size) {\n+  const size_t min_range = calculate_min_range(size);\n+  const size_t max_range = MAX2(align_down(size \/ ZForceDiscontiguousHeapReservations, ZGranuleSize), min_range);\n+  size_t reserved = 0;\n+\n+  \/\/ Try to reserve ZForceDiscontiguousHeapReservations number of virtual memory\n+  \/\/ ranges. Starting with higher addresses.\n+  uintptr_t end = ZAddressOffsetMax;\n+  while (reserved < size && end >= max_range) {\n+    const size_t remaining = size - reserved;\n+    const size_t reserve_size = MIN2(max_range, remaining);\n+    const uintptr_t reserve_start = end - reserve_size;\n+\n+    if (reserve_contiguous(to_zoffset(reserve_start), reserve_size)) {\n+      reserved += reserve_size;\n+    }\n+\n+    end -= reserve_size * 2;\n+  }\n+\n+  \/\/ If (reserved < size) attempt to reserve the rest via normal divide and conquer\n+  uintptr_t start = 0;\n+  while (reserved < size && start < ZAddressOffsetMax) {\n+    const size_t remaining = MIN2(size - reserved, ZAddressOffsetMax - start);\n+    reserved += reserve_discontiguous(to_zoffset(start), remaining, min_range);\n+    start += remaining;\n+  }\n+\n+  return reserved;\n+}\n+#endif\n+\n@@ -78,2 +112,3 @@\n-  return reserve_discontiguous(start, first_part, min_range) +\n-         reserve_discontiguous(start + first_part, second_part, min_range);\n+  const size_t first_size = reserve_discontiguous(start, first_part, min_range);\n+  const size_t second_size = reserve_discontiguous(start + first_part, second_part, min_range);\n+  return first_size + second_size;\n@@ -82,1 +117,1 @@\n-size_t ZVirtualMemoryManager::reserve_discontiguous(size_t size) {\n+size_t ZVirtualMemoryManager::calculate_min_range(size_t size) {\n@@ -86,1 +121,5 @@\n-  const size_t min_range = align_up(size \/ 100, ZGranuleSize);\n+  return align_up(size \/ ZMaxVirtualReservations, ZGranuleSize);\n+}\n+\n+size_t ZVirtualMemoryManager::reserve_discontiguous(size_t size) {\n+  const size_t min_range = calculate_min_range(size);\n@@ -101,1 +140,1 @@\n-  assert(is_aligned(size, ZGranuleSize), \"Must be granule aligned\");\n+  assert(is_aligned(size, ZGranuleSize), \"Must be granule aligned \" SIZE_FORMAT_X, size);\n@@ -112,1 +151,1 @@\n-  nmt_reserve(addr, size);\n+  ZNMT::reserve(addr, size);\n@@ -140,2 +179,11 @@\n-  size_t reserved = size;\n-  bool contiguous = true;\n+  auto do_reserve = [&]() {\n+#ifdef ASSERT\n+    if (ZForceDiscontiguousHeapReservations > 0) {\n+      return force_reserve_discontiguous(size);\n+    }\n+#endif\n+\n+    \/\/ Prefer a contiguous address space\n+    if (reserve_contiguous(size)) {\n+      return size;\n+    }\n@@ -143,2 +191,0 @@\n-  \/\/ Prefer a contiguous address space\n-  if (!reserve_contiguous(size)) {\n@@ -146,3 +192,6 @@\n-    reserved = reserve_discontiguous(size);\n-    contiguous = false;\n-  }\n+    return reserve_discontiguous(size);\n+  };\n+\n+  const size_t reserved = do_reserve();\n+\n+  const bool contiguous = _manager.free_is_contiguous();\n@@ -162,5 +211,0 @@\n-void ZVirtualMemoryManager::nmt_reserve(zaddress_unsafe start, size_t size) {\n-  MemTracker::record_virtual_memory_reserve((void*)untype(start), size, CALLER_PC);\n-  MemTracker::record_virtual_memory_type((void*)untype(start), mtJavaHeap);\n-}\n-\n@@ -182,0 +226,4 @@\n+  if (start == zoffset(UINTPTR_MAX)) {\n+    return ZVirtualMemory();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.cpp","additions":67,"deletions":19,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -50,0 +51,2 @@\n+  static size_t calculate_min_range(size_t size);\n+\n@@ -66,1 +69,1 @@\n-  void nmt_reserve(zaddress_unsafe start, size_t size);\n+  DEBUG_ONLY(size_t force_reserve_discontiguous(size_t size);)\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"zPageAge.hpp\"\n+#include \"gc\/z\/zGlobals.hpp\"\n+#include \"gc\/z\/zPageAge.hpp\"\n@@ -71,1 +72,11 @@\n-          range(-1, static_cast<int>(ZPageAgeMax))\n+          range(-1, static_cast<int>(ZPageAgeMax))                          \\\n+                                                                            \\\n+  develop(size_t, ZForceDiscontiguousHeapReservations, 0,                   \\\n+          \"The gc will attempt to split the heap reservation into this \"    \\\n+          \"many reservations, subject to available virtual address space \"  \\\n+          \"and invariant restrictions. Higher virtual addresses are \"       \\\n+          \"preferred \"                                                      \\\n+          \"0: Disabled \"                                                    \\\n+          \"1: Attempt contiguous reservation starting at a higher address \" \\\n+          \"N: Force that many reservations, if possible\")                   \\\n+          range(0, ZMaxVirtualReservations)\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestZForceDiscontiguousHeapReservations\n+ * @requires vm.gc.ZGenerational & vm.debug\n+ * @summary Test the ZForceDiscontiguousHeapReservations development flag\n+ * @library \/test\/lib\n+ * @run driver gc.z.TestZForceDiscontiguousHeapReservations\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestZForceDiscontiguousHeapReservations {\n+\n+    private static void testValue(int n) throws Exception  {\n+        \/**\n+         *  Xmx is picked so that it is divisible by 'ZForceDiscontiguousHeapReservations * ZGranuleSize'\n+         *  Xms is picked so that it is less than '16 * Xmx \/ ZForceDiscontiguousHeapReservations' as ZGC\n+         *   cannot currently handle a discontiguous heap with an initial size larger than the individual\n+         *   reservations.\n+         *\/\n+        final int XmxInM = 2000;\n+        final int XmsInM = Math.min(16 * XmxInM \/ (n + 1), XmxInM);\n+        OutputAnalyzer oa = ProcessTools.executeProcess(ProcessTools.createTestJvm(\n+                                                        \"-XX:+UseZGC\",\n+                                                        \"-XX:+ZGenerational\",\n+                                                        \"-Xms\" + XmsInM + \"M\",\n+                                                        \"-Xmx\" + XmxInM + \"M\",\n+                                                        \"-Xlog:gc,gc+init\",\n+                                                        \"-XX:ZForceDiscontiguousHeapReservations=\" + n,\n+                                                        \"-version\"))\n+                                        .outputTo(System.out)\n+                                        .errorTo(System.out)\n+                                        .shouldHaveExitValue(0);\n+        if (n > 1) {\n+            oa.shouldContain(\"Address Space Type: Discontiguous\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testValue(0);\n+        testValue(1);\n+        testValue(2);\n+        testValue(100);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZForceDiscontiguousHeapReservations.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestZNMT\n+ * @bug 8310743\n+ * @requires vm.gc.ZGenerational & vm.debug\n+ * @summary Test NMT and ZGenerational heap reservation \/ commits interactions.\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestZNMT\n+ *\/\n+\n+import static gc.testlibrary.Allocation.blackHole;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestZNMT {\n+    private static final int XmxInM = 2000;\n+    static class Test {\n+        private static final int K = 1024;\n+        private static final int M = K * K;\n+        public static void main(String[] args) throws Exception {\n+            final int zForceDiscontiguousHeapReservations = Integer.parseInt(args[0]);\n+            final int XmsInM = Integer.parseInt(args[1]);\n+            \/\/ 75% of the largest allocation that fits within one reservation\n+            \/\/ (or Xmx \/ zForceDiscontiguousHeapReservations), whichever is smallest\n+            final int allocationInM = (int)(Math.min(zForceDiscontiguousHeapReservations == 0\n+                                                        ? XmxInM\n+                                                        : XmxInM \/ zForceDiscontiguousHeapReservations,\n+                                                     XmsInM) * 0.75);\n+            ArrayList<byte[]> list = new ArrayList<>(zForceDiscontiguousHeapReservations);\n+            for (int i = 0; i < zForceDiscontiguousHeapReservations; i++) {\n+                list.add(new byte[allocationInM * M]);\n+            }\n+            blackHole(list);\n+        }\n+    }\n+\n+\n+    private static void testValue(int zForceDiscontiguousHeapReservations) throws Exception  {\n+        \/**\n+         *  Xmx is picked so that it is divisible by 'ZForceDiscontiguousHeapReservations * ZGranuleSize'\n+         *  Xms is picked so that it is less than '16 * Xmx \/ ZForceDiscontiguousHeapReservations' as ZGC\n+         *   cannot currently handle a discontiguous heap with an initial size larger than the individual\n+         *   reservations.\n+         *\/\n+        final int XmsInM = Math.min(16 * XmxInM \/ (zForceDiscontiguousHeapReservations + 1), XmxInM);\n+        OutputAnalyzer oa = ProcessTools.executeProcess(ProcessTools.createTestJvm(\n+                                                        \"-XX:+UseZGC\",\n+                                                        \"-XX:+ZGenerational\",\n+                                                        \"-Xms\" + XmsInM + \"M\",\n+                                                        \"-Xmx\" + XmxInM + \"M\",\n+                                                        \"-Xlog:gc,gc+init\",\n+                                                        \"-XX:ZForceDiscontiguousHeapReservations=\" + zForceDiscontiguousHeapReservations,\n+                                                        \"-XX:NativeMemoryTracking=detail\",\n+                                                        \"-XX:+PrintNMTStatistics\",\n+                                                        Test.class.getName(),\n+                                                        Integer.toString(zForceDiscontiguousHeapReservations),\n+                                                        Integer.toString(XmxInM)))\n+                                        .outputTo(System.out)\n+                                        .errorTo(System.out)\n+                                        .shouldHaveExitValue(0);\n+        if (zForceDiscontiguousHeapReservations > 1) {\n+            oa.shouldContain(\"Address Space Type: Discontiguous\");\n+        }\n+\n+        if (XmsInM < XmxInM) {\n+            \/\/ There will be reservations which are smaller than the total\n+            \/\/ memory allocated in TestZNMT.Test.main. This means that some\n+            \/\/ reservation will be completely committed and print the following\n+            \/\/ in the NMT statistics.\n+            oa.shouldMatch(\"reserved and committed \\\\d+ for Java Heap\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testValue(0);\n+        testValue(1);\n+        testValue(2);\n+        testValue(100);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZNMT.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}