{"files":[{"patch":"@@ -383,0 +383,4 @@\n+     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n+     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n+     * (but not less) than the alignment constraint of the selected value layout.\n+     * <p>\n@@ -439,0 +443,4 @@\n+     * <p>\n+     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n+     * strict (but not less) than the alignment constraint of the selected value layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    private static final MethodHandle MH_SLICE_LAYOUT;\n+    private static final MethodHandle MH_CHECK_ALIGN;\n@@ -70,0 +72,4 @@\n+            MH_SLICE_LAYOUT = lookup.findVirtual(MemorySegment.class, \"asSlice\",\n+                    MethodType.methodType(MemorySegment.class, long.class, MemoryLayout.class));\n+            MH_CHECK_ALIGN = lookup.findStatic(LayoutPath.class, \"checkAlign\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n@@ -196,8 +202,12 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(valueLayout);\n-        for (int i = strides.length - 1; i >= 0; i--) {\n-            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2,\n-                    strides[i],\n-                    bounds[i]);\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            handle = MethodHandles.collectCoordinates(handle, 1, collector);\n+        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n+        \/\/ we check the root layout instead\n+        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n+        VarHandle handle = Utils.makeSegmentViewVarHandle(accessedLayout);\n+        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n+\n+        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n+        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n+        \/\/ (see Utils::longToAddress)\n+        if (derefAdapters.length == 0 && enclosing != null) {\n+            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n+            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n@@ -205,2 +215,0 @@\n-        handle = MethodHandles.insertCoordinates(handle, 1,\n-                offset);\n@@ -234,0 +242,4 @@\n+    private MemoryLayout rootLayout() {\n+        return enclosing != null ? enclosing.rootLayout() : this.layout;\n+    }\n+\n@@ -235,1 +247,10 @@\n-        MethodHandle offsetHandle = offsetHandle(); \/\/ byte offset\n+        MethodHandle sliceHandle;\n+        if (enclosing != null) {\n+            \/\/ drop the alignment check for the accessed element, we check the root layout instead\n+            sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n+        } else {\n+            sliceHandle = MH_SLICE_LAYOUT; \/\/ (MS, long, MemoryLayout) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout); \/\/ (MS, long) -> MS\n+        }\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n@@ -237,3 +258,4 @@\n-        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n-        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle); \/\/ (MS, ...) -> MS\n+        if (enclosing != null) {\n+            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n+            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+        }\n@@ -244,0 +266,7 @@\n+    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+        }\n+        return segment;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":43,"deletions":14,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -146,0 +146,12 @@\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefMisAligned() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT).withName(\"x\"));\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(struct.byteSize() + 1).asSlice(1);\n+            VarHandle vhX = struct.varHandle(PathElement.groupElement(\"x\"), PathElement.dereferenceElement());\n+            vhX.set(segment, 42); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import org.testng.SkipException;\n@@ -38,0 +37,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -45,0 +45,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -137,0 +138,28 @@\n+    @Test\n+    public void testBadAlignmentOfRoot() throws Throwable {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            JAVA_INT,\n+            JAVA_SHORT.withName(\"x\"));\n+        assertEquals(struct.byteAlignment(), 4);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(struct.byteSize() + 2, struct.byteAlignment()).asSlice(2);\n+            assertEquals(seg.address() % JAVA_SHORT.byteAlignment(), 0); \/\/ should be aligned\n+            assertNotEquals(seg.address() % struct.byteAlignment(), 0); \/\/ should not be aligned\n+\n+            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+\n+            VarHandle vhX = struct.varHandle(groupElement(\"x\"));\n+            IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> {\n+                vhX.set(seg, (short) 42);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n+\n+            MethodHandle sliceX = struct.sliceHandle(groupElement(\"x\"));\n+            iae = expectThrows(IllegalArgumentException.class, () -> {\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n+        }\n+    }\n+\n@@ -341,1 +370,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"}]}