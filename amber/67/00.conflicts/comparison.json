{"files":[{"patch":"@@ -978,0 +978,4 @@\n+        boolean isLocal = env.info.scope.owner.kind == MTH;\n+        if (isLocal) {\n+            memberEnter.memberEnter(tree, env);\n+        }\n@@ -991,1 +995,3 @@\n-            Env<AttrContext> localEnv = memberEnter.methodEnv(tree, env);\n+            Env<AttrContext> localEnv = isLocal ?\n+                    localMethodEnv(tree, env) :\n+                    memberEnter.methodEnv(tree, env);\n@@ -996,8 +1002,9 @@\n-            \/\/ If we override any other methods, check that we do so properly.\n-            \/\/ JLS ???\n-            if (m.isStatic()) {\n-                chk.checkHideClashes(tree.pos(), env.enclClass.type, m);\n-            } else {\n-                chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);\n-            }\n-            chk.checkOverride(env, tree, m);\n+            if (!isLocal) {\n+                \/\/ If we override any other methods, check that we do so properly.\n+                \/\/ JLS ???\n+                if (m.isStatic()) {\n+                    chk.checkHideClashes(tree.pos(), env.enclClass.type, m);\n+                } else {\n+                    chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);\n+                }\n+                chk.checkOverride(env, tree, m);\n@@ -1005,2 +1012,3 @@\n-            if (isDefaultMethod && types.overridesObjectMethod(m.enclClass(), m)) {\n-                log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));\n+                if (isDefaultMethod && types.overridesObjectMethod(m.enclClass(), m)) {\n+                    log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));\n+                }\n@@ -3351,1 +3359,1 @@\n-        public Env<AttrContext> lambdaEnv(JCLambda that, Env<AttrContext> env) {\n+        public Env<AttrContext> lambdaEnv(JCTree that, Env<AttrContext> env) {\n@@ -3390,0 +3398,10 @@\n+        public Env<AttrContext> localMethodEnv(JCMethodDecl that, Env<AttrContext> env) {\n+            Env<AttrContext> localMethodEnv = lambdaEnv(that, env);\n+            if (that.sym.type != null) {\n+            \/\/when this is called in the enter stage, there's no type to be set\n+                localMethodEnv.info.returnResult = new ResultInfo(KindSelector.VAL, that.sym.type.getReturnType());\n+            }\n+            return localMethodEnv;\n+        }\n+\n+\n@@ -3982,0 +4000,1 @@\n+<<<<<<< HEAD\n@@ -3990,0 +4009,8 @@\n+=======\n+        tree.type = attribTree(tree.vartype, env, varInfo);\n+        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);\n+        if (chk.checkUnique(tree.pos(), v, env.info.scope)) {\n+            chk.checkTransparent(tree.pos(), v, env.info.scope);\n+        }\n+        annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n+>>>>>>> 1194e64d839bd95c66bacb9b78050b7713ab94c1\n@@ -5344,0 +5371,4 @@\n+        if (!c.isAnonymous()) {\n+            \/\/ anonymous classes get analyzed as part of instance creation expression statement\n+            analyzer.analyzeIfNeeded(tree, env);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":43,"deletions":12,"binary":false,"changes":55,"status":"modified"}]}