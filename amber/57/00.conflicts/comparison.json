{"files":[{"patch":"@@ -242,0 +242,1 @@\n+     *     mode |= NOINVOCATION : method invocations are not allowed\n@@ -249,0 +250,1 @@\n+    protected static final int NOINVOCATION = 0x40;\n@@ -251,1 +253,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        mode = (mode & (NOLAMBDA | NOINVOCATION)) | EXPR;\n@@ -255,1 +257,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        mode = (mode & (NOLAMBDA|NOINVOCATION)) | TYPE;\n@@ -567,1 +569,1 @@\n-        return ident(false);\n+        return ident(false, false);\n@@ -570,0 +572,1 @@\n+<<<<<<< HEAD\n@@ -571,0 +574,7 @@\n+=======\n+    protected Name ident(boolean advanceOnErrors) {\n+        return ident(advanceOnErrors, false);\n+    }\n+\n+    protected Name ident(boolean advanceOnErrors, boolean underscoreAllowed) {\n+>>>>>>> c55208014d1257fb64face07ec75bff157abcf0f\n@@ -596,4 +606,10 @@\n-            if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n-                log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n-            } else {\n-                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+            if (!underscoreAllowed) {\n+                if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {\n+                    log.error(token.pos, Errors.UnderscoreNotAllowed);\n+                } else {\n+                    if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n+                        log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n+                    } else {\n+                        log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+                    }\n+                }\n@@ -618,1 +634,5 @@\n-        JCExpression t = toP(F.at(token.pos).Ident(ident()));\n+        return qualident(allowAnnos, false);\n+    }\n+\n+    public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {\n+        JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));\n@@ -758,0 +778,25 @@\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern() {\n+        int pos = token.pos;\n+        if (token.kind == IDENTIFIER && token.name() == names.var) {\n+            nextToken();\n+            return toP(F.at(pos).BindingPattern(ident(), null));\n+        } else {\n+            JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);\n+            if (token.kind == LPAREN) {\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                do {\n+                    nextToken();\n+                    JCPattern nestedPattern = parsePattern();\n+                    nested.append(nestedPattern);\n+                } while (token.kind == COMMA);\n+                accept(RPAREN);\n+                return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));\n+            } else {\n+                return toP(F.at(pos).BindingPattern(ident(), e));\n+            }\n+        }\n+    }\n+\n@@ -940,0 +985,10 @@\n+                } else if (token.kind == LPAREN) {\n+                    checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n+                    ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern();\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                    accept(RPAREN);\n+                    pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));\n@@ -1269,1 +1324,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if ((mode & EXPR) != 0 && (mode & NOINVOCATION) == 0) {\n@@ -1799,1 +1854,1 @@\n-                formalParameters(true, false) :\n+                formalParameters(FormalParameterKind.LAMBDA) :\n@@ -2877,1 +2932,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);\n@@ -3374,0 +3429,29 @@\n+    \/** The kind of a formal parameter\n+     *\/\n+    enum FormalParameterKind {\n+        \/* a formal lambda parameter\n+         *\/\n+        LAMBDA {\n+            @Override\n+            boolean isLambdaParameter() {\n+                return true;\n+            }\n+        },\n+        \/* a formal catch clause parameter\n+         *\/\n+        CATCH,\n+        \/* a formal method parameter\n+         *\/\n+        METHOD,\n+        \/* a formal record parameter\n+         *\/\n+        RECORD;\n+\n+        boolean isLambdaParameter() {\n+            return false;\n+        }\n+        boolean isRecordParameter() {\n+            return false;\n+        }\n+    }\n+\n@@ -3377,1 +3461,1 @@\n-        return variableDeclaratorId(mods, type, false, false);\n+        return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);\n@@ -3379,2 +3463,2 @@\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {\n@@ -3383,1 +3467,3 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n+        boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);\n+        boolean isUnderscore = token.kind == UNDERSCORE;\n+        if (parameterKind.isLambdaParameter() && isUnderscore && !allowUnderscoreAsFormal) {\n@@ -3387,0 +3473,4 @@\n+        } else if (parameterKind == FormalParameterKind.METHOD && isUnderscore && allowUnderscoreAsFormal) {\n+            log.error(pos, Errors.UnderscoreAsIdentifierInMethod);\n+            name = token.name();\n+            nextToken();\n@@ -3389,1 +3479,1 @@\n-                !lambdaParameter ||\n+                parameterKind != FormalParameterKind.LAMBDA ||\n@@ -3393,1 +3483,1 @@\n-                JCExpression pn = qualident(false);\n+                JCExpression pn = qualident(false, allowUnderscoreAsFormal);\n@@ -3425,1 +3515,1 @@\n-        if (recordComponent && token.kind == LBRACKET) {\n+        if (parameterKind == FormalParameterKind.RECORD && token.kind == LBRACKET) {\n@@ -3428,1 +3518,0 @@\n-        type = bracketsOpt(type);\n@@ -3430,1 +3519,6 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        int dimensionsPos = token.pos;\n+        JCExpression typeWithDimensions = bracketsOpt(type);\n+        if (allowUnderscoreAsFormal && isUnderscore && typeWithDimensions != type) {\n+            log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);\n+        }\n+        return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));\n@@ -3784,1 +3878,1 @@\n-        List<JCVariableDecl> headerFields = formalParameters(false, true);\n+        List<JCVariableDecl> headerFields = formalParameters(FormalParameterKind.RECORD);\n@@ -3880,0 +3974,2 @@\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n@@ -3889,1 +3985,1 @@\n-            ClassDef(mods, name, List.nil(),\n+            ClassDef(mods, name, typarams,\n@@ -4007,1 +4103,1 @@\n-        List<JCExpression> typeArgs = typeArgumentsOpt();\n+        List<JCExpression> typeArgsConstr = typeArgumentsOpt();\n@@ -4011,0 +4107,2 @@\n+        List<JCExpression> typeArgsConstant = (token.kind == LT) ?\n+             typeArguments(false) : List.nil();\n@@ -4015,1 +4113,1 @@\n-            JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);\n+            JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.PUBLIC | Flags.ENUM | Flags.ENUM_CONSTANT_CLASS);\n@@ -4017,1 +4115,1 @@\n-            body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));\n+            body = toP(F.at(identPos).ClassDef(mods1, name, List.nil(), null, List.nil(), defs));\n@@ -4021,2 +4119,5 @@\n-        JCIdent ident = F.at(identPos).Ident(enumName);\n-        JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);\n+        JCExpression clazz = F.at(identPos).Ident(enumName);\n+        if (typeArgsConstant.nonEmpty()) {\n+            clazz = F.at(identPos).TypeApply(clazz, typeArgsConstant);\n+        }\n+        JCNewClass create = F.at(createPos).NewClass(null, typeArgsConstr, clazz, args, body);\n@@ -4025,2 +4126,5 @@\n-        ident = F.at(identPos).Ident(enumName);\n-        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));\n+        JCExpression vartype = F.at(identPos).Ident(enumName);\n+        if (typeArgsConstant.nonEmpty()) {\n+            vartype = F.at(identPos).TypeApply(vartype, typeArgsConstant);\n+        }\n+        JCTree result = toP(F.at(pos).VarDef(mods, name, vartype, create));\n@@ -4260,1 +4364,5 @@\n-                case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4264,1 +4372,5 @@\n-                case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4300,1 +4412,1 @@\n-                params = formalParameters();\n+                params = formalParameters(FormalParameterKind.METHOD);\n@@ -4416,4 +4528,1 @@\n-    List<JCVariableDecl> formalParameters() {\n-        return formalParameters(false, false);\n-    }\n-    List<JCVariableDecl> formalParameters(boolean lambdaParameters, boolean recordComponents) {\n+    List<JCVariableDecl> formalParameters(FormalParameterKind parameterKind) {\n@@ -4424,2 +4533,2 @@\n-            this.allowThisIdent = !lambdaParameters && !recordComponents;\n-            lastParam = formalParameter(lambdaParameters, recordComponents);\n+            this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA && parameterKind != FormalParameterKind.RECORD;\n+            lastParam = formalParameter(parameterKind);\n@@ -4437,1 +4546,1 @@\n-                params.append(lastParam = formalParameter(lambdaParameters, recordComponents));\n+                params.append(lastParam = formalParameter(parameterKind));\n@@ -4548,3 +4657,3 @@\n-    protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {\n-        JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();\n-        if (recordComponent && mods.flags != 0) {\n+    protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {\n+        JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();\n+        if (parameterKind == FormalParameterKind.RECORD && mods.flags != 0) {\n@@ -4553,1 +4662,1 @@\n-        if (recordComponent) {\n+        if (parameterKind == FormalParameterKind.RECORD) {\n@@ -4559,1 +4668,1 @@\n-        JCExpression type = parseType(lambdaParameter);\n+        JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);\n@@ -4576,1 +4685,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, parameterKind);\n@@ -4581,1 +4690,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":155,"deletions":46,"binary":false,"changes":201,"status":"modified"}]}