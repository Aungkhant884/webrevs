{"files":[{"patch":"@@ -226,0 +226,1 @@\n+<<<<<<< HEAD\n@@ -227,0 +228,4 @@\n+=======\n+        SEALED_CLASSES(JDK16, Fragments.FeatureSealedClasses, DiagKind.PLURAL),\n+        CONCISE_METHOD_BODIES(JDK15, Fragments.FeatureConciseMethodBodies, DiagKind.PLURAL),\n+>>>>>>> ae136f76dc75210f4973431ff5c281a138a5c228\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -844,0 +844,2 @@\n+compiler.err.constructors.cant.have.concise.body=\\\n+    constructors cannot have a concise body\n@@ -2939,0 +2941,3 @@\n+compiler.misc.feature.concise.method.bodies=\\\n+    concise method bodies\n+\n@@ -3744,0 +3749,1 @@\n+<<<<<<< HEAD\n@@ -3747,0 +3753,25 @@\n+=======\n+# concise methods\n+\n+# 0: string\n+compiler.note.potential.concise.method.found=\\\n+    This method''s body: {0}\\n\\\n+    can be turned into a concise method\n+\n+compiler.warn.potential.concise.method.found=\\\n+    This method''s body can be turned into a concise method\n+\n+compiler.err.only.method.references.allowed=\\\n+    the expression after the '=' in a concise method must be a method reference\n+\n+compiler.err.expression.must.be.type.or.constant.or.final.field=\\\n+    the expression to the left of '::' must be: type, a constant or a final field\n+\n+# helper for valhalla\n+\n+compiler.note.api.with.generic.type.in.signature.found=\\\n+    api with generic array type in signature found\n+\n+compiler.note.api.with.non.generic.type.in.signature.found=\\\n+    api with non generic array type in signature found\n+>>>>>>> ae136f76dc75210f4973431ff5c281a138a5c228\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"}]}