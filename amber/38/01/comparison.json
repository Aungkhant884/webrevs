{"files":[{"patch":"@@ -37,1 +37,1 @@\n-files=.*\\.java$|.*\\.cpp$|.*\\.hpp$|.*\\.c$|.*\\.h$\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,12 @@\n-    SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$root\"\"$SOURCE_POSTFIX\"\n+\n+    VM_CI=\"jdk.internal.vm.ci\/share\/classes\"\n+    VM_COMPILER=\"src\/jdk.internal.vm.compiler\/share\/classes\"\n+    if test \"${root#*$VM_CI}\" != \"$root\" || test \"${root#*$VM_COMPILER}\" != \"$root\"; then\n+        for subdir in \"$root\"\/*; do\n+            if [ -d \"$subdir\" ]; then\n+                SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$subdir\"\/src\"$SOURCE_POSTFIX\"\n+            fi\n+        done\n+    else\n+        SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$root\"\"$SOURCE_POSTFIX\"\n+    fi\n","filename":"bin\/idea.sh","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,0 +132,6 @@\n+  ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+    AD_SRC_FILES += $(call uniq, $(wildcard $(foreach d, $(AD_SRC_ROOTS), \\\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_sve.ad \\\n+    )))\n+  endif\n+\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,43 @@\n+class SVEVectorRegister(FloatRegister):\n+    def __str__(self):\n+        return self.astr(\"z\")\n+\n+class SVEPRegister(Register):\n+    def __str__(self):\n+        return self.astr(\"p\")\n+\n+    def generate(self):\n+        self.number = random.randint(0, 15)\n+        return self\n+\n+class SVEGoverningPRegister(Register):\n+    def __str__(self):\n+        return self.astr(\"p\")\n+    def generate(self):\n+        self.number = random.randint(0, 7)\n+        return self\n+\n+class RegVariant(object):\n+    def __init__(self, low, high):\n+        self.number = random.randint(low, high)\n+\n+    def astr(self):\n+        nameMap = {\n+             0: \".b\",\n+             1: \".h\",\n+             2: \".s\",\n+             3: \".d\",\n+             4: \".q\"\n+        }\n+        return nameMap.get(self.number)\n+\n+    def cstr(self):\n+        nameMap = {\n+             0: \"__ B\",\n+             1: \"__ H\",\n+             2: \"__ S\",\n+             3: \"__ D\",\n+             4: \"__ Q\"\n+        }\n+        return nameMap.get(self.number)\n+\n@@ -85,1 +128,4 @@\n-              'z' : FloatZero}\n+              'z' : FloatZero,\n+              'p' : SVEPRegister,\n+              'P' : SVEGoverningPRegister,\n+              'Z' : SVEVectorRegister}\n@@ -842,0 +888,94 @@\n+class SVEVectorOp(Instruction):\n+    def __init__(self, args):\n+        name = args[0]\n+        regTypes = args[1]\n+        regs = []\n+        for c in regTypes:\n+            regs.append(OperandFactory.create(c).generate())\n+        self.reg = regs\n+        self.numRegs = len(regs)\n+        if regTypes[0] != \"p\" and regTypes[1] == 'P':\n+           self._isPredicated = True\n+           self._merge = \"\/m\"\n+        else:\n+           self._isPredicated = False\n+           self._merge =\"\"\n+\n+        self._bitwiseop = False\n+        if name[0] == 'f':\n+            self._width = RegVariant(2, 3)\n+        elif not self._isPredicated and (name == \"and\" or name == \"eor\" or name == \"orr\"):\n+            self._width = RegVariant(3, 3)\n+            self._bitwiseop = True\n+        else:\n+            self._width = RegVariant(0, 3)\n+        if len(args) > 2:\n+            self._dnm = args[2]\n+        else:\n+            self._dnm = None\n+        Instruction.__init__(self, name)\n+\n+    def cstr(self):\n+        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(0, self.numRegs)] + [\");\"])\n+        if self._bitwiseop:\n+            width = []\n+            formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)] + [\");\"])\n+        else:\n+            width = [self._width.cstr()]\n+        return (formatStr\n+                % tuple([\"__ sve_\" + self._name + \"(\"] +\n+                        [str(self.reg[0])] +\n+                        width +\n+                        [str(self.reg[i]) for i in range(1, self.numRegs)]))\n+    def astr(self):\n+        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)])\n+        if self._dnm == 'dn':\n+            formatStr += \", %s\"\n+            dnReg = [str(self.reg[0]) + self._width.astr()]\n+        else:\n+            dnReg = []\n+\n+        if self._isPredicated:\n+            restRegs = [str(self.reg[1]) + self._merge] + dnReg + [str(self.reg[i]) + self._width.astr() for i in range(2, self.numRegs)]\n+        else:\n+            restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(1, self.numRegs)]\n+        return (formatStr\n+                % tuple([Instruction.astr(self)] +\n+                        [str(self.reg[0]) + self._width.astr()] +\n+                        restRegs))\n+    def generate(self):\n+        return self\n+\n+class SVEReductionOp(Instruction):\n+    def __init__(self, args):\n+        name = args[0]\n+        lowRegType = args[1]\n+        self.reg = []\n+        Instruction.__init__(self, name)\n+        self.reg.append(OperandFactory.create('s').generate())\n+        self.reg.append(OperandFactory.create('P').generate())\n+        self.reg.append(OperandFactory.create('Z').generate())\n+        self._width = RegVariant(lowRegType, 3)\n+    def cstr(self):\n+        return \"__ sve_%s(%s, %s, %s, %s);\" % (self.name(),\n+                                              str(self.reg[0]),\n+                                              self._width.cstr(),\n+                                              str(self.reg[1]),\n+                                              str(self.reg[2]))\n+    def astr(self):\n+        if self.name() == \"uaddv\":\n+            dstRegName = \"d\" + str(self.reg[0].number)\n+        else:\n+            dstRegName = self._width.astr()[1] + str(self.reg[0].number)\n+        formatStr = \"%s %s, %s, %s\"\n+        if self.name() == \"fadda\":\n+            formatStr += \", %s\"\n+            moreReg = [dstRegName]\n+        else:\n+            moreReg = []\n+        return formatStr % tuple([self.name()] +\n+                                 [dstRegName] +\n+                                 [str(self.reg[1])] +\n+                                 moreReg +\n+                                 [str(self.reg[2]) + self._width.astr()])\n+\n@@ -1163,1 +1303,36 @@\n-                        [\"ld1\",    \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"]])\n+                        [\"ld1\",    \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"],\n+                        # SVE instructions\n+                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"inc\",    \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n+                        [\"dec\",    \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n+                        [\"lsl\",    \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n+                        [\"lsr\",    \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n+                        [\"asr\",    \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n+                        [\"lsr\",    \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n+                        [\"asr\",    \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n+                        [\"addvl\",  \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n+                        [\"addpl\",  \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n+                        [\"cntp\",   \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n+                        [\"dup\",    \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n+                        [\"dup\",    \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n+                        [\"dup\",    \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n+                        [\"dup\",    \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n+                        [\"ld1b\",   \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n+                        [\"ld1h\",   \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n+                        [\"ld1w\",   \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n+                        [\"ld1b\",   \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n+                        [\"ld1w\",   \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n+                        [\"ld1d\",   \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n+                        [\"st1w\",   \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n+                        [\"st1h\",   \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n+                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r18));\",       \"st1d\\t{z0.d}, p4, [x0, x18, LSL #3]\"],\n+                        [\"ldr\",    \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n+                        [\"ldr\",    \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n+                        [\"str\",    \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+])\n@@ -1188,0 +1363,43 @@\n+generate(SVEVectorOp, [[\"add\", \"ZZZ\"],\n+                       [\"sub\", \"ZZZ\"],\n+                       [\"fadd\", \"ZZZ\"],\n+                       [\"fmul\", \"ZZZ\"],\n+                       [\"fsub\", \"ZZZ\"],\n+                       [\"abs\", \"ZPZ\"],\n+                       [\"add\", \"ZPZ\", \"dn\"],\n+                       [\"asr\", \"ZPZ\", \"dn\"],\n+                       [\"cnt\", \"ZPZ\"],\n+                       [\"lsl\", \"ZPZ\", \"dn\"],\n+                       [\"lsr\", \"ZPZ\", \"dn\"],\n+                       [\"mul\", \"ZPZ\", \"dn\"],\n+                       [\"neg\", \"ZPZ\"],\n+                       [\"not\", \"ZPZ\"],\n+                       [\"smax\", \"ZPZ\", \"dn\"],\n+                       [\"smin\", \"ZPZ\", \"dn\"],\n+                       [\"sub\", \"ZPZ\", \"dn\"],\n+                       [\"fabs\", \"ZPZ\"],\n+                       [\"fadd\", \"ZPZ\", \"dn\"],\n+                       [\"fdiv\", \"ZPZ\", \"dn\"],\n+                       [\"fmax\", \"ZPZ\", \"dn\"],\n+                       [\"fmin\", \"ZPZ\", \"dn\"],\n+                       [\"fmul\", \"ZPZ\", \"dn\"],\n+                       [\"fneg\", \"ZPZ\"],\n+                       [\"frintm\", \"ZPZ\"],\n+                       [\"frintn\", \"ZPZ\"],\n+                       [\"frintp\", \"ZPZ\"],\n+                       [\"fsqrt\", \"ZPZ\"],\n+                       [\"fsub\", \"ZPZ\", \"dn\"],\n+                       [\"fmla\", \"ZPZZ\"],\n+                       [\"fmls\", \"ZPZZ\"],\n+                       [\"fnmla\", \"ZPZZ\"],\n+                       [\"fnmls\", \"ZPZZ\"],\n+                       [\"mla\", \"ZPZZ\"],\n+                       [\"mls\", \"ZPZZ\"],\n+                       [\"and\", \"ZZZ\"],\n+                       [\"eor\", \"ZZZ\"],\n+                       [\"orr\", \"ZZZ\"],\n+                      ])\n+\n+generate(SVEReductionOp, [[\"andv\", 0], [\"orv\", 0], [\"eorv\", 0], [\"smaxv\", 0], [\"sminv\", 0],\n+                          [\"fminv\", 2], [\"fmaxv\", 2], [\"fadda\", 2], [\"uaddv\", 0]])\n+\n@@ -1196,2 +1414,2 @@\n-# compile for 8.1 and sha2 because of lse atomics and sha512 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.1-a+sha2\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n+# compile for sve with 8.1 and sha2 because of lse atomics and sha512 crypto extension.\n+subprocess.check_call([AARCH64_AS, \"-march=armv8.1-a+sha2+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64-asmtest.py","additions":222,"deletions":4,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-\/\/   r8-r9 invisible to the allocator (so we can use them as scratch regs)\n+\/\/   r8-r9 non-allocatable (so we can use them as scratch regs)\n@@ -97,0 +97,4 @@\n+reg_def R8      ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()         ); \/\/ rscratch1, non-allocatable\n+reg_def R8_H    ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()->next() );\n+reg_def R9      ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()         ); \/\/ rscratch2, non-allocatable\n+reg_def R9_H    ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()->next() );\n@@ -143,1 +147,1 @@\n-\/\/ Float\/Double Registers\n+\/\/ Float\/Double\/Vector Registers\n@@ -164,159 +168,318 @@\n-  reg_def V0   ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()          );\n-  reg_def V0_H ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next()  );\n-  reg_def V0_J ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(2) );\n-  reg_def V0_K ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(3) );\n-\n-  reg_def V1   ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()          );\n-  reg_def V1_H ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next()  );\n-  reg_def V1_J ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(2) );\n-  reg_def V1_K ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(3) );\n-\n-  reg_def V2   ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()          );\n-  reg_def V2_H ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next()  );\n-  reg_def V2_J ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(2) );\n-  reg_def V2_K ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(3) );\n-\n-  reg_def V3   ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()          );\n-  reg_def V3_H ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next()  );\n-  reg_def V3_J ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(2) );\n-  reg_def V3_K ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(3) );\n-\n-  reg_def V4   ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()          );\n-  reg_def V4_H ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next()  );\n-  reg_def V4_J ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(2) );\n-  reg_def V4_K ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(3) );\n-\n-  reg_def V5   ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()          );\n-  reg_def V5_H ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next()  );\n-  reg_def V5_J ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(2) );\n-  reg_def V5_K ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(3) );\n-\n-  reg_def V6   ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()          );\n-  reg_def V6_H ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next()  );\n-  reg_def V6_J ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(2) );\n-  reg_def V6_K ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(3) );\n-\n-  reg_def V7   ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()          );\n-  reg_def V7_H ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next()  );\n-  reg_def V7_J ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(2) );\n-  reg_def V7_K ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(3) );\n-\n-  reg_def V8   ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()          );\n-  reg_def V8_H ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next()  );\n-  reg_def V8_J ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(2) );\n-  reg_def V8_K ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(3) );\n-\n-  reg_def V9   ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()          );\n-  reg_def V9_H ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next()  );\n-  reg_def V9_J ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(2) );\n-  reg_def V9_K ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(3) );\n-\n-  reg_def V10  ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()         );\n-  reg_def V10_H( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next() );\n-  reg_def V10_J( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2));\n-  reg_def V10_K( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3));\n-\n-  reg_def V11  ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()         );\n-  reg_def V11_H( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next() );\n-  reg_def V11_J( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2));\n-  reg_def V11_K( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3));\n-\n-  reg_def V12  ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()         );\n-  reg_def V12_H( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next() );\n-  reg_def V12_J( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2));\n-  reg_def V12_K( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3));\n-\n-  reg_def V13  ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()         );\n-  reg_def V13_H( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next() );\n-  reg_def V13_J( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2));\n-  reg_def V13_K( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3));\n-\n-  reg_def V14  ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()         );\n-  reg_def V14_H( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next() );\n-  reg_def V14_J( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2));\n-  reg_def V14_K( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3));\n-\n-  reg_def V15  ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()         );\n-  reg_def V15_H( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next() );\n-  reg_def V15_J( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2));\n-  reg_def V15_K( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3));\n-\n-  reg_def V16  ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()         );\n-  reg_def V16_H( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next() );\n-  reg_def V16_J( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2));\n-  reg_def V16_K( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3));\n-\n-  reg_def V17  ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()         );\n-  reg_def V17_H( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next() );\n-  reg_def V17_J( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2));\n-  reg_def V17_K( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3));\n-\n-  reg_def V18  ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()         );\n-  reg_def V18_H( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next() );\n-  reg_def V18_J( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2));\n-  reg_def V18_K( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3));\n-\n-  reg_def V19  ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()         );\n-  reg_def V19_H( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next() );\n-  reg_def V19_J( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2));\n-  reg_def V19_K( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3));\n-\n-  reg_def V20  ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()         );\n-  reg_def V20_H( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next() );\n-  reg_def V20_J( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2));\n-  reg_def V20_K( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3));\n-\n-  reg_def V21  ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()         );\n-  reg_def V21_H( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next() );\n-  reg_def V21_J( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2));\n-  reg_def V21_K( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3));\n-\n-  reg_def V22  ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()         );\n-  reg_def V22_H( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next() );\n-  reg_def V22_J( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2));\n-  reg_def V22_K( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3));\n-\n-  reg_def V23  ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()         );\n-  reg_def V23_H( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next() );\n-  reg_def V23_J( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2));\n-  reg_def V23_K( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3));\n-\n-  reg_def V24  ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()         );\n-  reg_def V24_H( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next() );\n-  reg_def V24_J( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2));\n-  reg_def V24_K( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3));\n-\n-  reg_def V25  ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()         );\n-  reg_def V25_H( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next() );\n-  reg_def V25_J( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2));\n-  reg_def V25_K( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3));\n-\n-  reg_def V26  ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()         );\n-  reg_def V26_H( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next() );\n-  reg_def V26_J( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2));\n-  reg_def V26_K( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3));\n-\n-  reg_def V27  ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()         );\n-  reg_def V27_H( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next() );\n-  reg_def V27_J( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2));\n-  reg_def V27_K( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3));\n-\n-  reg_def V28  ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()         );\n-  reg_def V28_H( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next() );\n-  reg_def V28_J( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2));\n-  reg_def V28_K( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3));\n-\n-  reg_def V29  ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()         );\n-  reg_def V29_H( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next() );\n-  reg_def V29_J( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2));\n-  reg_def V29_K( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3));\n-\n-  reg_def V30  ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()         );\n-  reg_def V30_H( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next() );\n-  reg_def V30_J( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2));\n-  reg_def V30_K( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3));\n-\n-  reg_def V31  ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()         );\n-  reg_def V31_H( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next() );\n-  reg_def V31_J( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2));\n-  reg_def V31_K( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3));\n+\/\/ For SVE vector registers, we simply extend vector register size to 8\n+\/\/ 'logical' slots. This is nominally 256 bits but it actually covers\n+\/\/ all possible 'physical' SVE vector register lengths from 128 ~ 2048\n+\/\/ bits. The 'physical' SVE vector register length is detected during\n+\/\/ startup, so the register allocator is able to identify the correct\n+\/\/ number of bytes needed for an SVE spill\/unspill.\n+\/\/ Note that a vector register with 4 slots denotes a 128-bit NEON\n+\/\/ register allowing it to be distinguished from the corresponding SVE\n+\/\/ vector register when the SVE vector length is 128 bits.\n+\n+  reg_def V0   ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()          );\n+  reg_def V0_H ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next()  );\n+  reg_def V0_J ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(2) );\n+  reg_def V0_K ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(3) );\n+  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n+  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n+  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n+  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n+\n+  reg_def V1   ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()          );\n+  reg_def V1_H ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next()  );\n+  reg_def V1_J ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(2) );\n+  reg_def V1_K ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(3) );\n+  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n+  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n+  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n+  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n+\n+  reg_def V2   ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()          );\n+  reg_def V2_H ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next()  );\n+  reg_def V2_J ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(2) );\n+  reg_def V2_K ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(3) );\n+  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n+  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n+  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n+  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n+\n+  reg_def V3   ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()          );\n+  reg_def V3_H ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next()  );\n+  reg_def V3_J ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(2) );\n+  reg_def V3_K ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(3) );\n+  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n+  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n+  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n+  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n+\n+  reg_def V4   ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()          );\n+  reg_def V4_H ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next()  );\n+  reg_def V4_J ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(2) );\n+  reg_def V4_K ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(3) );\n+  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n+  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n+  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n+  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n+\n+  reg_def V5   ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()          );\n+  reg_def V5_H ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next()  );\n+  reg_def V5_J ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(2) );\n+  reg_def V5_K ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(3) );\n+  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n+  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n+  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n+  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n+\n+  reg_def V6   ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()          );\n+  reg_def V6_H ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next()  );\n+  reg_def V6_J ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(2) );\n+  reg_def V6_K ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(3) );\n+  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n+  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n+  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n+  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n+\n+  reg_def V7   ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()          );\n+  reg_def V7_H ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next()  );\n+  reg_def V7_J ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(2) );\n+  reg_def V7_K ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(3) );\n+  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n+  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n+  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n+  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n+\n+  reg_def V8   ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()          );\n+  reg_def V8_H ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next()  );\n+  reg_def V8_J ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(2) );\n+  reg_def V8_K ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(3) );\n+  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n+  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n+  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n+  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n+\n+  reg_def V9   ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()          );\n+  reg_def V9_H ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next()  );\n+  reg_def V9_J ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(2) );\n+  reg_def V9_K ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(3) );\n+  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n+  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n+  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n+  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n+\n+  reg_def V10   ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()          );\n+  reg_def V10_H ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next()  );\n+  reg_def V10_J ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2) );\n+  reg_def V10_K ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3) );\n+  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n+  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n+  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n+  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n+\n+  reg_def V11   ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()          );\n+  reg_def V11_H ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next()  );\n+  reg_def V11_J ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2) );\n+  reg_def V11_K ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3) );\n+  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n+  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n+  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n+  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n+\n+  reg_def V12   ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()          );\n+  reg_def V12_H ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next()  );\n+  reg_def V12_J ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2) );\n+  reg_def V12_K ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3) );\n+  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n+  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n+  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n+  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n+\n+  reg_def V13   ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()          );\n+  reg_def V13_H ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next()  );\n+  reg_def V13_J ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2) );\n+  reg_def V13_K ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3) );\n+  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n+  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n+  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n+  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n+\n+  reg_def V14   ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()          );\n+  reg_def V14_H ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next()  );\n+  reg_def V14_J ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2) );\n+  reg_def V14_K ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3) );\n+  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n+  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n+  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n+  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n+\n+  reg_def V15   ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()          );\n+  reg_def V15_H ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next()  );\n+  reg_def V15_J ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2) );\n+  reg_def V15_K ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3) );\n+  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n+  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n+  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n+  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n+\n+  reg_def V16   ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()          );\n+  reg_def V16_H ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next()  );\n+  reg_def V16_J ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2) );\n+  reg_def V16_K ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3) );\n+  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n+  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n+  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n+  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n+\n+  reg_def V17   ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()          );\n+  reg_def V17_H ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next()  );\n+  reg_def V17_J ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2) );\n+  reg_def V17_K ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3) );\n+  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n+  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n+  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n+  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n+\n+  reg_def V18   ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()          );\n+  reg_def V18_H ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next()  );\n+  reg_def V18_J ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2) );\n+  reg_def V18_K ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3) );\n+  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n+  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n+  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n+  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n+\n+  reg_def V19   ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()          );\n+  reg_def V19_H ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next()  );\n+  reg_def V19_J ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2) );\n+  reg_def V19_K ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3) );\n+  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n+  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n+  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n+  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n+\n+  reg_def V20   ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()          );\n+  reg_def V20_H ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next()  );\n+  reg_def V20_J ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2) );\n+  reg_def V20_K ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3) );\n+  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n+  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n+  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n+  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n+\n+  reg_def V21   ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()          );\n+  reg_def V21_H ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next()  );\n+  reg_def V21_J ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2) );\n+  reg_def V21_K ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3) );\n+  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n+  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n+  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n+  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n+\n+  reg_def V22   ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()          );\n+  reg_def V22_H ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next()  );\n+  reg_def V22_J ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2) );\n+  reg_def V22_K ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3) );\n+  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n+  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n+  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n+  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n+\n+  reg_def V23   ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()          );\n+  reg_def V23_H ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next()  );\n+  reg_def V23_J ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2) );\n+  reg_def V23_K ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3) );\n+  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n+  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n+  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n+  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n+\n+  reg_def V24   ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()          );\n+  reg_def V24_H ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next()  );\n+  reg_def V24_J ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2) );\n+  reg_def V24_K ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3) );\n+  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n+  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n+  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n+  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n+\n+  reg_def V25   ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()          );\n+  reg_def V25_H ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next()  );\n+  reg_def V25_J ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2) );\n+  reg_def V25_K ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3) );\n+  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n+  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n+  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n+  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n+\n+  reg_def V26   ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()          );\n+  reg_def V26_H ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next()  );\n+  reg_def V26_J ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2) );\n+  reg_def V26_K ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3) );\n+  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n+  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n+  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n+  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n+\n+  reg_def V27   ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()          );\n+  reg_def V27_H ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next()  );\n+  reg_def V27_J ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2) );\n+  reg_def V27_K ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3) );\n+  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n+  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n+  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n+  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n+\n+  reg_def V28   ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()          );\n+  reg_def V28_H ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next()  );\n+  reg_def V28_J ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2) );\n+  reg_def V28_K ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3) );\n+  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n+  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n+  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n+  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n+\n+  reg_def V29   ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()          );\n+  reg_def V29_H ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next()  );\n+  reg_def V29_J ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2) );\n+  reg_def V29_K ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3) );\n+  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n+  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n+  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n+  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n+\n+  reg_def V30   ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()          );\n+  reg_def V30_H ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next()  );\n+  reg_def V30_J ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2) );\n+  reg_def V30_K ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3) );\n+  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n+  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n+  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n+  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n+\n+  reg_def V31   ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()          );\n+  reg_def V31_H ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next()  );\n+  reg_def V31_J ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2) );\n+  reg_def V31_K ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3) );\n+  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n+  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n+  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n+  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n+\n+\n+\/\/ ----------------------------\n+\/\/ SVE Predicate Registers\n+\/\/ ----------------------------\n+  reg_def P0 (SOC, SOC, Op_RegVMask, 0, p0->as_VMReg());\n+  reg_def P1 (SOC, SOC, Op_RegVMask, 1, p1->as_VMReg());\n+  reg_def P2 (SOC, SOC, Op_RegVMask, 2, p2->as_VMReg());\n+  reg_def P3 (SOC, SOC, Op_RegVMask, 3, p3->as_VMReg());\n+  reg_def P4 (SOC, SOC, Op_RegVMask, 4, p4->as_VMReg());\n+  reg_def P5 (SOC, SOC, Op_RegVMask, 5, p5->as_VMReg());\n+  reg_def P6 (SOC, SOC, Op_RegVMask, 6, p6->as_VMReg());\n+  reg_def P7 (SOC, SOC, Op_RegVMask, 7, p7->as_VMReg());\n+  reg_def P8 (SOC, SOC, Op_RegVMask, 8, p8->as_VMReg());\n+  reg_def P9 (SOC, SOC, Op_RegVMask, 9, p9->as_VMReg());\n+  reg_def P10 (SOC, SOC, Op_RegVMask, 10, p10->as_VMReg());\n+  reg_def P11 (SOC, SOC, Op_RegVMask, 11, p11->as_VMReg());\n+  reg_def P12 (SOC, SOC, Op_RegVMask, 12, p12->as_VMReg());\n+  reg_def P13 (SOC, SOC, Op_RegVMask, 13, p13->as_VMReg());\n+  reg_def P14 (SOC, SOC, Op_RegVMask, 14, p14->as_VMReg());\n+  reg_def P15 (SOC, SOC, Op_RegVMask, 15, p15->as_VMReg());\n@@ -336,1 +499,0 @@\n-\n@@ -384,0 +546,2 @@\n+    R8, R8_H,   \/\/ rscratch1\n+    R9, R9_H,   \/\/ rscratch2\n@@ -389,16 +553,16 @@\n-    V16, V16_H, V16_J, V16_K,\n-    V17, V17_H, V17_J, V17_K,\n-    V18, V18_H, V18_J, V18_K,\n-    V19, V19_H, V19_J, V19_K,\n-    V20, V20_H, V20_J, V20_K,\n-    V21, V21_H, V21_J, V21_K,\n-    V22, V22_H, V22_J, V22_K,\n-    V23, V23_H, V23_J, V23_K,\n-    V24, V24_H, V24_J, V24_K,\n-    V25, V25_H, V25_J, V25_K,\n-    V26, V26_H, V26_J, V26_K,\n-    V27, V27_H, V27_J, V27_K,\n-    V28, V28_H, V28_J, V28_K,\n-    V29, V29_H, V29_J, V29_K,\n-    V30, V30_H, V30_J, V30_K,\n-    V31, V31_H, V31_J, V31_K,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n@@ -407,8 +571,8 @@\n-    V0, V0_H, V0_J, V0_K,\n-    V1, V1_H, V1_J, V1_K,\n-    V2, V2_H, V2_J, V2_K,\n-    V3, V3_H, V3_J, V3_K,\n-    V4, V4_H, V4_J, V4_K,\n-    V5, V5_H, V5_J, V5_K,\n-    V6, V6_H, V6_J, V6_K,\n-    V7, V7_H, V7_J, V7_K,\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n@@ -417,8 +581,28 @@\n-    V8, V8_H, V8_J, V8_K,\n-    V9, V9_H, V9_J, V9_K,\n-    V10, V10_H, V10_J, V10_K,\n-    V11, V11_H, V11_J, V11_K,\n-    V12, V12_H, V12_J, V12_K,\n-    V13, V13_H, V13_J, V13_K,\n-    V14, V14_H, V14_J, V14_K,\n-    V15, V15_H, V15_J, V15_K,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+);\n+\n+alloc_class chunk2 (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    P7,\n+\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15,\n@@ -427,1 +611,1 @@\n-alloc_class chunk2(RFLAGS);\n+alloc_class chunk3(RFLAGS);\n@@ -711,0 +895,36 @@\n+\/\/ Class for all SVE vector registers.\n+reg_class vectora_reg (\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+);\n+\n@@ -943,0 +1163,33 @@\n+\/\/ Class for all SVE predicate registers.\n+reg_class pr_reg (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15\n+);\n+\n+\/\/ Class for SVE governing predicate registers, which are used\n+\/\/ to determine the active elements of a predicated instruction.\n+reg_class gov_pr (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+);\n+\n@@ -1647,0 +1900,4 @@\n+  if (UseSVE > 0 && C->max_vector_size() >= 16) {\n+    __ reinitialize_ptrue();\n+  }\n+\n@@ -1745,1 +2002,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_stack };\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n@@ -1753,3 +2010,2 @@\n-  \/\/ we have 30 int registers * 2 halves\n-  \/\/ (rscratch1 and rscratch2 are omitted)\n-  int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);\n+  \/\/ we have 32 int registers * 2 halves\n+  int slots_of_int_registers = RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers;\n@@ -1761,2 +2017,3 @@\n-  \/\/ we have 32 float register * 4 halves\n-  if (reg < slots_of_int_registers + FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers) {\n+  \/\/ we have 32 float register * 8 halves\n+  int slots_of_float_registers = FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers) {\n@@ -1766,1 +2023,6 @@\n-  \/\/ Between float regs & stack is the flags regs.\n+  int slots_of_predicate_registers = PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers + slots_of_predicate_registers) {\n+    return rc_predicate;\n+  }\n+\n+  \/\/ Between predicate regs & stack is the flags.\n@@ -1805,2 +2067,22 @@\n-    assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n-    if (cbuf) {\n+    if (ireg == Op_VecA && cbuf) {\n+      C2_MacroAssembler _masm(cbuf);\n+      int sve_vector_reg_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+      if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {\n+        \/\/ stack->stack\n+        __ spill_copy_sve_vector_stack_to_stack(src_offset, dst_offset,\n+                                                sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_stack) {\n+        __ spill_sve_vector(as_FloatRegister(Matcher::_regEncode[src_lo]), ra_->reg2offset(dst_lo),\n+                            sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_float) {\n+        __ unspill_sve_vector(as_FloatRegister(Matcher::_regEncode[dst_lo]), ra_->reg2offset(src_lo),\n+                              sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_float) {\n+        __ sve_orr(as_FloatRegister(Matcher::_regEncode[dst_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]));\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    } else if (cbuf) {\n+      assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n@@ -1824,2 +2106,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(dst_lo));\n+                 ireg == Op_VecD ? __ D : __ Q,\n+                 ra_->reg2offset(dst_lo));\n@@ -1828,2 +2110,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(src_lo));\n+                   ireg == Op_VecD ? __ D : __ Q,\n+                   ra_->reg2offset(src_lo));\n@@ -1914,1 +2196,16 @@\n-      st->print(\"\\t# vector spill size = %d\", ideal_reg()==Op_VecD ? 64:128);\n+      int vsize = 0;\n+      switch (ideal_reg()) {\n+      case Op_VecD:\n+        vsize = 64;\n+        break;\n+      case Op_VecX:\n+        vsize = 128;\n+        break;\n+      case Op_VecA:\n+        vsize = Matcher::scalable_vector_reg_size(T_BYTE) * 8;\n+        break;\n+      default:\n+        assert(false, \"bad register type for spill\");\n+        ShouldNotReachHere();\n+      }\n+      st->print(\"\\t# vector spill size = %d\", vsize);\n@@ -1916,1 +2213,1 @@\n-      st->print(\"\\t# spill size = %d\", is64 ? 64:32);\n+      st->print(\"\\t# spill size = %d\", is64 ? 64 : 32);\n@@ -2082,1 +2379,1 @@\n-  if (!match_rule_supported(opcode)) {\n+  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n@@ -2085,5 +2382,11 @@\n-\n-  \/\/ Special cases which require vector length\n-  switch (opcode) {\n-    case Op_MulAddVS2VI: {\n-      if (vlen != 4) {\n+  int bit_size = vlen * type2aelembytes(bt) * 8;\n+  if (UseSVE == 0 && bit_size > 128) {\n+    return false;\n+  }\n+  if (UseSVE > 0) {\n+    return op_sve_supported(opcode);\n+  } else { \/\/ NEON\n+    \/\/ Special cases\n+    switch (opcode) {\n+    case Op_MulAddVS2VI:\n+      if (bit_size < 128) {\n@@ -2093,0 +2396,4 @@\n+    case Op_MulVL:\n+      return false;\n+    default:\n+      break;\n@@ -2095,1 +2402,0 @@\n-\n@@ -2100,1 +2406,1 @@\n-  return false;\n+  return UseSVE > 0;\n@@ -2136,1 +2442,2 @@\n-  int size = MIN2(16,(int)MaxVectorSize);\n+  \/\/ The MaxVectorSize should have been set by detecting SVE max vector register size.\n+  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n@@ -2149,1 +2456,6 @@\n-\/\/  For the moment limit the vector size to 8 bytes\n+  int max_size = max_vector_size(bt);\n+  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n+    \/\/ Currently vector length less than SVE vector register size is not supported.\n+    return max_size;\n+  } else {\n+    \/\/  For the moment limit the vector size to 8 bytes with NEON.\n@@ -2153,0 +2465,10 @@\n+  }\n+}\n+\n+const bool Matcher::supports_scalable_vector() {\n+  return UseSVE > 0;\n+}\n+\n+\/\/ Actual max scalable vector register length.\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return Matcher::max_vector_size(bt);\n@@ -2157,0 +2479,3 @@\n+  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+    return Op_VecA;\n+  }\n@@ -3425,0 +3750,5 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      \/\/ Only non uncommon_trap calls need to reinitialize ptrue.\n+      if (uncommon_trap_request() == 0) {\n+        __ reinitialize_ptrue();\n+      }\n@@ -3435,0 +3765,2 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n@@ -3471,0 +3803,3 @@\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n+    }\n@@ -3480,0 +3815,5 @@\n+#ifdef ASSERT\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ verify_ptrue();\n+    }\n+#endif\n@@ -4250,0 +4590,35 @@\n+\/\/ 8 bit signed value.\n+operand immI8()\n+%{\n+  predicate(n->get_int() <= 127 && n->get_int() >= -128);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immI8_shift8()\n+%{\n+  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n+            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immL8_shift8()\n+%{\n+  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n+            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4868,0 +5243,12 @@\n+\/\/ Generic vector class. This will be used for\n+\/\/ all vector operands, including NEON and SVE,\n+\/\/ but currently only used for SVE VecA.\n+operand vReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectora_reg));\n+  match(VecA);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -5176,0 +5563,9 @@\n+operand pRegGov()\n+%{\n+  constraint(ALLOC_IN_RC(gov_pr));\n+  match(RegVMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16171,1 +16567,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 16);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 16);\n@@ -16227,1 +16623,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16252,1 +16648,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16277,1 +16673,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16302,1 +16698,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16326,1 +16722,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16350,1 +16746,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16362,1 +16758,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16374,1 +16770,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16401,1 +16797,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16414,1 +16810,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":627,"deletions":231,"binary":false,"changes":858,"status":"modified"},{"patch":"@@ -0,0 +1,1637 @@\n+\/\/\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n+\n+\/\/ AArch64 SVE Architecture Description File\n+\n+\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+\n+operand vmemA_immIOffset4()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_immLOffset4()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\n+operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  bool op_sve_supported(int opcode);\n+%}\n+\n+source %{\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n+                                   FloatRegister reg, PRegister pg, BasicType bt,\n+                                   int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    Assembler::SIMD_RegVariant type;\n+    int esize = type2aelembytes(bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(esize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        type = Assembler::B;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        type = Assembler::H;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        type = Assembler::S;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        type = Assembler::D;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  bool op_sve_supported(int opcode) {\n+    switch (opcode) {\n+      case Op_MulAddVS2VI:\n+        \/\/ No multiply reduction instructions\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ Others\n+      case Op_Extract:\n+      case Op_ExtractB:\n+      case Op_ExtractC:\n+      case Op_ExtractD:\n+      case Op_ExtractF:\n+      case Op_ExtractI:\n+      case Op_ExtractL:\n+      case Op_ExtractS:\n+      case Op_ExtractUB:\n+        return false;\n+      default:\n+        return true;\n+    }\n+  }\n+\n+%}\n+\n+definitions %{\n+  int_def SVE_COST             (200, 200);\n+%}\n+\n+\n+\n+\n+\/\/ All SVE instructions\n+\n+\/\/ vector load\/store\n+\n+\/\/ Use predicated vector load\/store\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                         vector_element_basic_type(this), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                         vector_element_basic_type(this, $src), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ vector abs\n+\n+instruct vabsB(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (AbsVB src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (AbsVS src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (AbsVI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (AbsVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (AbsVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fabs(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (AbsVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fabs(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add\n+\n+instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (AddVB src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (AddVS src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (AddVI src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (AddVL src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (AddVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fadd(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (AddVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fadd(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and\n+\n+instruct vand(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (AndV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or\n+\n+instruct vor(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (OrV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor\n+\n+instruct vxor(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (XorV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector float div\n+\n+instruct vdivF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (DivVF dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (DivVD dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max\n+\n+instruct vmaxF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mla\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaB(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaS(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaI(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaL(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsB(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsS(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsI(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsL(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ vector mul\n+\n+instruct vmulB(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (MulVB dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (MulVS dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (MulVI dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (MulVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmul(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (MulVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmul(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fneg\n+\n+instruct vnegF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (NegVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fneg(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (NegVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fneg(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ popcount vector\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (PopCountVI src));\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  ins_encode %{\n+     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n+            \"umov  $dst, $tmp, S, 0\\n\\t\"\n+            \"addw  $dst, $dst, $src1\\t # add reduction S\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n+            \"umov  $dst, $tmp, D, 0\\n\\t\"\n+            \"add  $dst, $dst, $src1\\t # add reduction D\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max reduction\n+\n+instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t # max reduction F\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t # max reduction D\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min reduction\n+\n+instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t # min reduction F\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t # min reduction D\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector replicate\n+\n+instruct replicateB(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (ReplicateB src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (ReplicateS src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL(vReg dst, iRegL src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct replicateB_imm8(vReg dst, immI8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (ReplicateB con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (ReplicateS con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateI con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateL con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct replicateF(vReg dst, vRegF src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateD(vReg dst, vRegD src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift\n+\n+instruct vasrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (RShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (RShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (RShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (RShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (LShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (LShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (LShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (LShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (URShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (URShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (URShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (URShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (RShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) con = 7;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (RShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 16) con = 15;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (RShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (RShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (URShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (URShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (URShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (URShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (LShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (LShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (LShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (LShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sqrt\n+\n+instruct vsqrtF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (SqrtVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (SqrtVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sub\n+\n+instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (SubVB src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (SubVS src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (SubVI src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (SubVL src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (SubVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (SubVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":1637,"deletions":0,"binary":false,"changes":1637,"status":"added"},{"patch":"@@ -0,0 +1,767 @@\n+\/\/\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+dnl Generate the warning\n+\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n+dnl\n+\n+\/\/ AArch64 SVE Architecture Description File\n+\n+dnl\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3     )\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len)\n+define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n+operand vmemA_imm$1Offset$3()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), $3,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(Con$1);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}')\n+dnl\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4)\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4)\n+dnl\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1,            $2     )\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr, imm_len)\n+define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n+operand vmemA_indOff$1$2(iRegP reg, vmemA_imm$1Offset$2 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    `index'(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}')\n+dnl\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(I, 4)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(L, 4)\n+\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  bool op_sve_supported(int opcode);\n+%}\n+\n+source %{\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n+                                   FloatRegister reg, PRegister pg, BasicType bt,\n+                                   int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    Assembler::SIMD_RegVariant type;\n+    int esize = type2aelembytes(bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(esize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        type = Assembler::B;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        type = Assembler::H;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        type = Assembler::S;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        type = Assembler::D;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  bool op_sve_supported(int opcode) {\n+    switch (opcode) {\n+      case Op_MulAddVS2VI:\n+        \/\/ No multiply reduction instructions\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ Others\n+      case Op_Extract:\n+      case Op_ExtractB:\n+      case Op_ExtractC:\n+      case Op_ExtractD:\n+      case Op_ExtractF:\n+      case Op_ExtractI:\n+      case Op_ExtractL:\n+      case Op_ExtractS:\n+      case Op_ExtractUB:\n+        return false;\n+      default:\n+        return true;\n+    }\n+  }\n+\n+%}\n+\n+definitions %{\n+  int_def SVE_COST             (200, 200);\n+%}\n+\n+\n+dnl\n+dnl ELEMENT_SHORT_CHART($1, $2)\n+dnl ELEMENT_SHORT_CHART(etype, node)\n+define(`ELEMENT_SHORT_CHAR',`ifelse(`$1', `T_SHORT',\n+  `($2->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            ($2->bottom_type()->is_vect()->element_basic_type() == T_CHAR))',\n+   `($2->bottom_type()->is_vect()->element_basic_type() == $1)')')\n+dnl\n+\n+\/\/ All SVE instructions\n+\n+\/\/ vector load\/store\n+\n+\/\/ Use predicated vector load\/store\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                         vector_element_basic_type(this), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                         vector_element_basic_type(this, $src), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl UNARY_OP_TRUE_PREDICATE_ETYPE($1,        $2,      $3,           $4,   $5,          %6  )\n+dnl UNARY_OP_TRUE_PREDICATE_ETYPE(insn_name, op_name, element_type, size, min_vec_len, insn)\n+define(`UNARY_OP_TRUE_PREDICATE_ETYPE', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == $3);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"$6 $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ $6(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector abs\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsB, AbsVB, T_BYTE,   B, 16, sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsS, AbsVS, T_SHORT,  H, 8,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsI, AbsVI, T_INT,    S, 4,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsL, AbsVL, T_LONG,   D, 2,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsF, AbsVF, T_FLOAT,  S, 4,  sve_fabs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsD, AbsVD, T_DOUBLE, D, 2,  sve_fabs)\n+dnl\n+dnl BINARY_OP_UNPREDICATED($1,        $2       $3,   $4           $5  )\n+dnl BINARY_OP_UNPREDICATED(insn_name, op_name, size, min_vec_len, insn)\n+define(`BINARY_OP_UNPREDICATED', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src1, $src2\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector add\n+BINARY_OP_UNPREDICATED(vaddB, AddVB, B, 16, sve_add)\n+BINARY_OP_UNPREDICATED(vaddS, AddVS, H, 8,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddI, AddVI, S, 4,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddL, AddVL, D, 2,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddF, AddVF, S, 4,  sve_fadd)\n+BINARY_OP_UNPREDICATED(vaddD, AddVD, D, 2,  sve_fadd)\n+dnl\n+dnl BINARY_OP_UNSIZED($1,        $2,      $3,          $4  )\n+dnl BINARY_OP_UNSIZED(insn_name, op_name, min_vec_len, insn)\n+define(`BINARY_OP_UNSIZED', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $3);\n+  match(Set dst ($2 src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$4  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ $4(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector and\n+BINARY_OP_UNSIZED(vand, AndV, 16, sve_and)\n+\n+\/\/ vector or\n+BINARY_OP_UNSIZED(vor, OrV, 16, sve_orr)\n+\n+\/\/ vector xor\n+BINARY_OP_UNSIZED(vxor, XorV, 16, sve_eor)\n+dnl\n+dnl VDIVF($1,          $2  , $3         )\n+dnl VDIVF(name_suffix, size, min_vec_len)\n+define(`VDIVF', `\n+instruct vdiv$1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (DivV$1 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector float div\n+VDIVF(F, S, 4)\n+VDIVF(D, D, 2)\n+\n+dnl\n+dnl BINARY_OP_TRUE_PREDICATE_ETYPE($1,        $2,      $3,           $4,   $5,          $6  )\n+dnl BINARY_OP_TRUE_PREDICATE_ETYPE(insn_name, op_name, element_type, size, min_vec_len, insn)\n+define(`BINARY_OP_TRUE_PREDICATE_ETYPE', `\n+instruct $1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == $3);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$6 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ $6(as_FloatRegister($dst_src1$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector max\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxF, MaxV, T_FLOAT,  S, 4,  sve_fmax)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxD, MaxV, T_DOUBLE, D, 2,  sve_fmax)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vminF, MinV, T_FLOAT,  S, 4,  sve_fmin)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vminD, MinV, T_DOUBLE, D, 2,  sve_fmin)\n+\n+dnl\n+dnl VFMLA($1           $2    $3         )\n+dnl VFMLA(name_suffix, size, min_vec_len)\n+define(`VFMLA', `\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fmla\n+VFMLA(F, S, 4)\n+VFMLA(D, D, 2)\n+\n+dnl\n+dnl VFMLS($1           $2    $3         )\n+dnl VFMLS(name_suffix, size, min_vec_len)\n+define(`VFMLS', `\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary (NegV$1 src2) src3)));\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 (NegV$1 src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fmls\n+VFMLS(F, S, 4)\n+VFMLS(D, D, 2)\n+\n+dnl\n+dnl VFNMLA($1           $2    $3         )\n+dnl VFNMLA(name_suffix, size, min_vec_len)\n+define(`VFNMLA', `\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary (NegV$1 src2) src3)));\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 (NegV$1 src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmla\n+VFNMLA(F, S, 4)\n+VFNMLA(D, D, 2)\n+\n+dnl\n+dnl VFNMLS($1           $2    $3         )\n+dnl VFNMLS(name_suffix, size, min_vec_len)\n+define(`VFNMLS', `\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmls\n+VFNMLS(F, S, 4)\n+VFNMLS(D, D, 2)\n+\n+dnl\n+dnl VMLA($1           $2    $3         )\n+dnl VMLA(name_suffix, size, min_vec_len)\n+define(`VMLA', `\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmla$1(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (AddV$1 dst_src1 (MulV$1 src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mla\n+VMLA(B, B, 16)\n+VMLA(S, H, 8)\n+VMLA(I, S, 4)\n+VMLA(L, D, 2)\n+\n+dnl\n+dnl VMLS($1           $2    $3         )\n+dnl VMLS(name_suffix, size, min_vec_len)\n+define(`VMLS', `\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmls$1(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (SubV$1 dst_src1 (MulV$1 src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mls\n+VMLS(B, B, 16)\n+VMLS(S, H, 8)\n+VMLS(I, S, 4)\n+VMLS(L, D, 2)\n+\n+dnl\n+dnl BINARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl BINARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`BINARY_OP_TRUE_PREDICATE', `\n+instruct $1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst_src1$$reg), __ $3,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector mul\n+BINARY_OP_TRUE_PREDICATE(vmulB, MulVB, B, 16, sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulS, MulVS, H, 8,  sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulI, MulVI, S, 4,  sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulL, MulVL, D, 2,  sve_mul)\n+BINARY_OP_UNPREDICATED(vmulF, MulVF, S, 4, sve_fmul)\n+BINARY_OP_UNPREDICATED(vmulD, MulVD, D, 2, sve_fmul)\n+\n+dnl\n+dnl UNARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,            $5  )\n+dnl UNARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_bytes, insn)\n+define(`UNARY_OP_TRUE_PREDICATE', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $4);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fneg\n+UNARY_OP_TRUE_PREDICATE(vnegF, NegVF, S, 16, sve_fneg)\n+UNARY_OP_TRUE_PREDICATE(vnegD, NegVD, D, 16, sve_fneg)\n+\n+\/\/ popcount vector\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (PopCountVI src));\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  ins_encode %{\n+     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl REDUCE_ADD($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n+dnl REDUCE_ADD(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n+define(`REDUCE_ADD', `\n+instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            ELEMENT_SHORT_CHAR($6, n->in(2)));\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n+            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n+            \"$7  $dst, $dst, $src1\\t # add reduction $5\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n+    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n+dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n+define(`REDUCE_ADDF', `\n+instruct $1($3 src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst ($2 src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector add reduction\n+REDUCE_ADD(reduce_addI, AddReductionVI, iRegINoSp, iRegIorL2I, S, T_INT, addw)\n+REDUCE_ADD(reduce_addL, AddReductionVL, iRegLNoSp, iRegL, D, T_LONG, add)\n+REDUCE_ADDF(reduce_addF, AddReductionVF, vRegF, S)\n+REDUCE_ADDF(reduce_addD, AddReductionVD, vRegD, D)\n+\n+dnl\n+dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n+dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n+define(`REDUCE_FMINMAX', `\n+instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_f$1v $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"f$1s $dst, $dst, $src1\\t # $1 reduction $2\" %}\n+  ins_encode %{\n+    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\/\/ vector max reduction\n+REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector min reduction\n+REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n+dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n+define(`REPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n+dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n+define(`REPLICATE_IMM8', `\n+instruct $1(vReg dst, $3 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl FREPLICATE($1,        $2,      $3,      $4,   $5         )\n+dnl FREPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n+define(`FREPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector replicate\n+REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n+REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n+REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n+REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n+\n+REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n+REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n+REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n+REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n+\n+FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n+FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n+dnl\n+dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`VSHIFT_TRUE_PREDICATE', `\n+instruct $1(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`VSHIFT_IMM_UNPREDICATE', `\n+instruct $1(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src, $shift\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;dnl\n+ifelse(eval(index(`$1', `vasr') == 0 || index(`$1', `vlsr') == 0), 1, `\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')dnl\n+ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$3', `B') == 0), 1, `\n+    if (con >= 8) con = 7;')ifelse(eval(index(`$3', `H') == 0), 1, `\n+    if (con >= 16) con = 15;')')dnl\n+ifelse(eval((index(`$1', `vlsl') == 0 || index(`$1', `vlsr') == 0) && (index(`$3', `B') == 0 || index(`$3', `H') == 0)), 1, `\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_COUNT($1,        $2,   $3,          $4  )\n+dnl VSHIFT_COUNT(insn_name, size, min_vec_len, type)\n+define(`VSHIFT_COUNT', `\n+instruct $1(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3 &&\n+            ELEMENT_SHORT_CHAR($4, n));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $2, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector shift\n+VSHIFT_TRUE_PREDICATE(vasrB, RShiftVB,  B, 16, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrS, RShiftVS,  H,  8, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrI, RShiftVI,  S,  4, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrL, RShiftVL,  D,  2, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vlslB, LShiftVB,  B, 16, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslS, LShiftVS,  H,  8, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslI, LShiftVI,  S,  4, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslL, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlsrB, URShiftVB, B, 16, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrS, URShiftVS, H,  8, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrI, URShiftVI, S,  4, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrL, URShiftVL, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  B, 16, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  H,  8, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  S,  4, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  D,  2, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, B, 16, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, H,  8, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, S,  4, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  B, 16, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  H,  8, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  S,  4, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_COUNT(vshiftcntB, B, 16, T_BYTE)\n+VSHIFT_COUNT(vshiftcntS, H,  8, T_SHORT)\n+VSHIFT_COUNT(vshiftcntI, S,  4, T_INT)\n+VSHIFT_COUNT(vshiftcntL, D,  2, T_LONG)\n+\n+\/\/ vector sqrt\n+UNARY_OP_TRUE_PREDICATE(vsqrtF, SqrtVF, S, 16, sve_fsqrt)\n+UNARY_OP_TRUE_PREDICATE(vsqrtD, SqrtVD, D, 16, sve_fsqrt)\n+\n+\/\/ vector sub\n+BINARY_OP_UNPREDICATED(vsubB, SubVB, B, 16, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubS, SubVS, H, 8, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubI, SubVI, S, 4, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubL, SubVL, D, 2, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubF, SubVF, S, 4, sve_fsub)\n+BINARY_OP_UNPREDICATED(vsubD, SubVD, D, 2, sve_fsub)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":767,"deletions":0,"binary":false,"changes":767,"status":"added"},{"patch":"@@ -639,0 +639,33 @@\n+    __ sve_cpy(z0, __ S, p0, v1);                      \/\/       mov     z0.s, p0\/m, s1\n+    __ sve_inc(r0, __ S);                              \/\/       incw    x0\n+    __ sve_dec(r1, __ H);                              \/\/       dech    x1\n+    __ sve_lsl(z0, __ B, z1, 7);                       \/\/       lsl     z0.b, z1.b, #7\n+    __ sve_lsl(z21, __ H, z1, 15);                     \/\/       lsl     z21.h, z1.h, #15\n+    __ sve_lsl(z0, __ S, z1, 31);                      \/\/       lsl     z0.s, z1.s, #31\n+    __ sve_lsl(z0, __ D, z1, 63);                      \/\/       lsl     z0.d, z1.d, #63\n+    __ sve_lsr(z0, __ B, z1, 7);                       \/\/       lsr     z0.b, z1.b, #7\n+    __ sve_asr(z0, __ H, z11, 15);                     \/\/       asr     z0.h, z11.h, #15\n+    __ sve_lsr(z30, __ S, z1, 31);                     \/\/       lsr     z30.s, z1.s, #31\n+    __ sve_asr(z0, __ D, z1, 63);                      \/\/       asr     z0.d, z1.d, #63\n+    __ sve_addvl(sp, r0, 31);                          \/\/       addvl   sp, x0, #31\n+    __ sve_addpl(r1, sp, -32);                         \/\/       addpl   x1, sp, -32\n+    __ sve_cntp(r8, __ B, p0, p1);                     \/\/       cntp    x8, p0, p1.b\n+    __ sve_dup(z0, __ B, 127);                         \/\/       dup     z0.b, 127\n+    __ sve_dup(z1, __ H, -128);                        \/\/       dup     z1.h, -128\n+    __ sve_dup(z2, __ S, 32512);                       \/\/       dup     z2.s, 32512\n+    __ sve_dup(z7, __ D, -32768);                      \/\/       dup     z7.d, -32768\n+    __ sve_ld1b(z0, __ B, p0, Address(sp));            \/\/       ld1b    {z0.b}, p0\/z, [sp]\n+    __ sve_ld1h(z10, __ H, p1, Address(sp, -8));       \/\/       ld1h    {z10.h}, p1\/z, [sp, #-8, MUL VL]\n+    __ sve_ld1w(z20, __ S, p2, Address(r0, 7));        \/\/       ld1w    {z20.s}, p2\/z, [x0, #7, MUL VL]\n+    __ sve_ld1b(z30, __ B, p3, Address(sp, r8));       \/\/       ld1b    {z30.b}, p3\/z, [sp, x8]\n+    __ sve_ld1w(z0, __ S, p4, Address(sp, r28));       \/\/       ld1w    {z0.s}, p4\/z, [sp, x28, LSL #2]\n+    __ sve_ld1d(z11, __ D, p5, Address(r0, r1));       \/\/       ld1d    {z11.d}, p5\/z, [x0, x1, LSL #3]\n+    __ sve_st1b(z22, __ B, p6, Address(sp));           \/\/       st1b    {z22.b}, p6, [sp]\n+    __ sve_st1b(z31, __ B, p7, Address(sp, -8));       \/\/       st1b    {z31.b}, p7, [sp, #-8, MUL VL]\n+    __ sve_st1w(z0, __ S, p1, Address(r0, 7));         \/\/       st1w    {z0.s}, p1, [x0, #7, MUL VL]\n+    __ sve_st1b(z0, __ B, p2, Address(sp, r1));        \/\/       st1b    {z0.b}, p2, [sp, x1]\n+    __ sve_st1h(z0, __ H, p3, Address(sp, r8));        \/\/       st1h    {z0.h}, p3, [sp, x8, LSL #1]\n+    __ sve_st1d(z0, __ D, p4, Address(r0, r18));       \/\/       st1d    {z0.d}, p4, [x0, x18, LSL #3]\n+    __ sve_ldr(z0, Address(sp));                       \/\/       ldr     z0, [sp]\n+    __ sve_ldr(z31, Address(sp, -256));                \/\/       ldr     z31, [sp, #-256, MUL VL]\n+    __ sve_str(z8, Address(r8, 255));                  \/\/       str     z8, [x8, #255, MUL VL]\n@@ -762,0 +795,51 @@\n+\/\/ SVEVectorOp\n+    __ sve_add(z25, __ B, z15, z4);                    \/\/       add     z25.b, z15.b, z4.b\n+    __ sve_sub(z4, __ S, z11, z17);                    \/\/       sub     z4.s, z11.s, z17.s\n+    __ sve_fadd(z16, __ D, z17, z10);                  \/\/       fadd    z16.d, z17.d, z10.d\n+    __ sve_fmul(z22, __ D, z12, z25);                  \/\/       fmul    z22.d, z12.d, z25.d\n+    __ sve_fsub(z28, __ D, z14, z10);                  \/\/       fsub    z28.d, z14.d, z10.d\n+    __ sve_abs(z1, __ H, p3, z30);                     \/\/       abs     z1.h, p3\/m, z30.h\n+    __ sve_add(z15, __ B, p1, z2);                     \/\/       add     z15.b, p1\/m, z15.b, z2.b\n+    __ sve_asr(z13, __ S, p4, z16);                    \/\/       asr     z13.s, p4\/m, z13.s, z16.s\n+    __ sve_cnt(z3, __ D, p0, z11);                     \/\/       cnt     z3.d, p0\/m, z11.d\n+    __ sve_lsl(z5, __ D, p2, z14);                     \/\/       lsl     z5.d, p2\/m, z5.d, z14.d\n+    __ sve_lsr(z29, __ B, p0, z20);                    \/\/       lsr     z29.b, p0\/m, z29.b, z20.b\n+    __ sve_mul(z20, __ S, p5, z27);                    \/\/       mul     z20.s, p5\/m, z20.s, z27.s\n+    __ sve_neg(z26, __ B, p6, z4);                     \/\/       neg     z26.b, p6\/m, z4.b\n+    __ sve_not(z22, __ B, p4, z30);                    \/\/       not     z22.b, p4\/m, z30.b\n+    __ sve_smax(z11, __ H, p2, z27);                   \/\/       smax    z11.h, p2\/m, z11.h, z27.h\n+    __ sve_smin(z28, __ S, p5, z30);                   \/\/       smin    z28.s, p5\/m, z28.s, z30.s\n+    __ sve_sub(z30, __ S, p1, z13);                    \/\/       sub     z30.s, p1\/m, z30.s, z13.s\n+    __ sve_fabs(z30, __ D, p4, z26);                   \/\/       fabs    z30.d, p4\/m, z26.d\n+    __ sve_fadd(z15, __ S, p3, z11);                   \/\/       fadd    z15.s, p3\/m, z15.s, z11.s\n+    __ sve_fdiv(z6, __ D, p7, z16);                    \/\/       fdiv    z6.d, p7\/m, z6.d, z16.d\n+    __ sve_fmax(z27, __ S, p7, z7);                    \/\/       fmax    z27.s, p7\/m, z27.s, z7.s\n+    __ sve_fmin(z19, __ D, p2, z4);                    \/\/       fmin    z19.d, p2\/m, z19.d, z4.d\n+    __ sve_fmul(z17, __ S, p4, z22);                   \/\/       fmul    z17.s, p4\/m, z17.s, z22.s\n+    __ sve_fneg(z28, __ D, p3, z21);                   \/\/       fneg    z28.d, p3\/m, z21.d\n+    __ sve_frintm(z18, __ S, p5, z2);                  \/\/       frintm  z18.s, p5\/m, z2.s\n+    __ sve_frintn(z6, __ S, p3, z15);                  \/\/       frintn  z6.s, p3\/m, z15.s\n+    __ sve_frintp(z12, __ D, p5, z1);                  \/\/       frintp  z12.d, p5\/m, z1.d\n+    __ sve_fsqrt(z18, __ S, p1, z17);                  \/\/       fsqrt   z18.s, p1\/m, z17.s\n+    __ sve_fsub(z15, __ S, p5, z13);                   \/\/       fsub    z15.s, p5\/m, z15.s, z13.s\n+    __ sve_fmla(z20, __ D, p7, z27, z11);              \/\/       fmla    z20.d, p7\/m, z27.d, z11.d\n+    __ sve_fmls(z3, __ D, p0, z30, z23);               \/\/       fmls    z3.d, p0\/m, z30.d, z23.d\n+    __ sve_fnmla(z17, __ S, p2, z27, z26);             \/\/       fnmla   z17.s, p2\/m, z27.s, z26.s\n+    __ sve_fnmls(z6, __ D, p5, z22, z30);              \/\/       fnmls   z6.d, p5\/m, z22.d, z30.d\n+    __ sve_mla(z2, __ H, p7, z26, z18);                \/\/       mla     z2.h, p7\/m, z26.h, z18.h\n+    __ sve_mls(z22, __ B, p4, z2, z17);                \/\/       mls     z22.b, p4\/m, z2.b, z17.b\n+    __ sve_and(z24, z25, z22);                         \/\/       and     z24.d, z25.d, z22.d\n+    __ sve_eor(z18, z12, z3);                          \/\/       eor     z18.d, z12.d, z3.d\n+    __ sve_orr(z29, z28, z16);                         \/\/       orr     z29.d, z28.d, z16.d\n+\n+\/\/ SVEReductionOp\n+    __ sve_andv(v6, __ S, p2, z28);                    \/\/       andv s6, p2, z28.s\n+    __ sve_orv(v7, __ H, p1, z7);                      \/\/       orv h7, p1, z7.h\n+    __ sve_eorv(v9, __ B, p5, z8);                     \/\/       eorv b9, p5, z8.b\n+    __ sve_smaxv(v27, __ B, p5, z30);                  \/\/       smaxv b27, p5, z30.b\n+    __ sve_sminv(v26, __ H, p0, z16);                  \/\/       sminv h26, p0, z16.h\n+    __ sve_fminv(v3, __ D, p6, z8);                    \/\/       fminv d3, p6, z8.d\n+    __ sve_fmaxv(v21, __ D, p6, z26);                  \/\/       fmaxv d21, p6, z26.d\n+    __ sve_fadda(v22, __ S, p0, z4);                   \/\/       fadda s22, p0, s22, z4.s\n+    __ sve_uaddv(v17, __ H, p0, z3);                   \/\/       uaddv d17, p0, z3.h\n+\n@@ -813,1 +897,1 @@\n-  a8:   140001f2        b       870 <forth>\n+  a8:   14000242        b       9b0 <forth>\n@@ -816,1 +900,1 @@\n-  b4:   940001ef        bl      870 <forth>\n+  b4:   9400023f        bl      9b0 <forth>\n@@ -819,1 +903,1 @@\n-  c0:   34003d8a        cbz     w10, 870 <forth>\n+  c0:   3400478a        cbz     w10, 9b0 <forth>\n@@ -822,1 +906,1 @@\n-  cc:   35003d28        cbnz    w8, 870 <forth>\n+  cc:   35004728        cbnz    w8, 9b0 <forth>\n@@ -825,1 +909,1 @@\n-  d8:   b4003ccb        cbz     x11, 870 <forth>\n+  d8:   b40046cb        cbz     x11, 9b0 <forth>\n@@ -828,1 +912,1 @@\n-  e4:   b5003c7d        cbnz    x29, 870 <forth>\n+  e4:   b500467d        cbnz    x29, 9b0 <forth>\n@@ -831,1 +915,1 @@\n-  f0:   10003c13        adr     x19, 870 <forth>\n+  f0:   10004613        adr     x19, 9b0 <forth>\n@@ -835,1 +919,1 @@\n- 100:   36303b96        tbz     w22, #6, 870 <forth>\n+ 100:   36304596        tbz     w22, #6, 9b0 <forth>\n@@ -838,1 +922,1 @@\n- 10c:   37583b2c        tbnz    w12, #11, 870 <forth>\n+ 10c:   3758452c        tbnz    w12, #11, 9b0 <forth>\n@@ -855,1 +939,1 @@\n- 150:   54003900        b.eq    870 <forth>  \/\/ b.none\n+ 150:   54004300        b.eq    9b0 <forth>  \/\/ b.none\n@@ -858,1 +942,1 @@\n- 15c:   540038a1        b.ne    870 <forth>  \/\/ b.any\n+ 15c:   540042a1        b.ne    9b0 <forth>  \/\/ b.any\n@@ -861,1 +945,1 @@\n- 168:   54003842        b.cs    870 <forth>  \/\/ b.hs, b.nlast\n+ 168:   54004242        b.cs    9b0 <forth>  \/\/ b.hs, b.nlast\n@@ -864,1 +948,1 @@\n- 174:   540037e2        b.cs    870 <forth>  \/\/ b.hs, b.nlast\n+ 174:   540041e2        b.cs    9b0 <forth>  \/\/ b.hs, b.nlast\n@@ -867,1 +951,1 @@\n- 180:   54003783        b.cc    870 <forth>  \/\/ b.lo, b.ul, b.last\n+ 180:   54004183        b.cc    9b0 <forth>  \/\/ b.lo, b.ul, b.last\n@@ -870,1 +954,1 @@\n- 18c:   54003723        b.cc    870 <forth>  \/\/ b.lo, b.ul, b.last\n+ 18c:   54004123        b.cc    9b0 <forth>  \/\/ b.lo, b.ul, b.last\n@@ -873,1 +957,1 @@\n- 198:   540036c4        b.mi    870 <forth>  \/\/ b.first\n+ 198:   540040c4        b.mi    9b0 <forth>  \/\/ b.first\n@@ -876,1 +960,1 @@\n- 1a4:   54003665        b.pl    870 <forth>  \/\/ b.nfrst\n+ 1a4:   54004065        b.pl    9b0 <forth>  \/\/ b.nfrst\n@@ -879,1 +963,1 @@\n- 1b0:   54003606        b.vs    870 <forth>\n+ 1b0:   54004006        b.vs    9b0 <forth>\n@@ -882,1 +966,1 @@\n- 1bc:   540035a7        b.vc    870 <forth>\n+ 1bc:   54003fa7        b.vc    9b0 <forth>\n@@ -885,1 +969,1 @@\n- 1c8:   54003548        b.hi    870 <forth>  \/\/ b.pmore\n+ 1c8:   54003f48        b.hi    9b0 <forth>  \/\/ b.pmore\n@@ -888,1 +972,1 @@\n- 1d4:   540034e9        b.ls    870 <forth>  \/\/ b.plast\n+ 1d4:   54003ee9        b.ls    9b0 <forth>  \/\/ b.plast\n@@ -891,1 +975,1 @@\n- 1e0:   5400348a        b.ge    870 <forth>  \/\/ b.tcont\n+ 1e0:   54003e8a        b.ge    9b0 <forth>  \/\/ b.tcont\n@@ -894,1 +978,1 @@\n- 1ec:   5400342b        b.lt    870 <forth>  \/\/ b.tstop\n+ 1ec:   54003e2b        b.lt    9b0 <forth>  \/\/ b.tstop\n@@ -897,1 +981,1 @@\n- 1f8:   540033cc        b.gt    870 <forth>\n+ 1f8:   54003dcc        b.gt    9b0 <forth>\n@@ -900,1 +984,1 @@\n- 204:   5400336d        b.le    870 <forth>\n+ 204:   54003d6d        b.le    9b0 <forth>\n@@ -903,1 +987,1 @@\n- 210:   5400330e        b.al    870 <forth>\n+ 210:   54003d0e        b.al    9b0 <forth>\n@@ -906,1 +990,1 @@\n- 21c:   540032af        b.nv    870 <forth>\n+ 21c:   54003caf        b.nv    9b0 <forth>\n@@ -1032,1 +1116,1 @@\n- 414:   580022fb        ldr     x27, 870 <forth>\n+ 414:   58002cfb        ldr     x27, 9b0 <forth>\n@@ -1207,104 +1291,184 @@\n- 6d0:   1e601000        fmov    d0, #2.000000000000000000e+00\n- 6d4:   1e603000        fmov    d0, #2.125000000000000000e+00\n- 6d8:   1e621000        fmov    d0, #4.000000000000000000e+00\n- 6dc:   1e623000        fmov    d0, #4.250000000000000000e+00\n- 6e0:   1e641000        fmov    d0, #8.000000000000000000e+00\n- 6e4:   1e643000        fmov    d0, #8.500000000000000000e+00\n- 6e8:   1e661000        fmov    d0, #1.600000000000000000e+01\n- 6ec:   1e663000        fmov    d0, #1.700000000000000000e+01\n- 6f0:   1e681000        fmov    d0, #1.250000000000000000e-01\n- 6f4:   1e683000        fmov    d0, #1.328125000000000000e-01\n- 6f8:   1e6a1000        fmov    d0, #2.500000000000000000e-01\n- 6fc:   1e6a3000        fmov    d0, #2.656250000000000000e-01\n- 700:   1e6c1000        fmov    d0, #5.000000000000000000e-01\n- 704:   1e6c3000        fmov    d0, #5.312500000000000000e-01\n- 708:   1e6e1000        fmov    d0, #1.000000000000000000e+00\n- 70c:   1e6e3000        fmov    d0, #1.062500000000000000e+00\n- 710:   1e701000        fmov    d0, #-2.000000000000000000e+00\n- 714:   1e703000        fmov    d0, #-2.125000000000000000e+00\n- 718:   1e721000        fmov    d0, #-4.000000000000000000e+00\n- 71c:   1e723000        fmov    d0, #-4.250000000000000000e+00\n- 720:   1e741000        fmov    d0, #-8.000000000000000000e+00\n- 724:   1e743000        fmov    d0, #-8.500000000000000000e+00\n- 728:   1e761000        fmov    d0, #-1.600000000000000000e+01\n- 72c:   1e763000        fmov    d0, #-1.700000000000000000e+01\n- 730:   1e781000        fmov    d0, #-1.250000000000000000e-01\n- 734:   1e783000        fmov    d0, #-1.328125000000000000e-01\n- 738:   1e7a1000        fmov    d0, #-2.500000000000000000e-01\n- 73c:   1e7a3000        fmov    d0, #-2.656250000000000000e-01\n- 740:   1e7c1000        fmov    d0, #-5.000000000000000000e-01\n- 744:   1e7c3000        fmov    d0, #-5.312500000000000000e-01\n- 748:   1e7e1000        fmov    d0, #-1.000000000000000000e+00\n- 74c:   1e7e3000        fmov    d0, #-1.062500000000000000e+00\n- 750:   f8388098        swp     x24, x24, [x4]\n- 754:   f8340010        ldadd   x20, x16, [x0]\n- 758:   f8241175        ldclr   x4, x21, [x11]\n- 75c:   f83e22d0        ldeor   x30, x16, [x22]\n- 760:   f82432ef        ldset   x4, x15, [x23]\n- 764:   f83a5186        ldsmin  x26, x6, [x12]\n- 768:   f82f41ee        ldsmax  x15, x14, [x15]\n- 76c:   f82973b9        ldumin  x9, x25, [x29]\n- 770:   f82b6194        ldumax  x11, x20, [x12]\n- 774:   f8b28216        swpa    x18, x22, [x16]\n- 778:   f8b50358        ldadda  x21, x24, [x26]\n- 77c:   f8a61206        ldclra  x6, x6, [x16]\n- 780:   f8b02219        ldeora  x16, x25, [x16]\n- 784:   f8bc3218        ldseta  x28, x24, [x16]\n- 788:   f8ba514f        ldsmina x26, x15, [x10]\n- 78c:   f8ad428e        ldsmaxa x13, x14, [x20]\n- 790:   f8a173d7        ldumina x1, x23, [x30]\n- 794:   f8ae60c2        ldumaxa x14, x2, [x6]\n- 798:   f8e38328        swpal   x3, x8, [x25]\n- 79c:   f8e003db        ldaddal x0, x27, [x30]\n- 7a0:   f8e513c5        ldclral x5, x5, [x30]\n- 7a4:   f8eb2019        ldeoral x11, x25, [x0]\n- 7a8:   f8ff3260        ldsetal xzr, x0, [x19]\n- 7ac:   f8fd513a        ldsminal        x29, x26, [x9]\n- 7b0:   f8fa41ec        ldsmaxal        x26, x12, [x15]\n- 7b4:   f8eb724b        lduminal        x11, x11, [x18]\n- 7b8:   f8f96316        ldumaxal        x25, x22, [x24]\n- 7bc:   f8608171        swpl    x0, x17, [x11]\n- 7c0:   f86600dd        ldaddl  x6, x29, [x6]\n- 7c4:   f86512a5        ldclrl  x5, x5, [x21]\n- 7c8:   f8732250        ldeorl  x19, x16, [x18]\n- 7cc:   f87e339b        ldsetl  x30, x27, [x28]\n- 7d0:   f861503c        ldsminl x1, x28, [x1]\n- 7d4:   f874421d        ldsmaxl x20, x29, [x16]\n- 7d8:   f86d73aa        lduminl x13, x10, [x29]\n- 7dc:   f87d62d3        ldumaxl x29, x19, [x22]\n- 7e0:   b82a83e4        swp     w10, w4, [sp]\n- 7e4:   b83503e8        ldadd   w21, w8, [sp]\n- 7e8:   b833138a        ldclr   w19, w10, [x28]\n- 7ec:   b82220b9        ldeor   w2, w25, [x5]\n- 7f0:   b82332c8        ldset   w3, w8, [x22]\n- 7f4:   b83350ad        ldsmin  w19, w13, [x5]\n- 7f8:   b83d42b8        ldsmax  w29, w24, [x21]\n- 7fc:   b83a7078        ldumin  w26, w24, [x3]\n- 800:   b83862fa        ldumax  w24, w26, [x23]\n- 804:   b8af8075        swpa    w15, w21, [x3]\n- 808:   b8b80328        ldadda  w24, w8, [x25]\n- 80c:   b8b41230        ldclra  w20, w16, [x17]\n- 810:   b8a22001        ldeora  w2, w1, [x0]\n- 814:   b8b83064        ldseta  w24, w4, [x3]\n- 818:   b8ac539f        ldsmina w12, wzr, [x28]\n- 81c:   b8aa405a        ldsmaxa w10, w26, [x2]\n- 820:   b8ac73f2        ldumina w12, w18, [sp]\n- 824:   b8a163ad        ldumaxa w1, w13, [x29]\n- 828:   b8e08193        swpal   w0, w19, [x12]\n- 82c:   b8f101b6        ldaddal w17, w22, [x13]\n- 830:   b8fc13fe        ldclral w28, w30, [sp]\n- 834:   b8e1239a        ldeoral w1, w26, [x28]\n- 838:   b8e4309e        ldsetal w4, w30, [x4]\n- 83c:   b8e6535e        ldsminal        w6, w30, [x26]\n- 840:   b8f24109        ldsmaxal        w18, w9, [x8]\n- 844:   b8ec7280        lduminal        w12, w0, [x20]\n- 848:   b8e16058        ldumaxal        w1, w24, [x2]\n- 84c:   b8608309        swpl    w0, w9, [x24]\n- 850:   b87a03d0        ldaddl  w26, w16, [x30]\n- 854:   b86312ea        ldclrl  w3, w10, [x23]\n- 858:   b86a2244        ldeorl  w10, w4, [x18]\n- 85c:   b862310b        ldsetl  w2, w11, [x8]\n- 860:   b86a522f        ldsminl w10, w15, [x17]\n- 864:   b862418a        ldsmaxl w2, w10, [x12]\n- 868:   b86c71af        lduminl w12, w15, [x13]\n- 86c:   b8626287        ldumaxl w2, w7, [x20]\n+ 6d0:   05a08020        mov     z0.s, p0\/m, s1\n+ 6d4:   04b0e3e0        incw    x0\n+ 6d8:   0470e7e1        dech    x1\n+ 6dc:   042f9c20        lsl     z0.b, z1.b, #7\n+ 6e0:   043f9c35        lsl     z21.h, z1.h, #15\n+ 6e4:   047f9c20        lsl     z0.s, z1.s, #31\n+ 6e8:   04ff9c20        lsl     z0.d, z1.d, #63\n+ 6ec:   04299420        lsr     z0.b, z1.b, #7\n+ 6f0:   04319160        asr     z0.h, z11.h, #15\n+ 6f4:   0461943e        lsr     z30.s, z1.s, #31\n+ 6f8:   04a19020        asr     z0.d, z1.d, #63\n+ 6fc:   042053ff        addvl   sp, x0, #31\n+ 700:   047f5401        addpl   x1, sp, #-32\n+ 704:   25208028        cntp    x8, p0, p1.b\n+ 708:   2538cfe0        mov     z0.b, #127\n+ 70c:   2578d001        mov     z1.h, #-128\n+ 710:   25b8efe2        mov     z2.s, #32512\n+ 714:   25f8f007        mov     z7.d, #-32768\n+ 718:   a400a3e0        ld1b    {z0.b}, p0\/z, [sp]\n+ 71c:   a4a8a7ea        ld1h    {z10.h}, p1\/z, [sp, #-8, mul vl]\n+ 720:   a547a814        ld1w    {z20.s}, p2\/z, [x0, #7, mul vl]\n+ 724:   a4084ffe        ld1b    {z30.b}, p3\/z, [sp, x8]\n+ 728:   a55c53e0        ld1w    {z0.s}, p4\/z, [sp, x28, lsl #2]\n+ 72c:   a5e1540b        ld1d    {z11.d}, p5\/z, [x0, x1, lsl #3]\n+ 730:   e400fbf6        st1b    {z22.b}, p6, [sp]\n+ 734:   e408ffff        st1b    {z31.b}, p7, [sp, #-8, mul vl]\n+ 738:   e547e400        st1w    {z0.s}, p1, [x0, #7, mul vl]\n+ 73c:   e4014be0        st1b    {z0.b}, p2, [sp, x1]\n+ 740:   e4a84fe0        st1h    {z0.h}, p3, [sp, x8, lsl #1]\n+ 744:   e5f25000        st1d    {z0.d}, p4, [x0, x18, lsl #3]\n+ 748:   858043e0        ldr     z0, [sp]\n+ 74c:   85a043ff        ldr     z31, [sp, #-256, mul vl]\n+ 750:   e59f5d08        str     z8, [x8, #255, mul vl]\n+ 754:   1e601000        fmov    d0, #2.000000000000000000e+00\n+ 758:   1e603000        fmov    d0, #2.125000000000000000e+00\n+ 75c:   1e621000        fmov    d0, #4.000000000000000000e+00\n+ 760:   1e623000        fmov    d0, #4.250000000000000000e+00\n+ 764:   1e641000        fmov    d0, #8.000000000000000000e+00\n+ 768:   1e643000        fmov    d0, #8.500000000000000000e+00\n+ 76c:   1e661000        fmov    d0, #1.600000000000000000e+01\n+ 770:   1e663000        fmov    d0, #1.700000000000000000e+01\n+ 774:   1e681000        fmov    d0, #1.250000000000000000e-01\n+ 778:   1e683000        fmov    d0, #1.328125000000000000e-01\n+ 77c:   1e6a1000        fmov    d0, #2.500000000000000000e-01\n+ 780:   1e6a3000        fmov    d0, #2.656250000000000000e-01\n+ 784:   1e6c1000        fmov    d0, #5.000000000000000000e-01\n+ 788:   1e6c3000        fmov    d0, #5.312500000000000000e-01\n+ 78c:   1e6e1000        fmov    d0, #1.000000000000000000e+00\n+ 790:   1e6e3000        fmov    d0, #1.062500000000000000e+00\n+ 794:   1e701000        fmov    d0, #-2.000000000000000000e+00\n+ 798:   1e703000        fmov    d0, #-2.125000000000000000e+00\n+ 79c:   1e721000        fmov    d0, #-4.000000000000000000e+00\n+ 7a0:   1e723000        fmov    d0, #-4.250000000000000000e+00\n+ 7a4:   1e741000        fmov    d0, #-8.000000000000000000e+00\n+ 7a8:   1e743000        fmov    d0, #-8.500000000000000000e+00\n+ 7ac:   1e761000        fmov    d0, #-1.600000000000000000e+01\n+ 7b0:   1e763000        fmov    d0, #-1.700000000000000000e+01\n+ 7b4:   1e781000        fmov    d0, #-1.250000000000000000e-01\n+ 7b8:   1e783000        fmov    d0, #-1.328125000000000000e-01\n+ 7bc:   1e7a1000        fmov    d0, #-2.500000000000000000e-01\n+ 7c0:   1e7a3000        fmov    d0, #-2.656250000000000000e-01\n+ 7c4:   1e7c1000        fmov    d0, #-5.000000000000000000e-01\n+ 7c8:   1e7c3000        fmov    d0, #-5.312500000000000000e-01\n+ 7cc:   1e7e1000        fmov    d0, #-1.000000000000000000e+00\n+ 7d0:   1e7e3000        fmov    d0, #-1.062500000000000000e+00\n+ 7d4:   f8388098        swp     x24, x24, [x4]\n+ 7d8:   f8340010        ldadd   x20, x16, [x0]\n+ 7dc:   f8241175        ldclr   x4, x21, [x11]\n+ 7e0:   f83e22d0        ldeor   x30, x16, [x22]\n+ 7e4:   f82432ef        ldset   x4, x15, [x23]\n+ 7e8:   f83a5186        ldsmin  x26, x6, [x12]\n+ 7ec:   f82f41ee        ldsmax  x15, x14, [x15]\n+ 7f0:   f82973b9        ldumin  x9, x25, [x29]\n+ 7f4:   f82b6194        ldumax  x11, x20, [x12]\n+ 7f8:   f8b28216        swpa    x18, x22, [x16]\n+ 7fc:   f8b50358        ldadda  x21, x24, [x26]\n+ 800:   f8a61206        ldclra  x6, x6, [x16]\n+ 804:   f8b02219        ldeora  x16, x25, [x16]\n+ 808:   f8bc3218        ldseta  x28, x24, [x16]\n+ 80c:   f8ba514f        ldsmina x26, x15, [x10]\n+ 810:   f8ad428e        ldsmaxa x13, x14, [x20]\n+ 814:   f8a173d7        ldumina x1, x23, [x30]\n+ 818:   f8ae60c2        ldumaxa x14, x2, [x6]\n+ 81c:   f8e38328        swpal   x3, x8, [x25]\n+ 820:   f8e003db        ldaddal x0, x27, [x30]\n+ 824:   f8e513c5        ldclral x5, x5, [x30]\n+ 828:   f8eb2019        ldeoral x11, x25, [x0]\n+ 82c:   f8ff3260        ldsetal xzr, x0, [x19]\n+ 830:   f8fd513a        ldsminal        x29, x26, [x9]\n+ 834:   f8fa41ec        ldsmaxal        x26, x12, [x15]\n+ 838:   f8eb724b        lduminal        x11, x11, [x18]\n+ 83c:   f8f96316        ldumaxal        x25, x22, [x24]\n+ 840:   f8608171        swpl    x0, x17, [x11]\n+ 844:   f86600dd        ldaddl  x6, x29, [x6]\n+ 848:   f86512a5        ldclrl  x5, x5, [x21]\n+ 84c:   f8732250        ldeorl  x19, x16, [x18]\n+ 850:   f87e339b        ldsetl  x30, x27, [x28]\n+ 854:   f861503c        ldsminl x1, x28, [x1]\n+ 858:   f874421d        ldsmaxl x20, x29, [x16]\n+ 85c:   f86d73aa        lduminl x13, x10, [x29]\n+ 860:   f87d62d3        ldumaxl x29, x19, [x22]\n+ 864:   b82a83e4        swp     w10, w4, [sp]\n+ 868:   b83503e8        ldadd   w21, w8, [sp]\n+ 86c:   b833138a        ldclr   w19, w10, [x28]\n+ 870:   b82220b9        ldeor   w2, w25, [x5]\n+ 874:   b82332c8        ldset   w3, w8, [x22]\n+ 878:   b83350ad        ldsmin  w19, w13, [x5]\n+ 87c:   b83d42b8        ldsmax  w29, w24, [x21]\n+ 880:   b83a7078        ldumin  w26, w24, [x3]\n+ 884:   b83862fa        ldumax  w24, w26, [x23]\n+ 888:   b8af8075        swpa    w15, w21, [x3]\n+ 88c:   b8b80328        ldadda  w24, w8, [x25]\n+ 890:   b8b41230        ldclra  w20, w16, [x17]\n+ 894:   b8a22001        ldeora  w2, w1, [x0]\n+ 898:   b8b83064        ldseta  w24, w4, [x3]\n+ 89c:   b8ac539f        ldsmina w12, wzr, [x28]\n+ 8a0:   b8aa405a        ldsmaxa w10, w26, [x2]\n+ 8a4:   b8ac73f2        ldumina w12, w18, [sp]\n+ 8a8:   b8a163ad        ldumaxa w1, w13, [x29]\n+ 8ac:   b8e08193        swpal   w0, w19, [x12]\n+ 8b0:   b8f101b6        ldaddal w17, w22, [x13]\n+ 8b4:   b8fc13fe        ldclral w28, w30, [sp]\n+ 8b8:   b8e1239a        ldeoral w1, w26, [x28]\n+ 8bc:   b8e4309e        ldsetal w4, w30, [x4]\n+ 8c0:   b8e6535e        ldsminal        w6, w30, [x26]\n+ 8c4:   b8f24109        ldsmaxal        w18, w9, [x8]\n+ 8c8:   b8ec7280        lduminal        w12, w0, [x20]\n+ 8cc:   b8e16058        ldumaxal        w1, w24, [x2]\n+ 8d0:   b8608309        swpl    w0, w9, [x24]\n+ 8d4:   b87a03d0        ldaddl  w26, w16, [x30]\n+ 8d8:   b86312ea        ldclrl  w3, w10, [x23]\n+ 8dc:   b86a2244        ldeorl  w10, w4, [x18]\n+ 8e0:   b862310b        ldsetl  w2, w11, [x8]\n+ 8e4:   b86a522f        ldsminl w10, w15, [x17]\n+ 8e8:   b862418a        ldsmaxl w2, w10, [x12]\n+ 8ec:   b86c71af        lduminl w12, w15, [x13]\n+ 8f0:   b8626287        ldumaxl w2, w7, [x20]\n+ 8f4:   042401f9        add     z25.b, z15.b, z4.b\n+ 8f8:   04b10564        sub     z4.s, z11.s, z17.s\n+ 8fc:   65ca0230        fadd    z16.d, z17.d, z10.d\n+ 900:   65d90996        fmul    z22.d, z12.d, z25.d\n+ 904:   65ca05dc        fsub    z28.d, z14.d, z10.d\n+ 908:   0456afc1        abs     z1.h, p3\/m, z30.h\n+ 90c:   0400044f        add     z15.b, p1\/m, z15.b, z2.b\n+ 910:   0490920d        asr     z13.s, p4\/m, z13.s, z16.s\n+ 914:   04daa163        cnt     z3.d, p0\/m, z11.d\n+ 918:   04d389c5        lsl     z5.d, p2\/m, z5.d, z14.d\n+ 91c:   0411829d        lsr     z29.b, p0\/m, z29.b, z20.b\n+ 920:   04901774        mul     z20.s, p5\/m, z20.s, z27.s\n+ 924:   0417b89a        neg     z26.b, p6\/m, z4.b\n+ 928:   041eb3d6        not     z22.b, p4\/m, z30.b\n+ 92c:   04480b6b        smax    z11.h, p2\/m, z11.h, z27.h\n+ 930:   048a17dc        smin    z28.s, p5\/m, z28.s, z30.s\n+ 934:   048105be        sub     z30.s, p1\/m, z30.s, z13.s\n+ 938:   04dcb35e        fabs    z30.d, p4\/m, z26.d\n+ 93c:   65808d6f        fadd    z15.s, p3\/m, z15.s, z11.s\n+ 940:   65cd9e06        fdiv    z6.d, p7\/m, z6.d, z16.d\n+ 944:   65869cfb        fmax    z27.s, p7\/m, z27.s, z7.s\n+ 948:   65c78893        fmin    z19.d, p2\/m, z19.d, z4.d\n+ 94c:   658292d1        fmul    z17.s, p4\/m, z17.s, z22.s\n+ 950:   04ddaebc        fneg    z28.d, p3\/m, z21.d\n+ 954:   6582b452        frintm  z18.s, p5\/m, z2.s\n+ 958:   6580ade6        frintn  z6.s, p3\/m, z15.s\n+ 95c:   65c1b42c        frintp  z12.d, p5\/m, z1.d\n+ 960:   658da632        fsqrt   z18.s, p1\/m, z17.s\n+ 964:   658195af        fsub    z15.s, p5\/m, z15.s, z13.s\n+ 968:   65eb1f74        fmla    z20.d, p7\/m, z27.d, z11.d\n+ 96c:   65f723c3        fmls    z3.d, p0\/m, z30.d, z23.d\n+ 970:   65ba4b71        fnmla   z17.s, p2\/m, z27.s, z26.s\n+ 974:   65fe76c6        fnmls   z6.d, p5\/m, z22.d, z30.d\n+ 978:   04525f42        mla     z2.h, p7\/m, z26.h, z18.h\n+ 97c:   04117056        mls     z22.b, p4\/m, z2.b, z17.b\n+ 980:   04363338        and     z24.d, z25.d, z22.d\n+ 984:   04a33192        eor     z18.d, z12.d, z3.d\n+ 988:   0470339d        orr     z29.d, z28.d, z16.d\n+ 98c:   049a2b86        andv    s6, p2, z28.s\n+ 990:   045824e7        orv     h7, p1, z7.h\n+ 994:   04193509        eorv    b9, p5, z8.b\n+ 998:   040837db        smaxv   b27, p5, z30.b\n+ 99c:   044a221a        sminv   h26, p0, z16.h\n+ 9a0:   65c73903        fminv   d3, p6, z8.d\n+ 9a4:   65c63b55        fmaxv   d21, p6, z26.d\n+ 9a8:   65982096        fadda   s22, p0, s22, z4.s\n+ 9ac:   04412071        uaddv   d17, p0, z3.h\n@@ -1325,7 +1489,7 @@\n-    0x14000000,     0x17ffffd7,     0x140001f2,     0x94000000,\n-    0x97ffffd4,     0x940001ef,     0x3400000a,     0x34fffa2a,\n-    0x34003d8a,     0x35000008,     0x35fff9c8,     0x35003d28,\n-    0xb400000b,     0xb4fff96b,     0xb4003ccb,     0xb500001d,\n-    0xb5fff91d,     0xb5003c7d,     0x10000013,     0x10fff8b3,\n-    0x10003c13,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36303b96,     0x3758000c,     0x375ff7cc,     0x37583b2c,\n+    0x14000000,     0x17ffffd7,     0x14000242,     0x94000000,\n+    0x97ffffd4,     0x9400023f,     0x3400000a,     0x34fffa2a,\n+    0x3400478a,     0x35000008,     0x35fff9c8,     0x35004728,\n+    0xb400000b,     0xb4fff96b,     0xb40046cb,     0xb500001d,\n+    0xb5fff91d,     0xb500467d,     0x10000013,     0x10fff8b3,\n+    0x10004613,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36304596,     0x3758000c,     0x375ff7cc,     0x3758452c,\n@@ -1336,13 +1500,13 @@\n-    0x54003900,     0x54000001,     0x54fff541,     0x540038a1,\n-    0x54000002,     0x54fff4e2,     0x54003842,     0x54000002,\n-    0x54fff482,     0x540037e2,     0x54000003,     0x54fff423,\n-    0x54003783,     0x54000003,     0x54fff3c3,     0x54003723,\n-    0x54000004,     0x54fff364,     0x540036c4,     0x54000005,\n-    0x54fff305,     0x54003665,     0x54000006,     0x54fff2a6,\n-    0x54003606,     0x54000007,     0x54fff247,     0x540035a7,\n-    0x54000008,     0x54fff1e8,     0x54003548,     0x54000009,\n-    0x54fff189,     0x540034e9,     0x5400000a,     0x54fff12a,\n-    0x5400348a,     0x5400000b,     0x54fff0cb,     0x5400342b,\n-    0x5400000c,     0x54fff06c,     0x540033cc,     0x5400000d,\n-    0x54fff00d,     0x5400336d,     0x5400000e,     0x54ffefae,\n-    0x5400330e,     0x5400000f,     0x54ffef4f,     0x540032af,\n+    0x54004300,     0x54000001,     0x54fff541,     0x540042a1,\n+    0x54000002,     0x54fff4e2,     0x54004242,     0x54000002,\n+    0x54fff482,     0x540041e2,     0x54000003,     0x54fff423,\n+    0x54004183,     0x54000003,     0x54fff3c3,     0x54004123,\n+    0x54000004,     0x54fff364,     0x540040c4,     0x54000005,\n+    0x54fff305,     0x54004065,     0x54000006,     0x54fff2a6,\n+    0x54004006,     0x54000007,     0x54fff247,     0x54003fa7,\n+    0x54000008,     0x54fff1e8,     0x54003f48,     0x54000009,\n+    0x54fff189,     0x54003ee9,     0x5400000a,     0x54fff12a,\n+    0x54003e8a,     0x5400000b,     0x54fff0cb,     0x54003e2b,\n+    0x5400000c,     0x54fff06c,     0x54003dcc,     0x5400000d,\n+    0x54fff00d,     0x54003d6d,     0x5400000e,     0x54ffefae,\n+    0x54003d0e,     0x5400000f,     0x54ffef4f,     0x54003caf,\n@@ -1380,1 +1544,1 @@\n-    0xbd1b1869,     0x580022fb,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x58002cfb,     0x1800000b,     0xf8945060,\n@@ -1424,26 +1588,46 @@\n-    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n-    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n-    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n-    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n-    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n-    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n-    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n-    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n-    0xf8388098,     0xf8340010,     0xf8241175,     0xf83e22d0,\n-    0xf82432ef,     0xf83a5186,     0xf82f41ee,     0xf82973b9,\n-    0xf82b6194,     0xf8b28216,     0xf8b50358,     0xf8a61206,\n-    0xf8b02219,     0xf8bc3218,     0xf8ba514f,     0xf8ad428e,\n-    0xf8a173d7,     0xf8ae60c2,     0xf8e38328,     0xf8e003db,\n-    0xf8e513c5,     0xf8eb2019,     0xf8ff3260,     0xf8fd513a,\n-    0xf8fa41ec,     0xf8eb724b,     0xf8f96316,     0xf8608171,\n-    0xf86600dd,     0xf86512a5,     0xf8732250,     0xf87e339b,\n-    0xf861503c,     0xf874421d,     0xf86d73aa,     0xf87d62d3,\n-    0xb82a83e4,     0xb83503e8,     0xb833138a,     0xb82220b9,\n-    0xb82332c8,     0xb83350ad,     0xb83d42b8,     0xb83a7078,\n-    0xb83862fa,     0xb8af8075,     0xb8b80328,     0xb8b41230,\n-    0xb8a22001,     0xb8b83064,     0xb8ac539f,     0xb8aa405a,\n-    0xb8ac73f2,     0xb8a163ad,     0xb8e08193,     0xb8f101b6,\n-    0xb8fc13fe,     0xb8e1239a,     0xb8e4309e,     0xb8e6535e,\n-    0xb8f24109,     0xb8ec7280,     0xb8e16058,     0xb8608309,\n-    0xb87a03d0,     0xb86312ea,     0xb86a2244,     0xb862310b,\n-    0xb86a522f,     0xb862418a,     0xb86c71af,     0xb8626287,\n+    0x05a08020,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,\n+    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,\n+    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,\n+    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n+    0x25b8efe2,     0x25f8f007,     0xa400a3e0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe547e400,     0xe4014be0,\n+    0xe4a84fe0,     0xe5f25000,     0x858043e0,     0x85a043ff,\n+    0xe59f5d08,     0x1e601000,     0x1e603000,     0x1e621000,\n+    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n+    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n+    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n+    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n+    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n+    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n+    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n+    0x1e7e3000,     0xf8388098,     0xf8340010,     0xf8241175,\n+    0xf83e22d0,     0xf82432ef,     0xf83a5186,     0xf82f41ee,\n+    0xf82973b9,     0xf82b6194,     0xf8b28216,     0xf8b50358,\n+    0xf8a61206,     0xf8b02219,     0xf8bc3218,     0xf8ba514f,\n+    0xf8ad428e,     0xf8a173d7,     0xf8ae60c2,     0xf8e38328,\n+    0xf8e003db,     0xf8e513c5,     0xf8eb2019,     0xf8ff3260,\n+    0xf8fd513a,     0xf8fa41ec,     0xf8eb724b,     0xf8f96316,\n+    0xf8608171,     0xf86600dd,     0xf86512a5,     0xf8732250,\n+    0xf87e339b,     0xf861503c,     0xf874421d,     0xf86d73aa,\n+    0xf87d62d3,     0xb82a83e4,     0xb83503e8,     0xb833138a,\n+    0xb82220b9,     0xb82332c8,     0xb83350ad,     0xb83d42b8,\n+    0xb83a7078,     0xb83862fa,     0xb8af8075,     0xb8b80328,\n+    0xb8b41230,     0xb8a22001,     0xb8b83064,     0xb8ac539f,\n+    0xb8aa405a,     0xb8ac73f2,     0xb8a163ad,     0xb8e08193,\n+    0xb8f101b6,     0xb8fc13fe,     0xb8e1239a,     0xb8e4309e,\n+    0xb8e6535e,     0xb8f24109,     0xb8ec7280,     0xb8e16058,\n+    0xb8608309,     0xb87a03d0,     0xb86312ea,     0xb86a2244,\n+    0xb862310b,     0xb86a522f,     0xb862418a,     0xb86c71af,\n+    0xb8626287,     0x042401f9,     0x04b10564,     0x65ca0230,\n+    0x65d90996,     0x65ca05dc,     0x0456afc1,     0x0400044f,\n+    0x0490920d,     0x04daa163,     0x04d389c5,     0x0411829d,\n+    0x04901774,     0x0417b89a,     0x041eb3d6,     0x04480b6b,\n+    0x048a17dc,     0x048105be,     0x04dcb35e,     0x65808d6f,\n+    0x65cd9e06,     0x65869cfb,     0x65c78893,     0x658292d1,\n+    0x04ddaebc,     0x6582b452,     0x6580ade6,     0x65c1b42c,\n+    0x658da632,     0x658195af,     0x65eb1f74,     0x65f723c3,\n+    0x65ba4b71,     0x65fe76c6,     0x04525f42,     0x04117056,\n+    0x04363338,     0x04a33192,     0x0470339d,     0x049a2b86,\n+    0x045824e7,     0x04193509,     0x040837db,     0x044a221a,\n+    0x65c73903,     0x65c63b55,     0x65982096,     0x04412071,\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":363,"deletions":179,"binary":false,"changes":542,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+\/\/ Preserved predicate register with all elements set TRUE.\n+REGISTER_DECLARATION(PRegister, ptrue, p7);\n+\n@@ -276,0 +279,8 @@\n+  void prf(PRegister r, int lsb) {\n+    f(r->encoding_nocheck(), lsb + 3, lsb);\n+  }\n+\n+  void pgrf(PRegister r, int lsb) {\n+    f(r->encoding_nocheck(), lsb + 2, lsb);\n+  }\n+\n@@ -564,0 +575,12 @@\n+\n+  static bool offset_ok_for_sve_immed(long offset, int shift, int vl \/* sve vector length *\/) {\n+    if (offset % vl == 0) {\n+      \/\/ Convert address offset into sve imm offset (MUL VL).\n+      int sve_offset = offset \/ vl;\n+      if (((-(1 << (shift - 1))) <= sve_offset) && (sve_offset < (1 << (shift - 1)))) {\n+        \/\/ sve_offset can be encoded\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n@@ -687,0 +710,6 @@\n+  void prf(PRegister reg, int lsb) {\n+    current->prf(reg, lsb);\n+  }\n+  void pgrf(PRegister reg, int lsb) {\n+    current->pgrf(reg, lsb);\n+  }\n@@ -2476,5 +2505,6 @@\n-  void umov(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {\n-    starti;\n-    f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);\n-    f(((idx<<1)|1)<<(int)T, 20, 16), f(0b001111, 15, 10);\n-    rf(Vn, 5), rf(Rd, 0);\n+#define INSN(NAME, op)                                                     \\\n+  void NAME(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {   \\\n+    starti;                                                                \\\n+    f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);                   \\\n+    f(((idx<<1)|1)<<(int)T, 20, 16), f(op, 15, 10);                        \\\n+    rf(Vn, 5), rf(Rd, 0);                                                  \\\n@@ -2483,0 +2513,4 @@\n+  INSN(umov, 0b001111);\n+  INSN(smov, 0b001011);\n+#undef INSN\n+\n@@ -2714,1 +2748,1 @@\n-void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)\n+  void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)\n@@ -2724,0 +2758,286 @@\n+\/\/ SVE arithmetics - unpredicated\n+#define INSN(NAME, opcode)                                                             \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid register variant\");                                        \\\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(1, 21),                                     \\\n+    rf(Zm, 16), f(0, 15, 13), f(opcode, 12, 10), rf(Zn, 5), rf(Zd, 0);                 \\\n+  }\n+  INSN(sve_add, 0b000);\n+  INSN(sve_sub, 0b001);\n+#undef INSN\n+\n+\/\/ SVE floating-point arithmetic - unpredicated\n+#define INSN(NAME, opcode)                                                             \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T == S || T == D, \"invalid register variant\");                              \\\n+    f(0b01100101, 31, 24), f(T, 23, 22), f(0, 21),                                     \\\n+    rf(Zm, 16), f(0, 15, 13), f(opcode, 12, 10), rf(Zn, 5), rf(Zd, 0);                 \\\n+  }\n+\n+  INSN(sve_fadd, 0b000);\n+  INSN(sve_fmul, 0b010);\n+  INSN(sve_fsub, 0b001);\n+#undef INSN\n+\n+private:\n+  void sve_predicate_reg_insn(unsigned op24, unsigned op13,\n+                              FloatRegister Zd_or_Vd, SIMD_RegVariant T,\n+                              PRegister Pg, FloatRegister Zn_or_Vn) {\n+    starti;\n+    f(op24, 31, 24), f(T, 23, 22), f(op13, 21, 13);\n+    pgrf(Pg, 10), rf(Zn_or_Vn, 5), rf(Zd_or_Vd, 0);\n+  }\n+\n+public:\n+\n+\/\/ SVE integer arithmetics - predicate\n+#define INSN(NAME, op1, op2)                                                                            \\\n+  void NAME(FloatRegister Zdn_or_Zd_or_Vd, SIMD_RegVariant T, PRegister Pg, FloatRegister Znm_or_Vn) {  \\\n+    assert(T != Q, \"invalid register variant\");                                                         \\\n+    sve_predicate_reg_insn(op1, op2, Zdn_or_Zd_or_Vd, T, Pg, Znm_or_Vn);                                \\\n+  }\n+\n+  INSN(sve_abs,  0b00000100, 0b010110101); \/\/ vector abs, unary\n+  INSN(sve_add,  0b00000100, 0b000000000); \/\/ vector add\n+  INSN(sve_andv, 0b00000100, 0b011010001); \/\/ bitwise and reduction to scalar\n+  INSN(sve_asr,  0b00000100, 0b010000100); \/\/ vector arithmetic shift right\n+  INSN(sve_cnt,  0b00000100, 0b011010101)  \/\/ count non-zero bits\n+  INSN(sve_cpy,  0b00000101, 0b100000100); \/\/ copy scalar to each active vector element\n+  INSN(sve_eorv, 0b00000100, 0b011001001); \/\/ bitwise xor reduction to scalar\n+  INSN(sve_lsl,  0b00000100, 0b010011100); \/\/ vector logical shift left\n+  INSN(sve_lsr,  0b00000100, 0b010001100); \/\/ vector logical shift right\n+  INSN(sve_mul,  0b00000100, 0b010000000); \/\/ vector mul\n+  INSN(sve_neg,  0b00000100, 0b010111101); \/\/ vector neg, unary\n+  INSN(sve_not,  0b00000100, 0b011110101); \/\/ bitwise invert vector, unary\n+  INSN(sve_orv,  0b00000100, 0b011000001); \/\/ bitwise or reduction to scalar\n+  INSN(sve_smax, 0b00000100, 0b001000000); \/\/ signed maximum vectors\n+  INSN(sve_smaxv, 0b00000100, 0b001000001); \/\/ signed maximum reduction to scalar\n+  INSN(sve_smin,  0b00000100, 0b001010000); \/\/ signed minimum vectors\n+  INSN(sve_sminv, 0b00000100, 0b001010001); \/\/ signed minimum reduction to scalar\n+  INSN(sve_sub,   0b00000100, 0b000001000); \/\/ vector sub\n+  INSN(sve_uaddv, 0b00000100, 0b000001001); \/\/ unsigned add reduction to scalar\n+#undef INSN\n+\n+\/\/ SVE floating-point arithmetics - predicate\n+#define INSN(NAME, op1, op2)                                                                          \\\n+  void NAME(FloatRegister Zd_or_Zdn_or_Vd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn_or_Zm) { \\\n+    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    sve_predicate_reg_insn(op1, op2, Zd_or_Zdn_or_Vd, T, Pg, Zn_or_Zm);                               \\\n+  }\n+\n+  INSN(sve_fabs,    0b00000100, 0b011100101);\n+  INSN(sve_fadd,    0b01100101, 0b000000100);\n+  INSN(sve_fadda,   0b01100101, 0b011000001); \/\/ add strictly-ordered reduction to scalar Vd\n+  INSN(sve_fdiv,    0b01100101, 0b001101100);\n+  INSN(sve_fmax,    0b01100101, 0b000110100); \/\/ floating-point maximum\n+  INSN(sve_fmaxv,   0b01100101, 0b000110001); \/\/ floating-point maximum recursive reduction to scalar\n+  INSN(sve_fmin,    0b01100101, 0b000111100); \/\/ floating-point minimum\n+  INSN(sve_fminv,   0b01100101, 0b000111001); \/\/ floating-point minimum recursive reduction to scalar\n+  INSN(sve_fmul,    0b01100101, 0b000010100);\n+  INSN(sve_fneg,    0b00000100, 0b011101101);\n+  INSN(sve_frintm,  0b01100101, 0b000010101); \/\/ floating-point round to integral value, toward minus infinity\n+  INSN(sve_frintn,  0b01100101, 0b000000101); \/\/ floating-point round to integral value, nearest with ties to even\n+  INSN(sve_frintp,  0b01100101, 0b000001101); \/\/ floating-point round to integral value, toward plus infinity\n+  INSN(sve_fsqrt,   0b01100101, 0b001101101);\n+  INSN(sve_fsub,    0b01100101, 0b000001100);\n+#undef INSN\n+\n+  \/\/ SVE multiple-add\/sub - predicated\n+#define INSN(NAME, op0, op1, op2)                                                                     \\\n+  void NAME(FloatRegister Zda, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                                           \\\n+    assert(T != Q, \"invalid size\");                                                                   \\\n+    f(op0, 31, 24), f(T, 23, 22), f(op1, 21), rf(Zm, 16);                                             \\\n+    f(op2, 15, 13), pgrf(Pg, 10), rf(Zn, 5), rf(Zda, 0);                                              \\\n+  }\n+\n+  INSN(sve_fmla,  0b01100101, 1, 0b000); \/\/ floating-point fused multiply-add: Zda = Zda + Zn * Zm\n+  INSN(sve_fmls,  0b01100101, 1, 0b001); \/\/ floating-point fused multiply-subtract: Zda = Zda + -Zn * Zm\n+  INSN(sve_fnmla, 0b01100101, 1, 0b010); \/\/ floating-point negated fused multiply-add: Zda = -Zda + -Zn * Zm\n+  INSN(sve_fnmls, 0b01100101, 1, 0b011); \/\/ floating-point negated fused multiply-subtract: Zda = -Zda + Zn * Zm\n+  INSN(sve_mla,   0b00000100, 0, 0b010); \/\/ multiply-add: Zda = Zda + Zn*Zm\n+  INSN(sve_mls,   0b00000100, 0, 0b011); \/\/ multiply-subtract: Zda = Zda + -Zn*Zm\n+#undef INSN\n+\n+\/\/ SVE bitwise logical - unpredicated\n+#define INSN(NAME, opc)                                              \\\n+  void NAME(FloatRegister Zd, FloatRegister Zn, FloatRegister Zm) {  \\\n+    starti;                                                          \\\n+    f(0b00000100, 31, 24), f(opc, 23, 22), f(1, 21),                 \\\n+    rf(Zm, 16), f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);           \\\n+  }\n+  INSN(sve_and, 0b00);\n+  INSN(sve_eor, 0b10);\n+  INSN(sve_orr, 0b01);\n+#undef INSN\n+\n+\/\/ SVE shift immediate - unpredicated\n+#define INSN(NAME, opc, isSHR)                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, int shift) { \\\n+    starti;                                                                     \\\n+    \/* The encodings for the tszh:tszl:imm3 fields (bits 23:22 20:19 18:16)     \\\n+     * for shift right is calculated as:                                        \\\n+     *   0001 xxx       B, shift = 16  - UInt(tszh:tszl:imm3)                   \\\n+     *   001x xxx       H, shift = 32  - UInt(tszh:tszl:imm3)                   \\\n+     *   01xx xxx       S, shift = 64  - UInt(tszh:tszl:imm3)                   \\\n+     *   1xxx xxx       D, shift = 128 - UInt(tszh:tszl:imm3)                   \\\n+     * for shift left is calculated as:                                         \\\n+     *   0001 xxx       B, shift = UInt(tszh:tszl:imm3) - 8                     \\\n+     *   001x xxx       H, shift = UInt(tszh:tszl:imm3) - 16                    \\\n+     *   01xx xxx       S, shift = UInt(tszh:tszl:imm3) - 32                    \\\n+     *   1xxx xxx       D, shift = UInt(tszh:tszl:imm3) - 64                    \\\n+     *\/                                                                         \\\n+    assert(T != Q, \"Invalid register variant\");                                 \\\n+    if (isSHR) {                                                                \\\n+      assert(((1 << (T + 3)) >= shift) && (shift > 0) , \"Invalid shift value\"); \\\n+    } else {                                                                    \\\n+      assert(((1 << (T + 3)) > shift) && (shift >= 0) , \"Invalid shift value\"); \\\n+    }                                                                           \\\n+    int cVal = (1 << ((T + 3) + (isSHR ? 1 : 0)));                              \\\n+    int encodedShift = isSHR ? cVal - shift : cVal + shift;                     \\\n+    int tszh = encodedShift >> 5;                                               \\\n+    int tszl_imm = encodedShift & 0x1f;                                         \\\n+    f(0b00000100, 31, 24);                                                      \\\n+    f(tszh, 23, 22), f(1,21), f(tszl_imm, 20, 16);                              \\\n+    f(0b100, 15, 13), f(opc, 12, 10), rf(Zn, 5), rf(Zd, 0);                     \\\n+  }\n+\n+  INSN(sve_asr, 0b100, \/* isSHR = *\/ true);\n+  INSN(sve_lsl, 0b111, \/* isSHR = *\/ false);\n+  INSN(sve_lsr, 0b101, \/* isSHR = *\/ true);\n+#undef INSN\n+\n+private:\n+\n+  \/\/ Scalar base + immediate index\n+  void sve_ld_st1(FloatRegister Zt, Register Xn, int imm, PRegister Pg,\n+              SIMD_RegVariant T, int op1, int type, int op2) {\n+    starti;\n+    assert_cond(T >= type);\n+    f(op1, 31, 25), f(type, 24, 23), f(T, 22, 21);\n+    f(0, 20), sf(imm, 19, 16), f(op2, 15, 13);\n+    pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);\n+  }\n+\n+  \/\/ Scalar base + scalar index\n+  void sve_ld_st1(FloatRegister Zt, Register Xn, Register Xm, PRegister Pg,\n+              SIMD_RegVariant T, int op1, int type, int op2) {\n+    starti;\n+    assert_cond(T >= type);\n+    f(op1, 31, 25), f(type, 24, 23), f(T, 22, 21);\n+    rf(Xm, 16), f(op2, 15, 13);\n+    pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);\n+  }\n+\n+  void sve_ld_st1(FloatRegister Zt, PRegister Pg,\n+              SIMD_RegVariant T, const Address &a,\n+              int op1, int type, int imm_op2, int scalar_op2) {\n+    switch (a.getMode()) {\n+    case Address::base_plus_offset:\n+      sve_ld_st1(Zt, a.base(), a.offset(), Pg, T, op1, type, imm_op2);\n+      break;\n+    case Address::base_plus_offset_reg:\n+      sve_ld_st1(Zt, a.base(), a.index(), Pg, T, op1, type, scalar_op2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+public:\n+\n+\/\/ SVE load\/store - predicated\n+#define INSN(NAME, op1, type, imm_op2, scalar_op2)                                   \\\n+  void NAME(FloatRegister Zt, SIMD_RegVariant T, PRegister Pg, const Address &a) {   \\\n+    assert(T != Q, \"invalid register variant\");                                      \\\n+    sve_ld_st1(Zt, Pg, T, a, op1, type, imm_op2, scalar_op2);                        \\\n+  }\n+\n+  INSN(sve_ld1b, 0b1010010, 0b00, 0b101, 0b010);\n+  INSN(sve_st1b, 0b1110010, 0b00, 0b111, 0b010);\n+  INSN(sve_ld1h, 0b1010010, 0b01, 0b101, 0b010);\n+  INSN(sve_st1h, 0b1110010, 0b01, 0b111, 0b010);\n+  INSN(sve_ld1w, 0b1010010, 0b10, 0b101, 0b010);\n+  INSN(sve_st1w, 0b1110010, 0b10, 0b111, 0b010);\n+  INSN(sve_ld1d, 0b1010010, 0b11, 0b101, 0b010);\n+  INSN(sve_st1d, 0b1110010, 0b11, 0b111, 0b010);\n+#undef INSN\n+\n+\/\/ SVE load\/store - unpredicated\n+#define INSN(NAME, op1)                                                         \\\n+  void NAME(FloatRegister Zt, const Address &a)  {                              \\\n+    starti;                                                                     \\\n+    assert(a.index() == noreg, \"invalid address variant\");                      \\\n+    f(op1, 31, 29), f(0b0010110, 28, 22), sf(a.offset() >> 3, 21, 16),          \\\n+    f(0b010, 15, 13), f(a.offset() & 0x7, 12, 10), srf(a.base(), 5), rf(Zt, 0); \\\n+  }\n+\n+  INSN(sve_ldr, 0b100); \/\/ LDR (vector)\n+  INSN(sve_str, 0b111); \/\/ STR (vector)\n+#undef INSN\n+\n+#define INSN(NAME, op) \\\n+  void NAME(Register Xd, Register Xn, int imm6) {                 \\\n+    starti;                                                       \\\n+    f(0b000001000, 31, 23), f(op, 22, 21);                        \\\n+    srf(Xn, 16), f(0b01010, 15, 11), sf(imm6, 10, 5), srf(Xd, 0); \\\n+  }\n+\n+  INSN(sve_addvl, 0b01);\n+  INSN(sve_addpl, 0b11);\n+#undef INSN\n+\n+\/\/ SVE inc\/dec register by element count\n+#define INSN(NAME, op) \\\n+  void NAME(Register Xdn, SIMD_RegVariant T, unsigned imm4 = 1, int pattern = 0b11111) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    f(0b00000100,31, 24), f(T, 23, 22), f(0b11, 21, 20);                                 \\\n+    f(imm4 - 1, 19, 16), f(0b11100, 15, 11), f(op, 10), f(pattern, 9, 5), rf(Xdn, 0);    \\\n+  }\n+\n+  INSN(sve_inc, 0);\n+  INSN(sve_dec, 1);\n+#undef INSN\n+\n+  \/\/ SVE predicate count\n+  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n+    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n+  }\n+\n+  \/\/ SVE dup scalar\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, Register Rn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b100000001110, 21, 10);\n+    srf(Rn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE dup imm\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    if (imm8 <= 127 && imm8 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+      sh = 1;\n+      imm8 = (imm8 >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b11100011, 21, 14);\n+    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+  }\n+\n+  void sve_ptrue(PRegister pd, SIMD_RegVariant esize, int pattern = 0b11111) {\n+    starti;\n+    f(0b00100101, 31, 24), f(esize, 23, 22), f(0b011000111000, 21, 10);\n+    f(pattern, 9, 5), f(0b0, 4), prf(pd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":326,"deletions":6,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -305,5 +305,1 @@\n-    \/\/ Save possibly live regs.\n-    RegSet live_regs = RegSet::range(r0, r4) - dst;\n-    __ push(live_regs, sp);\n-    __ strd(v0, __ pre(sp, 2 * -wordSize));\n-\n+    __ push_call_clobbered_registers();\n@@ -311,4 +307,1 @@\n-\n-    \/\/ Restore possibly live regs.\n-    __ ldrd(v0, __ post(sp, 2 * wordSize));\n-    __ pop(live_regs, sp);\n+    __ pop_call_clobbered_registers();\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -434,0 +434,5 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -435,1 +440,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -30,0 +32,4 @@\n+#ifdef LINUX\n+#include <sys\/mman.h>\n+#endif \/\/ LINUX\n+\n@@ -138,0 +144,54 @@\n+\/\/ Default value if probing is not implemented for a certain platform: 128TB\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+\/\/ Minimum value returned, if probing fails: 64GB\n+static const size_t MINIMUM_MAX_ADDRESS_BIT = 36;\n+\n+static size_t probe_valid_max_address_bit() {\n+#ifdef LINUX\n+  size_t max_address_bit = 0;\n+  const size_t page_size = os::vm_page_size();\n+  for (size_t i = DEFAULT_MAX_ADDRESS_BIT; i > MINIMUM_MAX_ADDRESS_BIT; --i) {\n+    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n+    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n+      \/\/ msync suceeded, the address is valid, and maybe even already mapped.\n+      max_address_bit = i;\n+      break;\n+    }\n+    if (errno != ENOMEM) {\n+      \/\/ Some error occured. This should never happen, but msync\n+      \/\/ has some undefined behavior, hence ignore this bit.\n+#ifdef ASSERT\n+      fatal(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n+#else \/\/ ASSERT\n+      log_warning_p(gc)(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n+#endif \/\/ ASSERT\n+      continue;\n+    }\n+    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n+    \/\/ Try to map it, to see if the address is valid.\n+    void* const result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+    if (result_addr != MAP_FAILED) {\n+      munmap(result_addr, page_size);\n+    }\n+    if ((uintptr_t) result_addr == base_addr) {\n+      \/\/ address is valid\n+      max_address_bit = i;\n+      break;\n+    }\n+  }\n+  if (max_address_bit == 0) {\n+    \/\/ probing failed, allocate a very high page and take that bit as the maximum\n+    const uintptr_t high_addr = ((uintptr_t) 1U) << DEFAULT_MAX_ADDRESS_BIT;\n+    void* const result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+    if (result_addr != MAP_FAILED) {\n+      max_address_bit = BitsPerSize_t - count_leading_zeros((size_t) result_addr) - 1;\n+      munmap(result_addr, page_size);\n+    }\n+  }\n+  log_info_p(gc, init)(\"Probing address space for the highest valid bit: \" SIZE_FORMAT, max_address_bit);\n+  return MAX2(max_address_bit, MINIMUM_MAX_ADDRESS_BIT);\n+#else \/\/ LINUX\n+  return DEFAULT_MAX_ADDRESS_BIT;\n+#endif \/\/ LINUX\n+}\n+\n@@ -139,2 +199,3 @@\n-  const size_t min_address_offset_bits = 42; \/\/ 4TB\n-  const size_t max_address_offset_bits = 44; \/\/ 16TB\n+  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n+  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const size_t min_address_offset_bits = max_address_offset_bits - 2;\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zGlobals_aarch64.cpp","additions":63,"deletions":2,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+  product(uint, UseSVE, 0,                                              \\\n+          \"Highest supported SVE instruction set version\")              \\\n+          range(0, 2)                                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2120,1 +2120,1 @@\n-\/\/ Return the number of words pushed\n+\/\/ Return the number of dwords pushed\n@@ -2123,0 +2123,7 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2137,0 +2144,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(stack, stack, sve_vector_size_in_bytes * count);\n+    for (int i = 0; i < count; i++) {\n+      sve_str(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2139,1 +2156,1 @@\n-    return 1;\n+    return 2;\n@@ -2160,1 +2177,1 @@\n-  return count;\n+  return count * 2;\n@@ -2163,0 +2180,1 @@\n+\/\/ Return the number of dwords poped\n@@ -2165,0 +2183,2 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n@@ -2166,0 +2186,4 @@\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2179,0 +2203,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = count - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    add(stack, stack, sve_vector_size_in_bytes * count);\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2181,1 +2215,1 @@\n-    return 1;\n+    return 2;\n@@ -2202,1 +2236,1 @@\n-  return count;\n+  return count * 2;\n@@ -2650,2 +2684,2 @@\n-void MacroAssembler::push_CPU_state(bool save_vectors) {\n-  int step = (save_vectors ? 8 : 4) * wordSize;\n+void MacroAssembler::push_CPU_state(bool save_vectors, bool use_sve,\n+                                    int sve_vector_size_in_bytes) {\n@@ -2653,5 +2687,14 @@\n-  mov(rscratch1, -step);\n-  sub(sp, sp, step);\n-  for (int i = 28; i >= 4; i -= 4) {\n-    st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+  if (save_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+    for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+      sve_str(as_FloatRegister(i), Address(sp, i));\n+    }\n+  } else {\n+    int step = (save_vectors ? 8 : 4) * wordSize;\n+    mov(rscratch1, -step);\n+    sub(sp, sp, step);\n+    for (int i = 28; i >= 4; i -= 4) {\n+      st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+    }\n+    st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2659,1 +2702,0 @@\n-  st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2662,5 +2704,13 @@\n-void MacroAssembler::pop_CPU_state(bool restore_vectors) {\n-  int step = (restore_vectors ? 8 : 4) * wordSize;\n-  for (int i = 0; i <= 28; i += 4)\n-    ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+void MacroAssembler::pop_CPU_state(bool restore_vectors, bool use_sve,\n+                                   int sve_vector_size_in_bytes) {\n+  if (restore_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = FloatRegisterImpl::number_of_registers - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(i), Address(sp, i));\n+    }\n+    add(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+  } else {\n+    int step = (restore_vectors ? 8 : 4) * wordSize;\n+    for (int i = 0; i <= 28; i += 4)\n+      ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+  }\n@@ -2715,0 +2765,15 @@\n+Address MacroAssembler::sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp) {\n+  assert(offset >= 0, \"spill to negative address?\");\n+\n+  Register base = sp;\n+\n+  \/\/ An immediate offset in the range 0 to 255 which is multiplied\n+  \/\/ by the current vector or predicate register size in bytes.\n+  if (offset % sve_reg_size_in_bytes == 0 && offset < ((1<<8)*sve_reg_size_in_bytes)) {\n+    return Address(base, offset \/ sve_reg_size_in_bytes);\n+  }\n+\n+  add(tmp, base, offset);\n+  return Address(tmp);\n+}\n+\n@@ -5224,0 +5289,21 @@\n+\n+void MacroAssembler::verify_sve_vector_length() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  movw(rscratch1, zr);\n+  sve_inc(rscratch1, B);\n+  subsw(zr, rscratch1, VM_Version::get_initial_sve_vector_length());\n+  br(EQ, verify_ok);\n+  stop(\"Error: SVE vector length has changed since jvm startup\");\n+  bind(verify_ok);\n+}\n+\n+void MacroAssembler::verify_ptrue() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  sve_cntp(rscratch1, B, ptrue, ptrue); \/\/ get true elements count.\n+  sve_dec(rscratch1, B);\n+  cbz(rscratch1, verify_ok);\n+  stop(\"Error: the preserved predicate register (p7) elements are not all true\");\n+  bind(verify_ok);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":104,"deletions":18,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -876,2 +876,4 @@\n-  void push_CPU_state(bool save_vectors = false);\n-  void pop_CPU_state(bool restore_vectors = false) ;\n+  void push_CPU_state(bool save_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n+  void pop_CPU_state(bool restore_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n@@ -957,0 +959,5 @@\n+  void verify_sve_vector_length();\n+  void reinitialize_ptrue() {\n+    sve_ptrue(ptrue, B);\n+  }\n+  void verify_ptrue();\n@@ -1306,0 +1313,1 @@\n+  Address sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp=rscratch2);\n@@ -1329,0 +1337,3 @@\n+  void spill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_str(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1339,0 +1350,3 @@\n+  void unspill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_ldr(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1352,1 +1366,9 @@\n-\n+  void spill_copy_sve_vector_stack_to_stack(int src_offset, int dst_offset,\n+                                            int sve_vec_reg_size_in_bytes) {\n+    assert(sve_vec_reg_size_in_bytes % 16 == 0, \"unexpected sve vector reg size\");\n+    for (int i = 0; i < sve_vec_reg_size_in_bytes \/ 16; i++) {\n+      spill_copy128(src_offset, dst_offset);\n+      src_offset += 16;\n+      dst_offset += 16;\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n@@ -36,0 +36,3 @@\n+const int ConcreteRegisterImpl::max_pr\n+  = ConcreteRegisterImpl::max_fpr + PRegisterImpl::number_of_registers;\n+\n@@ -57,0 +60,8 @@\n+\n+const char* PRegisterImpl::name() const {\n+  const char* names[number_of_registers] = {\n+    \"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+    \"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\"\n+  };\n+  return is_valid() ? names[encoding()] : \"noreg\";\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-    max_slots_per_register = 4,\n+    max_slots_per_register = 8,\n@@ -134,1 +134,2 @@\n-    extra_save_slots_per_register = max_slots_per_register - save_slots_per_register\n+    slots_per_neon_register = 4,\n+    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register\n@@ -190,0 +191,82 @@\n+\/\/ SVE vector registers, shared with the SIMD&FP v0-v31. Vn maps to Zn[127:0].\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z0     , ( 0));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z1     , ( 1));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z2     , ( 2));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z3     , ( 3));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z4     , ( 4));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z5     , ( 5));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z6     , ( 6));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z7     , ( 7));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z8     , ( 8));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z9     , ( 9));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z10    , (10));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z11    , (11));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z12    , (12));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z13    , (13));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z14    , (14));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z15    , (15));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z16    , (16));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z17    , (17));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z18    , (18));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z19    , (19));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z20    , (20));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z21    , (21));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z22    , (22));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z23    , (23));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z24    , (24));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z25    , (25));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z26    , (26));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z27    , (27));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z28    , (28));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z29    , (29));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z30    , (30));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z31    , (31));\n+\n+\n+class PRegisterImpl;\n+typedef PRegisterImpl* PRegister;\n+inline PRegister as_PRegister(int encoding) {\n+  return (PRegister)(intptr_t)encoding;\n+}\n+\n+\/\/ The implementation of predicate registers for the architecture\n+class PRegisterImpl: public AbstractRegisterImpl {\n+ public:\n+  enum {\n+    number_of_registers = 16,\n+    max_slots_per_register = 1\n+  };\n+\n+  \/\/ construction\n+  inline friend PRegister as_PRegister(int encoding);\n+\n+  VMReg as_VMReg();\n+\n+  \/\/ derived registers, offsets, and addresses\n+  PRegister successor() const     { return as_PRegister(encoding() + 1); }\n+\n+  \/\/ accessors\n+  int   encoding() const          { assert(is_valid(), \"invalid register\"); return (intptr_t)this; }\n+  int   encoding_nocheck() const  { return (intptr_t)this; }\n+  bool  is_valid() const          { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }\n+  const char* name() const;\n+};\n+\n+\/\/ The predicate registers of SVE.\n+CONSTANT_REGISTER_DECLARATION(PRegister, p0,  ( 0));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p1,  ( 1));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p2,  ( 2));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p3,  ( 3));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p4,  ( 4));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p5,  ( 5));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p6,  ( 6));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p7,  ( 7));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p8,  ( 8));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p9,  ( 9));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p10, (10));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p11, (11));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p12, (12));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p13, (13));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p14, (14));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p15, (15));\n+\n@@ -202,0 +285,1 @@\n+                           PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers +\n@@ -208,0 +292,1 @@\n+  static const int max_pr;\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":88,"deletions":3,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,52 @@\n+\n+REGISTER_DEFINITION(FloatRegister, z0);\n+REGISTER_DEFINITION(FloatRegister, z1);\n+REGISTER_DEFINITION(FloatRegister, z2);\n+REGISTER_DEFINITION(FloatRegister, z3);\n+REGISTER_DEFINITION(FloatRegister, z4);\n+REGISTER_DEFINITION(FloatRegister, z5);\n+REGISTER_DEFINITION(FloatRegister, z6);\n+REGISTER_DEFINITION(FloatRegister, z7);\n+REGISTER_DEFINITION(FloatRegister, z8);\n+REGISTER_DEFINITION(FloatRegister, z9);\n+REGISTER_DEFINITION(FloatRegister, z10);\n+REGISTER_DEFINITION(FloatRegister, z11);\n+REGISTER_DEFINITION(FloatRegister, z12);\n+REGISTER_DEFINITION(FloatRegister, z13);\n+REGISTER_DEFINITION(FloatRegister, z14);\n+REGISTER_DEFINITION(FloatRegister, z15);\n+REGISTER_DEFINITION(FloatRegister, z16);\n+REGISTER_DEFINITION(FloatRegister, z17);\n+REGISTER_DEFINITION(FloatRegister, z18);\n+REGISTER_DEFINITION(FloatRegister, z19);\n+REGISTER_DEFINITION(FloatRegister, z20);\n+REGISTER_DEFINITION(FloatRegister, z21);\n+REGISTER_DEFINITION(FloatRegister, z22);\n+REGISTER_DEFINITION(FloatRegister, z23);\n+REGISTER_DEFINITION(FloatRegister, z24);\n+REGISTER_DEFINITION(FloatRegister, z25);\n+REGISTER_DEFINITION(FloatRegister, z26);\n+REGISTER_DEFINITION(FloatRegister, z27);\n+REGISTER_DEFINITION(FloatRegister, z28);\n+REGISTER_DEFINITION(FloatRegister, z29);\n+REGISTER_DEFINITION(FloatRegister, z30);\n+REGISTER_DEFINITION(FloatRegister, z31);\n+\n+REGISTER_DEFINITION(PRegister, p0);\n+REGISTER_DEFINITION(PRegister, p1);\n+REGISTER_DEFINITION(PRegister, p2);\n+REGISTER_DEFINITION(PRegister, p3);\n+REGISTER_DEFINITION(PRegister, p4);\n+REGISTER_DEFINITION(PRegister, p5);\n+REGISTER_DEFINITION(PRegister, p6);\n+REGISTER_DEFINITION(PRegister, p7);\n+REGISTER_DEFINITION(PRegister, p8);\n+REGISTER_DEFINITION(PRegister, p9);\n+REGISTER_DEFINITION(PRegister, p10);\n+REGISTER_DEFINITION(PRegister, p11);\n+REGISTER_DEFINITION(PRegister, p12);\n+REGISTER_DEFINITION(PRegister, p13);\n+REGISTER_DEFINITION(PRegister, p14);\n+REGISTER_DEFINITION(PRegister, p15);\n+\n+REGISTER_DEFINITION(PRegister, ptrue);\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -118,0 +118,10 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+  int sve_vector_size_in_slots = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+  sve_vector_size_in_slots = Matcher::scalable_vector_reg_size(T_FLOAT);\n+#endif\n+\n@@ -120,0 +130,2 @@\n+    int vect_words = 0;\n+    int extra_save_slots_per_register = 0;\n@@ -121,2 +133,7 @@\n-    int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register \/\n-                     VMRegImpl::slots_per_word;\n+    if (use_sve) {\n+      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegisterImpl::save_slots_per_register;\n+    } else {\n+      extra_save_slots_per_register = FloatRegisterImpl::extra_save_slots_per_neon_register;\n+    }\n+    vect_words = FloatRegisterImpl::number_of_registers * extra_save_slots_per_register \/\n+                 VMRegImpl::slots_per_word;\n@@ -141,1 +158,1 @@\n-  __ push_CPU_state(save_vectors);\n+  __ push_CPU_state(save_vectors, use_sve, sve_vector_size_in_bytes);\n@@ -165,2 +182,7 @@\n-    int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :\n-                                   (FloatRegisterImpl::save_slots_per_register * i);\n+    int sp_offset = 0;\n+    if (save_vectors) {\n+      sp_offset = use_sve ? (sve_vector_size_in_slots * i) :\n+                            (FloatRegisterImpl::slots_per_neon_register * i);\n+    } else {\n+      sp_offset = FloatRegisterImpl::save_slots_per_register * i;\n+    }\n@@ -175,1 +197,5 @@\n-#if !COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n+  __ pop_CPU_state(restore_vectors, Matcher::supports_scalable_vector(),\n+                   Matcher::scalable_vector_reg_size(T_BYTE));\n+#else\n+#if !INCLUDE_JVMCI\n@@ -179,0 +205,1 @@\n+#endif\n@@ -1845,0 +1872,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n@@ -2777,0 +2809,6 @@\n+  if (UseSVE > 0 && save_vectors) {\n+    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+    __ reinitialize_ptrue();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -491,0 +491,5 @@\n+    if (UseSVE > 0 ) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -5021,0 +5026,6 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1375,0 +1375,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -39,1 +40,0 @@\n-#include <sys\/auxv.h>\n@@ -41,0 +41,2 @@\n+#include <sys\/auxv.h>\n+#include <sys\/prctl.h>\n@@ -70,0 +72,14 @@\n+#ifndef HWCAP_SVE\n+#define HWCAP_SVE (1 << 22)\n+#endif\n+\n+#ifndef HWCAP2_SVE2\n+#define HWCAP2_SVE2 (1 << 1)\n+#endif\n+\n+#ifndef PR_SVE_GET_VL\n+\/\/ For old toolchains which do not have SVE related macros defined.\n+#define PR_SVE_SET_VL   50\n+#define PR_SVE_GET_VL   51\n+#endif\n+\n@@ -77,0 +93,1 @@\n+int VM_Version::_initial_sve_vector_length;\n@@ -119,1 +136,0 @@\n-\n@@ -170,0 +186,1 @@\n+  uint64_t auxv2 = getauxval(AT_HWCAP2);\n@@ -301,0 +318,2 @@\n+  if (auxv & HWCAP_SVE) strcat(buf, \", sve\");\n+  if (auxv2 & HWCAP2_SVE2) strcat(buf, \", sve2\");\n@@ -440,0 +459,12 @@\n+  if (auxv & HWCAP_SVE) {\n+    if (FLAG_IS_DEFAULT(UseSVE)) {\n+      FLAG_SET_DEFAULT(UseSVE, (auxv2 & HWCAP2_SVE2) ? 2 : 1);\n+    }\n+    if (UseSVE > 0) {\n+      _initial_sve_vector_length = prctl(PR_SVE_GET_VL);\n+    }\n+  } else if (UseSVE > 0) {\n+    warning(\"UseSVE specified, but not supported on current CPU. Disabling SVE.\");\n+    FLAG_SET_DEFAULT(UseSVE, 0);\n+  }\n+\n@@ -474,0 +505,44 @@\n+  if (UseSVE > 0) {\n+    if (FLAG_IS_DEFAULT(MaxVectorSize)) {\n+      MaxVectorSize = _initial_sve_vector_length;\n+    } else if (MaxVectorSize < 16) {\n+      warning(\"SVE does not support vector length less than 16 bytes. Disabling SVE.\");\n+      UseSVE = 0;\n+    } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {\n+      int new_vl = prctl(PR_SVE_SET_VL, MaxVectorSize);\n+      _initial_sve_vector_length = new_vl;\n+      \/\/ If MaxVectorSize is larger than system largest supported SVE vector length, above prctl()\n+      \/\/ call will set task vector length to the system largest supported value. So, we also update\n+      \/\/ MaxVectorSize to that largest supported value.\n+      if (new_vl < 0) {\n+        vm_exit_during_initialization(\n+          err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n+                  (int)MaxVectorSize));\n+      } else if (new_vl != MaxVectorSize) {\n+        warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n+                new_vl, new_vl);\n+      }\n+      MaxVectorSize = new_vl;\n+    } else {\n+      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d\", (int)MaxVectorSize));\n+    }\n+  }\n+\n+  if (UseSVE == 0) {  \/\/ NEON\n+    int min_vector_size = 8;\n+    int max_vector_size = 16;\n+    if (!FLAG_IS_DEFAULT(MaxVectorSize)) {\n+      if (!is_power_of_2(MaxVectorSize)) {\n+        vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d\", (int)MaxVectorSize));\n+      } else if (MaxVectorSize < min_vector_size) {\n+        warning(\"MaxVectorSize must be at least %i on this platform\", min_vector_size);\n+        FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);\n+      } else if (MaxVectorSize > max_vector_size) {\n+        warning(\"MaxVectorSize must be at most %i on this platform\", max_vector_size);\n+        FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);\n+      }\n+    } else {\n+      FLAG_SET_DEFAULT(MaxVectorSize, 16);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":77,"deletions":2,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  static int _initial_sve_vector_length;\n+\n@@ -109,0 +111,1 @@\n+  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n@@ -39,0 +39,4 @@\n+inline VMReg PRegisterImpl::as_VMReg() {\n+  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_fpr);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1009,0 +1009,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2382,0 +2382,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/compiledIC_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1613,0 +1613,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1618,0 +1618,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2837,1 +2837,1 @@\n-    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, \"missing type\");\n+    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 8, \"missing type\");\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-  if (SafepointMechanism::should_block(thread) ||\n+  if (SafepointMechanism::should_process(thread) ||\n@@ -554,1 +554,1 @@\n-  if (SafepointMechanism::should_block(THREAD)) {\n+  if (SafepointMechanism::should_process(THREAD)) {\n@@ -686,1 +686,1 @@\n-  if (SafepointMechanism::should_block(THREAD)) {\n+  if (SafepointMechanism::should_process(THREAD)) {\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n- * Return the number of milliseconds per period\n+ * Return the number of microseconds per period\n@@ -210,1 +210,1 @@\n- *    quota time in milliseconds\n+ *    quota time in microseconds\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n- * Return the number of milliseconds per period\n+ * Return the number of microseconds per period\n@@ -81,1 +81,1 @@\n- *    quota time in milliseconds\n+ *    quota time in microseconds\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2017, SAP SE. All rights reserved.\n+ * Copyright (c) 2017 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os\/windows\/symbolengine.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -937,0 +937,1 @@\n+    case 'A':  return \"TypeVect::VECTA\";\n@@ -947,0 +948,4 @@\n+  if (strncmp(idealOp, \"RegVMask\", 8) == 0) {\n+    return \"Type::BOTTOM\";\n+  }\n+\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3945,0 +3945,2 @@\n+         strcmp(opType,\"RegVMask\")==0 ||\n+         strcmp(opType,\"VecA\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-    st->print_cr(\"NULL\");\n+    st->print(\"NULL\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2679,1 +2679,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1283,1 +1283,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,1 @@\n-\n-\/\/ ======= Concurrent Mark Thread ========\n+#include \"utilities\/ticks.hpp\"\n@@ -52,1 +51,0 @@\n-  _vtime_mark_accum(0.0),\n@@ -80,1 +78,1 @@\n-double G1ConcurrentMarkThread::mmu_delay_end(G1Policy* g1_policy, bool remark) {\n+double G1ConcurrentMarkThread::mmu_delay_end(G1Policy* policy, bool remark) {\n@@ -83,1 +81,1 @@\n-  \/\/    - G1MMUTracker::add_pause(), when_sec() and its variation(when_ms() etc..) can be called\n+  \/\/    - G1MMUTracker::add_pause(), when_sec() and when_max_gc_sec() can be called\n@@ -91,1 +89,1 @@\n-  const G1Analytics* analytics = g1_policy->analytics();\n+  const G1Analytics* analytics = policy->analytics();\n@@ -95,1 +93,1 @@\n-  G1MMUTracker *mmu_tracker = g1_policy->mmu_tracker();\n+  G1MMUTracker *mmu_tracker = policy->mmu_tracker();\n@@ -100,3 +98,5 @@\n-void G1ConcurrentMarkThread::delay_to_keep_mmu(G1Policy* g1_policy, bool remark) {\n-  if (g1_policy->use_adaptive_young_list_length()) {\n-    double delay_end_sec = mmu_delay_end(g1_policy, remark);\n+void G1ConcurrentMarkThread::delay_to_keep_mmu(bool remark) {\n+  G1Policy* policy = G1CollectedHeap::heap()->policy();\n+\n+  if (policy->use_adaptive_young_list_length()) {\n+    double delay_end_sec = mmu_delay_end(policy, remark);\n@@ -105,1 +105,1 @@\n-    while (!_cm->has_aborted()) {\n+    while (!_cm->has_aborted() && !should_terminate()) {\n@@ -112,2 +112,0 @@\n-      } else if (should_terminate()) {\n-        break;                  \/\/ Wakeup for pending termination request.\n@@ -139,9 +137,1 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1Policy* policy = g1h->policy();\n-\n-  while (!should_terminate()) {\n-    \/\/ wait until started is set.\n-    sleep_before_next_cycle();\n-    if (should_terminate()) {\n-      break;\n-    }\n+  while (wait_for_next_cycle()) {\n@@ -150,3 +140,0 @@\n-\n-    _cm->concurrent_cycle_start();\n-\n@@ -154,100 +141,0 @@\n-    {\n-      ResourceMark rm;\n-\n-      double cycle_start = os::elapsedVTime();\n-\n-      {\n-        G1ConcPhaseTimer p(_cm, \"Concurrent Clear Claimed Marks\");\n-        ClassLoaderDataGraph::clear_claimed_marks();\n-      }\n-\n-      \/\/ We have to ensure that we finish scanning the root regions\n-      \/\/ before the next GC takes place. To ensure this we have to\n-      \/\/ make sure that we do not join the STS until the root regions\n-      \/\/ have been scanned. If we did then it's possible that a\n-      \/\/ subsequent GC could block us from joining the STS and proceed\n-      \/\/ without the root regions have been scanned which would be a\n-      \/\/ correctness issue.\n-\n-      {\n-        G1ConcPhaseTimer p(_cm, \"Concurrent Scan Root Regions\");\n-        _cm->scan_root_regions();\n-      }\n-\n-      \/\/ Note: ConcurrentGCBreakpoints before here risk deadlock,\n-      \/\/ because a young GC must wait for root region scanning.\n-\n-      \/\/ It would be nice to use the G1ConcPhaseTimer class here but\n-      \/\/ the \"end\" logging is inside the loop and not at the end of\n-      \/\/ a scope. Also, the timer doesn't support nesting.\n-      \/\/ Mimicking the same log output instead.\n-      jlong mark_start = os::elapsed_counter();\n-      log_info(gc, marking)(\"Concurrent Mark (%.3fs)\",\n-                            TimeHelper::counter_to_seconds(mark_start));\n-      for (uint iter = 1; !_cm->has_aborted(); ++iter) {\n-        \/\/ Concurrent marking.\n-        {\n-          ConcurrentGCBreakpoints::at(\"AFTER MARKING STARTED\");\n-          G1ConcPhaseTimer p(_cm, \"Concurrent Mark From Roots\");\n-          _cm->mark_from_roots();\n-        }\n-        if (_cm->has_aborted()) {\n-          break;\n-        }\n-\n-        if (G1UseReferencePrecleaning) {\n-          G1ConcPhaseTimer p(_cm, \"Concurrent Preclean\");\n-          _cm->preclean();\n-        }\n-        if (_cm->has_aborted()) {\n-          break;\n-        }\n-\n-        \/\/ Delay remark pause for MMU.\n-        double mark_end_time = os::elapsedVTime();\n-        jlong mark_end = os::elapsed_counter();\n-        _vtime_mark_accum += (mark_end_time - cycle_start);\n-        delay_to_keep_mmu(policy, true \/* remark *\/);\n-        if (_cm->has_aborted()) {\n-          break;\n-        }\n-\n-        \/\/ Pause Remark.\n-        ConcurrentGCBreakpoints::at(\"BEFORE MARKING COMPLETED\");\n-        log_info(gc, marking)(\"Concurrent Mark (%.3fs, %.3fs) %.3fms\",\n-                              TimeHelper::counter_to_seconds(mark_start),\n-                              TimeHelper::counter_to_seconds(mark_end),\n-                              TimeHelper::counter_to_millis(mark_end - mark_start));\n-        CMRemark cl(_cm);\n-        VM_G1Concurrent op(&cl, \"Pause Remark\");\n-        VMThread::execute(&op);\n-        if (_cm->has_aborted()) {\n-          break;\n-        } else if (!_cm->restart_for_overflow()) {\n-          break;                \/\/ Exit loop if no restart requested.\n-        } else {\n-          \/\/ Loop to restart for overflow.\n-          log_info(gc, marking)(\"Concurrent Mark Restart for Mark Stack Overflow (iteration #%u)\",\n-                                iter);\n-        }\n-      }\n-\n-      if (!_cm->has_aborted()) {\n-        G1ConcPhaseTimer p(_cm, \"Concurrent Rebuild Remembered Sets\");\n-        _cm->rebuild_rem_set_concurrently();\n-      }\n-\n-      double end_time = os::elapsedVTime();\n-      \/\/ Update the total virtual time before doing this, since it will try\n-      \/\/ to measure it to get the vtime for this marking.\n-      _vtime_accum = (end_time - _vtime_start);\n-\n-      if (!_cm->has_aborted()) {\n-        delay_to_keep_mmu(policy, false \/* cleanup *\/);\n-      }\n-\n-      if (!_cm->has_aborted()) {\n-        CMCleanup cl_cl(_cm);\n-        VM_G1Concurrent op(&cl_cl, \"Pause Cleanup\");\n-        VMThread::execute(&op);\n-      }\n@@ -255,9 +142,3 @@\n-      \/\/ We now want to allow clearing of the marking bitmap to be\n-      \/\/ suspended by a collection pause.\n-      \/\/ We may have aborted just before the remark. Do not bother clearing the\n-      \/\/ bitmap then, as it has been done during mark abort.\n-      if (!_cm->has_aborted()) {\n-        G1ConcPhaseTimer p(_cm, \"Concurrent Cleanup for Next Mark\");\n-        _cm->cleanup_for_next_mark();\n-      }\n-    }\n+    concurrent_cycle_start();\n+    full_concurrent_cycle_do();\n+    concurrent_cycle_end();\n@@ -265,12 +146,1 @@\n-    \/\/ Update the number of full collections that have been\n-    \/\/ completed. This will also notify the G1OldGCCount_lock in case a\n-    \/\/ Java thread is waiting for a full GC to happen (e.g., it\n-    \/\/ called System.gc() with +ExplicitGCInvokesConcurrent).\n-    {\n-      SuspendibleThreadSetJoiner sts_join;\n-      g1h->increment_old_marking_cycles_completed(true \/* concurrent *\/,\n-                                                  !_cm->has_aborted() \/* liveness_completed *\/);\n-\n-      _cm->concurrent_cycle_end();\n-      ConcurrentGCBreakpoints::notify_active_to_idle();\n-    }\n+    _vtime_accum = (os::elapsedVTime() - _vtime_start);\n@@ -286,4 +156,1 @@\n-\n-void G1ConcurrentMarkThread::sleep_before_next_cycle() {\n-  \/\/ We join here because we don't want to do the \"shouldConcurrentMark()\"\n-  \/\/ below while the world is otherwise stopped.\n+bool G1ConcurrentMarkThread::wait_for_next_cycle() {\n@@ -300,0 +167,156 @@\n+\n+  return !should_terminate();\n+}\n+\n+void G1ConcurrentMarkThread::phase_clear_cld_claimed_marks() {\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Clear Claimed Marks\");\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_scan_root_regions() {\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Scan Root Regions\");\n+  _cm->scan_root_regions();\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_mark_loop() {\n+  Ticks mark_start = Ticks::now();\n+  log_info(gc, marking)(\"Concurrent Mark\");\n+\n+  for (uint iter = 1; true; ++iter) {\n+    \/\/ Subphase 1: Mark From Roots.\n+    if (subphase_mark_from_roots()) return true;\n+\n+    \/\/ Subphase 2: Preclean (optional)\n+    if (G1UseReferencePrecleaning) {\n+      if (subphase_preclean()) return true;\n+    }\n+\n+    \/\/ Subphase 3: Wait for Remark.\n+    if (subphase_delay_to_keep_mmu_before_remark()) return true;\n+\n+    \/\/ Subphase 4: Remark pause\n+    if (subphase_remark()) return true;\n+\n+    \/\/ Check if we need to restart the marking loop.\n+    if (!mark_loop_needs_restart()) break;\n+\n+    log_info(gc, marking)(\"Concurrent Mark Restart for Mark Stack Overflow (iteration #%u)\",\n+                          iter);\n+  }\n+\n+  log_info(gc, marking)(\"Concurrent Mark %.3fms\",\n+                        (Ticks::now() - mark_start).seconds() * 1000.0);\n+\n+  return false;\n+}\n+\n+bool G1ConcurrentMarkThread::mark_loop_needs_restart() const {\n+  return _cm->has_overflown();\n+}\n+\n+bool G1ConcurrentMarkThread::subphase_mark_from_roots() {\n+  ConcurrentGCBreakpoints::at(\"AFTER MARKING STARTED\");\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Mark From Roots\");\n+  _cm->mark_from_roots();\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::subphase_preclean() {\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Preclean\");\n+  _cm->preclean();\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::subphase_delay_to_keep_mmu_before_remark() {\n+  delay_to_keep_mmu(true \/* remark *\/);\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::subphase_remark() {\n+  ConcurrentGCBreakpoints::at(\"BEFORE MARKING COMPLETED\");\n+  CMRemark cl(_cm);\n+  VM_G1Concurrent op(&cl, \"Pause Remark\");\n+  VMThread::execute(&op);\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_rebuild_remembered_sets() {\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Rebuild Remembered Sets\");\n+  _cm->rebuild_rem_set_concurrently();\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_delay_to_keep_mmu_before_cleanup() {\n+  delay_to_keep_mmu(false \/* cleanup *\/);\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_cleanup() {\n+  CMCleanup cl(_cm);\n+  VM_G1Concurrent op(&cl, \"Pause Cleanup\");\n+  VMThread::execute(&op);\n+  return _cm->has_aborted();\n+}\n+\n+bool G1ConcurrentMarkThread::phase_clear_bitmap_for_next_mark() {\n+  G1ConcPhaseTimer p(_cm, \"Concurrent Cleanup for Next Mark\");\n+  _cm->cleanup_for_next_mark();\n+  return _cm->has_aborted();\n+}\n+\n+void G1ConcurrentMarkThread::concurrent_cycle_start() {\n+  _cm->concurrent_cycle_start();\n+}\n+\n+void G1ConcurrentMarkThread::full_concurrent_cycle_do() {\n+  HandleMark hm(Thread::current());\n+  ResourceMark rm;\n+\n+  \/\/ Phase 1: Clear CLD claimed marks.\n+  phase_clear_cld_claimed_marks();\n+\n+  \/\/ We have to ensure that we finish scanning the root regions\n+  \/\/ before the next GC takes place. To ensure this we have to\n+  \/\/ make sure that we do not join the STS until the root regions\n+  \/\/ have been scanned. If we did then it's possible that a\n+  \/\/ subsequent GC could block us from joining the STS and proceed\n+  \/\/ without the root regions have been scanned which would be a\n+  \/\/ correctness issue.\n+  \/\/\n+  \/\/ So do not return before the scan root regions phase as a GC waits for a\n+  \/\/ notification from it.\n+  \/\/\n+  \/\/ For the same reason ConcurrentGCBreakpoints (in the phase methods) before\n+  \/\/ here risk deadlock, because a young GC must wait for root region scanning.\n+\n+  \/\/ Phase 2: Scan root regions.\n+  if (phase_scan_root_regions()) return;\n+\n+  \/\/ Phase 3: Actual mark loop.\n+  if (phase_mark_loop()) return;\n+\n+  \/\/ Phase 4: Rebuild remembered sets.\n+  if (phase_rebuild_remembered_sets()) return;\n+\n+  \/\/ Phase 5: Wait for Cleanup.\n+  if (phase_delay_to_keep_mmu_before_cleanup()) return;\n+\n+  \/\/ Phase 6: Cleanup pause\n+  if (phase_cleanup()) return;\n+\n+  \/\/ Phase 7: Clear bitmap for next mark.\n+  phase_clear_bitmap_for_next_mark();\n+}\n+\n+void G1ConcurrentMarkThread::concurrent_cycle_end() {\n+  \/\/ Update the number of full collections that have been\n+  \/\/ completed. This will also notify the G1OldGCCount_lock in case a\n+  \/\/ Java thread is waiting for a full GC to happen (e.g., it\n+  \/\/ called System.gc() with +ExplicitGCInvokesConcurrent).\n+  SuspendibleThreadSetJoiner sts_join;\n+  G1CollectedHeap::heap()->increment_old_marking_cycles_completed(true \/* concurrent *\/,\n+                                                                  !_cm->has_aborted());\n+\n+  _cm->concurrent_cycle_end();\n+  ConcurrentGCBreakpoints::notify_active_to_idle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":173,"deletions":150,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  double _vtime_mark_accum;\n@@ -44,1 +43,1 @@\n-  enum State {\n+  enum ServiceState {\n@@ -50,1 +49,1 @@\n-  volatile State _state;\n+  volatile ServiceState _state;\n@@ -52,4 +51,32 @@\n-  void sleep_before_next_cycle();\n-  \/\/ Delay marking to meet MMU.\n-  void delay_to_keep_mmu(G1Policy* g1_policy, bool remark);\n-  double mmu_delay_end(G1Policy* g1_policy, bool remark);\n+  \/\/ Wait for next cycle. Returns false if the service should be stopped.\n+  bool wait_for_next_cycle();\n+\n+  bool mark_loop_needs_restart() const;\n+\n+  \/\/ Phases and subphases for the full concurrent marking cycle in order.\n+  \/\/\n+  \/\/ All these methods return true if the marking should be aborted. Except\n+  \/\/ phase_clear_cld_claimed_marks() because we must not abort before\n+  \/\/ scanning the root regions because of a potential deadlock otherwise.\n+  void phase_clear_cld_claimed_marks();\n+  bool phase_scan_root_regions();\n+\n+  bool phase_mark_loop();\n+  bool subphase_mark_from_roots();\n+  bool subphase_preclean();\n+  bool subphase_delay_to_keep_mmu_before_remark();\n+  bool subphase_remark();\n+\n+  bool phase_rebuild_remembered_sets();\n+  bool phase_delay_to_keep_mmu_before_cleanup();\n+  bool phase_cleanup();\n+  bool phase_clear_bitmap_for_next_mark();\n+\n+  void concurrent_cycle_start();\n+\n+  void full_concurrent_cycle_do();\n+  void concurrent_cycle_end();\n+\n+  \/\/ Delay pauses to meet MMU.\n+  void delay_to_keep_mmu(bool remark);\n+  double mmu_delay_end(G1Policy* policy, bool remark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  return _vtime_mark_accum + _cm->all_task_accum_vtime();\n+  return _cm->all_task_accum_vtime();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,2 +94,2 @@\n-  _marking_times_s(10, 0.95),\n-  _allocation_rate_s(10, 0.95),\n+  _marking_times_s(10, 0.05),\n+  _allocation_rate_s(10, 0.05),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,4 +65,0 @@\n-  inline bool now_max_gc(double current_time) {\n-    return when_sec(current_time, max_gc_time()) < 0.00001;\n-  }\n-\n@@ -72,10 +68,0 @@\n-\n-  inline jlong when_max_gc_ms(double current_time) {\n-    double when = when_max_gc_sec(current_time);\n-    return (jlong) (when * 1000.0);\n-  }\n-\n-  inline jlong when_ms(double current_time, double pause_time) {\n-    double when = when_sec(current_time, pause_time);\n-    return (jlong) (when * 1000.0);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1335,16 +1335,0 @@\n-    \/\/ Stop adding regions if the remaining reclaimable space is\n-    \/\/ not above G1HeapWastePercent.\n-    size_t reclaimable_bytes = candidates->remaining_reclaimable_bytes();\n-    double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);\n-    double threshold = (double) G1HeapWastePercent;\n-    if (reclaimable_percent <= threshold) {\n-      \/\/ We've added enough old regions that the amount of uncollected\n-      \/\/ reclaimable space is at or below the waste threshold. Stop\n-      \/\/ adding old regions to the CSet.\n-      log_debug(gc, ergo, cset)(\"Finish adding old regions to collection set (Reclaimable percentage below threshold). \"\n-                                \"Reclaimable: \" SIZE_FORMAT \"%s (%1.2f%%) threshold: \" UINTX_FORMAT \"%%\",\n-                                byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),\n-                                reclaimable_percent, G1HeapWastePercent);\n-      break;\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,0 +193,2 @@\n+  _capacity_at_last_gc(0),\n+  _used_at_last_gc(0),\n@@ -593,0 +595,7 @@\n+\n+\/\/ It's the caller's responsibility to ensure glitch-freedom\n+\/\/ (if required).\n+void CollectedHeap::update_capacity_and_used_at_gc() {\n+  _capacity_at_last_gc = capacity();\n+  _used_at_last_gc     = used();\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  \/\/ Historic gc information\n+  size_t _capacity_at_last_gc;\n+  size_t _used_at_last_gc;\n+\n@@ -242,0 +246,5 @@\n+  \/\/ Historic gc information\n+  size_t free_at_last_gc() const { return _capacity_at_last_gc - _used_at_last_gc; }\n+  size_t used_at_last_gc() const { return _used_at_last_gc; }\n+  void update_capacity_and_used_at_gc();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -38,1 +39,1 @@\n-  _max_interval = (Universe::get_heap_free_at_last_gc() \/ M) * SoftRefLRUPolicyMSPerMB;\n+  _max_interval = (Universe::heap()->free_at_last_gc() \/ M) * SoftRefLRUPolicyMSPerMB;\n@@ -66,1 +67,1 @@\n-  max_heap -= Universe::get_heap_used_at_last_gc();\n+  max_heap -= Universe::heap()->used_at_last_gc();\n","filename":"src\/hotspot\/share\/gc\/shared\/referencePolicy.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gcTrace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahTracer.hpp\"\n@@ -33,0 +33,5 @@\n+class ShenandoahTracer : public GCTracer {\n+public:\n+  ShenandoahTracer() : GCTracer(Shenandoah) {}\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-        Universe::update_heap_info_at_gc();\n+        Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTRACER_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHTRACER_HPP\n-\n-#include \"gc\/shared\/gcTrace.hpp\"\n-\n-class ShenandoahTracer : public GCTracer {\n-public:\n-  ShenandoahTracer() : GCTracer(Shenandoah) {}\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHTRACER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTracer.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -383,1 +383,1 @@\n-    Universe::update_heap_info_at_gc();\n+    Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,2 +149,1 @@\n-  assert(ZThread::is_java() || ZThread::is_vm() || ZThread::is_runtime_worker(),\n-         \"Should be a Java, VM or Runtime worker thread\");\n+  assert(!ZThread::is_worker(), \"Should not be a worker thread\");\n@@ -211,3 +210,0 @@\n-  assert(ZThread::is_java() || ZThread::is_vm() || ZThread::is_worker() || ZThread::is_runtime_worker(),\n-         \"Unknown thread\");\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-NumberSeq ZStatCycle::_normalized_duration(0.3 \/* alpha *\/);\n+NumberSeq ZStatCycle::_normalized_duration(0.7 \/* alpha *\/);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-       CALL_VM(SafepointMechanism::block_if_requested(THREAD), handle_exception); \\\n+       CALL_VM(SafepointMechanism::process_if_requested(THREAD), handle_exception); \\\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  sample->set_heap_used_at_last_gc(Universe::get_heap_used_at_last_gc());\n+  sample->set_heap_used_at_last_gc(Universe::heap()->used_at_last_gc());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+    _thread_oop(thread->threadObj()),\n@@ -134,0 +135,1 @@\n+  oop _thread_oop;\n@@ -193,1 +195,1 @@\n-      ev->set_state(java_lang_Thread::get_thread_status(jth->threadObj()));\n+      ev->set_state(java_lang_Thread::get_thread_status(_thread_oop));\n@@ -205,1 +207,1 @@\n-    _closure(closure), _jt(jt), _stacktrace(frames, max_frames), _success(false) {\n+    _closure(closure), _jt(jt), _thread_oop(jt->threadObj()), _stacktrace(frames, max_frames), _success(false) {\n@@ -214,0 +216,1 @@\n+  oop _thread_oop;\n@@ -218,1 +221,1 @@\n-static void write_native_event(JfrThreadSampleClosure& closure, JavaThread* jt) {\n+static void write_native_event(JfrThreadSampleClosure& closure, JavaThread* jt, oop thread_oop) {\n@@ -222,1 +225,1 @@\n-  ev->set_state(java_lang_Thread::get_thread_status(jt->threadObj()));\n+  ev->set_state(java_lang_Thread::get_thread_status(thread_oop));\n@@ -244,1 +247,1 @@\n-    write_native_event(_closure, _jt);\n+    write_native_event(_closure, _jt, _thread_oop);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-    if (SafepointMechanism::should_block(thread)) {\n+    if (SafepointMechanism::should_process(thread)) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,4 +336,3 @@\n-  bool created = false;\n-  SourceObjInfo* p = _src_obj_table.lookup(src_obj);\n-  if (p == NULL) {\n-    p = _src_obj_table.add(src_obj, src_info);\n+  bool created;\n+  SourceObjInfo* p = _src_obj_table.add_if_absent(src_obj, src_info, &created);\n+  if (created) {\n@@ -343,1 +342,0 @@\n-    created = true;\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,3 +97,3 @@\n-  bool* found = _has_been_visited.lookup(ref->obj());\n-  if (found != NULL) {\n-    assert(*found == read_only, \"must be\");\n+  bool created;\n+  _has_been_visited.add_if_absent(ref->obj(), read_only, &created);\n+  if (!created) {\n@@ -102,1 +102,0 @@\n-    _has_been_visited.add(ref->obj(), read_only);\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-size_t          Universe::_heap_capacity_at_last_gc;\n-size_t          Universe::_heap_used_at_last_gc = 0;\n-\n@@ -868,8 +865,0 @@\n-\n-\/\/ It's the caller's responsibility to ensure glitch-freedom\n-\/\/ (if required).\n-void Universe::update_heap_info_at_gc() {\n-  _heap_capacity_at_last_gc = heap()->capacity();\n-  _heap_used_at_last_gc     = heap()->used();\n-}\n-\n@@ -1011,1 +1000,1 @@\n-    Universe::update_heap_info_at_gc();\n+    Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -165,4 +165,0 @@\n-  \/\/ Historic gc information\n-  static size_t _heap_capacity_at_last_gc;\n-  static size_t _heap_used_at_last_gc;\n-\n@@ -312,5 +308,0 @@\n-  \/\/ Historic gc information\n-  static size_t get_heap_free_at_last_gc()             { return _heap_capacity_at_last_gc - _heap_used_at_last_gc; }\n-  static size_t get_heap_used_at_last_gc()             { return _heap_used_at_last_gc; }\n-  static void update_heap_info_at_gc();\n-\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2188,1 +2188,1 @@\n-    \/\/ Also have to add the method to the list safely, which the cld lock\n+    \/\/ Also have to add the method to the list safely, which the lock\n@@ -2190,1 +2190,1 @@\n-    MutexLocker ml(cld->metaspace_lock(),  Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n@@ -2212,1 +2212,1 @@\n-    \/\/ Also have to add the method to the list safely, which the cld lock\n+    \/\/ Also have to add the method to the list safely, which the lock\n@@ -2214,1 +2214,1 @@\n-    MutexLocker ml(cld->metaspace_lock(),  Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/reflectionAccessorImplKlassHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/reflectionAccessorImplKlassHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -387,3 +387,0 @@\n-  product(bool, InsertMemBarAfterArraycopy, true,                           \\\n-          \"Insert memory barrier after arraycopy call\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  if( _is_scalable ) tty->print(\"Scalable \");\n@@ -647,1 +648,9 @@\n-          OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); \/\/ Find lo\n+          int num_regs = lrg.num_regs();\n+          if (lrg.is_scalable() && OptoReg::is_stack(hi)) {\n+            \/\/ For scalable vector registers, when they are allocated in physical\n+            \/\/ registers, num_regs is RegMask::SlotsPerVecA for reg mask of scalable\n+            \/\/ vector. If they are allocated on stack, we need to get the actual\n+            \/\/ num_regs, which reflects the physical length of scalable registers.\n+            num_regs = lrg.scalable_reg_slots();\n+          }\n+          OptoReg::Name lo = OptoReg::add(hi, (1-num_regs)); \/\/ Find lo\n@@ -805,1 +814,1 @@\n-        if (RegMask::is_vector(ireg))\n+        if (RegMask::is_vector(ireg)) {\n@@ -807,0 +816,11 @@\n+          if (ireg == Op_VecA) {\n+            assert(Matcher::supports_scalable_vector(), \"scalable vector should be supported\");\n+            lrg._is_scalable = 1;\n+            \/\/ For scalable vector, when it is allocated in physical register,\n+            \/\/ num_regs is RegMask::SlotsPerVecA for reg mask,\n+            \/\/ which may not be the actual physical register size.\n+            \/\/ If it is allocated in stack, we need to get the actual\n+            \/\/ physical length of scalable vector register.\n+            lrg.set_scalable_reg_slots(Matcher::scalable_vector_reg_size(T_FLOAT));\n+          }\n+        }\n@@ -908,0 +928,7 @@\n+        case Op_VecA:\n+          assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+          assert(RegMask::num_registers(Op_VecA) == RegMask::SlotsPerVecA, \"sanity\");\n+          assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecA), \"vector should be aligned\");\n+          lrg.set_num_regs(RegMask::SlotsPerVecA);\n+          lrg.set_reg_pressure(1);\n+          break;\n@@ -1308,0 +1335,40 @@\n+static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+  int num_regs = lrg.num_regs();\n+  OptoReg::Name assigned = mask.find_first_set(lrg, num_regs);\n+\n+  if (lrg.is_scalable()) {\n+    \/\/ a physical register is found\n+    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+      return assigned;\n+    }\n+\n+    \/\/ find available stack slots for scalable register\n+    if (lrg._is_vector) {\n+      num_regs = lrg.scalable_reg_slots();\n+      \/\/ if actual scalable vector register is exactly SlotsPerVecA * 32 bits\n+      if (num_regs == RegMask::SlotsPerVecA) {\n+        return assigned;\n+      }\n+\n+      \/\/ mask has been cleared out by clear_to_sets(SlotsPerVecA) before choose_color, but it\n+      \/\/ does not work for scalable size. We have to find adjacent scalable_reg_slots() bits\n+      \/\/ instead of SlotsPerVecA bits.\n+      assigned = mask.find_first_set(lrg, num_regs); \/\/ find highest valid reg\n+      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+        \/\/ Verify the found reg has scalable_reg_slots() bits set.\n+        if (mask.is_valid_reg(assigned, num_regs)) {\n+          return assigned;\n+        } else {\n+          \/\/ Remove more for each iteration\n+          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n+          mask.clear_to_sets(RegMask::SlotsPerVecA); \/\/ Align by SlotsPerVecA bits\n+          assigned = mask.find_first_set(lrg, num_regs);\n+        }\n+      }\n+      return OptoReg::Bad; \/\/ will cause chunk change, and retry next chunk\n+    }\n+  }\n+\n+  return assigned;\n+}\n+\n@@ -1341,1 +1408,1 @@\n-      OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());\n+      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n@@ -1350,1 +1417,1 @@\n-    return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);\n+    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n@@ -1405,1 +1472,0 @@\n-\n@@ -1487,1 +1553,0 @@\n-\n@@ -1512,1 +1577,5 @@\n-        assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        if (Matcher::supports_scalable_vector()) {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecA, \"sanity\");\n+        } else {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        }\n@@ -1516,1 +1585,5 @@\n-        for (int i = 1; i < n_regs; i++)\n+        \/\/ We always choose the high bit, then mask the low bits by register size\n+        if (lrg->is_scalable() && OptoReg::is_stack(lrg->reg())) { \/\/ stack\n+          n_regs = lrg->scalable_reg_slots();\n+        }\n+        for (int i = 1; i < n_regs; i++) {\n@@ -1518,0 +1591,1 @@\n+        }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":82,"deletions":8,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,3 @@\n-      assert(_mask.is_aligned_sets(_num_regs), \"mask is not aligned, adjacent sets\");\n+      if (!(_is_scalable && OptoReg::is_stack(_reg))) {\n+        assert(_mask.is_aligned_sets(_num_regs), \"mask is not aligned, adjacent sets\");\n+      }\n@@ -140,1 +142,0 @@\n-  \/\/ Number of registers this live range uses when it colors\n@@ -142,0 +143,1 @@\n+  \/\/ Number of registers this live range uses when it colors\n@@ -144,0 +146,6 @@\n+\n+  \/\/ For scalable register, num_regs may not be the actual physical register size.\n+  \/\/ We need to get the actual physical length of scalable register when scalable\n+  \/\/ register is spilled. The size of one slot is 32-bit.\n+  uint _scalable_reg_slots;     \/\/ Actual scalable register length of slots.\n+                                \/\/ Meaningful only when _is_scalable is true.\n@@ -148,0 +156,17 @@\n+  uint scalable_reg_slots() { return _scalable_reg_slots; }\n+  void set_scalable_reg_slots(uint slots) {\n+    assert(_is_scalable, \"scalable register\");\n+    assert(slots > 0, \"slots of scalable register is not valid\");\n+    _scalable_reg_slots = slots;\n+  }\n+\n+  bool is_scalable() {\n+#ifdef ASSERT\n+    if (_is_scalable) {\n+      \/\/ Should only be a vector for now, but it could also be a RegVMask in future.\n+      assert(_is_vector && (_num_regs == RegMask::SlotsPerVecA), \"unexpected scalable reg\");\n+    }\n+#endif\n+    return _is_scalable;\n+  }\n+\n@@ -173,0 +198,2 @@\n+         _is_scalable:1,        \/\/ True if register size is scalable\n+                                \/\/      e.g. Arm SVE vector\/predicate registers.\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-  } else if (InsertMemBarAfterArraycopy) {\n+  } else {\n@@ -1104,3 +1104,0 @@\n-    RegionNode* slow_region = new RegionNode(1);\n-    transform_later(slow_region);\n-\n@@ -1179,9 +1176,0 @@\n-\n-    \/\/ Do not let reads from the destination float above the arraycopy.\n-    \/\/ Since we cannot type the arrays, we don't know which slices\n-    \/\/ might be affected.  We could restrict this barrier only to those\n-    \/\/ memory slices which pertain to array elements--but don't bother.\n-    if (!InsertMemBarAfterArraycopy) {\n-      \/\/ (If InsertMemBarAfterArraycopy, there is already one in place.)\n-      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n-    }\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  idealreg2spillmask  [Op_VecA] = NULL;\n@@ -104,0 +105,1 @@\n+  idealreg2debugmask  [Op_VecA] = NULL;\n@@ -117,0 +119,1 @@\n+  idealreg2mhdebugmask[Op_VecA] = NULL;\n@@ -430,1 +433,1 @@\n-#define NOF_STACK_MASKS (3*6+5)\n+#define NOF_STACK_MASKS (3*6+6)\n@@ -466,5 +469,6 @@\n-  idealreg2spillmask  [Op_VecS] = &rms[18];\n-  idealreg2spillmask  [Op_VecD] = &rms[19];\n-  idealreg2spillmask  [Op_VecX] = &rms[20];\n-  idealreg2spillmask  [Op_VecY] = &rms[21];\n-  idealreg2spillmask  [Op_VecZ] = &rms[22];\n+  idealreg2spillmask  [Op_VecA] = &rms[18];\n+  idealreg2spillmask  [Op_VecS] = &rms[19];\n+  idealreg2spillmask  [Op_VecD] = &rms[20];\n+  idealreg2spillmask  [Op_VecX] = &rms[21];\n+  idealreg2spillmask  [Op_VecY] = &rms[22];\n+  idealreg2spillmask  [Op_VecZ] = &rms[23];\n@@ -497,0 +501,1 @@\n+  RegMask scalable_stack_mask = aligned_stack_mask;\n@@ -567,7 +572,27 @@\n-   if (UseFPUForSpilling) {\n-     \/\/ This mask logic assumes that the spill operations are\n-     \/\/ symmetric and that the registers involved are the same size.\n-     \/\/ On sparc for instance we may have to use 64 bit moves will\n-     \/\/ kill 2 registers when used with F0-F31.\n-     idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n+\n+  if (Matcher::supports_scalable_vector()) {\n+    int k = 1;\n+    OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);\n+    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+    \/\/ otherwise vector spills could stomp over stack slots in caller frame.\n+    for (; (in >= init_in) && (k < scalable_vector_reg_size(T_FLOAT)); k++) {\n+      scalable_stack_mask.Remove(in);\n+      in = OptoReg::add(in, -1);\n+    }\n+\n+    \/\/ For VecA\n+     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n+     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n+  } else {\n+    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n+  }\n+\n+  if (UseFPUForSpilling) {\n+    \/\/ This mask logic assumes that the spill operations are\n+    \/\/ symmetric and that the registers involved are the same size.\n+    \/\/ On sparc for instance we may have to use 64 bit moves will\n+    \/\/ kill 2 registers when used with F0-F31.\n+    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n@@ -575,4 +600,4 @@\n-     idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n@@ -580,1 +605,1 @@\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n@@ -582,4 +607,4 @@\n-     \/\/ ARM has support for moving 64bit values between a pair of\n-     \/\/ integer registers and a double register\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    \/\/ ARM has support for moving 64bit values between a pair of\n+    \/\/ integer registers and a double register\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n@@ -588,1 +613,1 @@\n-   }\n+  }\n@@ -881,0 +906,1 @@\n+  idealreg2regmask[Op_VecA] = regmask_for_ideal_register(Op_VecA, ret);\n@@ -1566,1 +1592,0 @@\n-\n@@ -2424,1 +2449,1 @@\n-    assert(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n+    assert(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n@@ -2441,0 +2466,1 @@\n+    case Op_VecA: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":51,"deletions":25,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -341,0 +341,4 @@\n+  static const bool supports_scalable_vector();\n+  \/\/ Actual max scalable vector register length.\n+  static const int scalable_vector_reg_size(const BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  \"RegFlags\",\n+  \"VecA\",\n@@ -47,0 +47,2 @@\n+  \"RegVMask\",\n+  \"RegFlags\",\n","filename":"src\/hotspot\/share\/opto\/opcodes.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  macro(VecA)                   \/\/ Machine vectora register\n@@ -45,0 +46,1 @@\n+  macro(RegVMask)               \/\/ Vector mask\/predicate register\n","filename":"src\/hotspot\/share\/opto\/opcodes.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,0 @@\n-  int n_regs = RegMask::num_registers(val->ideal_reg());\n@@ -272,0 +271,1 @@\n+  int n_regs = RegMask::num_registers(val->ideal_reg(), lrgs(val_idx));\n@@ -308,0 +308,11 @@\n+    \/\/ For scalable register, number of registers may be inconsistent between\n+    \/\/ \"val_reg\" and \"reg\". For example, when \"val\" resides in register\n+    \/\/ but \"reg\" is located in stack.\n+    if (lrgs(val_idx).is_scalable()) {\n+      assert(val->ideal_reg() == Op_VecA, \"scalable vector register\");\n+      if (OptoReg::is_stack(reg)) {\n+        n_regs = lrgs(val_idx).scalable_reg_slots();\n+      } else {\n+        n_regs = RegMask::SlotsPerVecA;\n+      }\n+    }\n@@ -309,1 +320,8 @@\n-      uint last = (n_regs-1); \/\/ Looking for the last part of a set\n+      uint last;\n+      if (lrgs(val_idx).is_scalable()) {\n+        assert(val->ideal_reg() == Op_VecA, \"scalable vector register\");\n+        \/\/ For scalable vector register, regmask is always SlotsPerVecA bits aligned\n+        last = RegMask::SlotsPerVecA - 1;\n+      } else {\n+        last = (n_regs-1); \/\/ Looking for the last part of a set\n+      }\n@@ -594,1 +612,1 @@\n-      OptoReg::Name preg = lrgs(_lrg_map.live_range_id(phi)).reg();\n+      OptoReg::Name preg = lrgs(pidx).reg();\n@@ -622,1 +640,1 @@\n-        int n_regs = RegMask::num_registers(phi->ideal_reg());\n+        int n_regs = RegMask::num_registers(phi->ideal_reg(), lrgs(pidx));\n@@ -666,1 +684,1 @@\n-            int n_regs = RegMask::num_registers(def_ideal_reg);\n+            int n_regs = RegMask::num_registers(def_ideal_reg, lrgs(_lrg_map.live_range_id(def)));\n@@ -710,1 +728,1 @@\n-      int n_regs = RegMask::num_registers(n_ideal_reg);\n+      int n_regs = RegMask::num_registers(n_ideal_reg, lrgs(lidx));\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -62,1 +63,1 @@\n-  return (ireg == Op_VecS || ireg == Op_VecD ||\n+  return (ireg == Op_VecA || ireg == Op_VecS || ireg == Op_VecD ||\n@@ -69,1 +70,1 @@\n-        return 16;\n+        return SlotsPerVecZ;\n@@ -71,1 +72,1 @@\n-        return 8;\n+        return SlotsPerVecY;\n@@ -73,1 +74,1 @@\n-        return 4;\n+        return SlotsPerVecX;\n@@ -75,0 +76,1 @@\n+        return SlotsPerVecD;\n@@ -81,0 +83,3 @@\n+      case Op_VecA:\n+        assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+        return SlotsPerVecA;\n@@ -86,0 +91,13 @@\n+int RegMask::num_registers(uint ireg, LRG &lrg) {\n+  int n_regs = num_registers(ireg);\n+\n+  \/\/ assigned is OptoReg which is selected by register allocator\n+  OptoReg::Name assigned = lrg.reg();\n+  assert(OptoReg::is_valid(assigned), \"should be valid opto register\");\n+\n+  if (lrg.is_scalable() && OptoReg::is_stack(assigned)) {\n+    n_regs = lrg.scalable_reg_slots();\n+  }\n+  return n_regs;\n+}\n+\n@@ -160,0 +178,10 @@\n+\/\/ Check that whether given reg number with size is valid\n+\/\/ for current regmask, where reg is the highest number.\n+bool RegMask::is_valid_reg(OptoReg::Name reg, const int size) const {\n+  for (int i = 0; i < size; i++) {\n+    if (!Member(reg - i)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n@@ -167,2 +195,7 @@\n-OptoReg::Name RegMask::find_first_set(const int size) const {\n-  assert(is_aligned_sets(size), \"mask is not aligned, adjacent sets\");\n+OptoReg::Name RegMask::find_first_set(LRG &lrg, const int size) const {\n+  if (lrg.is_scalable()) {\n+    \/\/ For scalable vector register, regmask is SlotsPerVecA bits aligned.\n+    assert(is_aligned_sets(SlotsPerVecA), \"mask is not aligned, adjacent sets\");\n+  } else {\n+    assert(is_aligned_sets(size), \"mask is not aligned, adjacent sets\");\n+  }\n@@ -248,1 +281,3 @@\n-      if ((bit & low_bits_mask) == 0) return false;\n+      if ((bit & low_bits_mask) == 0) {\n+        return false;\n+      }\n@@ -253,1 +288,3 @@\n-      if ((bits & set) != set) return false;\n+      if ((bits & set) != set) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+class LRG;\n+\n@@ -94,0 +96,1 @@\n+         SlotsPerVecA = 8,\n@@ -98,1 +101,2 @@\n-         SlotsPerVecZ = 16 };\n+         SlotsPerVecZ = 16,\n+         };\n@@ -222,0 +226,4 @@\n+  \/\/ Check that whether given reg number with size is valid\n+  \/\/ for current regmask, where reg is the highest number.\n+  bool is_valid_reg(OptoReg::Name reg, const int size) const;\n+\n@@ -225,1 +233,1 @@\n-  OptoReg::Name find_first_set(const int size) const;\n+  OptoReg::Name find_first_set(LRG &lrg, const int size) const;\n@@ -239,0 +247,1 @@\n+  static int num_registers(uint ireg, LRG &lrg);\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,2 +97,5 @@\n-  \/\/ Do vectors exist on this architecture?\n-  if (Matcher::vector_width_in_bytes(T_BYTE) < 2) return;\n+  \/\/ SuperWord only works with power of two vector sizes.\n+  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n+  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -71,0 +72,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -77,0 +79,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -649,0 +652,4 @@\n+  if (Matcher::supports_scalable_vector()) {\n+    TypeVect::VECTA = TypeVect::make(T_BYTE, Matcher::scalable_vector_reg_size(T_BYTE));\n+  }\n+\n@@ -665,0 +672,2 @@\n+\n+  mreg2type[Op_VecA] = TypeVect::VECTA;\n@@ -984,0 +993,1 @@\n+  Bad,          \/\/ VectorA - handled in v-call\n@@ -1884,1 +1894,0 @@\n-\n@@ -2255,0 +2264,1 @@\n+const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n@@ -2265,1 +2275,0 @@\n-  assert(length > 1 && is_power_of_2(length), \"vector length is power of 2\");\n@@ -2269,0 +2278,2 @@\n+  case Op_VecA:\n+    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n@@ -2300,1 +2311,1 @@\n-\n+  case VectorA:\n@@ -2355,0 +2366,2 @@\n+  case VectorA:\n+    st->print(\"vectora[\"); break;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+class     TypeVectA;\n@@ -90,0 +91,1 @@\n+    VectorA,                    \/\/ (Scalable) Vector types for vector length agnostic\n@@ -760,0 +762,1 @@\n+  static const TypeVect *VECTA;\n@@ -771,0 +774,5 @@\n+class TypeVectA : public TypeVect {\n+  friend class TypeVect;\n+  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+};\n+\n@@ -1625,1 +1633,1 @@\n-  assert( _base >= VectorS && _base <= VectorZ, \"Not a Vector\" );\n+  assert( _base >= VectorA && _base <= VectorZ, \"Not a Vector\" );\n@@ -1630,1 +1638,1 @@\n-  return (_base >= VectorS && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorA && _base <= VectorZ) ? (TypeVect*)this : NULL;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -821,1 +821,1 @@\n-    return vopc != opc && Matcher::match_rule_supported(vopc);\n+    return vopc != opc && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1717,9 +1717,12 @@\n-    \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n-    if (java_thread == JavaThread::current()) {\n-      state->update_for_pop_top_frame();\n-    } else {\n-      VM_UpdateForPopTopFrame op(state);\n-      VMThread::execute(&op);\n-      jvmtiError err = op.result();\n-      if (err != JVMTI_ERROR_NONE) {\n-        return err;\n+    \/\/ thread. All other usage needs to use a handshake for safety.\n+    {\n+      MutexLocker mu(JvmtiThreadState_lock);\n+      if (java_thread == JavaThread::current()) {\n+        state->update_for_pop_top_frame();\n+      } else {\n+        UpdateForPopTopFrameClosure op(state);\n+        bool executed = Handshake::execute_direct(&op, java_thread);\n+        jvmtiError err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+        if (err != JVMTI_ERROR_NONE) {\n+          return err;\n+        }\n@@ -1799,0 +1802,1 @@\n+  MutexLocker mu(JvmtiThreadState_lock);\n@@ -1803,3 +1807,3 @@\n-    VM_SetFramePop op(this, state, depth);\n-    VMThread::execute(&op);\n-    err = op.result();\n+    SetFramePopClosure op(this, state, depth);\n+    bool executed = Handshake::execute_direct(&op, java_thread);\n+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1507,1 +1507,1 @@\n-VM_UpdateForPopTopFrame::doit() {\n+UpdateForPopTopFrameClosure::do_thread(Thread *target) {\n@@ -1509,2 +1509,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1512,2 +1512,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n@@ -1518,1 +1517,1 @@\n-VM_SetFramePop::doit() {\n+SetFramePopClosure::do_thread(Thread *target) {\n@@ -1520,2 +1519,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1524,2 +1523,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -339,2 +339,2 @@\n-\/\/ VM operation to update for pop top frame.\n-class VM_UpdateForPopTopFrame : public VM_Operation {\n+\/\/ HandshakeClosure to update for pop top frame.\n+class UpdateForPopTopFrameClosure : public HandshakeClosure {\n@@ -346,5 +346,4 @@\n-  VM_UpdateForPopTopFrame(JvmtiThreadState* state) {\n-    _state = state;\n-    _result = JVMTI_ERROR_NONE;\n-  }\n-  VMOp_Type type() const { return VMOp_UpdateForPopTopFrame; }\n+  UpdateForPopTopFrameClosure(JvmtiThreadState* state)\n+    : HandshakeClosure(\"UpdateForPopTopFrame\"),\n+      _state(state),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n@@ -352,1 +351,1 @@\n-  void doit();\n+  void do_thread(Thread *target);\n@@ -355,2 +354,2 @@\n-\/\/ VM operation to set frame pop.\n-class VM_SetFramePop : public VM_Operation {\n+\/\/ HandshakeClosure to set frame pop.\n+class SetFramePopClosure : public HandshakeClosure {\n@@ -364,7 +363,6 @@\n-  VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {\n-    _env = env;\n-    _state = state;\n-    _depth = depth;\n-    _result = JVMTI_ERROR_NONE;\n-  }\n-  VMOp_Type type() const { return VMOp_SetFramePop; }\n+  SetFramePopClosure(JvmtiEnv *env, JvmtiThreadState* state, jint depth)\n+    : HandshakeClosure(\"SetFramePop\"),\n+      _env(env),\n+      _state(state),\n+      _depth(depth),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n@@ -372,1 +370,1 @@\n-  void doit();\n+  void do_thread(Thread *target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,2 +194,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -209,2 +212,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -217,2 +223,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -224,8 +233,0 @@\n-void JvmtiEnvThreadState::clear_to_frame_pop(int frame_number)  {\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n-  JvmtiFramePop fpop(frame_number);\n-  JvmtiEventController::clear_to_frame_pop(this, fpop);\n-}\n-\n-\n@@ -233,2 +234,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -243,1 +247,1 @@\n-class VM_GetCurrentLocation : public VM_Operation {\n+class GetCurrentLocationClosure : public HandshakeClosure {\n@@ -245,1 +249,0 @@\n-   JavaThread *_thread;\n@@ -250,7 +253,8 @@\n-  VM_GetCurrentLocation(JavaThread *thread) {\n-     _thread = thread;\n-   }\n-  VMOp_Type type() const { return VMOp_GetCurrentLocation; }\n-  void doit() {\n-    ResourceMark rmark; \/\/ _thread != Thread::current()\n-    RegisterMap rm(_thread, false);\n+  GetCurrentLocationClosure()\n+    : HandshakeClosure(\"GetCurrentLocation\"),\n+      _method_id(NULL),\n+      _bci(0) {}\n+  void do_thread(Thread *target) {\n+    JavaThread *jt = (JavaThread *)target;\n+    ResourceMark rmark; \/\/ jt != Thread::current()\n+    RegisterMap rm(jt, false);\n@@ -260,2 +264,2 @@\n-    if (!_thread->is_exiting() && _thread->has_last_Java_frame()) {\n-      javaVFrame* vf = _thread->last_java_vframe(&rm);\n+    if (!jt->is_exiting() && jt->has_last_Java_frame()) {\n+      javaVFrame* vf = jt->last_java_vframe(&rm);\n@@ -310,3 +314,9 @@\n-      \/\/ so get current location at safepoint.\n-      VM_GetCurrentLocation op(_thread);\n-      VMThread::execute(&op);\n+      \/\/ so get current location with direct handshake.\n+      GetCurrentLocationClosure op;\n+      Thread *current = Thread::current();\n+      if (current == _thread || _thread->active_handshaker() == current) {\n+        op.do_thread(_thread);\n+      } else {\n+        bool executed = Handshake::execute_direct(&op, _thread);\n+        guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  void clear_to_frame_pop(int frame_number);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -334,2 +334,5 @@\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    hs.do_thread(state->get_thread());\n+  assert(state->get_thread()->is_Java_thread(), \"just checking\");\n+  JavaThread *target = (JavaThread *)state->get_thread();\n+  Thread *current = Thread::current();\n+  if (target == current || target->active_handshaker() == current) {\n+    hs.do_thread(target);\n@@ -337,1 +340,2 @@\n-    Handshake::execute_direct(&hs, state->get_thread());\n+    bool executed = Handshake::execute_direct(&hs, target);\n+    guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n@@ -978,3 +982,0 @@\n-\n-\n-\n@@ -983,1 +984,1 @@\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n+  assert(JvmtiThreadState_lock->is_locked(), \"Must be locked.\");\n@@ -987,1 +988,0 @@\n-\n@@ -990,1 +990,1 @@\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n+  assert(JvmtiThreadState_lock->is_locked(), \"Must be locked.\");\n@@ -992,7 +992,0 @@\n-}\n-\n-\n-void\n-JvmtiEventController::clear_to_frame_pop(JvmtiEnvThreadState *ets, JvmtiFramePop fpop) {\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n-  JvmtiEventControllerPrivate::clear_to_frame_pop(ets, fpop);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-  static void clear_to_frame_pop(JvmtiEnvThreadState *env_thread, JvmtiFramePop fpop);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1648,1 +1648,4 @@\n-        ets->clear_frame_pop(cur_frame_number);\n+        {\n+          MutexLocker mu(JvmtiThreadState_lock);\n+          ets->clear_frame_pop(cur_frame_number);\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -275,3 +275,3 @@\n-  guarantee(SafepointSynchronize::is_at_safepoint() ||\n-    (JavaThread *)Thread::current() == get_thread(),\n-    \"must be current thread or at safepoint\");\n+  Thread *current = Thread::current();\n+  guarantee(current == get_thread() || current == get_thread()->active_handshaker(),\n+            \"must be current thread or direct handshake\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+  { \"InsertMemBarAfterArraycopy\",    JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-    if (SafepointMechanism::should_block(self)) {\n+    if (SafepointMechanism::should_process(self)) {\n@@ -386,1 +386,2 @@\n-  _thread_in_process_handshake(false)\n+  _thread_in_process_handshake(false),\n+  _active_handshaker(NULL)\n@@ -388,1 +389,0 @@\n-  DEBUG_ONLY(_active_handshaker = NULL;)\n@@ -513,1 +513,1 @@\n-    DEBUG_ONLY(_active_handshaker = Thread::current();)\n+    _active_handshaker = Thread::current();\n@@ -515,1 +515,1 @@\n-    DEBUG_ONLY(_active_handshaker = NULL;)\n+    _active_handshaker = NULL;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-#ifdef ASSERT\n@@ -112,2 +111,0 @@\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    SafepointMechanism::block_if_requested(thread);\n+    SafepointMechanism::process_if_requested(thread);\n@@ -117,1 +117,1 @@\n-    if (SafepointMechanism::should_block(thread) || thread->is_suspend_after_native()) {\n+    if (SafepointMechanism::should_process(thread) || thread->is_suspend_after_native()) {\n@@ -138,1 +138,1 @@\n-    SafepointMechanism::block_if_requested(_thread);\n+    SafepointMechanism::process_if_requested(_thread);\n@@ -293,1 +293,1 @@\n-    if (SafepointMechanism::should_block(_thread)) {\n+    if (SafepointMechanism::should_process(_thread)) {\n@@ -295,1 +295,1 @@\n-      SafepointMechanism::block_if_requested(_thread);\n+      SafepointMechanism::process_if_requested(_thread);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-  def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never); \/\/ used for creating jmethodIDs.\n+  def(JmethodIdCreation_lock       , PaddedMutex  , special-2,   true,  _safepoint_check_never); \/\/ used for creating jmethodIDs.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -709,3 +709,0 @@\n-  \/\/ I'd like to write:\n-  \/\/   guarantee (((oop)(object()))->mark() == markWord::encode(this), \"invariant\") ;\n-  \/\/ but as we're at a safepoint that's not safe.\n@@ -1786,1 +1783,1 @@\n-      if (SafepointMechanism::should_block(Self)) {\n+      if (SafepointMechanism::should_process(Self)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -777,1 +777,1 @@\n-  \/\/ cross_modify_fence is done by SafepointMechanism::block_if_requested_slow\n+  \/\/ cross_modify_fence is done by SafepointMechanism::process_operation_if_requested_slow\n@@ -927,1 +927,1 @@\n-\/\/ Block the thread at poll or poll return for safepoint\/handshake.\n+\/\/ Process pending operation.\n@@ -966,2 +966,2 @@\n-    \/\/ Block the thread\n-    SafepointMechanism::block_if_requested(thread());\n+    \/\/ Process pending operation\n+    SafepointMechanism::process_if_requested(thread());\n@@ -982,2 +982,2 @@\n-    \/\/ Block the thread\n-    SafepointMechanism::block_if_requested(thread());\n+    \/\/ Process pending operation\n+    SafepointMechanism::process_if_requested(thread());\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-void SafepointMechanism::block_or_handshake(JavaThread *thread) {\n+void SafepointMechanism::process(JavaThread *thread) {\n@@ -86,1 +86,1 @@\n-void SafepointMechanism::block_if_requested_slow(JavaThread *thread) {\n+void SafepointMechanism::process_if_requested_slow(JavaThread *thread) {\n@@ -91,1 +91,1 @@\n-  block_or_handshake(thread);\n+  process(thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  static void block_or_handshake(JavaThread *thread);\n-  static void block_if_requested_slow(JavaThread *thread);\n+  static void process(JavaThread *thread);\n+  static void process_if_requested_slow(JavaThread *thread);\n@@ -67,1 +67,1 @@\n-  static inline bool should_block(Thread* thread);\n+  static inline bool should_process(Thread* thread);\n@@ -69,2 +69,2 @@\n-  \/\/ Blocks a thread until safepoint\/handshake is completed.\n-  static inline void block_if_requested(JavaThread* thread);\n+  \/\/ Processes a pending requested operation.\n+  static inline void process_if_requested(JavaThread* thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-bool SafepointMechanism::should_block(Thread* thread) {\n+bool SafepointMechanism::should_process(Thread* thread) {\n@@ -54,1 +54,1 @@\n-void SafepointMechanism::block_if_requested(JavaThread *thread) {\n+void SafepointMechanism::process_if_requested(JavaThread *thread) {\n@@ -58,1 +58,1 @@\n-  block_if_requested_slow(thread);\n+  process_if_requested_slow(thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-  if (SafepointMechanism::should_block(thread)) {\n+  if (SafepointMechanism::should_process(thread)) {\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1895,1 +1895,1 @@\n-    \/\/ Note that we allocate the objectmonitor speculatively, _before_ attempting\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n@@ -1897,3 +1897,3 @@\n-    \/\/ allocated the objectmonitor, and then finally STed the address of the\n-    \/\/ objectmonitor into the mark.  This was correct, but artificially lengthened\n-    \/\/ the interval in which INFLATED appeared in the mark, thus increasing\n+    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n+    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n+    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n@@ -1902,1 +1902,1 @@\n-    \/\/ We now use per-thread private objectmonitor free lists.\n+    \/\/ We now use per-thread private ObjectMonitor free lists.\n@@ -1905,1 +1905,1 @@\n-    \/\/ multiple objectmonitors en-mass from the global free list to its local free list.\n+    \/\/ multiple ObjectMonitors en-mass from the global free list to its local free list.\n@@ -1915,1 +1915,1 @@\n-      \/\/ Optimistically prepare the objectmonitor - anticipate successful CAS\n+      \/\/ Optimistically prepare the ObjectMonitor - anticipate successful CAS\n@@ -2316,1 +2316,1 @@\n-      if (SafepointMechanism::should_block(self) &&\n+      if (SafepointMechanism::should_process(self) &&\n@@ -2510,1 +2510,1 @@\n-        assert(SafepointMechanism::should_block(self), \"sanity check\");\n+        assert(SafepointMechanism::should_process(self), \"sanity check\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2616,3 +2616,11 @@\n-  set_thread_state(_thread_blocked);\n-  java_suspend_self();\n-  set_thread_state_fence(state);\n+\n+  do {\n+    set_thread_state(_thread_blocked);\n+    java_suspend_self();\n+    \/\/ The current thread could have been suspended again. We have to check for\n+    \/\/ suspend after restoring the saved state. Without this the current thread\n+    \/\/ might return to _thread_in_Java and execute bytecodes for an arbitrary\n+    \/\/ long time.\n+    set_thread_state_fence(state);\n+  } while (is_external_suspend());\n+\n@@ -2623,1 +2631,1 @@\n-    SafepointMechanism::block_if_requested(this);\n+    SafepointMechanism::process_if_requested(this);\n@@ -2653,1 +2661,1 @@\n-    SafepointMechanism::block_if_requested(thread);\n+    SafepointMechanism::process_if_requested(thread);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1368,1 +1368,0 @@\n-#ifdef ASSERT\n@@ -1372,1 +1371,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-  template(UpdateForPopTopFrame)                  \\\n-  template(SetFramePop)                           \\\n@@ -86,1 +84,0 @@\n-  template(GetCurrentLocation)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-      if (e->hash() == hash && e->_key == key) {\n+      if (e->hash() == hash && EQUALS(e->_key, key)) {\n@@ -322,0 +322,21 @@\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n+  \/\/  pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* add_if_absent(K key, V value, bool* p_created) {\n+    unsigned int hash = HASH(key);\n+    int index = BasicHashtable<F>::hash_to_index(hash);\n+    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n+      if (e->hash() == hash && EQUALS(e->_key, key)) {\n+        *p_created = false;\n+        return &(e->_value);\n+      }\n+    }\n+\n+    KVHashtableEntry* entry = new_entry(hash, key, value);\n+    BasicHashtable<F>::add_entry(BasicHashtable<F>::hash_to_index(hash), entry);\n+    *p_created = true;\n+    return &(entry->_value);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    \/\/ Note: alpha is actually (1.0 - _alpha) in our code\n@@ -52,1 +51,1 @@\n-    double incr = (1.0 - _alpha) * diff;\n+    double incr = _alpha * diff;\n@@ -54,1 +53,1 @@\n-    _dvariance = _alpha * (_dvariance + diff * incr);\n+    _dvariance = (1.0 - _alpha) * (_dvariance + diff * incr);\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#define DEFAULT_ALPHA_VALUE 0.7\n+#define DEFAULT_ALPHA_VALUE 0.3\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-  \/\/ *p_created is new if entry was created, false if entry pre-existed.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n@@ -153,1 +153,1 @@\n-  \/\/ *p_created is new if entry was created, false if entry pre-existed.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.GenerateJLIClassesHelper.traceSpeciesType;\n@@ -478,5 +479,1 @@\n-                if (TRACE_RESOLVE && salvage != null) {\n-                    \/\/ Used by jlink species pregeneration plugin, see\n-                    \/\/ jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin\n-                    System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (salvaged)\");\n-                }\n+                traceSpeciesType(className, salvage);\n@@ -484,3 +481,0 @@\n-                if (TRACE_RESOLVE) {\n-                    System.out.println(\"[SPECIES_FRESOLVE] \" + className + \" (Error) \" + ex.getMessage());\n-                }\n@@ -497,5 +491,1 @@\n-                    if (TRACE_RESOLVE) {\n-                        \/\/ Used by jlink species pregeneration plugin, see\n-                        \/\/ jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin\n-                        System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (generated)\");\n-                    }\n+                    traceSpeciesType(className, salvage);\n@@ -507,3 +497,0 @@\n-                    if (TRACE_RESOLVE) {\n-                        System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (Error #2)\" );\n-                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Stream;\n@@ -36,2 +40,6 @@\n-import static java.lang.invoke.MethodTypeForm.LF_INVINTERFACE;\n-import static java.lang.invoke.MethodTypeForm.LF_INVVIRTUAL;\n+import static java.lang.invoke.LambdaForm.basicTypeSignature;\n+import static java.lang.invoke.LambdaForm.shortenSignature;\n+import static java.lang.invoke.LambdaForm.BasicType.*;\n+import static java.lang.invoke.MethodHandleStatics.TRACE_RESOLVE;\n+import static java.lang.invoke.MethodTypeForm.*;\n+import static java.lang.invoke.LambdaForm.Kind.*;\n@@ -44,0 +52,2 @@\n+    private static final String LF_RESOLVE = \"[LF_RESOLVE]\";\n+    private static final String SPECIES_RESOLVE = \"[SPECIES_RESOLVE]\";\n@@ -45,0 +55,302 @@\n+    static void traceLambdaForm(String name, MethodType type, Class<?> holder, MemberName resolvedMember) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n+                    shortenSignature(basicTypeSignature(type)) +\n+                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+        }\n+    }\n+\n+    static void traceSpeciesType(String cn, Class<?> salvage) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n+        }\n+    }\n+\n+    \/\/ Map from DirectMethodHandle method type name to index to LambdForms\n+    static final Map<String, Integer> DMH_METHOD_TYPE_MAP =\n+            Map.of(\n+                    DIRECT_INVOKE_VIRTUAL.methodName,     LF_INVVIRTUAL,\n+                    DIRECT_INVOKE_STATIC.methodName,      LF_INVSTATIC,\n+                    DIRECT_INVOKE_SPECIAL.methodName,     LF_INVSPECIAL,\n+                    DIRECT_NEW_INVOKE_SPECIAL.methodName, LF_NEWINVSPECIAL,\n+                    DIRECT_INVOKE_INTERFACE.methodName,   LF_INVINTERFACE,\n+                    DIRECT_INVOKE_STATIC_INIT.methodName, LF_INVSTATIC_INIT,\n+                    DIRECT_INVOKE_SPECIAL_IFC.methodName, LF_INVSPECIAL_IFC\n+            );\n+\n+    static final String DIRECT_HOLDER = \"java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String DELEGATING_HOLDER = \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\";\n+    static final String BASIC_FORMS_HOLDER = \"java\/lang\/invoke\/LambdaForm$Holder\";\n+    static final String INVOKERS_HOLDER = \"java\/lang\/invoke\/Invokers$Holder\";\n+    static final String INVOKERS_HOLDER_CLASS_NAME = INVOKERS_HOLDER.replace('\/', '.');\n+    static final String BMH_SPECIES_PREFIX = \"java.lang.invoke.BoundMethodHandle$Species_\";\n+\n+    static class HolderClassBuilder {\n+\n+\n+        private final TreeSet<String> speciesTypes = new TreeSet<>();\n+        private final TreeSet<String> invokerTypes = new TreeSet<>();\n+        private final TreeSet<String> callSiteTypes = new TreeSet<>();\n+        private final Map<String, Set<String>> dmhMethods = new TreeMap<>();\n+\n+        HolderClassBuilder addSpeciesType(String type) {\n+            speciesTypes.add(expandSignature(type));\n+            return this;\n+        }\n+\n+        HolderClassBuilder addInvokerType(String methodType) {\n+            validateMethodType(methodType);\n+            invokerTypes.add(methodType);\n+            return this;\n+        }\n+\n+        HolderClassBuilder addCallSiteType(String csType) {\n+            validateMethodType(csType);\n+            callSiteTypes.add(csType);\n+            return this;\n+        }\n+\n+        Map<String, byte[]> build() {\n+            int count = 0;\n+            for (Set<String> entry : dmhMethods.values()) {\n+                count += entry.size();\n+            }\n+            MethodType[] directMethodTypes = new MethodType[count];\n+            int[] dmhTypes = new int[count];\n+            int index = 0;\n+            for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {\n+                String dmhType = entry.getKey();\n+                for (String type : entry.getValue()) {\n+                    \/\/ The DMH type to actually ask for is retrieved by removing\n+                    \/\/ the first argument, which needs to be of Object.class\n+                    MethodType mt = asMethodType(type);\n+                    if (mt.parameterCount() < 1 ||\n+                            mt.parameterType(0) != Object.class) {\n+                        throw new RuntimeException(\n+                                \"DMH type parameter must start with L: \" + dmhType + \" \" + type);\n+                    }\n+\n+                    \/\/ Adapt the method type of the LF to retrieve\n+                    directMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+\n+                    \/\/ invokeVirtual and invokeInterface must have a leading Object\n+                    \/\/ parameter, i.e., the receiver\n+                    dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);\n+                    if (dmhTypes[index] == LF_INVINTERFACE || dmhTypes[index] == LF_INVVIRTUAL) {\n+                        if (mt.parameterCount() < 2 ||\n+                                mt.parameterType(1) != Object.class) {\n+                            throw new RuntimeException(\n+                                    \"DMH type parameter must start with LL: \" + dmhType + \" \" + type);\n+                        }\n+                    }\n+                    index++;\n+                }\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ and the last argument, which needs to be of Object.class\n+            MethodType[] invokerMethodTypes = new MethodType[invokerTypes.size()];\n+            index = 0;\n+            for (String invokerType : invokerTypes) {\n+                MethodType mt = asMethodType(invokerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 2 ||\n+                        mt.parameterType(0) != Object.class ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The callSite type to ask for is retrieved by removing the last\n+            \/\/ argument, which needs to be of Object.class\n+            MethodType[] callSiteMethodTypes = new MethodType[callSiteTypes.size()];\n+            index = 0;\n+            for (String callSiteType : callSiteTypes) {\n+                MethodType mt = asMethodType(callSiteType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 1 ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"CallSite type parameter must end with Object: \" + callSiteType);\n+                }\n+                callSiteMethodTypes[index] = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                index++;\n+            }\n+\n+            Map<String, byte[]> result = new TreeMap<>();\n+            result.put(DIRECT_HOLDER,\n+                       generateDirectMethodHandleHolderClassBytes(\n+                            DIRECT_HOLDER, directMethodTypes, dmhTypes));\n+            result.put(DELEGATING_HOLDER,\n+                       generateDelegatingMethodHandleHolderClassBytes(\n+                            DELEGATING_HOLDER, directMethodTypes));\n+            result.put(INVOKERS_HOLDER,\n+                       generateInvokersHolderClassBytes(INVOKERS_HOLDER,\n+                            invokerMethodTypes, callSiteMethodTypes));\n+            result.put(BASIC_FORMS_HOLDER,\n+                       generateBasicFormsClassBytes(BASIC_FORMS_HOLDER));\n+\n+            speciesTypes.forEach(types -> {\n+                Map.Entry<String, byte[]> entry = generateConcreteBMHClassBytes(types);\n+                result.put(entry.getKey(), entry.getValue());\n+            });\n+\n+            \/\/ clear builder\n+            speciesTypes.clear();\n+            invokerTypes.clear();\n+            callSiteTypes.clear();\n+            dmhMethods.clear();\n+\n+            return result;\n+        }\n+\n+        private static MethodType asMethodType(String basicSignatureString) {\n+            String[] parts = basicSignatureString.split(\"_\");\n+            assert (parts.length == 2);\n+            assert (parts[1].length() == 1);\n+            String parameters = expandSignature(parts[0]);\n+            Class<?> rtype = simpleType(parts[1].charAt(0));\n+            if (parameters.isEmpty()) {\n+                return MethodType.methodType(rtype);\n+            } else {\n+                Class<?>[] ptypes = new Class<?>[parameters.length()];\n+                for (int i = 0; i < ptypes.length; i++) {\n+                    ptypes[i] = simpleType(parameters.charAt(i));\n+                }\n+                return MethodType.methodType(rtype, ptypes);\n+            }\n+        }\n+\n+        private void addDMHMethodType(String dmh, String methodType) {\n+            validateMethodType(methodType);\n+            Set<String> methodTypes = dmhMethods.get(dmh);\n+            if (methodTypes == null) {\n+                methodTypes = new TreeSet<>();\n+                dmhMethods.put(dmh, methodTypes);\n+            }\n+            methodTypes.add(methodType);\n+        }\n+\n+        private static void validateMethodType(String type) {\n+            String[] typeParts = type.split(\"_\");\n+            \/\/ check return type (second part)\n+            if (typeParts.length != 2 || typeParts[1].length() != 1\n+                    || !isBasicTypeChar(typeParts[1].charAt(0))) {\n+                throw new RuntimeException(\n+                        \"Method type signature must be of form [LJIFD]*_[LJIFDV]\");\n+            }\n+            \/\/ expand and check arguments (first part)\n+            expandSignature(typeParts[0]);\n+        }\n+\n+        \/\/ Convert LL -> LL, L3 -> LLL\n+        private static String expandSignature(String signature) {\n+            StringBuilder sb = new StringBuilder();\n+            char last = 'X';\n+            int count = 0;\n+            for (int i = 0; i < signature.length(); i++) {\n+                char c = signature.charAt(i);\n+                if (c >= '0' && c <= '9') {\n+                    count *= 10;\n+                    count += (c - '0');\n+                } else {\n+                    requireBasicType(c);\n+                    for (int j = 1; j < count; j++) {\n+                        sb.append(last);\n+                    }\n+                    sb.append(c);\n+                    last = c;\n+                    count = 0;\n+                }\n+            }\n+\n+            \/\/ ended with a number, e.g., \"L2\": append last char count - 1 times\n+            if (count > 1) {\n+                requireBasicType(last);\n+                for (int j = 1; j < count; j++) {\n+                    sb.append(last);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void requireBasicType(char c) {\n+            if (!isArgBasicTypeChar(c)) {\n+                throw new RuntimeException(\n+                        \"Character \" + c + \" must correspond to a basic field type: LIJFD\");\n+            }\n+        }\n+\n+        private static Class<?> simpleType(char c) {\n+            if (isBasicTypeChar(c)) {\n+                return LambdaForm.BasicType.basicType(c).basicTypeClass();\n+            }\n+            switch (c) {\n+                case 'Z':\n+                case 'B':\n+                case 'S':\n+                case 'C':\n+                    throw new IllegalArgumentException(\"Not a valid primitive: \" + c +\n+                            \" (use I instead)\");\n+                default:\n+                    throw new IllegalArgumentException(\"Not a primitive: \" + c);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Returns a map of class name in internal form to the corresponding class bytes\n+     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n+     *\n+     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n+     * jlink phase.\n+     *\/\n+    static Map<String, byte[]> generateHolderClasses(Stream<String> traces)  {\n+        HolderClassBuilder builder = new HolderClassBuilder();\n+        traces.map(line -> line.split(\" \"))\n+                .forEach(parts -> {\n+                    switch (parts[0]) {\n+                        case SPECIES_RESOLVE:\n+                            \/\/ Allow for new types of species data classes being resolved here\n+                            assert parts.length == 3;\n+                            if (parts[1].startsWith(BMH_SPECIES_PREFIX)) {\n+                                String species = parts[1].substring(BMH_SPECIES_PREFIX.length());\n+                                if (!\"L\".equals(species)) {\n+                                    builder.addSpeciesType(species);\n+                                }\n+                            }\n+                            break;\n+                        case LF_RESOLVE:\n+                            assert parts.length > 3;\n+                            String methodType = parts[3];\n+                            if (parts[1].equals(INVOKERS_HOLDER_CLASS_NAME)) {\n+                                if (\"linkToTargetMethod\".equals(parts[2]) ||\n+                                        \"linkToCallSite\".equals(parts[2])) {\n+                                    builder.addCallSiteType(methodType);\n+                                } else {\n+                                    builder.addInvokerType(methodType);\n+                                }\n+                            } else if (parts[1].contains(\"DirectMethodHandle\")) {\n+                                String dmh = parts[2];\n+                                \/\/ ignore getObject etc for now (generated by default)\n+                                if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {\n+                                    builder.addDMHMethodType(dmh, methodType);\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break; \/\/ ignore\n+                    }\n+                });\n+\n+        return builder.build();\n+    }\n+\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n+     *\/\n@@ -71,0 +383,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n+     * an {@code int} representing method type.\n+     *\/\n@@ -118,0 +435,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DelegatingMethodHandles of each {@code MethodType} kind in the\n+     * {@code methodTypes} argument.\n+     *\/\n@@ -148,0 +470,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n+     *\/\n@@ -196,4 +523,1 @@\n-    private static byte[] generateCodeBytesForLFs(String className,\n-            String[] names, LambdaForm[] forms) {\n-\n-\n+    private static byte[] generateCodeBytesForLFs(String className, String[] names, LambdaForm[] forms) {\n@@ -232,0 +556,4 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n+     * species class implementing the signature defined by {@code types}.\n+     *\/\n@@ -235,1 +563,1 @@\n-            if (\"LIJFD\".indexOf(c) < 0) {\n+            if (!isArgBasicTypeChar(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":336,"deletions":8,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.GenerateJLIClassesHelper.traceLambdaForm;\n@@ -699,4 +700,1 @@\n-        if (TRACE_RESOLVE) {\n-            System.out.println(\"[LF_RESOLVE] \" + holder.getName() + \" \" + name + \" \" +\n-                    shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? \" (success)\" : \" (fail)\") );\n-        }\n+        traceLambdaForm(name, type, holder, resolvedMember);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1767,35 +1767,2 @@\n-            public byte[] generateDirectMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes, int[] types) {\n-                return GenerateJLIClassesHelper\n-                        .generateDirectMethodHandleHolderClassBytes(\n-                                className, methodTypes, types);\n-            }\n-\n-            @Override\n-            public byte[] generateDelegatingMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateDelegatingMethodHandleHolderClassBytes(\n-                                className, methodTypes);\n-            }\n-\n-            @Override\n-            public Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-                    final String types) {\n-                return GenerateJLIClassesHelper\n-                        .generateConcreteBMHClassBytes(types);\n-            }\n-\n-            @Override\n-            public byte[] generateBasicFormsClassBytes(final String className) {\n-                return GenerateJLIClassesHelper\n-                        .generateBasicFormsClassBytes(className);\n-            }\n-\n-            @Override\n-            public byte[] generateInvokersHolderClassBytes(final String className,\n-                    MethodType[] invokerMethodTypes,\n-                    MethodType[] callSiteMethodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateInvokersHolderClassBytes(className,\n-                                invokerMethodTypes, callSiteMethodTypes);\n+            public Map<String, byte[]> generateHolderClasses(Stream<String> traces) {\n+                return GenerateJLIClassesHelper.generateHolderClasses(traces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,3 @@\n- * <pre>\n- *     void foo(Map m) {\n- *         Map copy = new LinkedHashMap(m);\n+ * <pre>{@code\n+ *     void foo(Map<String, Integer> m) {\n+ *         Map<String, Integer> copy = new LinkedHashMap<>(m);\n@@ -55,1 +55,1 @@\n- * <\/pre>\n+ * }<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,3 +45,3 @@\n- * <pre>\n- *     void foo(Set s) {\n- *         Set copy = new LinkedHashSet(s);\n+ * <pre>{@code\n+ *     void foo(Set<String> s) {\n+ *         Set<String> copy = new LinkedHashSet<>(s);\n@@ -50,1 +50,1 @@\n- * <\/pre>\n+ * }<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashSet.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    int posixPerms = -1;\/\/ posix permissions\n+    int extraAttributes = -1; \/\/ e.g. POSIX permissions, sym links.\n@@ -134,1 +134,1 @@\n-        posixPerms = e.posixPerms;\n+        extraAttributes = e.extraAttributes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-            \/\/ 12 bits for setuid, setgid, sticky + perms\n-            e.posixPerms = CENATX_PERMS(cen, pos) & 0xFFF;\n+            \/\/ read all bits in this field, including sym link attributes\n+            e.extraAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n@@ -1099,1 +1099,0 @@\n-                \/\/ only set posix perms value via ZipEntry contructor for now\n@@ -1101,2 +1100,2 @@\n-                public int getPosixPerms(ZipEntry ze) {\n-                    return ze.posixPerms;\n+                public int getExtraAttributes(ZipEntry ze) {\n+                    return ze.extraAttributes;\n@@ -1105,2 +1104,2 @@\n-                public void setPosixPerms(ZipEntry ze, int perms) {\n-                    ze.posixPerms = perms;\n+                public void setExtraAttributes(ZipEntry ze, int extraAttrs) {\n+                    ze.extraAttributes = extraAttrs;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,1 +514,1 @@\n-        return (e.posixPerms < 0) ? version :\n+        return (e.extraAttributes < 0) ? version :\n@@ -609,2 +609,2 @@\n-        \/\/ external file attributes, used for storing posix permissions\n-        writeInt(e.posixPerms > 0 ? e.posixPerms << 16 : 0);\n+        \/\/ extra file attributes, used for storing posix permissions etc.\n+        writeInt(e.extraAttributes > 0 ? e.extraAttributes << 16 : 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -71,4 +72,4 @@\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n-     * an {@code int} representing method type.  Used by\n-     * GenerateJLIClassesPlugin to generate such a class during the jlink phase.\n+     * Returns a map of class name in internal forms to its corresponding\n+     * class bytes per the given stream of LF_RESOLVE and SPECIES_RESOLVE\n+     * trace logs. Used by GenerateJLIClassesPlugin to enable generation\n+     * of such classes during the jlink phase.\n@@ -76,36 +77,1 @@\n-    byte[] generateDirectMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes, int[] types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DelegatingMethodHandles of each {@code MethodType} kind in the\n-     * {@code methodTypes} argument.  Used by GenerateJLIClassesPlugin to\n-     * generate such a class during the jlink phase.\n-     *\/\n-    byte[] generateDelegatingMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n-     * species class implementing the signature defined by {@code types}. Used\n-     * by GenerateJLIClassesPlugin to enable generation of such classes during\n-     * the jlink phase. Should do some added validation since this string may be\n-     * user provided.\n-     *\/\n-    Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-            final String types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n-     *\/\n-    byte[] generateBasicFormsClassBytes(final String className);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n-     *\/\n-    byte[] generateInvokersHolderClassBytes(String className,\n-            MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes);\n+    Map<String, byte[]> generateHolderClasses(Stream<String> traces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":6,"deletions":40,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-    public void setPosixPerms(ZipEntry ze, int posixPerms);\n-    public int getPosixPerms(ZipEntry ze);\n+    public void setExtraAttributes(ZipEntry ze, int extraAttrs);\n+    public int getExtraAttributes(ZipEntry ze);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-            throw new IllegalAccessError(\"Already connected\");\n+            throw new IllegalStateException(\"Already connected\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/URLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        POSIXPERMS();\n+        ZIPFILEATTRS();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Event.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1338,1 +1338,1 @@\n-    [[NSNotificationCenter defaultCenter] addObserver:self\n+    [[NSNotificationCenter defaultCenter] addObserver:[AWTView class]\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-public class CMMException extends java.lang.RuntimeException {\n+public class CMMException extends RuntimeException {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/CMMException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.io.Serializable;\n@@ -94,1 +95,1 @@\n-public abstract class ColorSpace implements java.io.Serializable {\n+public abstract class ColorSpace implements Serializable {\n@@ -96,1 +97,4 @@\n-    static final long serialVersionUID = -409452704308689724L;\n+    \/**\n+     * Use serialVersionUID from JDK 1.2 for interoperability.\n+     *\/\n+    private static final long serialVersionUID = -409452704308689724L;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ColorSpace.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,4 @@\n-    static final long serialVersionUID = 3455889114070431483L;\n+    \/**\n+     * Use serialVersionUID from JDK 1.2 for interoperability.\n+     *\/\n+    private static final long serialVersionUID = 3455889114070431483L;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,3 @@\n+    \/**\n+     * Use serialVersionUID from JDK 1.2 for interoperability.\n+     *\/\n@@ -140,0 +143,1 @@\n+\n@@ -143,1 +147,1 @@\n-    public static final int icSigXYZData        = 0x58595A20;    \/* 'XYZ ' *\/\n+    public static final int icSigXYZData = 0x58595A20;\n@@ -148,1 +152,1 @@\n-    public static final int icSigLabData        = 0x4C616220;    \/* 'Lab ' *\/\n+    public static final int icSigLabData = 0x4C616220;\n@@ -153,1 +157,1 @@\n-    public static final int icSigLuvData        = 0x4C757620;    \/* 'Luv ' *\/\n+    public static final int icSigLuvData = 0x4C757620;\n@@ -158,1 +162,1 @@\n-    public static final int icSigYCbCrData        = 0x59436272;    \/* 'YCbr' *\/\n+    public static final int icSigYCbCrData = 0x59436272;\n@@ -163,1 +167,1 @@\n-    public static final int icSigYxyData        = 0x59787920;    \/* 'Yxy ' *\/\n+    public static final int icSigYxyData = 0x59787920;\n@@ -168,1 +172,1 @@\n-    public static final int icSigRgbData        = 0x52474220;    \/* 'RGB ' *\/\n+    public static final int icSigRgbData = 0x52474220;\n@@ -173,1 +177,1 @@\n-    public static final int icSigGrayData        = 0x47524159;    \/* 'GRAY' *\/\n+    public static final int icSigGrayData = 0x47524159;\n@@ -178,1 +182,1 @@\n-    public static final int icSigHsvData        = 0x48535620;    \/* 'HSV ' *\/\n+    public static final int icSigHsvData = 0x48535620;\n@@ -183,1 +187,1 @@\n-    public static final int icSigHlsData        = 0x484C5320;    \/* 'HLS ' *\/\n+    public static final int icSigHlsData = 0x484C5320;\n@@ -188,1 +192,1 @@\n-    public static final int icSigCmykData        = 0x434D594B;    \/* 'CMYK' *\/\n+    public static final int icSigCmykData = 0x434D594B;\n@@ -193,1 +197,1 @@\n-    public static final int icSigCmyData        = 0x434D5920;    \/* 'CMY ' *\/\n+    public static final int icSigCmyData = 0x434D5920;\n@@ -198,1 +202,1 @@\n-    public static final int icSigSpace2CLR        = 0x32434C52;    \/* '2CLR' *\/\n+    public static final int icSigSpace2CLR = 0x32434C52;\n@@ -203,1 +207,1 @@\n-    public static final int icSigSpace3CLR        = 0x33434C52;    \/* '3CLR' *\/\n+    public static final int icSigSpace3CLR = 0x33434C52;\n@@ -208,1 +212,1 @@\n-    public static final int icSigSpace4CLR        = 0x34434C52;    \/* '4CLR' *\/\n+    public static final int icSigSpace4CLR = 0x34434C52;\n@@ -213,1 +217,1 @@\n-    public static final int icSigSpace5CLR        = 0x35434C52;    \/* '5CLR' *\/\n+    public static final int icSigSpace5CLR = 0x35434C52;\n@@ -218,1 +222,1 @@\n-    public static final int icSigSpace6CLR        = 0x36434C52;    \/* '6CLR' *\/\n+    public static final int icSigSpace6CLR = 0x36434C52;\n@@ -223,1 +227,1 @@\n-    public static final int icSigSpace7CLR        = 0x37434C52;    \/* '7CLR' *\/\n+    public static final int icSigSpace7CLR = 0x37434C52;\n@@ -228,1 +232,1 @@\n-    public static final int icSigSpace8CLR        = 0x38434C52;    \/* '8CLR' *\/\n+    public static final int icSigSpace8CLR = 0x38434C52;\n@@ -233,1 +237,1 @@\n-    public static final int icSigSpace9CLR        = 0x39434C52;    \/* '9CLR' *\/\n+    public static final int icSigSpace9CLR = 0x39434C52;\n@@ -238,1 +242,1 @@\n-    public static final int icSigSpaceACLR        = 0x41434C52;    \/* 'ACLR' *\/\n+    public static final int icSigSpaceACLR = 0x41434C52;\n@@ -243,1 +247,1 @@\n-    public static final int icSigSpaceBCLR        = 0x42434C52;    \/* 'BCLR' *\/\n+    public static final int icSigSpaceBCLR = 0x42434C52;\n@@ -248,1 +252,1 @@\n-    public static final int icSigSpaceCCLR        = 0x43434C52;    \/* 'CCLR' *\/\n+    public static final int icSigSpaceCCLR = 0x43434C52;\n@@ -253,1 +257,1 @@\n-    public static final int icSigSpaceDCLR        = 0x44434C52;    \/* 'DCLR' *\/\n+    public static final int icSigSpaceDCLR = 0x44434C52;\n@@ -258,1 +262,1 @@\n-    public static final int icSigSpaceECLR        = 0x45434C52;    \/* 'ECLR' *\/\n+    public static final int icSigSpaceECLR = 0x45434C52;\n@@ -263,1 +267,1 @@\n-    public static final int icSigSpaceFCLR        = 0x46434C52;    \/* 'FCLR' *\/\n+    public static final int icSigSpaceFCLR = 0x46434C52;\n@@ -269,1 +273,1 @@\n-    public static final int icSigInputClass       = 0x73636E72;    \/* 'scnr' *\/\n+    public static final int icSigInputClass = 0x73636E72;\n@@ -274,1 +278,1 @@\n-    public static final int icSigDisplayClass     = 0x6D6E7472;    \/* 'mntr' *\/\n+    public static final int icSigDisplayClass = 0x6D6E7472;\n@@ -279,1 +283,1 @@\n-    public static final int icSigOutputClass      = 0x70727472;    \/* 'prtr' *\/\n+    public static final int icSigOutputClass = 0x70727472;\n@@ -284,1 +288,1 @@\n-    public static final int icSigLinkClass        = 0x6C696E6B;    \/* 'link' *\/\n+    public static final int icSigLinkClass = 0x6C696E6B;\n@@ -289,1 +293,1 @@\n-    public static final int icSigAbstractClass    = 0x61627374;    \/* 'abst' *\/\n+    public static final int icSigAbstractClass = 0x61627374;\n@@ -294,1 +298,1 @@\n-    public static final int icSigColorSpaceClass  = 0x73706163;    \/* 'spac' *\/\n+    public static final int icSigColorSpaceClass = 0x73706163;\n@@ -299,1 +303,1 @@\n-    public static final int icSigNamedColorClass  = 0x6e6d636c;    \/* 'nmcl' *\/\n+    public static final int icSigNamedColorClass = 0x6e6d636c;\n@@ -305,1 +309,1 @@\n-    public static final int icPerceptual            = 0;\n+    public static final int icPerceptual = 0;\n@@ -310,1 +314,1 @@\n-    public static final int icRelativeColorimetric    = 1;\n+    public static final int icRelativeColorimetric = 1;\n@@ -322,1 +326,1 @@\n-    public static final int icSaturation            = 2;\n+    public static final int icSaturation = 2;\n@@ -327,1 +331,1 @@\n-    public static final int icAbsoluteColorimetric    = 3;\n+    public static final int icAbsoluteColorimetric = 3;\n@@ -340,1 +344,1 @@\n-    public static final int icSigHead      = 0x68656164; \/* 'head' - special *\/\n+    public static final int icSigHead = 0x68656164;\n@@ -345,1 +349,1 @@\n-    public static final int icSigAToB0Tag         = 0x41324230;    \/* 'A2B0' *\/\n+    public static final int icSigAToB0Tag = 0x41324230;\n@@ -350,1 +354,1 @@\n-    public static final int icSigAToB1Tag         = 0x41324231;    \/* 'A2B1' *\/\n+    public static final int icSigAToB1Tag = 0x41324231;\n@@ -355,1 +359,1 @@\n-    public static final int icSigAToB2Tag         = 0x41324232;    \/* 'A2B2' *\/\n+    public static final int icSigAToB2Tag = 0x41324232;\n@@ -360,1 +364,1 @@\n-    public static final int icSigBlueColorantTag  = 0x6258595A;    \/* 'bXYZ' *\/\n+    public static final int icSigBlueColorantTag = 0x6258595A;\n@@ -367,1 +371,1 @@\n-    public static final int icSigBlueMatrixColumnTag = 0x6258595A; \/* 'bXYZ' *\/\n+    public static final int icSigBlueMatrixColumnTag = 0x6258595A;\n@@ -372,1 +376,1 @@\n-    public static final int icSigBlueTRCTag       = 0x62545243;    \/* 'bTRC' *\/\n+    public static final int icSigBlueTRCTag = 0x62545243;\n@@ -377,1 +381,1 @@\n-    public static final int icSigBToA0Tag         = 0x42324130;    \/* 'B2A0' *\/\n+    public static final int icSigBToA0Tag = 0x42324130;\n@@ -382,1 +386,1 @@\n-    public static final int icSigBToA1Tag         = 0x42324131;    \/* 'B2A1' *\/\n+    public static final int icSigBToA1Tag = 0x42324131;\n@@ -387,1 +391,1 @@\n-    public static final int icSigBToA2Tag         = 0x42324132;    \/* 'B2A2' *\/\n+    public static final int icSigBToA2Tag = 0x42324132;\n@@ -393,1 +397,0 @@\n-                                                                   \/* 'calt' *\/\n@@ -398,1 +401,1 @@\n-    public static final int icSigCharTargetTag    = 0x74617267;    \/* 'targ' *\/\n+    public static final int icSigCharTargetTag = 0x74617267;\n@@ -403,1 +406,1 @@\n-    public static final int icSigCopyrightTag     = 0x63707274;    \/* 'cprt' *\/\n+    public static final int icSigCopyrightTag = 0x63707274;\n@@ -408,1 +411,1 @@\n-    public static final int icSigCrdInfoTag       = 0x63726469;    \/* 'crdi' *\/\n+    public static final int icSigCrdInfoTag = 0x63726469;\n@@ -413,1 +416,1 @@\n-    public static final int icSigDeviceMfgDescTag = 0x646D6E64;    \/* 'dmnd' *\/\n+    public static final int icSigDeviceMfgDescTag = 0x646D6E64;\n@@ -418,1 +421,1 @@\n-    public static final int icSigDeviceModelDescTag = 0x646D6464;  \/* 'dmdd' *\/\n+    public static final int icSigDeviceModelDescTag = 0x646D6464;\n@@ -423,1 +426,1 @@\n-    public static final int icSigDeviceSettingsTag =  0x64657673;  \/* 'devs' *\/\n+    public static final int icSigDeviceSettingsTag = 0x64657673;\n@@ -428,1 +431,1 @@\n-    public static final int icSigGamutTag         = 0x67616D74;    \/* 'gamt' *\/\n+    public static final int icSigGamutTag = 0x67616D74;\n@@ -433,1 +436,1 @@\n-    public static final int icSigGrayTRCTag       = 0x6b545243;    \/* 'kTRC' *\/\n+    public static final int icSigGrayTRCTag = 0x6b545243;\n@@ -438,1 +441,1 @@\n-    public static final int icSigGreenColorantTag = 0x6758595A;    \/* 'gXYZ' *\/\n+    public static final int icSigGreenColorantTag = 0x6758595A;\n@@ -445,1 +448,1 @@\n-    public static final int icSigGreenMatrixColumnTag = 0x6758595A;\/* 'gXYZ' *\/\n+    public static final int icSigGreenMatrixColumnTag = 0x6758595A;\n@@ -450,1 +453,1 @@\n-    public static final int icSigGreenTRCTag      = 0x67545243;    \/* 'gTRC' *\/\n+    public static final int icSigGreenTRCTag = 0x67545243;\n@@ -455,1 +458,1 @@\n-    public static final int icSigLuminanceTag     = 0x6C756d69;    \/* 'lumi' *\/\n+    public static final int icSigLuminanceTag = 0x6C756d69;\n@@ -460,1 +463,1 @@\n-    public static final int icSigMeasurementTag   = 0x6D656173;    \/* 'meas' *\/\n+    public static final int icSigMeasurementTag = 0x6D656173;\n@@ -465,1 +468,1 @@\n-    public static final int icSigMediaBlackPointTag = 0x626B7074;  \/* 'bkpt' *\/\n+    public static final int icSigMediaBlackPointTag = 0x626B7074;\n@@ -470,1 +473,1 @@\n-    public static final int icSigMediaWhitePointTag = 0x77747074;  \/* 'wtpt' *\/\n+    public static final int icSigMediaWhitePointTag = 0x77747074;\n@@ -475,1 +478,1 @@\n-    public static final int icSigNamedColor2Tag   = 0x6E636C32;    \/* 'ncl2' *\/\n+    public static final int icSigNamedColor2Tag = 0x6E636C32;\n@@ -480,1 +483,1 @@\n-    public static final int icSigOutputResponseTag = 0x72657370;   \/* 'resp' *\/\n+    public static final int icSigOutputResponseTag = 0x72657370;\n@@ -485,1 +488,1 @@\n-    public static final int icSigPreview0Tag      = 0x70726530;    \/* 'pre0' *\/\n+    public static final int icSigPreview0Tag = 0x70726530;\n@@ -490,1 +493,1 @@\n-    public static final int icSigPreview1Tag      = 0x70726531;    \/* 'pre1' *\/\n+    public static final int icSigPreview1Tag = 0x70726531;\n@@ -495,1 +498,1 @@\n-    public static final int icSigPreview2Tag      = 0x70726532;    \/* 'pre2' *\/\n+    public static final int icSigPreview2Tag = 0x70726532;\n@@ -501,1 +504,0 @@\n-                                                                   \/* 'desc' *\/\n@@ -507,1 +509,0 @@\n-                                                                   \/* 'pseq' *\/\n@@ -512,1 +513,1 @@\n-    public static final int icSigPs2CRD0Tag       = 0x70736430;    \/* 'psd0' *\/\n+    public static final int icSigPs2CRD0Tag = 0x70736430;\n@@ -517,1 +518,1 @@\n-    public static final int icSigPs2CRD1Tag       = 0x70736431;    \/* 'psd1' *\/\n+    public static final int icSigPs2CRD1Tag = 0x70736431;\n@@ -522,1 +523,1 @@\n-    public static final int icSigPs2CRD2Tag       = 0x70736432;    \/* 'psd2' *\/\n+    public static final int icSigPs2CRD2Tag = 0x70736432;\n@@ -527,1 +528,1 @@\n-    public static final int icSigPs2CRD3Tag       = 0x70736433;    \/* 'psd3' *\/\n+    public static final int icSigPs2CRD3Tag = 0x70736433;\n@@ -532,1 +533,1 @@\n-    public static final int icSigPs2CSATag        = 0x70733273;    \/* 'ps2s' *\/\n+    public static final int icSigPs2CSATag = 0x70733273;\n@@ -538,1 +539,0 @@\n-                                                                   \/* 'ps2i' *\/\n@@ -543,1 +543,1 @@\n-    public static final int icSigRedColorantTag   = 0x7258595A;    \/* 'rXYZ' *\/\n+    public static final int icSigRedColorantTag = 0x7258595A;\n@@ -550,1 +550,1 @@\n-    public static final int icSigRedMatrixColumnTag = 0x7258595A;  \/* 'rXYZ' *\/\n+    public static final int icSigRedMatrixColumnTag = 0x7258595A;\n@@ -555,1 +555,1 @@\n-    public static final int icSigRedTRCTag        = 0x72545243;    \/* 'rTRC' *\/\n+    public static final int icSigRedTRCTag = 0x72545243;\n@@ -560,1 +560,1 @@\n-    public static final int icSigScreeningDescTag = 0x73637264;    \/* 'scrd' *\/\n+    public static final int icSigScreeningDescTag = 0x73637264;\n@@ -565,1 +565,1 @@\n-    public static final int icSigScreeningTag     = 0x7363726E;    \/* 'scrn' *\/\n+    public static final int icSigScreeningTag = 0x7363726E;\n@@ -570,1 +570,1 @@\n-    public static final int icSigTechnologyTag    = 0x74656368;    \/* 'tech' *\/\n+    public static final int icSigTechnologyTag = 0x74656368;\n@@ -575,1 +575,1 @@\n-    public static final int icSigUcrBgTag         = 0x62666420;    \/* 'bfd ' *\/\n+    public static final int icSigUcrBgTag = 0x62666420;\n@@ -580,1 +580,1 @@\n-    public static final int icSigViewingCondDescTag = 0x76756564;  \/* 'vued' *\/\n+    public static final int icSigViewingCondDescTag = 0x76756564;\n@@ -585,1 +585,1 @@\n-    public static final int icSigViewingConditionsTag = 0x76696577;\/* 'view' *\/\n+    public static final int icSigViewingConditionsTag = 0x76696577;\n@@ -590,1 +590,1 @@\n-    public static final int icSigChromaticityTag  = 0x6368726d;    \/* 'chrm' *\/\n+    public static final int icSigChromaticityTag = 0x6368726d;\n@@ -597,1 +597,1 @@\n-    public static final int icSigChromaticAdaptationTag = 0x63686164;\/* 'chad' *\/\n+    public static final int icSigChromaticAdaptationTag = 0x63686164;\n@@ -604,1 +604,1 @@\n-    public static final int icSigColorantOrderTag = 0x636C726F;    \/* 'clro' *\/\n+    public static final int icSigColorantOrderTag = 0x636C726F;\n@@ -611,1 +611,1 @@\n-    public static final int icSigColorantTableTag = 0x636C7274;    \/* 'clrt' *\/\n+    public static final int icSigColorantTableTag = 0x636C7274;\n@@ -617,1 +617,1 @@\n-    public static final int icHdrSize         = 0;  \/* Profile size in bytes *\/\n+    public static final int icHdrSize = 0;\n@@ -622,1 +622,1 @@\n-    public static final int icHdrCmmId        = 4;  \/* CMM for this profile *\/\n+    public static final int icHdrCmmId = 4;\n@@ -627,1 +627,1 @@\n-    public static final int icHdrVersion      = 8;  \/* Format version number *\/\n+    public static final int icHdrVersion = 8;\n@@ -632,1 +632,1 @@\n-    public static final int icHdrDeviceClass  = 12; \/* Type of profile *\/\n+    public static final int icHdrDeviceClass = 12;\n@@ -637,1 +637,1 @@\n-    public static final int icHdrColorSpace   = 16; \/* Color space of data *\/\n+    public static final int icHdrColorSpace = 16;\n@@ -642,1 +642,1 @@\n-    public static final int icHdrPcs          = 20; \/* PCS - XYZ or Lab only *\/\n+    public static final int icHdrPcs = 20;\n@@ -647,1 +647,1 @@\n-    public static final int icHdrDate       = 24; \/* Date profile was created *\/\n+    public static final int icHdrDate = 24;\n@@ -652,1 +652,1 @@\n-    public static final int icHdrMagic        = 36; \/* icMagicNumber *\/\n+    public static final int icHdrMagic = 36;\n@@ -657,1 +657,1 @@\n-    public static final int icHdrPlatform     = 40; \/* Primary Platform *\/\n+    public static final int icHdrPlatform = 40;\n@@ -662,1 +662,1 @@\n-    public static final int icHdrFlags        = 44; \/* Various bit settings *\/\n+    public static final int icHdrFlags = 44;\n@@ -667,1 +667,1 @@\n-    public static final int icHdrManufacturer = 48; \/* Device manufacturer *\/\n+    public static final int icHdrManufacturer = 48;\n@@ -672,1 +672,1 @@\n-    public static final int icHdrModel        = 52; \/* Device model number *\/\n+    public static final int icHdrModel = 52;\n@@ -677,1 +677,1 @@\n-    public static final int icHdrAttributes   = 56; \/* Device attributes *\/\n+    public static final int icHdrAttributes = 56;\n@@ -682,1 +682,1 @@\n-    public static final int icHdrRenderingIntent = 64; \/* Rendering intent *\/\n+    public static final int icHdrRenderingIntent = 64;\n@@ -687,1 +687,1 @@\n-    public static final int icHdrIlluminant   = 68; \/* Profile illuminant *\/\n+    public static final int icHdrIlluminant = 68;\n@@ -692,1 +692,1 @@\n-    public static final int icHdrCreator      = 80; \/* Profile creator *\/\n+    public static final int icHdrCreator = 80;\n@@ -699,1 +699,1 @@\n-    public static final int icHdrProfileID = 84; \/* Profile's ID *\/\n+    public static final int icHdrProfileID = 84;\n@@ -705,1 +705,1 @@\n-    public static final int icTagType          = 0;    \/* tag type signature *\/\n+    public static final int icTagType = 0;\n@@ -710,1 +710,1 @@\n-    public static final int icTagReserved      = 4;    \/* reserved *\/\n+    public static final int icTagReserved = 4;\n@@ -715,1 +715,1 @@\n-    public static final int icCurveCount       = 8;    \/* curveType count *\/\n+    public static final int icCurveCount = 8;\n@@ -720,1 +720,1 @@\n-    public static final int icCurveData        = 12;   \/* curveType data *\/\n+    public static final int icCurveData = 12;\n@@ -725,1 +725,1 @@\n-    public static final int icXYZNumberX       = 8;    \/* XYZNumber X *\/\n+    public static final int icXYZNumberX = 8;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":111,"deletions":111,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,1 @@\n-public class ICC_ProfileGray\n-extends ICC_Profile {\n+public class ICC_ProfileGray extends ICC_Profile {\n@@ -73,1 +72,1 @@\n-    static final long serialVersionUID = -1124721290732002649L;\n+    private static final long serialVersionUID = -1124721290732002649L;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,2 +81,1 @@\n-public class ICC_ProfileRGB\n-extends ICC_Profile {\n+public class ICC_ProfileRGB extends ICC_Profile {\n@@ -84,1 +83,4 @@\n-    static final long serialVersionUID = 8505067385152579334L;\n+    \/**\n+     * Use serialVersionUID from JDK 1.2 for interoperability.\n+     *\/\n+    private static final long serialVersionUID = 8505067385152579334L;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-public class ProfileDataException extends java.lang.RuntimeException {\n+public class ProfileDataException extends RuntimeException {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ProfileDataException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.awt.Color;\n-import java.awt.GraphicsEnvironment;\n@@ -31,0 +29,1 @@\n+import java.awt.GraphicsEnvironment;\n@@ -35,1 +34,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -37,0 +35,3 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import sun.java2d.InvalidPipeException;\n@@ -39,1 +40,0 @@\n-import sun.java2d.loops.CompositeType;\n@@ -82,1 +82,1 @@\n-                throw new IllegalArgumentException(\"Invalid Image variant\");\n+                throw new InvalidPipeException(\"Invalid Image variant\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/SurfaceManager.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.RenderingHints;\n-import java.awt.RenderingHints.Key;\n-import java.awt.geom.Area;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.NoninvertibleTransformException;\n@@ -37,10 +30,0 @@\n-import java.awt.image.BufferedImage;\n-import java.awt.image.BufferedImageOp;\n-import java.awt.image.RenderedImage;\n-import java.awt.image.renderable.RenderableImage;\n-import java.awt.image.renderable.RenderContext;\n-import java.awt.image.AffineTransformOp;\n-import java.awt.image.Raster;\n-import java.awt.image.WritableRaster;\n-import java.awt.Image;\n-import java.awt.Composite;\n@@ -48,3 +31,3 @@\n-import java.awt.image.ColorModel;\n-import java.awt.GraphicsConfiguration;\n-import java.awt.Paint;\n+import java.awt.Composite;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n@@ -52,0 +35,4 @@\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n@@ -53,0 +40,1 @@\n+import java.awt.Paint;\n@@ -54,4 +42,3 @@\n-import java.awt.TexturePaint;\n-import java.awt.geom.Rectangle2D;\n-import java.awt.geom.PathIterator;\n-import java.awt.geom.GeneralPath;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.RenderingHints.Key;\n@@ -60,5 +47,1 @@\n-import java.awt.FontMetrics;\n-import java.awt.Rectangle;\n-import java.text.AttributedCharacterIterator;\n-import java.awt.Font;\n-import java.awt.image.ImageObserver;\n+import java.awt.TexturePaint;\n@@ -66,0 +49,1 @@\n+import java.awt.font.FontRenderContext;\n@@ -68,0 +52,22 @@\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Area;\n+import java.awt.geom.GeneralPath;\n+import java.awt.geom.NoninvertibleTransformException;\n+import java.awt.geom.PathIterator;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.MultiResolutionImage;\n+import java.awt.image.Raster;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.VolatileImage;\n+import java.awt.image.WritableRaster;\n+import java.awt.image.renderable.RenderContext;\n+import java.awt.image.renderable.RenderableImage;\n+import java.lang.annotation.Native;\n+import java.text.AttributedCharacterIterator;\n+import java.util.Iterator;\n+import java.util.Map;\n@@ -69,0 +75,3 @@\n+import sun.awt.ConstrainableGraphics;\n+import sun.awt.SunHints;\n+import sun.awt.image.MultiResolutionToolkitImage;\n@@ -70,0 +79,2 @@\n+import sun.awt.image.ToolkitImage;\n+import sun.awt.util.PerformanceLogger;\n@@ -72,0 +83,9 @@\n+import sun.java2d.loops.Blit;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.FontInfo;\n+import sun.java2d.loops.MaskFill;\n+import sun.java2d.loops.RenderLoops;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.loops.XORComposite;\n+import sun.java2d.pipe.DrawImagePipe;\n+import sun.java2d.pipe.LoopPipe;\n@@ -74,0 +94,1 @@\n+import sun.java2d.pipe.Region;\n@@ -75,1 +96,0 @@\n-import sun.java2d.pipe.ValidatePipe;\n@@ -77,1 +97,0 @@\n-import sun.java2d.pipe.Region;\n@@ -79,18 +98,1 @@\n-import sun.java2d.pipe.DrawImagePipe;\n-import sun.java2d.pipe.LoopPipe;\n-import sun.java2d.loops.FontInfo;\n-import sun.java2d.loops.RenderLoops;\n-import sun.java2d.loops.CompositeType;\n-import sun.java2d.loops.SurfaceType;\n-import sun.java2d.loops.Blit;\n-import sun.java2d.loops.MaskFill;\n-import java.awt.font.FontRenderContext;\n-import sun.java2d.loops.XORComposite;\n-import sun.awt.ConstrainableGraphics;\n-import sun.awt.SunHints;\n-import sun.awt.util.PerformanceLogger;\n-import java.util.Map;\n-import java.util.Iterator;\n-\n-import java.lang.annotation.Native;\n-import java.awt.image.MultiResolutionImage;\n+import sun.java2d.pipe.ValidatePipe;\n@@ -101,3 +103,0 @@\n-import java.awt.image.VolatileImage;\n-import sun.awt.image.MultiResolutionToolkitImage;\n-import sun.awt.image.ToolkitImage;\n@@ -3105,54 +3104,8 @@\n-\n-        if (img instanceof VolatileImage) {\n-            final SurfaceData sd = SurfaceManager.getManager(img)\n-                    .getPrimarySurfaceData();\n-            final double scaleX = sd.getDefaultScaleX();\n-            final double scaleY = sd.getDefaultScaleY();\n-            if (scaleX == 1 && scaleY == 1) {\n-                return null;\n-            }\n-            sx1 = Region.clipRound(sx1 * scaleX);\n-            sx2 = Region.clipRound(sx2 * scaleX);\n-            sy1 = Region.clipRound(sy1 * scaleY);\n-            sy2 = Region.clipRound(sy2 * scaleY);\n-\n-            AffineTransform tx = null;\n-            if (xform != null) {\n-                tx = new AffineTransform(transform);\n-                transform(xform);\n-            }\n-            boolean result = scaleImage(img, dx1, dy1, dx2, dy2,\n-                                        sx1, sy1, sx2, sy2,\n-                                        bgcolor, observer);\n-            if (tx != null) {\n-                transform.setTransform(tx);\n-                invalidateTransform();\n-            }\n-            return result;\n-        } else if (img instanceof MultiResolutionImage) {\n-            \/\/ get scaled destination image size\n-\n-            int width = img.getWidth(observer);\n-            int height = img.getHeight(observer);\n-\n-            MultiResolutionImage mrImage = (MultiResolutionImage) img;\n-            Image resolutionVariant = getResolutionVariant(mrImage, width, height,\n-                                                           dx1, dy1, dx2, dy2,\n-                                                           sx1, sy1, sx2, sy2,\n-                                                           xform);\n-\n-            if (resolutionVariant != img && resolutionVariant != null) {\n-                \/\/ recalculate source region for the resolution variant\n-\n-                ImageObserver rvObserver = MultiResolutionToolkitImage.\n-                        getResolutionVariantObserver(img, observer,\n-                                width, height, -1, -1);\n-\n-                int rvWidth = resolutionVariant.getWidth(rvObserver);\n-                int rvHeight = resolutionVariant.getHeight(rvObserver);\n-\n-                if (rvWidth < 0 || rvHeight < 0) {\n-                    \/\/ The resolution variant is not loaded yet, try to use default resolution\n-                    resolutionVariant = mrImage.getResolutionVariant(width, height);\n-                    rvWidth = resolutionVariant.getWidth(rvObserver);\n-                    rvHeight = resolutionVariant.getHeight(rvObserver);\n+        try {\n+            if (img instanceof VolatileImage) {\n+                final SurfaceData sd = SurfaceManager.getManager(img)\n+                        .getPrimarySurfaceData();\n+                final double scaleX = sd.getDefaultScaleX();\n+                final double scaleY = sd.getDefaultScaleY();\n+                if (scaleX == 1 && scaleY == 1) {\n+                    return null;\n@@ -3160,12 +3113,45 @@\n-\n-                if (0 < width && 0 < height && 0 < rvWidth && 0 < rvHeight) {\n-\n-                    double widthScale = ((double) rvWidth) \/ width;\n-                    double heightScale = ((double) rvHeight) \/ height;\n-\n-                    if (resolutionVariant instanceof VolatileImage) {\n-                        SurfaceData sd = SurfaceManager\n-                                .getManager(resolutionVariant)\n-                                .getPrimarySurfaceData();\n-                        widthScale *= sd.getDefaultScaleX();\n-                        heightScale *= sd.getDefaultScaleY();\n+                sx1 = Region.clipRound(sx1 * scaleX);\n+                sx2 = Region.clipRound(sx2 * scaleX);\n+                sy1 = Region.clipRound(sy1 * scaleY);\n+                sy2 = Region.clipRound(sy2 * scaleY);\n+\n+                AffineTransform tx = null;\n+                if (xform != null) {\n+                    tx = new AffineTransform(transform);\n+                    transform(xform);\n+                }\n+                boolean result = scaleImage(img, dx1, dy1, dx2, dy2,\n+                                            sx1, sy1, sx2, sy2,\n+                                            bgcolor, observer);\n+                if (tx != null) {\n+                    transform.setTransform(tx);\n+                    invalidateTransform();\n+                }\n+                return result;\n+            } else if (img instanceof MultiResolutionImage) {\n+                \/\/ get scaled destination image size\n+\n+                int width = img.getWidth(observer);\n+                int height = img.getHeight(observer);\n+\n+                MultiResolutionImage mrImage = (MultiResolutionImage) img;\n+                Image resolutionVariant = getResolutionVariant(mrImage, width, height,\n+                                                               dx1, dy1, dx2, dy2,\n+                                                               sx1, sy1, sx2, sy2,\n+                                                               xform);\n+\n+                if (resolutionVariant != img && resolutionVariant != null) {\n+                    \/\/ recalculate source region for the resolution variant\n+\n+                    ImageObserver rvObserver = MultiResolutionToolkitImage.\n+                            getResolutionVariantObserver(img, observer,\n+                                    width, height, -1, -1);\n+\n+                    int rvWidth = resolutionVariant.getWidth(rvObserver);\n+                    int rvHeight = resolutionVariant.getHeight(rvObserver);\n+\n+                    if (rvWidth < 0 || rvHeight < 0) {\n+                        \/\/ The resolution variant is not loaded yet, try to use default resolution\n+                        resolutionVariant = mrImage.getResolutionVariant(width, height);\n+                        rvWidth = resolutionVariant.getWidth(rvObserver);\n+                        rvHeight = resolutionVariant.getHeight(rvObserver);\n@@ -3174,15 +3160,35 @@\n-                    sx1 = Region.clipScale(sx1, widthScale);\n-                    sy1 = Region.clipScale(sy1, heightScale);\n-                    sx2 = Region.clipScale(sx2, widthScale);\n-                    sy2 = Region.clipScale(sy2, heightScale);\n-\n-                    observer = rvObserver;\n-                    img = resolutionVariant;\n-\n-                    if (xform != null) {\n-                        assert dx1 == 0 && dy1 == 0;\n-                        assert dx2 == img.getWidth(observer);\n-                        assert dy2 == img.getHeight(observer);\n-                        AffineTransform renderTX = new AffineTransform(xform);\n-                        renderTX.scale(1 \/ widthScale, 1 \/ heightScale);\n-                        return transformImage(img, renderTX, observer);\n+                    if (0 < width && 0 < height && 0 < rvWidth && 0 < rvHeight) {\n+\n+                        double widthScale = ((double) rvWidth) \/ width;\n+                        double heightScale = ((double) rvHeight) \/ height;\n+\n+                        if (resolutionVariant instanceof VolatileImage) {\n+                            SurfaceData sd = SurfaceManager\n+                                    .getManager(resolutionVariant)\n+                                    .getPrimarySurfaceData();\n+                            widthScale *= sd.getDefaultScaleX();\n+                            heightScale *= sd.getDefaultScaleY();\n+                        }\n+\n+                        sx1 = Region.clipScale(sx1, widthScale);\n+                        sy1 = Region.clipScale(sy1, heightScale);\n+                        sx2 = Region.clipScale(sx2, widthScale);\n+                        sy2 = Region.clipScale(sy2, heightScale);\n+\n+                        observer = rvObserver;\n+                        img = resolutionVariant;\n+\n+                        if (xform != null) {\n+                            assert dx1 == 0 && dy1 == 0;\n+                            assert dx2 == img.getWidth(observer);\n+                            assert dy2 == img.getHeight(observer);\n+                            AffineTransform renderTX = new AffineTransform(xform);\n+                            renderTX.scale(1 \/ widthScale, 1 \/ heightScale);\n+                            return transformImage(img, renderTX, observer);\n+                        }\n+\n+                        return scaleImage(img, dx1, dy1, dx2, dy2,\n+                                          sx1, sy1, sx2, sy2,\n+                                          bgcolor, observer);\n+                    } else {\n+                        return false; \/\/ Image variant is not initialized yet\n@@ -3190,6 +3196,0 @@\n-\n-                    return scaleImage(img, dx1, dy1, dx2, dy2,\n-                                      sx1, sy1, sx2, sy2,\n-                                      bgcolor, observer);\n-                } else {\n-                    return false; \/\/ Image variant is not initialized yet\n@@ -3198,0 +3198,2 @@\n+        } catch (InvalidPipeException e) {\n+            return false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":141,"deletions":139,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    @java.io.Serial\n@@ -207,0 +208,1 @@\n+        @java.io.Serial\n@@ -311,1 +313,0 @@\n-         *\n@@ -316,0 +317,5 @@\n+         *\n+         * @param  in the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\n@@ -317,0 +323,1 @@\n+        @java.io.Serial\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationGroupDesc.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    @java.io.Serial\n@@ -231,0 +232,3 @@\n+     *\n+     * @param  out the {@code ObjectOutputStream} to which data is written\n+     * @throws IOException if an I\/O error occurs\n@@ -232,0 +236,1 @@\n+    @java.io.Serial\n@@ -290,0 +295,5 @@\n+     *\n+     * @param  in the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\n@@ -291,0 +301,1 @@\n+    @java.io.Serial\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationID.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -50,0 +51,1 @@\n+    @java.io.Serial\n@@ -360,0 +362,3 @@\n+     *\n+     * @param  out the {@code ObjectOutputStream} to which data is written\n+     * @throws IOException if an I\/O error occurs\n@@ -361,0 +366,1 @@\n+    @java.io.Serial\n@@ -421,0 +427,4 @@\n+     *\n+     * @param  in the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -422,0 +432,1 @@\n+    @java.io.Serial\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RemoteObject.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.IOException;\n@@ -198,0 +199,1 @@\n+    @java.io.Serial\n@@ -262,0 +264,5 @@\n+     *\n+     * @param  in the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\n@@ -263,0 +270,1 @@\n+    @java.io.Serial\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/UnicastRemoteObject.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2019 SAP SE. All rights reserved.\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2018 SAP SE. All rights reserved.\n","filename":"src\/jdk.attach\/aix\/native\/libattach\/VirtualMachineImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            return handleExceptions(() -> {\n+            Pair<Main.Result, Throwable> result = invocationHelper(() -> {\n@@ -106,1 +106,6 @@\n-            }, Main.Result.SYSERR, Main.Result.ABNORMAL);\n+            });\n+            if (result.snd == null) {\n+                return result.fst;\n+            } else {\n+                return (result.snd instanceof FatalError) ? Main.Result.SYSERR : Main.Result.ABNORMAL;\n+            }\n@@ -144,1 +149,1 @@\n-    private <T> T handleExceptions(Callable<T> c, T sysErrorResult, T abnormalErrorResult) {\n+    private <T> Pair<T, Throwable> invocationHelper(Callable<T> c) {\n@@ -147,1 +152,1 @@\n-            return c.call();\n+            return new Pair<>(c.call(), null);\n@@ -155,1 +160,1 @@\n-            return sysErrorResult;\n+            return new Pair<>(null, ex);\n@@ -178,1 +183,1 @@\n-            return abnormalErrorResult;\n+            return new Pair<>(null, ex);\n@@ -243,1 +248,5 @@\n-        return handleExceptions(this::parseInternal, List.nil(), List.nil());\n+        Pair<Iterable<? extends CompilationUnitTree>, Throwable> result =  invocationHelper(this::parseInternal);\n+        if (result.snd == null) {\n+            return result.fst;\n+        }\n+        throw new IllegalStateException(result.snd);\n@@ -370,1 +379,5 @@\n-        return handleExceptions(() -> analyze(null), List.nil(), List.nil());\n+        Pair<Iterable<? extends Element>, Throwable> result =  invocationHelper(() -> analyze(null));\n+        if (result.snd == null) {\n+            return result.fst;\n+        }\n+        throw new IllegalStateException(result.snd);\n@@ -432,1 +445,5 @@\n-        return handleExceptions(() -> generate(null), List.nil(), List.nil());\n+        Pair<Iterable<? extends JavaFileObject>, Throwable> result =  invocationHelper(() -> generate(null));\n+        if (result.snd == null) {\n+            return result.fst;\n+        }\n+        throw new IllegalStateException(result.snd);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);\n+                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n@@ -5055,1 +5055,1 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5068,1 +5068,3 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                            );\n@@ -5071,1 +5073,3 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                        );\n@@ -5110,1 +5114,1 @@\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3387,0 +3387,3 @@\n+            } else if (target == names.MODULE) {\n+                if (s.kind == MDL)\n+                    applicableTargets.add(names.MODULE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3802,1 +3802,2 @@\n-                                .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags & Flags.VARARGS, param.mods.annotations),\n+                                .VarDef(F.Modifiers(Flags.PARAMETER | Flags.GENERATED_MEMBER | param.mods.flags & Flags.VARARGS,\n+                                        param.mods.annotations),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+import com.sun.tools.javac.main.Option;\n@@ -249,0 +250,2 @@\n+            fm.handleOption(Option.MULTIRELEASE, sourceVersion);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3487,1 +3487,10 @@\n-    class is not allowed to extend sealed class: {0}\n+    class is not allowed to extend sealed class: {0} \\\n+    (as it is not listed in its 'permits' clause)\n+\n+# 0: symbol\n+compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=\\\n+    class {0} in unnamed module cannot extend a sealed class in a different package\n+\n+# 0: symbol, 1: symbol\n+compiler.err.class.in.module.cant.extend.sealed.in.diff.module=\\\n+    class {0} in module {1} cannot extend a sealed class in a different module\n@@ -3503,0 +3512,1 @@\n+# 0: fragment\n@@ -3504,1 +3514,7 @@\n-    local classes must not extend sealed classes\n+    {0} classes must not extend sealed classes\\\n+\n+compiler.misc.anonymous=\\\n+    anonymous\n+\n+compiler.misc.local=\\\n+    local\n@@ -3586,0 +3602,1 @@\n+# 0: symbol\n@@ -3587,1 +3604,1 @@\n-    constructor is not canonical, so its first statement must invoke another constructor\n+    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,1 +508,1 @@\n-    private boolean posixPermsDetected;\n+    private boolean extraAttrsDetected;\n@@ -952,4 +952,4 @@\n-        int perms = JUZFA.getPosixPerms(ze);\n-        if (!posixPermsDetected && perms != -1) {\n-            posixPermsDetected = true;\n-            Event.report(Event.ReporterCategory.POSIXPERMS, \"detected\");\n+        int extraAttrs = JUZFA.getExtraAttributes(ze);\n+        if (!extraAttrsDetected && extraAttrs != -1) {\n+            extraAttrsDetected = true;\n+            Event.report(Event.ReporterCategory.ZIPFILEATTRS, \"detected\");\n@@ -957,1 +957,1 @@\n-        JUZFA.setPosixPerms(ze2, perms);\n+        JUZFA.setExtraAttributes(ze2, extraAttrs);\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private static boolean permsDetected;\n+    private static boolean extraAttrsDetected;\n@@ -785,2 +785,2 @@\n-                    if (!permsDetected && JUZFA.getPosixPerms(je) != -1) {\n-                        permsDetected = true;\n+                    if (!extraAttrsDetected && JUZFA.getExtraAttributes(je) != -1) {\n+                        extraAttrsDetected = true;\n@@ -1250,2 +1250,2 @@\n-        if (permsDetected) {\n-            warnings.add(rb.getString(\"posix.attributes.detected\"));\n+        if (extraAttrsDetected) {\n+            warnings.add(rb.getString(\"extra.attributes.detected\"));\n@@ -1780,2 +1780,2 @@\n-            Event.setReportListener(Event.ReporterCategory.POSIXPERMS,\n-                    (t, o) -> permsDetected = true);\n+            Event.setReportListener(Event.ReporterCategory.ZIPFILEATTRS,\n+                    (t, o) -> extraAttrsDetected = true);\n@@ -1816,1 +1816,1 @@\n-            Event.clearReportListener(Event.ReporterCategory.POSIXPERMS);\n+            Event.clearReportListener(Event.ReporterCategory.ZIPFILEATTRS);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-        {\"posix.attributes.detected\", \"POSIX file permission attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n+        {\"extra.attributes.detected\", \"POSIX file permission and\/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.invoke.MethodType;\n@@ -37,2 +36,0 @@\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n@@ -75,15 +72,0 @@\n-    private static final String DIRECT_HOLDER = \"java\/lang\/invoke\/DirectMethodHandle$Holder\";\n-    private static final String DMH_INVOKE_VIRTUAL = \"invokeVirtual\";\n-    private static final String DMH_INVOKE_STATIC = \"invokeStatic\";\n-    private static final String DMH_INVOKE_SPECIAL = \"invokeSpecial\";\n-    private static final String DMH_NEW_INVOKE_SPECIAL = \"newInvokeSpecial\";\n-    private static final String DMH_INVOKE_INTERFACE = \"invokeInterface\";\n-    private static final String DMH_INVOKE_STATIC_INIT = \"invokeStaticInit\";\n-    private static final String DMH_INVOKE_SPECIAL_IFC = \"invokeSpecialIFC\";\n-\n-    private static final String DELEGATING_HOLDER = \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\";\n-    private static final String BASIC_FORMS_HOLDER = \"java\/lang\/invoke\/LambdaForm$Holder\";\n-\n-    private static final String INVOKERS_HOLDER_NAME = \"java.lang.invoke.Invokers$Holder\";\n-    private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace('.', '\/');\n-\n@@ -93,9 +75,2 @@\n-    private final TreeSet<String> speciesTypes = new TreeSet<>();\n-\n-    private final TreeSet<String> invokerTypes = new TreeSet<>();\n-\n-    private final TreeSet<String> callSiteTypes = new TreeSet<>();\n-\n-    private final Map<String, Set<String>> dmhMethods = new TreeMap<>();\n-\n-    String mainArgument;\n+    private String mainArgument;\n+    private Stream<String> traceFileStream;\n@@ -131,16 +106,0 @@\n-    private static int DMH_INVOKE_VIRTUAL_TYPE = 0;\n-    private static int DMH_INVOKE_INTERFACE_TYPE = 4;\n-\n-    \/\/ Map from DirectMethodHandle method type to internal ID, matching values\n-    \/\/ of the corresponding constants in java.lang.invoke.MethodTypeForm\n-    private static final Map<String, Integer> DMH_METHOD_TYPE_MAP =\n-            Map.of(\n-                DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,\n-                DMH_INVOKE_STATIC,      1,\n-                DMH_INVOKE_SPECIAL,     2,\n-                DMH_NEW_INVOKE_SPECIAL, 3,\n-                DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,\n-                DMH_INVOKE_STATIC_INIT, 5,\n-                DMH_INVOKE_SPECIAL_IFC, 20\n-            );\n-\n@@ -152,14 +111,0 @@\n-    private void addSpeciesType(String type) {\n-        speciesTypes.add(expandSignature(type));\n-    }\n-\n-    private void addInvokerType(String methodType) {\n-        validateMethodType(methodType);\n-        invokerTypes.add(methodType);\n-    }\n-\n-    private void addCallSiteType(String csType) {\n-        validateMethodType(csType);\n-        callSiteTypes.add(csType);\n-    }\n-\n@@ -173,3 +118,1 @@\n-                    readTraceConfig(\n-                        new BufferedReader(\n-                            new InputStreamReader(traceFile)).lines());\n+                    traceFileStream = new BufferedReader(new InputStreamReader(traceFile)).lines();\n@@ -183,1 +126,1 @@\n-                readTraceConfig(fileLines(file));\n+                traceFileStream = fileLines(file);\n@@ -188,46 +131,0 @@\n-    private void readTraceConfig(Stream<String> lines) {\n-        lines.map(line -> line.split(\" \"))\n-             .forEach(parts -> {\n-                switch (parts[0]) {\n-                    case \"[SPECIES_RESOLVE]\":\n-                        \/\/ Allow for new types of species data classes being resolved here\n-                        if (parts.length == 3 && parts[1].startsWith(\"java.lang.invoke.BoundMethodHandle$Species_\")) {\n-                            String species = parts[1].substring(\"java.lang.invoke.BoundMethodHandle$Species_\".length());\n-                            if (!\"L\".equals(species)) {\n-                                addSpeciesType(species);\n-                            }\n-                        }\n-                        break;\n-                    case \"[LF_RESOLVE]\":\n-                        String methodType = parts[3];\n-                        if (parts[1].equals(INVOKERS_HOLDER_NAME)) {\n-                            if (\"linkToTargetMethod\".equals(parts[2]) ||\n-                                    \"linkToCallSite\".equals(parts[2])) {\n-                                addCallSiteType(methodType);\n-                            } else {\n-                                addInvokerType(methodType);\n-                            }\n-                        } else if (parts[1].contains(\"DirectMethodHandle\")) {\n-                            String dmh = parts[2];\n-                            \/\/ ignore getObject etc for now (generated\n-                            \/\/ by default)\n-                            if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {\n-                                addDMHMethodType(dmh, methodType);\n-                            }\n-                        }\n-                        break;\n-                    default: break; \/\/ ignore\n-                }\n-            });\n-    }\n-\n-    private void addDMHMethodType(String dmh, String methodType) {\n-        validateMethodType(methodType);\n-        Set<String> methodTypes = dmhMethods.get(dmh);\n-        if (methodTypes == null) {\n-            methodTypes = new TreeSet<>();\n-            dmhMethods.put(dmh, methodTypes);\n-        }\n-        methodTypes.add(methodType);\n-    }\n-\n@@ -242,19 +139,0 @@\n-    private void validateMethodType(String type) {\n-        String[] typeParts = type.split(\"_\");\n-        \/\/ check return type (second part)\n-        if (typeParts.length != 2 || typeParts[1].length() != 1\n-                || \"LJIFDV\".indexOf(typeParts[1].charAt(0)) == -1) {\n-            throw new PluginException(\n-                    \"Method type signature must be of form [LJIFD]*_[LJIFDV]\");\n-        }\n-        \/\/ expand and check arguments (first part)\n-        expandSignature(typeParts[0]);\n-    }\n-\n-    private static void requireBasicType(char c) {\n-        if (\"LIJFD\".indexOf(c) < 0) {\n-            throw new PluginException(\n-                    \"Character \" + c + \" must correspond to a basic field type: LIJFD\");\n-        }\n-    }\n-\n@@ -266,0 +144,3 @@\n+                \/\/ No trace file given.  Copy all entries.\n+                if (traceFileStream == null) return entry;\n+\n@@ -278,83 +159,11 @@\n-        \/\/ Generate BMH Species classes\n-        speciesTypes.forEach(types -> generateBMHClass(types, out));\n-\n-        \/\/ Generate LambdaForm Holder classes\n-        generateHolderClasses(out);\n-\n-        \/\/ Let it go\n-        speciesTypes.clear();\n-        invokerTypes.clear();\n-        callSiteTypes.clear();\n-        dmhMethods.clear();\n-\n-        return out.build();\n-    }\n-\n-    private void generateBMHClass(String types, ResourcePoolBuilder out) {\n-        try {\n-            \/\/ Generate class\n-            Map.Entry<String, byte[]> result =\n-                    JLIA.generateConcreteBMHClassBytes(types);\n-            String className = result.getKey();\n-            byte[] bytes = result.getValue();\n-\n-            \/\/ Add class to pool\n-            ResourcePoolEntry ndata = ResourcePoolEntry.create(\n-                    \"\/java.base\/\" + className + \".class\",\n-                    bytes);\n-            out.add(ndata);\n-        } catch (Exception ex) {\n-            throw new PluginException(ex);\n-        }\n-    }\n-\n-    private void generateHolderClasses(ResourcePoolBuilder out) {\n-        int count = 0;\n-        for (Set<String> entry : dmhMethods.values()) {\n-            count += entry.size();\n-        }\n-        MethodType[] directMethodTypes = new MethodType[count];\n-        int[] dmhTypes = new int[count];\n-        int index = 0;\n-        for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {\n-            String dmhType = entry.getKey();\n-            for (String type : entry.getValue()) {\n-                \/\/ The DMH type to actually ask for is retrieved by removing\n-                \/\/ the first argument, which needs to be of Object.class\n-                MethodType mt = asMethodType(type);\n-                if (mt.parameterCount() < 1 ||\n-                    mt.parameterType(0) != Object.class) {\n-                    throw new PluginException(\n-                            \"DMH type parameter must start with L: \" + dmhType + \" \" + type);\n-                }\n-\n-                \/\/ Adapt the method type of the LF to retrieve\n-                directMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-\n-                \/\/ invokeVirtual and invokeInterface must have a leading Object\n-                \/\/ parameter, i.e., the receiver\n-                dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);\n-                if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||\n-                    dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {\n-                    if (mt.parameterCount() < 2 ||\n-                        mt.parameterType(1) != Object.class) {\n-                        throw new PluginException(\n-                                \"DMH type parameter must start with LL: \" + dmhType + \" \" + type);\n-                    }\n-                }\n-                index++;\n-            }\n-        }\n-\n-        \/\/ The invoker type to ask for is retrieved by removing the first\n-        \/\/ and the last argument, which needs to be of Object.class\n-        MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];\n-        int i = 0;\n-        for (String invokerType : invokerTypes) {\n-            MethodType mt = asMethodType(invokerType);\n-            final int lastParam = mt.parameterCount() - 1;\n-            if (mt.parameterCount() < 2 ||\n-                    mt.parameterType(0) != Object.class ||\n-                    mt.parameterType(lastParam) != Object.class) {\n-                throw new PluginException(\n-                        \"Invoker type parameter must start and end with Object: \" + invokerType);\n+        \/\/ Generate Holder classes\n+        if (traceFileStream != null) {\n+            try {\n+                JLIA.generateHolderClasses(traceFileStream)\n+                    .forEach((cn, bytes) -> {\n+                        String entryName = \"\/java.base\/\" + cn + \".class\";\n+                        ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n+                        out.add(ndata);\n+                    });\n+            } catch (Exception ex) {\n+                throw new PluginException(ex);\n@@ -362,42 +171,0 @@\n-            mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-            invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);\n-            i++;\n-        }\n-\n-        \/\/ The callSite type to ask for is retrieved by removing the last\n-        \/\/ argument, which needs to be of Object.class\n-        MethodType[] callSiteMethodTypes = new MethodType[this.callSiteTypes.size()];\n-        i = 0;\n-        for (String callSiteType : callSiteTypes) {\n-            MethodType mt = asMethodType(callSiteType);\n-            final int lastParam = mt.parameterCount() - 1;\n-            if (mt.parameterCount() < 1 ||\n-                    mt.parameterType(lastParam) != Object.class) {\n-                throw new PluginException(\n-                        \"CallSite type parameter must end with Object: \" + callSiteType);\n-            }\n-            callSiteMethodTypes[i] = mt.dropParameterTypes(lastParam, lastParam + 1);\n-            i++;\n-        }\n-        try {\n-            byte[] bytes = JLIA.generateDirectMethodHandleHolderClassBytes(\n-                    DIRECT_HOLDER, directMethodTypes, dmhTypes);\n-            ResourcePoolEntry ndata = ResourcePoolEntry\n-                    .create(DIRECT_METHOD_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateDelegatingMethodHandleHolderClassBytes(\n-                    DELEGATING_HOLDER, directMethodTypes);\n-            ndata = ResourcePoolEntry.create(DELEGATING_METHOD_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateInvokersHolderClassBytes(INVOKERS_HOLDER_INTERNAL_NAME,\n-                    invokerMethodTypes, callSiteMethodTypes);\n-            ndata = ResourcePoolEntry.create(INVOKERS_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateBasicFormsClassBytes(BASIC_FORMS_HOLDER);\n-            ndata = ResourcePoolEntry.create(BASIC_FORMS_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-        } catch (Exception ex) {\n-            throw new PluginException(ex);\n@@ -405,0 +172,1 @@\n+        return out.build();\n@@ -406,0 +174,1 @@\n+\n@@ -407,1 +176,1 @@\n-            \"\/java.base\/\" + DIRECT_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\";\n@@ -409,1 +178,1 @@\n-            \"\/java.base\/\" + DELEGATING_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\";\n@@ -411,1 +180,1 @@\n-            \"\/java.base\/\" + BASIC_FORMS_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\";\n@@ -413,74 +182,1 @@\n-            \"\/java.base\/\" + INVOKERS_HOLDER_INTERNAL_NAME + \".class\";\n-\n-    \/\/ Convert LL -> LL, L3 -> LLL\n-    public static String expandSignature(String signature) {\n-        StringBuilder sb = new StringBuilder();\n-        char last = 'X';\n-        int count = 0;\n-        for (int i = 0; i < signature.length(); i++) {\n-            char c = signature.charAt(i);\n-            if (c >= '0' && c <= '9') {\n-                count *= 10;\n-                count += (c - '0');\n-            } else {\n-                requireBasicType(c);\n-                for (int j = 1; j < count; j++) {\n-                    sb.append(last);\n-                }\n-                sb.append(c);\n-                last = c;\n-                count = 0;\n-            }\n-        }\n-\n-        \/\/ ended with a number, e.g., \"L2\": append last char count - 1 times\n-        if (count > 1) {\n-            requireBasicType(last);\n-            for (int j = 1; j < count; j++) {\n-                sb.append(last);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private static MethodType asMethodType(String basicSignatureString) {\n-        String[] parts = basicSignatureString.split(\"_\");\n-        assert(parts.length == 2);\n-        assert(parts[1].length() == 1);\n-        String parameters = expandSignature(parts[0]);\n-        Class<?> rtype = simpleType(parts[1].charAt(0));\n-        if (parameters.isEmpty()) {\n-            return MethodType.methodType(rtype);\n-        } else {\n-            Class<?>[] ptypes = new Class<?>[parameters.length()];\n-            for (int i = 0; i < ptypes.length; i++) {\n-                ptypes[i] = simpleType(parameters.charAt(i));\n-            }\n-            return MethodType.methodType(rtype, ptypes);\n-        }\n-    }\n-\n-    private static Class<?> simpleType(char c) {\n-        switch (c) {\n-            case 'F':\n-                return float.class;\n-            case 'D':\n-                return double.class;\n-            case 'I':\n-                return int.class;\n-            case 'L':\n-                return Object.class;\n-            case 'J':\n-                return long.class;\n-            case 'V':\n-                return void.class;\n-            case 'Z':\n-            case 'B':\n-            case 'S':\n-            case 'C':\n-                throw new IllegalArgumentException(\"Not a valid primitive: \" + c +\n-                        \" (use I instead)\");\n-            default:\n-                throw new IllegalArgumentException(\"Not a primitive: \" + c);\n-        }\n-    }\n+            \"\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\";\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":24,"deletions":328,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestObjectArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n@@ -37,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -41,0 +44,7 @@\n+        \/\/ Some CPUs (for example, ARM) does not support unaligned\n+        \/\/ memory accesses. This test may cause JVM crash due to\n+        \/\/ alignment check failure on such CPUs.\n+        if (!jdk.internal.misc.Unsafe.getUnsafe().unalignedAccess()) {\n+          throw new SkippedException(\n+            \"Platform is missing unaligned memory accesses support.\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8202414.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Arm Limited. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+\/**\n+ * @test\n+ *\n+ * @requires os.arch == \"aarch64\" & vm.compiler2.enabled\n+ * @summary Verify VM SVE checking behavior\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native compiler.c2.aarch64.TestSVEWithJNI\n+ *\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSVEWithJNI {\n+    static {\n+        System.loadLibrary(\"TestSVEWithJNI\");\n+    }\n+\n+    static final int EXIT_CODE = 99;\n+    \/\/ Returns a nonnegative on success, or a negative value on error.\n+    public static native int setVectorLength(int arg);\n+    \/\/ Returns a nonnegative value on success, or a negative value on error.\n+    public static native int getVectorLength();\n+\n+    public static final String MSG = \"Current Vector Size: \";\n+    public static void testNormal() {\n+        int vlen = getVectorLength();\n+        System.out.println(MSG + vlen);\n+        \/\/ Should be fine if no vector length changed.\n+        if (setVectorLength(vlen) < 0) {\n+            throw new Error(\"Error in setting vector length.\");\n+        }\n+    }\n+\n+    public static void testAbort() {\n+        int vlen = getVectorLength();\n+        if (vlen <= 16) {\n+            throw new Error(\"Error: unsupported vector length.\");\n+        }\n+        if (setVectorLength(16) < 0) {\n+            throw new Error(\"Error: setting vector length failed.\");\n+        }\n+    }\n+\n+    public static ProcessBuilder createProcessBuilder(String [] args, String mode) {\n+        List<String> vmopts = new ArrayList<>();\n+        String testjdkPath = System.getProperty(\"test.jdk\");\n+        Collections.addAll(vmopts, \"-Dtest.jdk=\" + testjdkPath);\n+        Collections.addAll(vmopts, args);\n+        Collections.addAll(vmopts, TestSVEWithJNI.class.getName(), mode);\n+        return ProcessTools.createJavaProcessBuilder(vmopts.toArray(new String[vmopts.size()]));\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        if (args.length == 0) {\n+            int vlen = getVectorLength();\n+            if (vlen < 0) {\n+                return;\n+            }\n+            String [][] testOpts = {\n+                {\"-Xint\", \"-XX:UseSVE=1\"},\n+                {\"-Xcomp\", \"-XX:UseSVE=1\"},\n+            };\n+            ProcessBuilder pb;\n+            OutputAnalyzer output;\n+            for (String [] opts : testOpts) {\n+                pb = createProcessBuilder(opts, \"normal\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldHaveExitValue(EXIT_CODE);\n+\n+                pb = createProcessBuilder(opts, \"abort\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(EXIT_CODE);\n+                output.shouldMatch(\"(error|Error|ERROR)\");\n+            }\n+\n+            \/\/ Verify MaxVectorSize\n+\n+            \/\/ Any SVE architecture should support 128-bit vector size.\n+            pb = createProcessBuilder(new String []{\"-XX:UseSVE=1\", \"-XX:MaxVectorSize=16\"}, \"normal\");\n+            output = new OutputAnalyzer(pb.start());\n+            output.shouldHaveExitValue(EXIT_CODE);\n+            output.shouldContain(MSG + 16);\n+\n+            \/\/ An unsupported large vector size value.\n+            pb = createProcessBuilder(new String []{\"-XX:UseSVE=1\", \"-XX:MaxVectorSize=512\"}, \"normal\");\n+            output = new OutputAnalyzer(pb.start());\n+            output.shouldHaveExitValue(EXIT_CODE);\n+            output.shouldContain(\"warning\");\n+        } else if (args[0].equals(\"normal\")) {\n+            testNormal();\n+            System.exit(EXIT_CODE);\n+        } else if (args[0].equals(\"abort\")) {\n+            testAbort();\n+            System.exit(EXIT_CODE);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestSVEWithJNI.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- *           vm.flavor == \"server\" & !vm.graal.enabled &\n+ *           vm.flavor == \"server\" &\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestVolatilesShenandoah.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Arm Limited. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifdef __aarch64__\n+\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys\/prctl.h>\n+#include <unistd.h>\n+\n+#ifndef PR_SVE_GET_VL\n+\/\/ For old toolchains which do not have SVE related macros defined.\n+#define PR_SVE_SET_VL   50\n+#define PR_SVE_GET_VL   51\n+#endif\n+\n+int get_current_thread_vl() {\n+  return prctl(PR_SVE_GET_VL);\n+}\n+\n+int set_current_thread_vl(unsigned long arg) {\n+  return prctl(PR_SVE_SET_VL, arg);\n+}\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+JNIEXPORT jint JNICALL Java_compiler_c2_aarch64_TestSVEWithJNI_setVectorLength\n+(JNIEnv * env, jclass clz, jint length) {\n+  return set_current_thread_vl(length);\n+}\n+\n+JNIEXPORT jint JNICALL Java_compiler_c2_aarch64_TestSVEWithJNI_getVectorLength\n+(JNIEnv *env, jclass clz) {\n+  return get_current_thread_vl();\n+}\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/libTestSVEWithJNI.c","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -8,2 +8,1 @@\n- * @run driver jdk.test.lib.FileInstaller words words\n- * @run main\/othervm -Xbatch compiler.c2.stemmer.Stemmer words\n+ * @run main\/othervm -Xbatch compiler.c2.stemmer.Stemmer ${test.src}\/words\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/stemmer\/Stemmer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ *        compiler.codecache.stress.TestCaseImpl\n@@ -55,1 +56,1 @@\n-public class OverloadCompileQueueTest implements Runnable {\n+class LockUnlockThread extends Thread {\n@@ -57,0 +58,26 @@\n+    private static final int DELAY_BETWEEN_LOCKS = 100;\n+    private final Random rng = Utils.getRandomInstance();\n+\n+    public volatile boolean isActive = true;\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (isActive) {\n+                int timeInLockedState = rng.nextInt(MAX_SLEEP);\n+                Helper.WHITE_BOX.lockCompilation();\n+                Thread.sleep(timeInLockedState);\n+                Helper.WHITE_BOX.unlockCompilation();\n+                Thread.sleep(DELAY_BETWEEN_LOCKS);\n+            }\n+        } catch (InterruptedException e) {\n+            if (isActive) {\n+                throw new Error(\"TESTBUG: LockUnlockThread was unexpectedly interrupted\", e);\n+            }\n+        } finally {\n+            Helper.WHITE_BOX.unlockCompilation();\n+        }\n+    }\n+}\n+\n+public class OverloadCompileQueueTest implements Runnable {\n@@ -65,1 +92,0 @@\n-    private final Random rng = Utils.getRandomInstance();\n@@ -80,1 +106,4 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws InterruptedException {\n+        LockUnlockThread lockUnlockThread = new LockUnlockThread();\n+        lockUnlockThread.start();\n+\n@@ -85,1 +114,0 @@\n-    }\n@@ -87,2 +115,3 @@\n-    public OverloadCompileQueueTest() {\n-        Helper.startInfiniteLoopThread(this::lockUnlock, 100L);\n+        lockUnlockThread.isActive = false;\n+        lockUnlockThread.interrupt();\n+        lockUnlockThread.join();\n@@ -108,12 +137,0 @@\n-    private void lockUnlock() {\n-        try {\n-            int sleep = rng.nextInt(MAX_SLEEP);\n-            Helper.WHITE_BOX.lockCompilation();\n-            Thread.sleep(sleep);\n-        } catch (InterruptedException e) {\n-            throw new Error(\"TESTBUG: lockUnlocker thread was unexpectedly interrupted\", e);\n-        } finally {\n-            Helper.WHITE_BOX.unlockCompilation();\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/OverloadCompileQueueTest.java","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.api.directives.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.api.directives.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/ApiDirectivesTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.api.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.api.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/ApiTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.asm.aarch64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.asm.aarch64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/AsmAarch64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.asm.amd64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.asm.amd64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/AsmAmd64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix jdk.internal.vm.compiler.collections.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix jdk.internal.vm.compiler.collections.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/CollectionsTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.[a-cA-C] -exclude ExcludeList.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.[a-cA-C] -exclude ${test.root}\/ProblemList-graal.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/Core01Test.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.[d-zD-Z] -exclude ExcludeList.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.[d-zD-Z] -exclude ${test.root}\/ProblemList-graal.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/Core02Test.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.aarch64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.aarch64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/CoreAarch64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.amd64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.amd64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/CoreAmd64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.jdk9.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.jdk9.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/CoreJdk9Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.debug.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.debug.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/DebugTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.ea -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.core.test.ea -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/EATest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.graph.test -exclude ExcludeList.txt -vmargs --add-opens=jdk.internal.vm.compiler\/org.graalvm.graphio=ALL-UNNAMED\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.graph.test -exclude ${test.root}\/ProblemList-graal.txt -vmargs --add-opens=jdk.internal.vm.compiler\/org.graalvm.graphio=ALL-UNNAMED\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/GraphTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.aarch64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.aarch64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotAarch64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.amd64.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.amd64.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotAmd64Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.jdk15.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.jdk15.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotJdk15Test.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.jdk9.test -exclude ExcludeList.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.jdk9.test -exclude ${test.root}\/ProblemList-graal.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotJdk9Test.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.lir.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.lir.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotLirTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.hotspot.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/HotspotTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.micro -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.micro -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/Jtt.MicroTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.backend -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.backend -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttBackendTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.bytecode -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.bytecode -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttBytecodeTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.except -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.except -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttExceptTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.hotpath -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.hotpath -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttHotpathTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.hotspot -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.hotspot -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttHotspotTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.jdk -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.jdk -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttJdkTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.[a-lA-L] -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.[a-lA-L] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttLangALTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.Math_[a-lA-L] -exclude ExcludeList.txt\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.Math_[a-lA-L] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttLangMathALTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.Math_[m-zM-Z] -exclude ExcludeList.txt\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.Math_[m-zM-Z] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttLangMathMZTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.[n-zN-Z] -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.lang.[n-zN-Z] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttLangNZTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.loop -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.loop -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttLoopTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.optimize -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.optimize -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttOptimizeTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.[a-eA-E] -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.[a-eA-E] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttReflectAETest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.Field_get -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.Field_get -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttReflectFieldGetTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.Field_set -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.Field_set -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttReflectFieldSetTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.[g-zG-Z] -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.reflect.[g-zG-Z] -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttReflectGZTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.threads -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.jtt.threads -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/JttThreadsTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.lir.jtt -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.lir.jtt -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/LirJttTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.lir.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.lir.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/LirTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.loop.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.loop.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/LoopTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.nodes.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.nodes.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/NodesTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.options.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.options.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/OptionsTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.phases.common.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.phases.common.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/PhasesCommonTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.jdk12.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.jdk12.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/Replacements12Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.jdk9.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.jdk9.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/Replacements9Test.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.test -exclude ExcludeList.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.compiler.replacements.test -exclude ${test.root}\/ProblemList-graal.txt -vmargs --add-opens=java.base\/java.lang=ALL-UNNAMED\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/ReplacementsTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary\n@@ -33,5 +32,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.util.test -exclude ExcludeList.txt\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI compiler.graalunit.common.GraalUnitTestLauncher -prefix org.graalvm.util.test -exclude ${test.root}\/ProblemList-graal.txt\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/UtilTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  \n+\n@@ -37,1 +37,1 @@\n-     \n+\n@@ -39,1 +39,1 @@\n-     \n+\n@@ -46,2 +46,2 @@\n-           ;;           \n-           \n+           ;;\n+\n@@ -53,1 +53,1 @@\n-           \n+\n@@ -59,2 +59,2 @@\n-           \n-           * )\n+\n+           *)\n@@ -63,1 +63,1 @@\n-           ;;  \n+           ;;\n@@ -69,2 +69,2 @@\n-      \n-  \n+\n+\n@@ -73,1 +73,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,0 @@\n- * @summary\n@@ -104,5 +103,1 @@\n- * @build compiler.graalunit.common.GraalUnitTestLauncher\n- *\n- * @run driver jdk.test.lib.FileInstaller ..\/..\/ProblemList-graal.txt ExcludeList.txt\n- *\n- * @run $action $flags compiler.graalunit.common.GraalUnitTestLauncher -prefix $pName -exclude ExcludeList.txt $vmargs\n+ * @run $action $flags compiler.graalunit.common.GraalUnitTestLauncher -prefix $pName -exclude \\${test.root}\/ProblemList-graal.txt $vmargs\n@@ -110,1 +105,1 @@\n- \n+\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/generateTests.sh","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2019 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2020 SAP SE. All rights reserved.\n@@ -29,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -41,0 +41,1 @@\n+import jtreg.SkippedException;\n@@ -134,2 +135,1 @@\n-            System.out.println(\"Platform is not supporting unaligned access - nothing to test.\");\n-            return;\n+            throw new SkippedException(\"Platform is not supporting unaligned access - nothing to test.\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeUnalignedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2018 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/BlockingCompilation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -102,1 +102,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -114,1 +114,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -154,1 +154,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocHumongousFragment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -106,1 +106,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -118,1 +118,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -130,1 +130,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -175,1 +175,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -106,1 +106,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -118,1 +118,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -130,1 +130,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -175,1 +175,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -110,1 +110,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -125,1 +125,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -170,1 +170,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -45,1 +45,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -56,1 +56,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -67,1 +67,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -78,1 +78,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -89,1 +89,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -100,1 +100,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -76,1 +76,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -86,1 +86,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -118,1 +118,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLotsOfCycles.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -60,1 +60,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -69,1 +69,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -87,1 +87,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSampling.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -89,1 +89,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -99,1 +99,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -109,1 +109,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -140,1 +140,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -97,1 +97,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -109,1 +109,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -121,1 +121,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -156,1 +156,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n@@ -72,0 +72,5 @@\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n+ *      -XX:+ShenandoahVerify -XX:+IgnoreUnrecognizedVMOptions -XX:TieredStopAtLevel=1\n+ *      TestVerifyJCStress\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyJCStress.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLoadPinnedAfterCall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -66,1 +66,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -77,1 +77,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -64,1 +64,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -74,1 +74,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSoftMaxHeapSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2017, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/TestJNIBlockFullGC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2017, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/libTestJNIBlockFullGC.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient & !vm.graal.enabled & vm.opt.ClassUnloading != false\n+ * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n@@ -215,1 +215,1 @@\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient & !vm.graal.enabled & vm.opt.ClassUnloading != false\n+ * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithShenandoah.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -97,1 +97,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n@@ -131,1 +131,1 @@\n- * @requires vm.gc.Shenandoah & !vm.graal.enabled\n+ * @requires vm.gc.Shenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOldWithShenandoah.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Test to verify GetObjectSize does not overflow on a 600M element int[]\n+ *\n+ * @test\n+ * @bug 8027230\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.instrument\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @requires vm.bits == 64\n+ * @requires vm.jvmti\n+ * @requires os.maxMemory > 6G\n+ * @build GetObjectSizeOverflowAgent\n+ * @run driver ClassFileInstaller GetObjectSizeOverflowAgent\n+ * @run main GetObjectSizeOverflow\n+ *\/\n+\n+import java.io.PrintWriter;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+public class GetObjectSizeOverflow {\n+    public static void main(String[] args) throws Exception  {\n+\n+        PrintWriter pw = new PrintWriter(\"MANIFEST.MF\");\n+        pw.println(\"Premain-Class: GetObjectSizeOverflowAgent\");\n+        pw.close();\n+\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jar\"), \"cmf\", \"MANIFEST.MF\", \"agent.jar\", \"GetObjectSizeOverflowAgent.class\"});\n+        pb.start().waitFor();\n+\n+        ProcessBuilder pt = ProcessTools.createTestJvm(\"-Xmx4000m\", \"-javaagent:agent.jar\",  \"GetObjectSizeOverflowAgent\");\n+        OutputAnalyzer output = new OutputAnalyzer(pt.start());\n+\n+        output.stdoutShouldContain(\"GetObjectSizeOverflow passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/resourcehogs\/serviceability\/jvmti\/GetObjectSizeOverflow.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/resourcehogs\/serviceability\/jvmti\/GetObjectSizeOverflowAgent.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeOverflowAgent.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2019 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/Safepoint\/TestAbortVMOnSafepointTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,4 +83,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -99,1 +95,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/CDSMHTest_generate.sh","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesCastFailureTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesGeneralTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesInvokersTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-import jtreg.SkippedException;\n-\n-import sun.hotspot.gc.GC;\n-\n@@ -67,1 +63,0 @@\n-    private static final String skippedException = \"jtreg.SkippedException: Unable to map shared archive: test did not complete\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, SAP SE and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016 SAP SE and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ThreadLoggingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderHierarchyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ShowReflectionTargetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * Test to verify GetObjectSize does not overflow on a 600M element int[]\n- *\n- * @test\n- * @bug 8027230\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.instrument\n- *          java.management\n- *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n- * @requires vm.bits == 64\n- * @requires vm.jvmti\n- * @build GetObjectSizeOverflowAgent\n- * @run driver ClassFileInstaller GetObjectSizeOverflowAgent\n- * @run main GetObjectSizeOverflow\n- *\/\n-\n-import java.io.PrintWriter;\n-\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jtreg.SkippedException;\n-\n-public class GetObjectSizeOverflow {\n-    public static void main(String[] args) throws Exception  {\n-\n-        PrintWriter pw = new PrintWriter(\"MANIFEST.MF\");\n-        pw.println(\"Premain-Class: GetObjectSizeOverflowAgent\");\n-        pw.close();\n-\n-        ProcessBuilder pb = new ProcessBuilder();\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jar\"), \"cmf\", \"MANIFEST.MF\", \"agent.jar\", \"GetObjectSizeOverflowAgent.class\"});\n-        pb.start().waitFor();\n-\n-        ProcessBuilder pt = ProcessTools.createTestJvm(\"-Xmx4000m\", \"-javaagent:agent.jar\",  \"GetObjectSizeOverflowAgent\");\n-        OutputAnalyzer output = new OutputAnalyzer(pt.start());\n-\n-        if (output.getStdout().contains(\"Could not reserve enough space\") || output.getStderr().contains(\"java.lang.OutOfMemoryError\")) {\n-            System.out.println(\"stdout: \" + output.getStdout());\n-            System.out.println(\"stderr: \" + output.getStderr());\n-            throw new SkippedException(\"Test could not reserve or allocate enough space\");\n-        }\n-\n-        output.stdoutShouldContain(\"GetObjectSizeOverflow passed\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeOverflow.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import java.io.PrintStream;\n+import jdk.test.lib.Utils;\n@@ -28,0 +28,2 @@\n+import java.io.PrintStream;\n+\n@@ -30,1 +32,1 @@\n- *\n+ * <p>\n@@ -32,9 +34,9 @@\n- *\n- *   -stressTime [time] execution time in seconds\n- *   -stressIterationsFactor [factor] iterations factor.\n- *   The actual number of iterations is obtained by multiplying standard\n- *   number of iterations (which is defined by the test itself) and this factor.\n- *   -stressThreadsFactor [factor] number of threads factor\n- *   The actual number of threads is determined by multiplying standard\n- *   number of threads (which is determined by test itself and may also depend\n- *   on machine configuration) and this factor.\n+ * <p>\n+ * -stressTime [time] execution time in seconds\n+ * -stressIterationsFactor [factor] iterations factor.\n+ * The actual number of iterations is obtained by multiplying standard\n+ * number of iterations (which is defined by the test itself) and this factor.\n+ * -stressThreadsFactor [factor] number of threads factor\n+ * The actual number of threads is determined by multiplying standard\n+ * number of threads (which is determined by test itself and may also depend\n+ * on machine configuration) and this factor.\n@@ -46,1 +48,1 @@\n-    public static enum StressOptionsParam {\n+    public enum StressOptionsParam {\n@@ -91,1 +93,1 @@\n-     * @param arg arguments\n+     * @param args arguments\n@@ -98,12 +100,0 @@\n-    \/**\n-     * Create stresser with same parameters as another.\n-     *\n-     * @param other another instance of StressOptions\n-     *\/\n-    public StressOptions(StressOptions other) {\n-        this.time = other.time;\n-        this.iterationsFactor = other.iterationsFactor;\n-        this.threadsFactor = other.threadsFactor;\n-        this.runsFactor = other.runsFactor;\n-    }\n-\n@@ -121,1 +111,1 @@\n-     *\n+     * <p>\n@@ -224,1 +214,1 @@\n-     * Obtain execution time in seconds.\n+     * Obtain execution time in seconds adjusted for TIMEOUT_FACTOR.\n@@ -229,1 +219,1 @@\n-        return time;\n+        return Utils.adjustTimeout(time);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/StressOptions.java","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-# disabled till JDK-8252004 is fixed\n-allowSmartActionArgs=false\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/TEST.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree001\/btree001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree003\/btree003.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree004\/btree004.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree006\/btree006.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree007\/btree007.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree009\/btree009.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree010\/btree010.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree012\/btree012.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain001\/chain001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain002\/chain002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain003\/chain003.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain004\/chain004.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain005\/chain005.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain006\/chain006.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain008\/chain008.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+java\/awt\/event\/KeyEvent\/KeyTyped\/CtrlASCII.java 8252713 linux-all\n@@ -274,1 +275,0 @@\n-sun\/java2d\/pipe\/InterpolationQualityTest.java 8171303 windows-all,linux-all,macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, SAP SE. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n","filename":"test\/jdk\/com\/sun\/jdi\/OnJcmdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+   @key headful\n@@ -53,0 +54,3 @@\n+                                System.err.println(\"file = \" + file);\n+                                System.err.println(\"file1 = \" + file1);\n+                                System.err.println(\"path = \" + path);\n","filename":"test\/jdk\/java\/awt\/FileDialog\/8003399\/bug8003399.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+   @key headful\n","filename":"test\/jdk\/java\/awt\/FileDialog\/8017487\/bug8017487.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.ImageCapabilities;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+import java.awt.image.VolatileImage;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+\n+\/**\n+ * @test\n+ * @bug 7183828\n+ * @summary Tests that no exceptions are thrown when we draw the custom image\n+ *\/\n+public final class CustomImage extends Image {\n+\n+    public static void main(String[] args) {\n+        Image ci = new CustomImage();\n+        VolatileImage cvi = new CustomVolatileImage();\n+\n+        BufferedImage bi = generateImage();\n+        Graphics2D g2d = bi.createGraphics();\n+        \/\/ Custom Image\n+        test(g2d.drawImage(ci, 0, 0, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 5, 5, 0, 0, 5, 5, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, 0, 0, 5, 5, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(ci, AffineTransform.getRotateInstance(30), null), bi);\n+        \/\/ Custom VolatileImage\n+        test(g2d.drawImage(cvi, 0, 0, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 5, 5, 0, 0, 5, 5, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, 0, 0, 5, 5, 0, 0, 9, 9, Color.BLUE, null), bi);\n+        test(g2d.drawImage(cvi, AffineTransform.getRotateInstance(30), null), bi);\n+\n+        g2d.dispose();\n+    }\n+\n+    private static BufferedImage generateImage() {\n+        BufferedImage bi = new BufferedImage(100, 100, TYPE_INT_ARGB_PRE);\n+        Graphics g = bi.createGraphics();\n+        g.setColor(Color.GREEN);\n+        g.fillRect(0, 0, 100, 100);\n+        g.dispose();\n+        return bi;\n+    }\n+\n+    private static void test(boolean complete, BufferedImage bi) {\n+        if (complete) {\n+            throw new RuntimeException(\"Custom image successfully drawn\");\n+        }\n+        for (int y = 0; y < bi.getHeight(); ++y) {\n+            for (int x = 0; x < bi.getWidth(); ++x) {\n+                if (bi.getRGB(x, y) != Color.GREEN.getRGB()) {\n+                    throw new RuntimeException(\"The image was changed\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getWidth(ImageObserver observer) {\n+        return 100;\n+    }\n+\n+    @Override\n+    public int getHeight(ImageObserver observer) {\n+        return 100;\n+    }\n+\n+    @Override\n+    public ImageProducer getSource() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Graphics getGraphics() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getProperty(String name, ImageObserver observer) {\n+        return null;\n+    }\n+\n+    private static final class CustomVolatileImage extends VolatileImage {\n+\n+        @Override\n+        public BufferedImage getSnapshot() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getWidth() {\n+            return 100;\n+        }\n+\n+        @Override\n+        public int getHeight() {\n+            return 100;\n+        }\n+\n+        @Override\n+        public Graphics2D createGraphics() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int validate(GraphicsConfiguration gc) {\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean contentsLost() {\n+            return false;\n+        }\n+\n+        @Override\n+        public ImageCapabilities getCapabilities() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getWidth(ImageObserver observer) {\n+            return 100;\n+        }\n+\n+        @Override\n+        public int getHeight(ImageObserver observer) {\n+            return 100;\n+        }\n+\n+        @Override\n+        public Object getProperty(String name, ImageObserver observer) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/DrawImage\/CustomImage.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.maxMemory >= 6G\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 6G)\n@@ -31,1 +31,0 @@\n- * @ignore This test has huge memory requirements\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/HugeCapacity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.maxMemory >= 6G\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 6G)\n@@ -31,1 +31,0 @@\n- * @ignore This test has huge memory requirements\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n- * @bug 4485208\n- * @summary  file: and ftp: URL handlers need to throw NPE in setRequestProperty\n+ * @bug 4485208 8252767\n+ * @summary Validate various request property methods on java.net.URLConnection\n+ * throw NullPointerException and IllegalStateException when expected\n+ * @run testng RequestProperties\n@@ -30,1 +32,8 @@\n-import java.net.*;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.file.Path;\n@@ -35,1 +44,0 @@\n-    static int failed;\n@@ -37,2 +45,6 @@\n-    public static void main (String args[]) throws Exception {\n-        List<String> urls = new ArrayList<>();\n+    private static final Class NPE = NullPointerException.class;\n+    private static final Class ISE = IllegalStateException.class;\n+\n+    @DataProvider(name = \"urls\")\n+    private Object[][] urls() {\n+        final List<String> urls = new ArrayList<>();\n@@ -42,1 +54,1 @@\n-        if (hasFtp())\n+        if (hasFtp()) {\n@@ -44,0 +56,57 @@\n+        }\n+        final Object[][] data = new Object[urls.size()][1];\n+        for (int i = 0; i < urls.size(); i++) {\n+            data[i][0] = urls.get(i);\n+        }\n+        return data;\n+    }\n+\n+\n+    \/**\n+     * Test that {@link java.net.URLConnection#setRequestProperty(String, String)} throws\n+     * a {@link NullPointerException} when passed null key\n+     *\/\n+    @Test(dataProvider = \"urls\")\n+    public void testSetRequestPropertyNullPointerException(final String url) throws Exception {\n+        final URLConnection conn = new URL(url).openConnection();\n+        Assert.assertThrows(NPE, () -> conn.setRequestProperty(null, \"bar\"));\n+        \/\/ expected to pass\n+        conn.setRequestProperty(\"key\", null);\n+    }\n+\n+    \/**\n+     * Test that {@link java.net.URLConnection#addRequestProperty(String, String)} throws\n+     * a {@link NullPointerException} when passed null key\n+     *\/\n+    @Test(dataProvider = \"urls\")\n+    public void testAddRequestPropertyNullPointerException(final String url) throws Exception {\n+        final URLConnection conn = new URL(url).openConnection();\n+        Assert.assertThrows(NPE, () -> conn.addRequestProperty(null, \"hello\"));\n+        \/\/ expected to pass\n+        conn.addRequestProperty(\"key\", null);\n+    }\n+\n+    \/**\n+     * Test that {@link java.net.URLConnection#getRequestProperty(String)} returns\n+     * null when the passed key is null\n+     *\/\n+    @Test(dataProvider = \"urls\")\n+    public void testGetRequestPropertyReturnsNull(final String url) throws Exception {\n+        final URLConnection conn = new URL(url).openConnection();\n+        Assert.assertNull(conn.getRequestProperty(null),\n+                \"getRequestProperty was expected to return null for null key\");\n+    }\n+\n+    \/**\n+     * Test that {@link java.net.URLConnection#setRequestProperty(String, String)} throws\n+     * an {@link IllegalStateException} when already connected\n+     *\/\n+    @Test\n+    public void testSetRequestPropertyIllegalStateException() throws Exception {\n+        final URLConnection conn = createAndConnectURLConnection();\n+        try {\n+            Assert.assertThrows(ISE, () -> conn.setRequestProperty(\"foo\", \"bar\"));\n+        } finally {\n+            safeClose(conn);\n+        }\n+    }\n@@ -45,2 +114,13 @@\n-        for (String urlStr : urls)\n-            test(new URL(urlStr));\n+    \/**\n+     * Test that {@link java.net.URLConnection#addRequestProperty(String, String)} throws\n+     * an {@link IllegalStateException} when already connected\n+     *\/\n+    @Test\n+    public void testAddRequestPropertyIllegalStateException() throws Exception {\n+        final URLConnection conn = createAndConnectURLConnection();\n+        try {\n+            Assert.assertThrows(ISE, () -> conn.addRequestProperty(\"foo\", \"bar\"));\n+        } finally {\n+            safeClose(conn);\n+        }\n+    }\n@@ -48,2 +128,12 @@\n-        if (failed != 0)\n-            throw new RuntimeException(failed + \" errors\") ;\n+    \/**\n+     * Test that {@link java.net.URLConnection#getRequestProperty(String)} throws\n+     * an {@link IllegalStateException} when already connected\n+     *\/\n+    @Test\n+    public void testGetRequestPropertyIllegalStateException() throws Exception {\n+        final URLConnection conn = createAndConnectURLConnection();\n+        try {\n+            Assert.assertThrows(ISE, () -> conn.getRequestProperty(\"hello\"));\n+        } finally {\n+            safeClose(conn);\n+        }\n@@ -52,2 +142,7 @@\n-    static void test(URL url) throws Exception {\n-        URLConnection urlc = url.openConnection();\n+    \/**\n+     * Test that {@link URLConnection#getRequestProperties()} throws\n+     * an {@link IllegalStateException} when already connected\n+     *\/\n+    @Test\n+    public void testGetRequestPropertiesIllegalStateException() throws Exception {\n+        final URLConnection conn = createAndConnectURLConnection();\n@@ -55,5 +150,14 @@\n-            urlc.setRequestProperty(null, null);\n-            System.out.println(url.getProtocol()\n-                               + \": setRequestProperty(null,) did not throw NPE\");\n-            failed++;\n-        } catch (NullPointerException e) { \/* Expected *\/ }\n+            Assert.assertThrows(ISE, () -> conn.getRequestProperties());\n+        } finally {\n+            safeClose(conn);\n+        }\n+    }\n+\n+    private static URLConnection createAndConnectURLConnection() throws IOException {\n+        final URL url = Path.of(System.getProperty(\"java.io.tmpdir\")).toUri().toURL();\n+        final URLConnection conn = url.openConnection();\n+        conn.connect();\n+        return conn;\n+    }\n+\n+    private static void safeClose(final URLConnection conn) {\n@@ -61,10 +165,3 @@\n-            urlc.addRequestProperty(null, null);\n-            System.out.println(url.getProtocol()\n-                               + \": addRequestProperty(null,) did not throw NPE\");\n-            failed++;\n-        } catch (NullPointerException e)  { \/* Expected *\/ }\n-\n-        if (urlc.getRequestProperty(null) != null) {\n-            System.out.println(url.getProtocol()\n-                               + \": getRequestProperty(null,) did not return null\");\n-            failed++;\n+            conn.getInputStream().close();\n+        } catch (Exception e) {\n+            \/\/ ignore\n@@ -76,1 +173,2 @@\n-            return new java.net.URL(\"ftp:\/\/\") != null;\n+            new java.net.URL(\"ftp:\/\/\");\n+            return true;\n","filename":"test\/jdk\/java\/net\/URLConnection\/RequestProperties.java","additions":128,"deletions":30,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -73,22 +73,0 @@\n-\n-        \/\/ Now check that properties whose keys or values are objects\n-        \/\/ are skipped.\n-\n-        P1.put(\"p1.object.prop\", Objects.OBJ1);\n-        P1.put(Objects.OBJ1, \"p1.object.prop\");\n-        P1.put(\"p2.object.prop\", \"p2.object.prop\");\n-        P2.put(\"p2.object.prop\", Objects.OBJ2);\n-        P2.put(Objects.OBJ2, \"p2.object.prop\");\n-        P3.put(\"p3.object.prop\", Objects.OBJ3);\n-        P3.put(Objects.OBJ3, \"p3.object.prop\");\n-\n-        Properties PP1 = loadFromXML(writeToXML(P1), null);\n-        Properties PP2 = loadFromXML(writeToXML(P2), PP1);\n-        Properties PP3 = loadFromXML(writeToXML(P3), PP2);\n-\n-        p1.setProperty(\"p2.object.prop\", \"p2.object.prop\");\n-        try {\n-            testResults(p1, PP1, p2, PP2, p3, PP3);\n-        } finally {\n-            p1.remove(\"p2.object.prop\");\n-        }\n","filename":"test\/jdk\/java\/util\/Properties\/LoadAndStoreXMLWithDefaults.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires (os.family == \"linux\")\n+ * @key headful\n+ * @bug 8218479\n+ * @summary Tests JTextPane background color\n+ * @run main TestJTextPaneBackgroundColor\n+ *\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+\n+public class TestJTextPaneBackgroundColor {\n+    private static JFrame frame;\n+    private static JTextPane textPane;\n+    private static Point point;\n+    private static Rectangle rect;\n+    private static Robot robot;\n+    private static final String GTK_LAF_CLASS = \"GTKLookAndFeel\";\n+\n+    private static void blockTillDisplayed(Component comp) {\n+        Point p = null;\n+        while (p == null) {\n+            try {\n+                p = comp.getLocationOnScreen();\n+            } catch (IllegalStateException e) {\n+                try {\n+                    Thread.sleep(500);\n+                } catch (InterruptedException ie) {\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!System.getProperty(\"os.name\").startsWith(\"Linux\")) {\n+            System.out.println(\"This test is meant for Linux platform only\");\n+            return;\n+        }\n+\n+        for (UIManager.LookAndFeelInfo lookAndFeelInfo :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (lookAndFeelInfo.getClassName().contains(GTK_LAF_CLASS)) {\n+                try {\n+                    UIManager.setLookAndFeel(lookAndFeelInfo.getClassName());\n+                } catch (final UnsupportedLookAndFeelException ignored) {\n+                    System.out.println(\"GTK L&F could not be set, so this \" +\n+                            \"test can not be run in this scenario \");\n+                    return;\n+                }\n+            }\n+        }\n+\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        try {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    JPanel panel = new JPanel();\n+                    textPane = new JTextPane();\n+                    textPane.setText(\"             \");\n+                    panel.add(textPane, BorderLayout.CENTER);\n+                    frame = new JFrame(\"TestJTextPaneBackgroundColor\");\n+                    frame.add(panel);\n+                    frame.setSize(200, 200);\n+                    frame.setAlwaysOnTop(true);\n+                    frame.setLocationRelativeTo(null);\n+                    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                    frame.setVisible(true);\n+                }\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            blockTillDisplayed(textPane);\n+            SwingUtilities.invokeAndWait(() -> {\n+                point = textPane.getLocationOnScreen();\n+                rect = textPane.getBounds();\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            Color textpaneBackgroundColor = robot\n+                    .getPixelColor(point.x+rect.width\/2, point.y+rect.height\/2);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            Color panelColor = robot\n+                    .getPixelColor(point.x-rect.width\/2, point.y+rect.height\/2);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            System.out.println(textpaneBackgroundColor);\n+            System.out.println(panelColor);\n+            if (textpaneBackgroundColor.equals(panelColor)) {\n+                throw new RuntimeException(\"The expected background color for \" +\n+                        \"TextPane was not found\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTextPane\/TestJTextPaneBackgroundColor.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2019 SAP SE. All rights reserved.\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,6 +31,5 @@\n- * @author Vadim.Pakhnushev@oracle.com\n- * @run main\/othervm -Dsun.java2d.xrender=false InterpolationQualityTest\n- * @run main\/othervm -Dsun.java2d.xrender=True InterpolationQualityTest\n- * @run main\/othervm -Dsun.java2d.d3d=false InterpolationQualityTest\n- * @run main\/othervm -Dsun.java2d.d3d=True InterpolationQualityTest\n- * @run main\/othervm InterpolationQualityTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 -Dsun.java2d.xrender=false InterpolationQualityTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 -Dsun.java2d.xrender=True InterpolationQualityTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 -Dsun.java2d.d3d=false InterpolationQualityTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 -Dsun.java2d.d3d=True InterpolationQualityTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InterpolationQualityTest\n","filename":"test\/jdk\/sun\/java2d\/pipe\/InterpolationQualityTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -75,2 +75,3 @@\n-    private static final String POSIXWARNING = \"POSIX file permission attributes detected. \" +\n-        \"These attributes are ignored when signing and are not protected by the signature.\";\n+    private static final String WARNING_MSG = \"POSIX file permission and\/or symlink \" +\n+        \"attributes detected. These attributes are ignored when signing and are not \" +\n+        \"protected by the signature.\";\n@@ -107,1 +108,1 @@\n-                .shouldContain(POSIXWARNING);\n+                .shouldContain(WARNING_MSG);\n@@ -119,1 +120,1 @@\n-                .shouldNotContain(POSIXWARNING);\n+                .shouldNotContain(WARNING_MSG);\n@@ -130,1 +131,1 @@\n-                .shouldContain(POSIXWARNING);\n+                .shouldContain(WARNING_MSG);\n@@ -139,1 +140,1 @@\n-                .shouldNotContain(POSIXWARNING);\n+                .shouldNotContain(WARNING_MSG);\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/PosixPermissionsTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8250968\n+ * @summary Symlinks attributes not preserved when using jarsigner on zip files\n+ * @modules jdk.jartool\/sun.security.tools.jarsigner\n+ *          java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/othervm SymLinkTest\n+ *\/\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.util.Formatter;\n+\n+import jdk.test.lib.SecurityTools;\n+\n+public class SymLinkTest {\n+    private final static String ZIPFILENAME = \"8250968-test.zip\";\n+    private static final String WARNING_MSG = \"POSIX file permission and\/or symlink \" +\n+            \"attributes detected. These attributes are ignored when signing and are not \" +\n+            \"protected by the signature.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Files.deleteIfExists(Paths.get(ZIPFILENAME));\n+        try (FileOutputStream fos = new FileOutputStream(ZIPFILENAME)) {\n+            fos.write(ZIPBYTES);\n+        }\n+\n+        \/\/ check permissions before signing\n+        verifyExtraAttrs(ZIPFILENAME);\n+\n+        SecurityTools.keytool(\n+                \"-genkey\",\n+                \"-keyalg\", \"RSA\",\n+                \"-dname\", \"CN=Coffey, OU=JPG, O=Oracle, L=Santa Clara, ST=California, C=US\",\n+                \"-alias\", \"examplekey\",\n+                \"-storepass\", \"password\",\n+                \"-keypass\", \"password\",\n+                \"-keystore\", \"examplekeystore\",\n+                \"-validity\", \"365\")\n+                .shouldHaveExitValue(0);\n+\n+        SecurityTools.jarsigner(\n+                \"-keystore\", \"examplekeystore\",\n+                \"-verbose\", ZIPFILENAME,\n+                \"-storepass\", \"password\",\n+                \"-keypass\", \"password\",\n+                \"examplekey\")\n+                .shouldHaveExitValue(0)\n+                .shouldContain(WARNING_MSG);\n+\n+        \/\/ zip file now signed. Recheck attributes\n+        verifyExtraAttrs(ZIPFILENAME);\n+\n+        SecurityTools.jarsigner(\"-keystore\", \"examplekeystore\",\n+                \"-storepass\", \"password\",\n+                \"-keypass\", \"password\",\n+                \"-verbose\",\n+                \"-verify\", ZIPFILENAME)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(WARNING_MSG);\n+    }\n+\n+    private static void verifyExtraAttrs(String zipFileName) throws IOException {\n+        \/\/ the 16 bit extra attributes value should equal 0xa1ff - look for that pattern.\n+        \/\/ Such values can be read from zip file via 'unzip -Z -l -v <zipfile>'\n+        try (FileInputStream fis = new FileInputStream(ZIPFILENAME)) {\n+            byte[] b = fis.readAllBytes();\n+            boolean patternFound;\n+            for (int i = 0; i < b.length -1; i++) {\n+                patternFound = ((b[i] & 0xFF) == 0xFF) &&  ((b[i + 1] & 0xFF) == 0xA1);\n+                if (patternFound) {\n+                    return;\n+                }\n+            }\n+            throw new RuntimeException(\"extra attribute value not detected\");\n+        }\n+    }\n+\n+    \/**\n+     * Utility method which takes an byte array and converts to byte array\n+     * declaration.  For example:\n+     * <pre>\n+     *     {@code\n+     *        var fooJar = Files.readAllBytes(Path.of(\"foo.jar\"));\n+     *        var result = createByteArray(fooJar, \"FOOBYTES\");\n+     *      }\n+     * <\/pre>\n+     * @param bytes A byte array used to create a byte array declaration\n+     * @param name Name to be used in the byte array declaration\n+     * @return The formatted byte array declaration\n+     *\/\n+    public static String createByteArray(byte[] bytes, String name) {\n+        StringBuilder sb = new StringBuilder(bytes.length * 5);\n+        Formatter fmt = new Formatter(sb);\n+        fmt.format(\"    public static byte[] %s = {\", name);\n+        final int linelen = 8;\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (i % linelen == 0) {\n+                fmt.format(\"%n        \");\n+            }\n+            fmt.format(\" (byte) 0x%x,\", bytes[i] & 0xff);\n+        }\n+        fmt.format(\"%n    };%n\");\n+        return sb.toString();\n+    }\n+\n+    \/*\n+     * Created using the createByteArray utility method.\n+     * The zipfile itself was created via this example:\n+     * $ ls -l z\n+     * lrwxrwxrwx 1 test test 4 Aug 27 18:33 z -> ..\/z\n+     * $ zip -ry test.zip z\n+     *\/\n+    public final static byte[] ZIPBYTES = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0xa, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x2e, (byte) 0x94, (byte) 0x1b, (byte) 0x51, (byte) 0xb4, (byte) 0xcc,\n+            (byte) 0xb6, (byte) 0xf1, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x4, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1c, (byte) 0x0, (byte) 0x7a, (byte) 0x55,\n+            (byte) 0x54, (byte) 0x9, (byte) 0x0, (byte) 0x3, (byte) 0x77, (byte) 0xfc, (byte) 0x47, (byte) 0x5f,\n+            (byte) 0x78, (byte) 0xfc, (byte) 0x47, (byte) 0x5f, (byte) 0x75, (byte) 0x78, (byte) 0xb, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x4, (byte) 0xec, (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x4, (byte) 0xec,\n+            (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x2e, (byte) 0x2e, (byte) 0x2f, (byte) 0x7a, (byte) 0x50,\n+            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x1e, (byte) 0x3, (byte) 0xa, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2e, (byte) 0x94, (byte) 0x1b, (byte) 0x51, (byte) 0xb4,\n+            (byte) 0xcc, (byte) 0xb6, (byte) 0xf1, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x4,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x18, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff,\n+            (byte) 0xa1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x7a, (byte) 0x55, (byte) 0x54,\n+            (byte) 0x5, (byte) 0x0, (byte) 0x3, (byte) 0x77, (byte) 0xfc, (byte) 0x47, (byte) 0x5f, (byte) 0x75,\n+            (byte) 0x78, (byte) 0xb, (byte) 0x0, (byte) 0x1, (byte) 0x4, (byte) 0xec, (byte) 0x3, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x4, (byte) 0xec, (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x47, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3f, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SymLinkTest.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -39,0 +42,1 @@\n+ * @bug 8252919\n@@ -48,1 +52,1 @@\n- * @run main\/othervm GenerateJLIClassesPluginTest\n+ * @run testng\/othervm GenerateJLIClassesPluginTest\n@@ -54,1 +58,2 @@\n-    public static void main(String[] args) throws Exception {\n+    @BeforeTest\n+    public static void setup() throws Exception {\n@@ -60,1 +65,0 @@\n-\n@@ -62,0 +66,1 @@\n+    }\n@@ -63,0 +68,2 @@\n+    @Test\n+    public static void testSpecies()  throws IOException {\n@@ -76,1 +83,1 @@\n-\n+        validateHolderClasses(image);\n@@ -80,0 +87,1 @@\n+    }\n@@ -81,0 +89,2 @@\n+    @Test\n+    public static void testInvalidSignatures() throws IOException {\n@@ -82,1 +92,1 @@\n-        ensureInvalidSignaturesFail(\n+        String[] args = new String[] {\n@@ -86,4 +96,1 @@\n-        );\n-    }\n-\n-    private static void ensureInvalidSignaturesFail(String ... args) throws IOException {\n+        };\n@@ -96,1 +103,1 @@\n-                    .output(helper.createNewImageDir(\"generate-jli-file\"))\n+                    .output(helper.createNewImageDir(\"invalid-signature\"))\n@@ -105,0 +112,22 @@\n+    @Test\n+    public static void nonExistentTraceFile() throws IOException {\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"non-existent-tracefile\"))\n+                .option(\"--generate-jli-classes=@NON_EXISTENT_FILE\")\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        Path image = result.assertSuccess();\n+        validateHolderClasses(image);\n+    }\n+\n+    private static void validateHolderClasses(Path image) throws IOException {\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(\"\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\"),\n+                List.of());\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        test(false, new String[]{\"--enable-preview\", \"--no-startup\"},\n+        test(false, new String[]{\"--no-startup\"},\n@@ -94,1 +94,1 @@\n-        test(false, new String[]{\"--enable-preview\", \"--no-startup\"},\n+        test(false, new String[]{\"--no-startup\"},\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @compile --enable-preview -source ${jdk.version} ConditionalExpressionResolvePending.java\n+ * @compile ConditionalExpressionResolvePending.java\n","filename":"test\/langtools\/tools\/javac\/ConditionalExpressionResolvePending.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-2 errors\n+Buggy.java:24:1: compiler.err.annotation.type.not.applicable\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/T8171332\/Processor.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.local.classes.cant.extend.sealed\n+\/\/ key: compiler.err.sealed.class.must.have.subclasses\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ key: compiler.misc.anonymous\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class Main {\n+    void m() {\n+        Shape shape = new Shape() {};\n+    }\n+}\n+\n+sealed interface Shape {}\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousCantInheritFromSealed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.in.module.cant.extend.sealed.in.diff.module\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --add-reads mSealed=mSub --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/CantExtendSealedInAnotherModule.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package a;\n+\n+public sealed class Base permits b.Impl {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSealed\/a\/Base.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module mSealed { exports a; }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSealed\/module-info.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package b;\n+\n+public final class Impl extends a.Base {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSub\/b\/Impl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module mSub { exports b; requires mSealed; }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSub\/module-info.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/CantExtendSealedInAnotherPkg.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p1;\n+\n+import p2.*;\n+\n+public sealed class Sealed permits p2.Sub {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/p1\/Sealed.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p2;\n+\n+import p1.*;\n+\n+public final class Sub extends p1.Sealed {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/p2\/Sub.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+\/\/ key: compiler.misc.local\n@@ -35,0 +36,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/LocalCantInheritFromSealed.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8158123 8161906 8162713 8202832\n+ * @bug 8158123 8161906 8162713 8202832 8235229\n@@ -41,0 +41,1 @@\n+import java.util.jar.Attributes;\n@@ -42,0 +43,1 @@\n+import toolbox.JarTask;\n@@ -801,0 +803,49 @@\n+\n+    @Test\n+    public void testMultiReleaseJarAndReleaseOption(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package api; public class A { }\");\n+        Path classes = base.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new JavacTask(tb)\n+                .outdir(classes)\n+                .files(findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        Path src9 = base.resolve(\"src9\");\n+        tb.writeJavaFiles(src9, \"module m { exports api; }\");\n+        Path classes9 = classes.resolve(\"META-INF\").resolve(\"versions\").resolve(\"9\");\n+        Files.createDirectories(classes9);\n+        new JavacTask(tb)\n+                .sourcepath(src, src9)\n+                .outdir(classes9)\n+                .files(findJavaFiles(src9))\n+                .run()\n+                .writeAll();\n+        Path jar = base.resolve(\"lib.jar\");\n+        new JarTask(tb, jar)\n+                .baseDir(classes)\n+                .files(Arrays.stream(tb.findFiles(\"class\", classes)).map(f -> classes.relativize(f).toString()).toArray(i -> new String[i]))\n+                .manifest(Attributes.Name.MULTI_RELEASE + \": true\\n\\n\")\n+                .run();\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc, \"module test { requires transitive m; }\", \"package impl; public class I { api.A a; }\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        Files.createDirectories(testClasses);\n+        new JavacTask(tb)\n+                .options(\"-Werror\", \"--module-path\", jar.toString())\n+                .sourcepath(testSrc)\n+                .outdir(testClasses)\n+                .files(findJavaFiles(testSrc))\n+                .run()\n+                .writeAll();\n+        new JavacTask(tb)\n+                .options(\"-Werror\", \"--module-path\", jar.toString(), \"--release\", \"9\", \"-doe\")\n+                .sourcepath(testSrc)\n+                .outdir(testClasses)\n+                .files(findJavaFiles(testSrc))\n+                .run()\n+                .writeAll();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/modules\/ModuleInfoTest.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * @compile --enable-preview -source ${jdk.version} BreakAndLoops.java\n- * @run main\/othervm --enable-preview BreakAndLoops\n+ * @compile BreakAndLoops.java\n+ * @run main BreakAndLoops\n","filename":"test\/langtools\/tools\/javac\/patterns\/BreakAndLoops.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * @compile --enable-preview -source ${jdk.version} ConditionalTest.java\n- * @run main\/othervm --enable-preview ConditionalTest\n+ * @compile ConditionalTest.java\n+ * @run main ConditionalTest\n","filename":"test\/langtools\/tools\/javac\/patterns\/ConditionalTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-            return true;\n+            return simpleName.equals(\"Source\") && kind == Kind.SOURCE;\n","filename":"test\/langtools\/tools\/javac\/processing\/errors\/CrashOnNonExistingAnnotation\/Processor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @test 8250629\n+ * @test 8250629 8252307 8247352\n@@ -389,0 +389,3 @@\n+        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+                \"record R(int x, int y) { public R(int y, int x, int z) { super(); this.x = this.y = 0; } }\");\n+\n@@ -1151,0 +1154,6 @@\n+                \"ElementType.FIELD,ElementType.CONSTRUCTOR\",\n+                \"ElementType.FIELD,ElementType.LOCAL_VARIABLE\",\n+                \"ElementType.FIELD,ElementType.ANNOTATION_TYPE\",\n+                \"ElementType.FIELD,ElementType.PACKAGE\",\n+                \"ElementType.FIELD,ElementType.TYPE_PARAMETER\",\n+                \"ElementType.FIELD,ElementType.MODULE\",\n@@ -1180,1 +1189,1 @@\n-            if (target.contains(\"FIELD\")) {\n+            if (target.contains(\"ElementType.FIELD\")) {\n@@ -1191,1 +1200,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1206,1 +1215,1 @@\n-            if (target.contains(\"PARAMETER\")) {\n+            if (target.contains(\"ElementType.PARAMETER\")) {\n@@ -1216,1 +1225,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1230,1 +1239,1 @@\n-            if (target.contains(\"METHOD\")) {\n+            if (target.contains(\"ElementType.METHOD\")) {\n@@ -1240,1 +1249,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1255,1 +1264,1 @@\n-            if (target.contains(\"RECORD_COMPONENT\")) {\n+            if (target.contains(\"ElementType.RECORD_COMPONENT\")) {\n@@ -1265,1 +1274,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1401,1 +1410,0 @@\n-            Assert.check(targetSet.isEmpty(), targetSet.toString());\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n- * @compile --enable-preview -source ${jdk.version} ClassBlockExits.java\n- * @run main\/othervm --enable-preview ClassBlockExits\n+ * @compile ClassBlockExits.java\n+ * @run main ClassBlockExits\n","filename":"test\/langtools\/tools\/javac\/recovery\/ClassBlockExits.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test 8247352\n@@ -376,1 +376,1 @@\n-                        \"public class Sub1 extends pkg1.Sealed {\\n\" +\n+                        \"public final class Sub1 extends pkg1.Sealed {\\n\" +\n@@ -387,3 +387,2 @@\n-                \"Sub1.java:3:8: compiler.err.non.sealed.sealed.or.final.expected\",\n-                \"Sealed.java:3:40: compiler.err.cant.inherit.from.sealed: pkg1.Sealed\",\n-                \"2 errors\");\n+                \"Sealed.java:3:40: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package: pkg1.Sealed\",\n+                \"1 error\");\n@@ -464,1 +463,1 @@\n-                \"Sealed.java:3:40: compiler.err.cant.inherit.from.sealed: pkg1.Sealed\",\n+                \"Sealed.java:3:40: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package: pkg1.Sealed\",\n@@ -604,3 +603,1 @@\n-            \"Base.java:1:46: compiler.err.cant.inherit.from.sealed: a.Base\",\n-            \"- compiler.note.preview.filename: Base.java\",\n-            \"- compiler.note.preview.recompile\",\n+            \"Base.java:1:46: compiler.err.class.in.module.cant.extend.sealed.in.diff.module: a.Base, mSealed\",\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"}]}