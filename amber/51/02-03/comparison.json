{"files":[{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@preview Associated with pattern matching for instanceof, a preview feature of\n+ *           the Java language.\n+ *\n+ *           This interface is associated with <i>pattern matching for instanceof<\/i>, a preview\n+ *           feature of the Java language. Preview features\n+ *           may be removed in a future release, or upgraded to permanent\n+ *           features of the Java language.}\n+ *\n+ * A deconstruction pattern tree\n+ *\n+ * @since 15\n+ *\/\n+public interface DeconstructionPatternTree extends PatternTree {\n+\n+    \/**\n+     * Returns the deconstructed type.\n+     * @return the deconstructed type\n+     *\/\n+    Tree getDeconstructor();\n+\n+    \/**\n+     * Returns the nested patterns.\n+     * @return the nested patterns.\n+     *\/\n+    List<? extends PatternTree> getNestedPatterns();\n+\n+}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -237,0 +237,15 @@\n+        \/**\n+         * {@preview Associated with pattern matching for instanceof, a preview feature of\n+         *           the Java language.\n+         *\n+         *           This enum constant is associated with <i>pattern matching for instanceof<\/i>, a preview\n+         *           feature of the Java language. Preview features\n+         *           may be removed in a future release, or upgraded to permanent\n+         *           features of the Java language.}\n+         *\n+         * Used for instances of {@link DeconstructionPatternTree}.\n+         *\n+         * @since 15\n+         *\/\n+        DECONSTRUCTION_PATTERN(DeconstructionPatternTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -277,0 +277,17 @@\n+    \/**\n+     * {@preview Associated with pattern matching for instanceof, a preview feature of\n+     *           the Java language.\n+     *\n+     *           This method is associated with <i>pattern matching for instanceof<\/i>, a preview\n+     *           feature of the Java language. Preview features\n+     *           may be removed in a future release, or upgraded to permanent\n+     *           features of the Java language.}\n+     *\n+     * Visits an DeconstructionPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 15\n+     *\/\n+    R visitDeconstructionPattern(DeconstructionPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -572,0 +572,13 @@\n+     * @return  the result of {@code defaultAction}\n+     * @since 15\n+     *\/\n+    @Override\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -701,0 +701,14 @@\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 15\n+     *\/\n+    @Override\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        R r = scan(node.getDeconstructor(), p);\n+        return scanAndReduce(node.getNestedPatterns(), p, r);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+            feature == Feature.DECONSTRUCTION_PATTERNS ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+        DECONSTRUCTION_PATTERNS(JDK16, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -3954,10 +3954,1 @@\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);\n@@ -3977,3 +3968,7 @@\n-        ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-        tree.type = attribTree(tree.vartype, env, varInfo);\n-        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);\n+        if (tree.vartype != null) {\n+            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n+            tree.type = attribTree(tree.vartype, env, varInfo);\n+        } else {\n+            tree.type = resultInfo.pt;\n+        }\n+        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);\n@@ -3983,2 +3978,4 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n-        annotate.flush();\n+        if (tree.vartype != null) {\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n+            annotate.flush();\n+        }\n@@ -3989,0 +3986,55 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.type = attribType(tree.deconstructor, env);\n+        Type site = types.removeWildcards(tree.type);\n+        List<Type> expectedRecordTypes;\n+        if (site.tsym.kind == Kind.TYP && ((ClassSymbol) site.tsym).isRecord()) {\n+            ClassSymbol record = (ClassSymbol) site.tsym;\n+            expectedRecordTypes = record.getRecordComponents().stream().map(rc -> types.memberType(site, rc)).collect(List.collector());\n+            tree.record = record;\n+        } else {\n+            log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));\n+            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+                                .limit(tree.nested.size())\n+                                .collect(List.collector());\n+        }\n+        ListBuffer<BindingSymbol> outBindings = new ListBuffer<>();\n+        List<Type> recordTypes = expectedRecordTypes;\n+        List<JCPattern> nestedPatterns = tree.nested;\n+        while (recordTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n+            boolean nestedIsVarPattern = nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n+                                         ((JCBindingPattern) nestedPatterns.head).vartype == null;\n+            attribExpr(nestedPatterns.head, env, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+            verifyCastable(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);\n+            outBindings.addAll(matchBindings.bindingsWhenTrue);\n+            nestedPatterns = nestedPatterns.tail;\n+            recordTypes = recordTypes.tail;\n+        }\n+        if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {\n+            while (nestedPatterns.nonEmpty()) {\n+                attribExpr(nestedPatterns.head, env, Type.noType);\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            List<Type> nestedTypes =\n+                    tree.nested.stream().map(p -> p.type).collect(List.collector());\n+            log.error(tree.pos(),\n+                      Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,\n+                                                             nestedTypes));\n+        }\n+        result = tree.type;\n+        matchBindings = new MatchBindings(outBindings.toList(), List.nil());\n+    }\n+\n+    private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {\n+        Warner warner = new Warner();\n+        if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                      Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":68,"deletions":16,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-        if (types.isCastable(found, req, castWarner(pos, found, req))) {\n+        if (checkCastable(pos, found, req, checkContext, castWarner(pos, found, req))) {\n@@ -636,1 +636,0 @@\n-            checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));\n@@ -641,0 +640,10 @@\n+    boolean checkCastable(DiagnosticPosition pos, Type found, Type req,\n+                          CheckContext checkContext, Warner warner) {\n+        if (types.isCastable(found, req, warner)) {\n+            return true;\n+        } else {\n+            checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2530,41 +2530,0 @@\n-    private String argsTypeSig(List<Type> typeList) {\n-        LowerSignatureGenerator sg = new LowerSignatureGenerator();\n-        sg.assembleSig(typeList);\n-        return sg.toString();\n-    }\n-\n-    \/**\n-     * Signature Generation\n-     *\/\n-    private class LowerSignatureGenerator extends Types.SignatureGenerator {\n-\n-        \/**\n-         * An output buffer for type signatures.\n-         *\/\n-        StringBuilder sb = new StringBuilder();\n-\n-        LowerSignatureGenerator() {\n-            super(types);\n-        }\n-\n-        @Override\n-        protected void append(char ch) {\n-            sb.append(ch);\n-        }\n-\n-        @Override\n-        protected void append(byte[] ba) {\n-            sb.append(new String(ba));\n-        }\n-\n-        @Override\n-        protected void append(Name name) {\n-            sb.append(name.toString());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return sb.toString();\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            case PARENS: case TYPETEST:\n+            case PARENS: case TYPETEST: case DECONSTRUCTIONPATTERN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -31,0 +32,1 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n@@ -33,1 +35,0 @@\n-import com.sun.tools.javac.code.Type;\n@@ -35,1 +36,0 @@\n-import com.sun.tools.javac.tree.JCTree;\n@@ -61,0 +61,1 @@\n+import java.util.LinkedHashMap;\n@@ -63,0 +64,2 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n+import com.sun.tools.javac.code.Type;\n@@ -67,0 +70,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -68,0 +73,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPattern;\n@@ -72,1 +78,0 @@\n-import java.util.HashMap;\n@@ -134,1 +139,2 @@\n-    private MethodSymbol currentMethodSym = null;\n+    private ClassSymbol currentClass;\n+    private Symbol currentOwnerSym = null;\n@@ -151,1 +157,1 @@\n-        if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {\n+        if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n@@ -153,0 +159,1 @@\n+            \/\/E instanceof T(PATT1, PATT2, ...)\n@@ -154,3 +161,1 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof T && (N = (T) N$temp == (T) N$temp))\n-            JCBindingPattern patt = (JCBindingPattern)tree.pattern;\n-            VarSymbol pattSym = patt.symbol;\n+            \/\/(let T' N$temp = E; N$temp instanceof T && <pattern extractor>)\n@@ -160,2 +165,2 @@\n-            VarSymbol temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,\n-                    names.fromString(pattSym.name.toString() + target.syntheticNameChar() + \"temp\"),\n+            VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"e\" + target.syntheticNameChar()),\n@@ -163,1 +168,1 @@\n-                    patt.symbol.owner);\n+                    currentOwnerSym);\n@@ -165,1 +170,14 @@\n-            Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));\n+            Type castTargetType;\n+            \/\/TODO: use rule switch (when boot JDK is 14):\n+            switch (tree.pattern.getTag()) {\n+                case BINDINGPATTERN:\n+                    castTargetType = ((JCBindingPattern)tree.pattern).symbol.type;\n+                    break;\n+                case DECONSTRUCTIONPATTERN:\n+                    castTargetType = ((JCDeconstructionPattern)tree.pattern).type;\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected pattern type: \" + tree.pattern.getTag());\n+            }\n+\n+            castTargetType = types.boxedTypeOrType(types.erasure(castTargetType));\n@@ -167,1 +185,10 @@\n-            result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));\n+            result = makeTypeTest(make.at(tree.pos).Ident(temp), make.Type(castTargetType));\n+            result = makeBinary(Tag.AND, (JCExpression)result,\n+                                         preparePatternExtractor(tree, tree.getPattern(), temp, castTargetType));\n+            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr),\n+                                               (JCExpression)result).setType(syms.booleanType);\n+            ((LetExpr) result).needsCond = true;\n+        } else {\n+            super.visitTypeTest(tree);\n+        }\n+    }\n@@ -169,1 +196,9 @@\n-            VarSymbol bindingVar = bindingContext.bindingDeclared(patt.symbol);\n+    private JCExpression preparePatternExtractor(JCInstanceOf tree, JCPattern patt, VarSymbol temp, Type targetType) {\n+        if (targetType == syms.botType) {\n+            targetType = syms.objectType;\n+        }\n+        if (patt.hasTag(Tag.BINDINGPATTERN)) {\n+            \/\/type test already done, finish handling of type test patterns (\"T N\")\n+            \/\/=>\n+            \/\/(let N = (T) N$temp; true)\n+            VarSymbol bindingVar = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);\n@@ -172,1 +207,1 @@\n-                        make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));\n+                        make.Ident(bindingVar), convert(make.Ident(temp), targetType)).setType(bindingVar.erasure(types));\n@@ -177,1 +212,1 @@\n-                result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);\n+                return nestedLE;\n@@ -179,2 +214,57 @@\n-            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);\n-            ((LetExpr) result).needsCond = true;\n+            return make.Literal(true);\n+        } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n+            \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+            \/\/=>\n+            \/\/<PATT1-handling> && <PATT2-handling> && ...\n+            JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;\n+            List<? extends RecordComponent> components = dpatt.record.getRecordComponents();\n+            List<? extends JCPattern> nestedPatterns = dpatt.nested;\n+            JCExpression test = null;\n+            while (components.nonEmpty() && nestedPatterns.nonEmpty()) {\n+                \/\/PATTn for record component COMPn of type Tn;\n+                \/\/PATTn is a type test pattern or a deconstruction pattern:\n+                \/\/=>\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n+                RecordComponent component = components.head;\n+                JCPattern nested = nestedPatterns.head;\n+                VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n+                                     component.erasure(types),\n+                                     currentOwnerSym);\n+                Symbol accessor = dpatt.record\n+                                       .members()\n+                                       .findFirst(component.name, s -> s.kind == Kind.MTH &&\n+                                                                       ((MethodSymbol) s).params.isEmpty());\n+                JCVariableDecl nestedTempVar =\n+                        make.VarDef(nestedTemp,\n+                                    make.App(make.Select(convert(make.Ident(temp), dpatt.type),\n+                                                         accessor)));\n+                JCExpression extracted =\n+                        preparePatternExtractor(tree, nested, nestedTemp, nested.type);\n+                JCExpression extraTest = null;\n+                if (!types.isAssignable(nestedTemp.type, nested.type)) {\n+                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n+                                             make.Type(nested.type));\n+                } else if (nested.type.isReference()) {\n+                    extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+                }\n+                if (extraTest != null) {\n+                    extracted = makeBinary(Tag.AND, extraTest, extracted);\n+                }\n+                LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n+                getAndRun.needsCond = true;\n+                getAndRun.setType(syms.booleanType);\n+                if (test == null) {\n+                    test = getAndRun;\n+                } else {\n+                    test = makeBinary(Tag.AND, test, getAndRun);\n+                }\n+                components = components.tail;\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            Assert.check(components.isEmpty() == nestedPatterns.isEmpty());\n+            return test != null ? test : make.Literal(true);\n@@ -182,1 +272,1 @@\n-            super.visitTypeTest(tree);\n+            throw new IllegalStateException();\n@@ -254,1 +344,1 @@\n-        MethodSymbol prevMethodSym = currentMethodSym;\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -256,1 +346,1 @@\n-            currentMethodSym = tree.sym;\n+            currentOwnerSym = tree.sym;\n@@ -259,1 +349,25 @@\n-            currentMethodSym = prevMethodSym;\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        Symbol prevOwnerSym = currentOwnerSym;\n+        try {\n+            if (tree.sym.owner.kind == Kind.TYP) {\n+                currentOwnerSym = tree.sym;\n+            }\n+            super.visitVarDef(tree);\n+        } finally {\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n@@ -300,0 +414,1 @@\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -301,0 +416,5 @@\n+            if (currentOwnerSym == null) {\n+                currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                 names.empty, null,\n+                                 currentClass);\n+            }\n@@ -309,0 +429,1 @@\n+            currentOwnerSym = prevOwnerSym;\n@@ -358,0 +479,16 @@\n+    \/** Make an attributed tree representing a literal. This will be an\n+     *  Ident node in the case of boolean literals, a Literal node in all\n+     *  other cases.\n+     *  @param type       The literal's type.\n+     *  @param value      The literal's value.\n+     *\/\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n+\n+    \/** Make an attributed tree representing null.\n+     *\/\n+    JCExpression makeNull() {\n+        return makeLit(syms.botType, null);\n+    }\n+\n@@ -379,1 +516,1 @@\n-            this.hoistedVarMap = new HashMap<>();\n+            this.hoistedVarMap = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":160,"deletions":23,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -588,0 +588,7 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.deconstructor = translate(tree.deconstructor, null);\n+        tree.nested = translate(tree.nested, null);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -269,0 +270,8 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCTree.JCDeconstructionPattern tree) {\n+        JCDeconstructionPattern that = (JCDeconstructionPattern) parameter;\n+        result =\n+                scan(tree.deconstructor, that.deconstructor)\n+                        && scan(tree.nested, that.nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+     *     mode |= NOINVOCATION : method invocations are not allowed\n@@ -249,0 +250,1 @@\n+    protected static final int NOINVOCATION = 0x40;\n@@ -251,1 +253,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        mode = (mode & (NOLAMBDA | NOINVOCATION)) | EXPR;\n@@ -255,1 +257,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        mode = (mode & (NOLAMBDA|NOINVOCATION)) | TYPE;\n@@ -771,0 +773,25 @@\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern() {\n+        int pos = token.pos;\n+        if (token.kind == IDENTIFIER && token.name() == names.var) {\n+            nextToken();\n+            return toP(F.at(pos).BindingPattern(ident(), null));\n+        } else {\n+            JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);\n+            if (token.kind == LPAREN) {\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                do {\n+                    nextToken();\n+                    JCPattern nestedPattern = parsePattern();\n+                    nested.append(nestedPattern);\n+                } while (token.kind == COMMA);\n+                accept(RPAREN);\n+                return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));\n+            } else {\n+                return toP(F.at(pos).BindingPattern(ident(), e));\n+            }\n+        }\n+    }\n+\n@@ -953,0 +980,10 @@\n+                } else if (token.kind == LPAREN) {\n+                    checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n+                    ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern();\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                    accept(RPAREN);\n+                    pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));\n@@ -1282,1 +1319,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if ((mode & EXPR) != 0 && (mode & NOINVOCATION) == 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2947,0 +2947,3 @@\n+compiler.misc.feature.deconstruction.patterns=\\\n+    deconstruction patterns\n+\n@@ -3755,0 +3758,10 @@\n+\n+# 0: symbol\n+compiler.err.deconstruction.pattern.only.records=\\\n+    deconstruction patterns can only be applied to records, {0} is not a record\n+\n+# 0: list of type, 1: list of type\n+compiler.err.incorrect.number.of.nested.patterns=\\\n+    incorrect number of nested patterns\\n\\\n+    required: {0}\\n\\\n+    found: {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -244,0 +244,2 @@\n+        DECONSTRUCTIONPATTERN,\n+\n@@ -2240,0 +2242,49 @@\n+    public static class JCDeconstructionPattern extends JCPattern\n+            implements DeconstructionPatternTree {\n+        public JCExpression deconstructor;\n+        public List<JCPattern> nested;\n+        public ClassSymbol record;\n+        public List<Type> innerTypes;\n+\n+        protected JCDeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+            this.deconstructor = deconstructor;\n+            this.nested = nested;\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Name getBinding() {\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Tree getDeconstructor() {\n+            return deconstructor;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends JCPattern> getNestedPatterns() {\n+            return nested;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitDeconstructionPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DECONSTRUCTION_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDeconstructionPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return DECONSTRUCTIONPATTERN;\n+        }\n+    }\n+\n@@ -3280,0 +3331,1 @@\n+        public void visitDeconstructionPattern(JCDeconstructionPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -903,0 +903,12 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        try {\n+            printExpr(tree.deconstructor);\n+            print(\"(\");\n+            printExprs(tree.nested);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -500,0 +500,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        JCDeconstructionPattern t = (JCDeconstructionPattern) node;\n+        JCExpression deconstructor = copy(t.deconstructor, p);\n+        List<JCPattern> nested = copy(t.nested, p);\n+        return M.at(t.pos).DeconstructionPattern(deconstructor, nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -485,0 +485,6 @@\n+    public JCDeconstructionPattern DeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+        JCDeconstructionPattern tree = new JCDeconstructionPattern(deconstructor, nested);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -311,0 +311,6 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern that) {\n+        scan(that.deconstructor);\n+        scan(that.nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -460,0 +460,7 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.deconstructor = translate(tree.deconstructor);\n+        tree.nested = translate(tree.nested);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-        new Patterns().run();\n+        new Patterns().runBinding();\n+        new Patterns().runDeconstruction();\n@@ -52,1 +53,1 @@\n-    public void run() throws Exception {\n+    public void runBinding() throws Exception {\n@@ -165,0 +166,106 @@\n+    public void runDeconstruction() throws Exception {\n+        String out = new JavapTask(tb)\n+                .options(\"-private\",\n+                         \"-verbose\")\n+                .classpath(System.getProperty(\"test.classes\"))\n+                .classes(\"Patterns$DeconstructionPattern\")\n+                .run()\n+                .getOutputLines(Task.OutputKind.DIRECT)\n+                .stream()\n+                .collect(Collectors.joining(\"\\n\"));\n+\n+        String constantPool = out.substring(0, out.indexOf('{'));\n+\n+        out = out.replaceAll(\"(?ms) *Code:.*?\\n( *RuntimeInvisibleTypeAnnotations:)\", \"$1\");\n+        out = out.substring(out.indexOf('{'));\n+        out = out.substring(0, out.lastIndexOf('}') + 1);\n+\n+        String A = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$A;\");\n+        String CA = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$CA;\");\n+        String value = snipCPNumber(constantPool, \"value\");\n+\n+        String expected = \"\"\"\n+                          {\n+                            private static final java.lang.Object o;\n+                              descriptor: Ljava\/lang\/Object;\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1s;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1m;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private final boolean B2s;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            private final boolean B2m;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            public Patterns$DeconstructionPattern();\n+                              descriptor: ()V\n+                              flags: (0x0001) ACC_PUBLIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=284, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=328, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=114, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=158, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=199, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=243, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            void testPatterns();\n+                              descriptor: ()V\n+                              flags: (0x0000)\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=72, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            static {};\n+                              descriptor: ()V\n+                              flags: (0x0008) ACC_STATIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=70, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=110, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=151, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                          }\"\"\".replace(\"_A_\", A).replace(\"_CA_\", CA).replace(\"_value_\", value);\n+\n+        if (!expected.equals(out)) {\n+            throw new AssertionError(\"Unexpected output:\\n\" + out + \"\\nexpected:\\n\" + expected);\n+        }\n+    }\n+\n@@ -222,0 +329,43 @@\n+\n+    static class DeconstructionPattern {\n+        @Target(ElementType.TYPE_USE)\n+        @Repeatable(CA.class)\n+        @interface A {}\n+        @Target(ElementType.TYPE_USE)\n+        @interface CA {\n+            public A[] value();\n+        }\n+\n+        private static final Object o = \"\";\n+        private static final boolean B1s = o instanceof R(@A String s) && s.isEmpty();\n+        private static final boolean B1m = o instanceof R(@A @A String s) && s.isEmpty();\n+        private final boolean B2s = o instanceof R(@A String s) && s.isEmpty();\n+        private final boolean B2m = o instanceof R(@A @A String s) && s.isEmpty();\n+\n+        static {\n+            boolean B3s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B3m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B4s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B4m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B5s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B5m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        public DeconstructionPattern() {\n+            boolean B6s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B6m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        void testPatterns() {\n+            boolean B7s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B7m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        record R(String s) {}\n+    }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":152,"deletions":2,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.deconstruction.pattern.only.records\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DeconstructionpatternOnlyRecords {\n+    public boolean deconstruction(Object o) {\n+        return o instanceof String(var content);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DeconstructionPatternOnlyRecords.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.incorrect.number.of.nested.patterns\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ key: compiler.misc.feature.records\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class IncorrectNumberOfNestedPatterns {\n+    private boolean t(Object o) {\n+        return o instanceof R(var i);\n+    }\n+    record R(int i, int j) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectNumberOfNestedPatterns.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -169,0 +169,6 @@\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1 );\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1 );\n@@ -177,0 +183,2 @@\n+\n+    record R(Integer i1, int i2) {}\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/Deduplication.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,0 +137,3 @@\n+            if (cf.getName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n+                continue;\n+            }\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify error reports for erroneous deconstruction patterns are sensible\n+ * @compile\/fail\/ref=DeconstructionPatternErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW DeconstructionPatternErrors.java\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class DeconstructionPatternErrors {\n+\n+    public static void main(String... args) throws Throwable {\n+        Object p;\n+        p = new P(42);\n+        if (p instanceof P(_));\n+        if (p instanceof P3(ArrayList<Integer> l));\n+        if (p instanceof P4(ArrayList<Integer> l));\n+        if (p instanceof P5(int i));\n+        if (p instanceof P(String s));\n+        if (p instanceof P5(P(var v)));\n+        if (p instanceof P2(var v1)); \/\/too few nested patterns\n+        if (p instanceof P2(Runnable v1)); \/\/too few nested patterns\n+        if (p instanceof P(var v1, var v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, int v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, Unresolvable v2)); \/\/too many nested patterns\n+        if (p instanceof GenRecord<String>(var v)); \/\/incorrect generic type\n+        if (p instanceof P4(GenRecord<String>(var v))); \/\/incorrect generic type\n+        if (p instanceof GenRecord<String>(Integer v)); \/\/inconsistency in types\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(Runnable r1, Runnable r2) {}\n+    public record P3(List<String> l) {}\n+    public record P4(Object o) {}\n+    public record P5(String s) {}\n+    public record GenRecord<T>(T s) {}\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n+DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n+DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:21:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+- compiler.note.preview.filename: DeconstructionPatternErrors.java\n+- compiler.note.preview.recompile\n+17 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test behavior of Pretty\n+ * @modules jdk.compiler\n+ * @compile --enable-preview -source ${jdk.version} PrettyTest.java\n+ * @run main\/othervm --enable-preview PrettyTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.tools.*;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+\n+public class PrettyTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        new PrettyTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        String code = \"class Test {\\n\" +\n+                      \"    boolean t(Object o) {\\n\" +\n+                      \"         boolean b;\\n\" +\n+                      \"         b = o instanceof String s;\\n\" +\n+                      \"         b = o instanceof R(String s);\\n\" +\n+                      \"         b = o instanceof R(var s);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), String t);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), var t);\\n\" +\n+                      \"    }\\n\" +\n+                      \"    record R(String s) {}\\n\" +\n+                      \"    record R2(R r, String s) {}\\n\" +\n+                      \"}\\n\";\n+        String pretty = parse(code).toString();\n+        String expected = \"\"\"\n+                          \\n\\\n+                          class Test {\n+                              \\n\\\n+                              boolean t(Object o) {\n+                                  boolean b;\n+                                  b = o instanceof String s;\n+                                  b = o instanceof R(String s);\n+                                  b = o instanceof R(\/*missing*\/ s);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                              }\n+                              \\n\\\n+                              class R {\n+                                  private final String s;\n+                              }\n+                              \\n\\\n+                              class R2 {\n+                                  private final R r;\n+                                  private final String s;\n+                              }\n+                          }\"\"\";\n+        if (!expected.equals(pretty)) {\n+            throw new AssertionError(\"Actual prettified source: \" + pretty);\n+        }\n+    }\n+\n+    private CompilationUnitTree parse(String code) throws IOException {\n+        final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n+        assert tool != null;\n+        DiagnosticListener<JavaFileObject> noErrors = d -> {};\n+\n+        StringWriter out = new StringWriter();\n+        JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,\n+            List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+            Arrays.asList(new MyFileObject(code)));\n+        return ct.parse().iterator().next();\n+    }\n+\n+    static class MyFileObject extends SimpleJavaFileObject {\n+        private String text;\n+\n+        public MyFileObject(String text) {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this.text = text;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return text;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/**\n+ * @test\n+ * @compile\/fail\/ref=SimpleDeconstructionPatternNoPreview.out -XDrawDiagnostics SimpleDeconstructionPattern.java\n+ * @compile --enable-preview -source ${jdk.version} SimpleDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview SimpleDeconstructionPattern\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class SimpleDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+\/\/        if (!test1(new P(42))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test1(new P(41))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test2(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test2a(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2a(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+\/\/        if (!test3(new P2(new P(42), \"\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test3(new P2(new P(41), \"\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test3(new P2(new P(42), \"a\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test4(new P2(new P(42), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(41), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(42), \"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test5(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test5(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+\/\/        if (!test6(new P(42))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (!test6(new P(41))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (!((new BaseUse(new BaseSubclass(0))) instanceof BaseUse(BaseSubclass(0)))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test7(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test7a(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7a(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8a(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8a(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test9(new P5(new ArrayList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test9(new P5(new LinkedList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testA(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testA(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testB(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testB(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testC(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testC(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testC(new P6(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen1(new GenRecord1<>(1L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen1(new GenRecord1<>(1L, \"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen2(new GenRecord1<>(3L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen2(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen3(new GenRecord1<>(3L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+\/\/    private static boolean test1(Object o) throws Throwable {\n+\/\/        return o instanceof P(42);\n+\/\/    }\n+\/\/\n+    private static void exp(Object o) throws Throwable {\n+        if (o instanceof P(var i)) {\n+            System.err.println(\"i=\" + i);\n+        }\n+    }\n+\n+    private static boolean test2(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+    private static boolean test2a(Object o) throws Throwable {\n+        return o instanceof P(int i) && i == 42;\n+    }\n+\n+\/\/    private static boolean test3(Object o) throws Throwable {\n+\/\/        return o instanceof P2(P(42), \"\");\n+\/\/    }\n+\/\/\n+    private static boolean test4(Object o) throws Throwable {\n+        return o instanceof P2(P(var i), var s) && i == 42 && \"\".equals(s);\n+    }\n+\n+    private static boolean test5(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+\/\/    private static boolean test6(Object o) throws Throwable {\n+\/\/        return o instanceof P(_);\n+\/\/    }\n+\n+    private static boolean test7(Object o) throws Throwable {\n+        return o instanceof P3(var s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test7a(Object o) throws Throwable {\n+        return o instanceof P3(String s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8(Object o) throws Throwable {\n+        return o instanceof P4(P3(var s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8a(Object o) throws Throwable {\n+        return o instanceof P4(P3(String s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test9(Object o) throws Throwable {\n+        return o instanceof P5(ArrayList<String> l) && !l.isEmpty();\n+    }\n+\n+    private static boolean testA(Object o) throws Throwable {\n+        return o instanceof P6(P3(var s));\n+    }\n+\n+    private static boolean testB(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s));\n+    }\n+\n+    private static boolean testC(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s)) && s.isEmpty();\n+    }\n+\n+    private static boolean testGen1(Object o) throws Throwable {\n+        return o instanceof GenRecord1(var i, var s) && s.length() == 0;\n+    }\n+\n+    private static boolean testGen2(Object o) throws Throwable {\n+        return o instanceof GenRecord1(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    private static boolean testGen3(Object o) throws Throwable {\n+        return o instanceof GenRecord1<?, ?>(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    private static boolean testGen4(GenBase<Integer, String> o) throws Throwable {\n+        return o instanceof GenRecord1<Integer, String>(var i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(P p, String s) {\n+    }\n+\n+    public record P3(String s) {\n+    }\n+\n+    public record P4(Object o) {}\n+\n+    public record P5(List<String> l) {}\n+    public record P6(P3 p) {}\n+\n+    public interface Base {}\n+    public record BaseUse(Base b) {}\n+    public record BaseSubclass(int i) implements Base {}\n+\n+    public interface GenBase<T1, T2 extends CharSequence> {}\n+    public record GenRecord1<T1, T2 extends CharSequence> (T1 i, T2 s) implements GenBase<T1, T2> {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+SimpleDeconstructionPattern.java:149:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+SimpleDeconstructionPattern.java:226:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:229:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:232:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:235:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:237:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:238:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:241:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:242:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:242:38: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:245:29: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:59: compiler.err.illegal.start.of.type\n+SimpleDeconstructionPattern.java:245:71: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:99: compiler.err.illegal.start.of.type\n+6 errors\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"}]}