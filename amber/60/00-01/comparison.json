{"files":[{"patch":"@@ -0,0 +1,23 @@\n+;\n+; Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+;\n+; This code is free software; you can redistribute it and\/or modify it\n+; under the terms of the GNU General Public License version 2 only, as\n+; published by the Free Software Foundation.\n+;\n+; This code is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; version 2 for more details (a copy is included in the LICENSE file that\n+; accompanied this code).\n+;\n+; You should have received a copy of the GNU General Public License version\n+; 2 along with this work; if not, write to the Free Software Foundation,\n+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+;\n+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+; or visit www.oracle.com if you need additional information or have any\n+; questions.\n+;\n+\n@@ -2,2 +25,3 @@\n-project=jdk\n-jbs=JDK\n+project=amber\n+repository=amber\n+jbs=jdk\n@@ -32,0 +56,1 @@\n+\n","filename":".jcheck\/conf","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -4427,1 +4427,1 @@\n-     * * {@preview Associated with sealed classes, a preview feature of the Java language.\n+     * {@preview Associated with sealed classes, a preview feature of the Java language.\n@@ -4434,2 +4434,3 @@\n-     * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.\n-     * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns\n+     * Returns {@code true} if and only if this {@code Class} object represents\n+     * a sealed class or interface. If this {@code Class} object represents a\n+     * primitive type, {@code void}, or an array type, this method returns\n@@ -4438,0 +4439,4 @@\n+     * @apiNote\n+     * This method reports on a distinct concept of sealing from\n+     * {@link Package#isSealed() Package::isSealed}.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -226,0 +226,4 @@\n+     * @apiNote\n+     * This method reports on a distinct concept of sealing from\n+     * {@link Class#isSealed() Class::isSealed}.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Package.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@preview Associated with pattern matching for instanceof, a preview feature of\n+ *           the Java language.\n+ *\n+ *           This interface is associated with <i>pattern matching for instanceof<\/i>, a preview\n+ *           feature of the Java language. Preview features\n+ *           may be removed in a future release, or upgraded to permanent\n+ *           features of the Java language.}\n+ *\n+ * A deconstruction pattern tree\n+ *\n+ * @since 15\n+ *\/\n+public interface DeconstructionPatternTree extends PatternTree {\n+\n+    \/**\n+     * Returns the deconstructed type.\n+     * @return the deconstructed type\n+     *\/\n+    Tree getDeconstructor();\n+\n+    \/**\n+     * Returns the nested patterns.\n+     * @return the nested patterns.\n+     *\/\n+    List<? extends PatternTree> getNestedPatterns();\n+\n+}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -237,0 +237,15 @@\n+        \/**\n+         * {@preview Associated with pattern matching for instanceof, a preview feature of\n+         *           the Java language.\n+         *\n+         *           This enum constant is associated with <i>pattern matching for instanceof<\/i>, a preview\n+         *           feature of the Java language. Preview features\n+         *           may be removed in a future release, or upgraded to permanent\n+         *           features of the Java language.}\n+         *\n+         * Used for instances of {@link DeconstructionPatternTree}.\n+         *\n+         * @since 15\n+         *\/\n+        DECONSTRUCTION_PATTERN(DeconstructionPatternTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -277,0 +277,17 @@\n+    \/**\n+     * {@preview Associated with pattern matching for instanceof, a preview feature of\n+     *           the Java language.\n+     *\n+     *           This method is associated with <i>pattern matching for instanceof<\/i>, a preview\n+     *           feature of the Java language. Preview features\n+     *           may be removed in a future release, or upgraded to permanent\n+     *           features of the Java language.}\n+     *\n+     * Visits an DeconstructionPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 15\n+     *\/\n+    R visitDeconstructionPattern(DeconstructionPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -572,0 +572,13 @@\n+     * @return  the result of {@code defaultAction}\n+     * @since 15\n+     *\/\n+    @Override\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -701,0 +701,14 @@\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 15\n+     *\/\n+    @Override\n+    public R visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        R r = scan(node.getDeconstructor(), p);\n+        return scanAndReduce(node.getNestedPatterns(), p, r);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+            feature == Feature.DECONSTRUCTION_PATTERNS ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,0 +221,3 @@\n+        LAMBDA_PARAMETER_SHADOWING(JDK16),\n+        UNDERSCORE_AS_PARAM_NAME(JDK16),\n+        DECONSTRUCTION_PATTERNS(JDK16, Fragments.FeatureDeconstructionPatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -158,0 +158,8 @@\n+    \/** A common method type for all those method symbols owning a lambda scope.\n+     *\/\n+    public final MethodType lambdaScopeMethodType;\n+\n+    \/** A common method type for all those method symbols owning a block scope.\n+     *\/\n+    public final MethodType blockScopeMethodType;\n+\n@@ -482,0 +490,3 @@\n+        lambdaScopeMethodType = new MethodType(List.nil(), voidType, List.nil(), methodClass);\n+        blockScopeMethodType = new MethodType(List.nil(), voidType, List.nil(), methodClass);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -171,0 +171,1 @@\n+        allowShadowingOfLambdaParameters = Feature.LAMBDA_PARAMETER_SHADOWING.allowedInSource(source);\n@@ -216,0 +217,5 @@\n+    \/**\n+     * Switch: allow shadowing of lambda parameters?\n+     *\/\n+    boolean allowShadowingOfLambdaParameters;\n+\n@@ -1316,0 +1322,6 @@\n+            if (tree.name == names.underscore) {\n+                WriteableScope enclScope = enter.enterScope(env);\n+                if (enclScope != null) {\n+                    enclScope.remove(tree.sym);\n+                }\n+            }\n@@ -1412,1 +1424,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, syms.blockScopeMethodType,\n@@ -3333,0 +3345,2 @@\n+            ClassSymbol enclClass = owner.enclClass();\n+            Symbol newScopeOwner = null;\n@@ -3335,2 +3349,1 @@\n-                ClassSymbol enclClass = owner.enclClass();\n-                Symbol newScopeOwner = env.info.scope.owner;\n+                newScopeOwner = env.info.scope.owner;\n@@ -3361,0 +3374,10 @@\n+            } else {\n+                if (allowShadowingOfLambdaParameters) {\n+                    newScopeOwner = new MethodSymbol(\n+                        HYPOTHETICAL,\n+                        names.empty,\n+                        syms.lambdaScopeMethodType,\n+                        owner);\n+                }\n+            }\n+            if (newScopeOwner != null) {\n@@ -3931,10 +3954,1 @@\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);\n@@ -3954,3 +3968,7 @@\n-        ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-        tree.type = attribTree(tree.vartype, env, varInfo);\n-        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);\n+        if (tree.vartype != null) {\n+            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n+            tree.type = attribTree(tree.vartype, env, varInfo);\n+        } else {\n+            tree.type = resultInfo.pt;\n+        }\n+        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);\n@@ -3960,2 +3978,4 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n-        annotate.flush();\n+        if (tree.vartype != null) {\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n+            annotate.flush();\n+        }\n@@ -3966,0 +3986,55 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.type = attribType(tree.deconstructor, env);\n+        Type site = types.removeWildcards(tree.type);\n+        List<Type> expectedRecordTypes;\n+        if (site.tsym.kind == Kind.TYP && ((ClassSymbol) site.tsym).isRecord()) {\n+            ClassSymbol record = (ClassSymbol) site.tsym;\n+            expectedRecordTypes = record.getRecordComponents().stream().map(rc -> types.memberType(site, rc)).collect(List.collector());\n+            tree.record = record;\n+        } else {\n+            log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));\n+            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+                                .limit(tree.nested.size())\n+                                .collect(List.collector());\n+        }\n+        ListBuffer<BindingSymbol> outBindings = new ListBuffer<>();\n+        List<Type> recordTypes = expectedRecordTypes;\n+        List<JCPattern> nestedPatterns = tree.nested;\n+        while (recordTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n+            boolean nestedIsVarPattern = nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n+                                         ((JCBindingPattern) nestedPatterns.head).vartype == null;\n+            attribExpr(nestedPatterns.head, env, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+            verifyCastable(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);\n+            outBindings.addAll(matchBindings.bindingsWhenTrue);\n+            nestedPatterns = nestedPatterns.tail;\n+            recordTypes = recordTypes.tail;\n+        }\n+        if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {\n+            while (nestedPatterns.nonEmpty()) {\n+                attribExpr(nestedPatterns.head, env, Type.noType);\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            List<Type> nestedTypes =\n+                    tree.nested.stream().map(p -> p.type).collect(List.collector());\n+            log.error(tree.pos(),\n+                      Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,\n+                                                             nestedTypes));\n+        }\n+        result = tree.type;\n+        matchBindings = new MatchBindings(outBindings.toList(), List.nil());\n+    }\n+\n+    private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {\n+        Warner warner = new Warner();\n+        if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                      Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":94,"deletions":19,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-        if (types.isCastable(found, req, castWarner(pos, found, req))) {\n+        if (checkCastable(pos, found, req, checkContext, castWarner(pos, found, req))) {\n@@ -636,1 +636,0 @@\n-            checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));\n@@ -641,0 +640,10 @@\n+    boolean checkCastable(DiagnosticPosition pos, Type found, Type req,\n+                          CheckContext checkContext, Warner warner) {\n+        if (types.isCastable(found, req, warner)) {\n+            return true;\n+        } else {\n+            checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));\n+            return false;\n+        }\n+    }\n+\n@@ -1310,1 +1319,4 @@\n-                           FINAL | NON_SEALED)) {\n+                           FINAL | NON_SEALED)\n+                 && checkDisjoint(pos, flags,\n+                                SEALED,\n+                                ANNOTATION)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -483,0 +483,1 @@\n+            owner1 = skipLambdaOwner(owner1);\n@@ -486,0 +487,1 @@\n+                owner1 = skipLambdaOwner(owner1);\n@@ -520,0 +522,7 @@\n+        private Symbol skipLambdaOwner(Symbol currentOwner) {\n+            while (currentOwner.type == syms.lambdaScopeMethodType) {\n+                currentOwner = currentOwner.owner;\n+            }\n+            return currentOwner;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2530,41 +2530,0 @@\n-    private String argsTypeSig(List<Type> typeList) {\n-        LowerSignatureGenerator sg = new LowerSignatureGenerator();\n-        sg.assembleSig(typeList);\n-        return sg.toString();\n-    }\n-\n-    \/**\n-     * Signature Generation\n-     *\/\n-    private class LowerSignatureGenerator extends Types.SignatureGenerator {\n-\n-        \/**\n-         * An output buffer for type signatures.\n-         *\/\n-        StringBuilder sb = new StringBuilder();\n-\n-        LowerSignatureGenerator() {\n-            super(types);\n-        }\n-\n-        @Override\n-        protected void append(char ch) {\n-            sb.append(ch);\n-        }\n-\n-        @Override\n-        protected void append(byte[] ba) {\n-            sb.append(new String(ba));\n-        }\n-\n-        @Override\n-        protected void append(Name name) {\n-            sb.append(name.toString());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return sb.toString();\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            case PARENS: case TYPETEST:\n+            case PARENS: case TYPETEST: case DECONSTRUCTIONPATTERN:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -31,0 +32,1 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n@@ -33,1 +35,0 @@\n-import com.sun.tools.javac.code.Type;\n@@ -35,1 +36,0 @@\n-import com.sun.tools.javac.tree.JCTree;\n@@ -61,0 +61,1 @@\n+import java.util.LinkedHashMap;\n@@ -63,0 +64,2 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n+import com.sun.tools.javac.code.Type;\n@@ -67,0 +70,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -68,0 +73,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPattern;\n@@ -72,1 +78,0 @@\n-import java.util.HashMap;\n@@ -134,1 +139,2 @@\n-    private MethodSymbol currentMethodSym = null;\n+    private ClassSymbol currentClass;\n+    private Symbol currentOwnerSym = null;\n@@ -151,1 +157,1 @@\n-        if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {\n+        if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n@@ -153,0 +159,1 @@\n+            \/\/E instanceof T(PATT1, PATT2, ...)\n@@ -154,3 +161,1 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof T && (N = (T) N$temp == (T) N$temp))\n-            JCBindingPattern patt = (JCBindingPattern)tree.pattern;\n-            VarSymbol pattSym = patt.symbol;\n+            \/\/(let T' N$temp = E; N$temp instanceof T && <pattern extractor>)\n@@ -160,2 +165,2 @@\n-            VarSymbol temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,\n-                    names.fromString(pattSym.name.toString() + target.syntheticNameChar() + \"temp\"),\n+            VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"e\" + target.syntheticNameChar()),\n@@ -163,1 +168,1 @@\n-                    patt.symbol.owner);\n+                    currentOwnerSym);\n@@ -165,1 +170,14 @@\n-            Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));\n+            Type castTargetType;\n+            \/\/TODO: use rule switch (when boot JDK is 14):\n+            switch (tree.pattern.getTag()) {\n+                case BINDINGPATTERN:\n+                    castTargetType = ((JCBindingPattern)tree.pattern).symbol.type;\n+                    break;\n+                case DECONSTRUCTIONPATTERN:\n+                    castTargetType = ((JCDeconstructionPattern)tree.pattern).type;\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected pattern type: \" + tree.pattern.getTag());\n+            }\n+\n+            castTargetType = types.boxedTypeOrType(types.erasure(castTargetType));\n@@ -167,1 +185,10 @@\n-            result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));\n+            result = makeTypeTest(make.at(tree.pos).Ident(temp), make.Type(castTargetType));\n+            result = makeBinary(Tag.AND, (JCExpression)result,\n+                                         preparePatternExtractor(tree, tree.getPattern(), temp, castTargetType));\n+            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr),\n+                                               (JCExpression)result).setType(syms.booleanType);\n+            ((LetExpr) result).needsCond = true;\n+        } else {\n+            super.visitTypeTest(tree);\n+        }\n+    }\n@@ -169,1 +196,9 @@\n-            VarSymbol bindingVar = bindingContext.bindingDeclared(patt.symbol);\n+    private JCExpression preparePatternExtractor(JCInstanceOf tree, JCPattern patt, VarSymbol temp, Type targetType) {\n+        if (targetType == syms.botType) {\n+            targetType = syms.objectType;\n+        }\n+        if (patt.hasTag(Tag.BINDINGPATTERN)) {\n+            \/\/type test already done, finish handling of type test patterns (\"T N\")\n+            \/\/=>\n+            \/\/(let N = (T) N$temp; true)\n+            VarSymbol bindingVar = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);\n@@ -172,1 +207,1 @@\n-                        make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));\n+                        make.Ident(bindingVar), convert(make.Ident(temp), targetType)).setType(bindingVar.erasure(types));\n@@ -177,1 +212,1 @@\n-                result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);\n+                return nestedLE;\n@@ -179,2 +214,57 @@\n-            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);\n-            ((LetExpr) result).needsCond = true;\n+            return make.Literal(true);\n+        } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n+            \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+            \/\/=>\n+            \/\/<PATT1-handling> && <PATT2-handling> && ...\n+            JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;\n+            List<? extends RecordComponent> components = dpatt.record.getRecordComponents();\n+            List<? extends JCPattern> nestedPatterns = dpatt.nested;\n+            JCExpression test = null;\n+            while (components.nonEmpty() && nestedPatterns.nonEmpty()) {\n+                \/\/PATTn for record component COMPn of type Tn;\n+                \/\/PATTn is a type test pattern or a deconstruction pattern:\n+                \/\/=>\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n+                RecordComponent component = components.head;\n+                JCPattern nested = nestedPatterns.head;\n+                VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n+                                     component.erasure(types),\n+                                     currentOwnerSym);\n+                Symbol accessor = dpatt.record\n+                                       .members()\n+                                       .findFirst(component.name, s -> s.kind == Kind.MTH &&\n+                                                                       ((MethodSymbol) s).params.isEmpty());\n+                JCVariableDecl nestedTempVar =\n+                        make.VarDef(nestedTemp,\n+                                    make.App(make.Select(convert(make.Ident(temp), dpatt.type),\n+                                                         accessor)));\n+                JCExpression extracted =\n+                        preparePatternExtractor(tree, nested, nestedTemp, nested.type);\n+                JCExpression extraTest = null;\n+                if (!types.isAssignable(nestedTemp.type, nested.type)) {\n+                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n+                                             make.Type(nested.type));\n+                } else if (nested.type.isReference()) {\n+                    extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+                }\n+                if (extraTest != null) {\n+                    extracted = makeBinary(Tag.AND, extraTest, extracted);\n+                }\n+                LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n+                getAndRun.needsCond = true;\n+                getAndRun.setType(syms.booleanType);\n+                if (test == null) {\n+                    test = getAndRun;\n+                } else {\n+                    test = makeBinary(Tag.AND, test, getAndRun);\n+                }\n+                components = components.tail;\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            Assert.check(components.isEmpty() == nestedPatterns.isEmpty());\n+            return test != null ? test : make.Literal(true);\n@@ -182,1 +272,1 @@\n-            super.visitTypeTest(tree);\n+            throw new IllegalStateException();\n@@ -254,1 +344,1 @@\n-        MethodSymbol prevMethodSym = currentMethodSym;\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -256,1 +346,1 @@\n-            currentMethodSym = tree.sym;\n+            currentOwnerSym = tree.sym;\n@@ -259,1 +349,25 @@\n-            currentMethodSym = prevMethodSym;\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        Symbol prevOwnerSym = currentOwnerSym;\n+        try {\n+            if (tree.sym.owner.kind == Kind.TYP) {\n+                currentOwnerSym = tree.sym;\n+            }\n+            super.visitVarDef(tree);\n+        } finally {\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n@@ -300,0 +414,1 @@\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -301,0 +416,5 @@\n+            if (currentOwnerSym == null) {\n+                currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                 names.empty, null,\n+                                 currentClass);\n+            }\n@@ -309,0 +429,1 @@\n+            currentOwnerSym = prevOwnerSym;\n@@ -358,0 +479,16 @@\n+    \/** Make an attributed tree representing a literal. This will be an\n+     *  Ident node in the case of boolean literals, a Literal node in all\n+     *  other cases.\n+     *  @param type       The literal's type.\n+     *  @param value      The literal's value.\n+     *\/\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n+\n+    \/** Make an attributed tree representing null.\n+     *\/\n+    JCExpression makeNull() {\n+        return makeLit(syms.botType, null);\n+    }\n+\n@@ -379,1 +516,1 @@\n-            this.hoistedVarMap = new HashMap<>();\n+            this.hoistedVarMap = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":160,"deletions":23,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -588,0 +588,7 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.deconstructor = translate(tree.deconstructor, null);\n+        tree.nested = translate(tree.nested, null);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -269,0 +270,8 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCTree.JCDeconstructionPattern tree) {\n+        JCDeconstructionPattern that = (JCDeconstructionPattern) parameter;\n+        result =\n+                scan(tree.deconstructor, that.deconstructor)\n+                        && scan(tree.nested, that.nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -147,0 +147,3 @@\n+    \/** The symbol table. *\/\n+    private final Symtab syms;\n+\n@@ -185,0 +188,2 @@\n+        syms = Symtab.instance(context);\n+\n@@ -331,1 +336,1 @@\n-            (c.owner.type == null \/\/ local to init block\n+            (c.owner.type == syms.blockScopeMethodType \/\/ local to init block\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+     *     mode |= NOINVOCATION : method invocations are not allowed\n@@ -249,0 +250,1 @@\n+    protected static final int NOINVOCATION = 0x40;\n@@ -251,1 +253,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        mode = (mode & (NOLAMBDA | NOINVOCATION)) | EXPR;\n@@ -255,1 +257,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        mode = (mode & (NOLAMBDA|NOINVOCATION)) | TYPE;\n@@ -567,1 +569,1 @@\n-        return ident(false);\n+        return ident(false, false);\n@@ -571,0 +573,4 @@\n+        return ident(allowClass, false);\n+    }\n+\n+    protected Name ident(boolean allowClass, boolean underscoreAllowed) {\n@@ -596,0 +602,4 @@\n+            if (!underscoreAllowed) {\n+                if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {\n+                    log.error(token.pos, Errors.UnderscoreNotAllowed);\n+                } else {\n@@ -600,0 +610,2 @@\n+            }\n+                }\n@@ -618,1 +630,5 @@\n-        JCExpression t = toP(F.at(token.pos).Ident(ident()));\n+        return qualident(allowAnnos, false);\n+    }\n+\n+    public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {\n+        JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));\n@@ -758,0 +774,25 @@\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern() {\n+        int pos = token.pos;\n+        if (token.kind == IDENTIFIER && token.name() == names.var) {\n+            nextToken();\n+            return toP(F.at(pos).BindingPattern(ident(), null));\n+        } else {\n+            JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);\n+            if (token.kind == LPAREN) {\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                do {\n+                    nextToken();\n+                    JCPattern nestedPattern = parsePattern();\n+                    nested.append(nestedPattern);\n+                } while (token.kind == COMMA);\n+                accept(RPAREN);\n+                return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));\n+            } else {\n+                return toP(F.at(pos).BindingPattern(ident(), e));\n+            }\n+        }\n+    }\n+\n@@ -940,0 +981,10 @@\n+                } else if (token.kind == LPAREN) {\n+                    checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n+                    ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern();\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                    accept(RPAREN);\n+                    pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));\n@@ -1269,1 +1320,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if ((mode & EXPR) != 0 && (mode & NOINVOCATION) == 0) {\n@@ -1799,1 +1850,1 @@\n-                formalParameters(true, false) :\n+                formalParameters(FormalParameterKind.LAMBDA) :\n@@ -2877,1 +2928,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);\n@@ -3374,0 +3425,29 @@\n+    \/** The kind of a formal parameter\n+     *\/\n+    enum FormalParameterKind {\n+        \/* a formal lambda parameter\n+         *\/\n+        LAMBDA {\n+            @Override\n+            boolean isLambdaParameter() {\n+                return true;\n+            }\n+        },\n+        \/* a formal catch clause parameter\n+         *\/\n+        CATCH,\n+        \/* a formal method parameter\n+         *\/\n+        METHOD,\n+        \/* a formal record parameter\n+         *\/\n+        RECORD;\n+\n+        boolean isLambdaParameter() {\n+            return false;\n+        }\n+        boolean isRecordParameter() {\n+            return false;\n+        }\n+    }\n+\n@@ -3377,1 +3457,1 @@\n-        return variableDeclaratorId(mods, type, false, false);\n+        return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);\n@@ -3379,2 +3459,2 @@\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {\n@@ -3383,1 +3463,3 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n+        boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);\n+        boolean isUnderscore = token.kind == UNDERSCORE;\n+        if (parameterKind.isLambdaParameter() && isUnderscore && !allowUnderscoreAsFormal) {\n@@ -3387,0 +3469,4 @@\n+        } else if (parameterKind == FormalParameterKind.METHOD && isUnderscore && allowUnderscoreAsFormal) {\n+            log.error(pos, Errors.UnderscoreAsIdentifierInMethod);\n+            name = token.name();\n+            nextToken();\n@@ -3389,1 +3475,1 @@\n-                !lambdaParameter ||\n+                parameterKind != FormalParameterKind.LAMBDA ||\n@@ -3393,1 +3479,1 @@\n-                JCExpression pn = qualident(false);\n+                JCExpression pn = qualident(false, allowUnderscoreAsFormal);\n@@ -3425,1 +3511,1 @@\n-        if (recordComponent && token.kind == LBRACKET) {\n+        if (parameterKind == FormalParameterKind.RECORD && token.kind == LBRACKET) {\n@@ -3428,1 +3514,0 @@\n-        type = bracketsOpt(type);\n@@ -3430,1 +3515,6 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        int dimensionsPos = token.pos;\n+        JCExpression typeWithDimensions = bracketsOpt(type);\n+        if (allowUnderscoreAsFormal && isUnderscore && typeWithDimensions != type) {\n+            log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);\n+        }\n+        return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));\n@@ -3784,1 +3874,1 @@\n-        List<JCVariableDecl> headerFields = formalParameters(false, true);\n+        List<JCVariableDecl> headerFields = formalParameters(FormalParameterKind.RECORD);\n@@ -4260,1 +4350,5 @@\n-                case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4264,1 +4358,5 @@\n-                case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4300,1 +4398,1 @@\n-                params = formalParameters();\n+                params = formalParameters(FormalParameterKind.METHOD);\n@@ -4416,4 +4514,1 @@\n-    List<JCVariableDecl> formalParameters() {\n-        return formalParameters(false, false);\n-    }\n-    List<JCVariableDecl> formalParameters(boolean lambdaParameters, boolean recordComponents) {\n+    List<JCVariableDecl> formalParameters(FormalParameterKind parameterKind) {\n@@ -4424,2 +4519,2 @@\n-            this.allowThisIdent = !lambdaParameters && !recordComponents;\n-            lastParam = formalParameter(lambdaParameters, recordComponents);\n+            this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA && parameterKind != FormalParameterKind.RECORD;\n+            lastParam = formalParameter(parameterKind);\n@@ -4437,1 +4532,1 @@\n-                params.append(lastParam = formalParameter(lambdaParameters, recordComponents));\n+                params.append(lastParam = formalParameter(parameterKind));\n@@ -4548,3 +4643,3 @@\n-    protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {\n-        JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();\n-        if (recordComponent && mods.flags != 0) {\n+    protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {\n+        JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();\n+        if (parameterKind == FormalParameterKind.RECORD && mods.flags != 0) {\n@@ -4553,1 +4648,1 @@\n-        if (recordComponent) {\n+        if (parameterKind == FormalParameterKind.RECORD) {\n@@ -4559,1 +4654,1 @@\n-        JCExpression type = parseType(lambdaParameter);\n+        JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);\n@@ -4576,1 +4671,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, parameterKind);\n@@ -4581,1 +4676,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":129,"deletions":34,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2947,0 +2947,3 @@\n+compiler.misc.feature.deconstruction.patterns=\\\n+    deconstruction patterns\n+\n@@ -2959,0 +2962,6 @@\n+compiler.err.underscore.not.allowed=\\\n+    as of release 10, '_' can only be used as an unused formal parameter.\n+\n+compiler.err.underscore.cant.be.followed.by.dimensions=\\\n+    parameter name ''_'' cannot be followed by dimensions\n+\n@@ -2963,0 +2972,4 @@\n+compiler.err.underscore.as.identifier.in.method=\\\n+    ''_'' used as an identifier\\n\\\n+    (use of ''_'' as an identifier is forbidden for method parameters)\n+\n@@ -3745,0 +3758,10 @@\n+\n+# 0: symbol\n+compiler.err.deconstruction.pattern.only.records=\\\n+    deconstruction patterns can only be applied to records, {0} is not a record\n+\n+# 0: list of type, 1: list of type\n+compiler.err.incorrect.number.of.nested.patterns=\\\n+    incorrect number of nested patterns\\n\\\n+    required: {0}\\n\\\n+    found: {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -244,0 +244,2 @@\n+        DECONSTRUCTIONPATTERN,\n+\n@@ -2240,0 +2242,49 @@\n+    public static class JCDeconstructionPattern extends JCPattern\n+            implements DeconstructionPatternTree {\n+        public JCExpression deconstructor;\n+        public List<JCPattern> nested;\n+        public ClassSymbol record;\n+        public List<Type> innerTypes;\n+\n+        protected JCDeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+            this.deconstructor = deconstructor;\n+            this.nested = nested;\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Name getBinding() {\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Tree getDeconstructor() {\n+            return deconstructor;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends JCPattern> getNestedPatterns() {\n+            return nested;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitDeconstructionPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DECONSTRUCTION_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDeconstructionPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return DECONSTRUCTIONPATTERN;\n+        }\n+    }\n+\n@@ -3280,0 +3331,1 @@\n+        public void visitDeconstructionPattern(JCDeconstructionPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -903,0 +903,12 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        try {\n+            printExpr(tree.deconstructor);\n+            print(\"(\");\n+            printExprs(tree.nested);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -500,0 +500,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDeconstructionPattern(DeconstructionPatternTree node, P p) {\n+        JCDeconstructionPattern t = (JCDeconstructionPattern) node;\n+        JCExpression deconstructor = copy(t.deconstructor, p);\n+        List<JCPattern> nested = copy(t.nested, p);\n+        return M.at(t.pos).DeconstructionPattern(deconstructor, nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -485,0 +485,6 @@\n+    public JCDeconstructionPattern DeconstructionPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+        JCDeconstructionPattern tree = new JCDeconstructionPattern(deconstructor, nested);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -311,0 +311,6 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern that) {\n+        scan(that.deconstructor);\n+        scan(that.nested);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -460,0 +460,7 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.deconstructor = translate(tree.deconstructor);\n+        tree.nested = translate(tree.nested);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+    public final Name underscore;\n@@ -363,0 +364,1 @@\n+        underscore = fromString(\"_\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-        new Patterns().run();\n+        new Patterns().runBinding();\n+        new Patterns().runDeconstruction();\n@@ -52,1 +53,1 @@\n-    public void run() throws Exception {\n+    public void runBinding() throws Exception {\n@@ -165,0 +166,106 @@\n+    public void runDeconstruction() throws Exception {\n+        String out = new JavapTask(tb)\n+                .options(\"-private\",\n+                         \"-verbose\")\n+                .classpath(System.getProperty(\"test.classes\"))\n+                .classes(\"Patterns$DeconstructionPattern\")\n+                .run()\n+                .getOutputLines(Task.OutputKind.DIRECT)\n+                .stream()\n+                .collect(Collectors.joining(\"\\n\"));\n+\n+        String constantPool = out.substring(0, out.indexOf('{'));\n+\n+        out = out.replaceAll(\"(?ms) *Code:.*?\\n( *RuntimeInvisibleTypeAnnotations:)\", \"$1\");\n+        out = out.substring(out.indexOf('{'));\n+        out = out.substring(0, out.lastIndexOf('}') + 1);\n+\n+        String A = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$A;\");\n+        String CA = snipCPNumber(constantPool, \"LPatterns$DeconstructionPattern$CA;\");\n+        String value = snipCPNumber(constantPool, \"value\");\n+\n+        String expected = \"\"\"\n+                          {\n+                            private static final java.lang.Object o;\n+                              descriptor: Ljava\/lang\/Object;\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1s;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private static final boolean B1m;\n+                              descriptor: Z\n+                              flags: (0x001a) ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n+\n+                            private final boolean B2s;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            private final boolean B2m;\n+                              descriptor: Z\n+                              flags: (0x0012) ACC_PRIVATE, ACC_FINAL\n+\n+                            public Patterns$DeconstructionPattern();\n+                              descriptor: ()V\n+                              flags: (0x0001) ACC_PUBLIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=284, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=328, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=71, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  4: #_A_(): LOCAL_VARIABLE, {start_pc=114, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  5: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=158, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  6: #_A_(): LOCAL_VARIABLE, {start_pc=199, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  7: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=243, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            void testPatterns();\n+                              descriptor: ()V\n+                              flags: (0x0000)\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=28, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=72, length=11, index=3}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+\n+                            static {};\n+                              descriptor: ()V\n+                              flags: (0x0008) ACC_STATIC\n+                                RuntimeInvisibleTypeAnnotations:\n+                                  0: #_A_(): LOCAL_VARIABLE, {start_pc=30, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$A\n+                                  1: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=70, length=11, index=0}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                                  2: #_A_(): LOCAL_VARIABLE, {start_pc=110, length=11, index=1}\n+                                    Patterns$DeconstructionPattern$A\n+                                  3: #_CA_(#_value_=[@#_A_(),@#_A_()]): LOCAL_VARIABLE, {start_pc=151, length=11, index=2}\n+                                    Patterns$DeconstructionPattern$CA(\n+                                      value=[@Patterns$DeconstructionPattern$A,@Patterns$DeconstructionPattern$A]\n+                                    )\n+                          }\"\"\".replace(\"_A_\", A).replace(\"_CA_\", CA).replace(\"_value_\", value);\n+\n+        if (!expected.equals(out)) {\n+            throw new AssertionError(\"Unexpected output:\\n\" + out + \"\\nexpected:\\n\" + expected);\n+        }\n+    }\n+\n@@ -222,0 +329,43 @@\n+\n+    static class DeconstructionPattern {\n+        @Target(ElementType.TYPE_USE)\n+        @Repeatable(CA.class)\n+        @interface A {}\n+        @Target(ElementType.TYPE_USE)\n+        @interface CA {\n+            public A[] value();\n+        }\n+\n+        private static final Object o = \"\";\n+        private static final boolean B1s = o instanceof R(@A String s) && s.isEmpty();\n+        private static final boolean B1m = o instanceof R(@A @A String s) && s.isEmpty();\n+        private final boolean B2s = o instanceof R(@A String s) && s.isEmpty();\n+        private final boolean B2m = o instanceof R(@A @A String s) && s.isEmpty();\n+\n+        static {\n+            boolean B3s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B3m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B4s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B4m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        {\n+            boolean B5s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B5m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        public DeconstructionPattern() {\n+            boolean B6s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B6m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        void testPatterns() {\n+            boolean B7s = o instanceof R(@A String s) && s.isEmpty();\n+            boolean B7m = o instanceof R(@A @A String s) && s.isEmpty();\n+        }\n+\n+        record R(String s) {}\n+    }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":152,"deletions":2,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.deconstruction.pattern.only.records\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DeconstructionpatternOnlyRecords {\n+    public boolean deconstruction(Object o) {\n+        return o instanceof String(var content);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DeconstructionPatternOnlyRecords.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.incorrect.number.of.nested.patterns\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ key: compiler.misc.feature.records\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class IncorrectNumberOfNestedPatterns {\n+    private boolean t(Object o) {\n+        return o instanceof R(var i);\n+    }\n+    record R(int i, int j) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IncorrectNumberOfNestedPatterns.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -source 9 -Xlint:-options\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreAsIdentifierError.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.underscore.cant.be.followed.by.dimensions\n+\/\/ key: compiler.err.underscore.as.identifier.in.method\n+\n+class UnderscoreCantBeFollowedByDims {\n+    void m(String _[]) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreCantBeFollowedByDims.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+\/\/ options: -source 9 -Xlint:-options\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInLambdaExpression.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.underscore.as.identifier.in.method\n+\n+public class UnderscoreInMethodParameters {\n+    void m(String _) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInMethodParameters.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.underscore.not.allowed\n+\n+import java.util.function.*;\n+\n+class UnderscoreAsIdentifierError {\n+    BiFunction<Integer, String, String> biss = (i, j) -> String.valueOf(_);\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreOnlyInLamdaError.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -7,1 +7,2 @@\n- * @compile\/fail\/ref=IdentifierTest9.out -XDrawDiagnostics IdentifierTest.java\n+ * @compile\/fail\/ref=IdentifierTest9.out -source 9 -Xlint:-options -XDrawDiagnostics IdentifierTest.java\n+ * @compile\/fail\/ref=IdentifierTest10.out -Xlint:-options -XDrawDiagnostics IdentifierTest.java\n@@ -183,1 +184,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+IdentifierTest.java:42:11: compiler.err.underscore.not.allowed\n+IdentifierTest.java:45:16: compiler.err.underscore.not.allowed\n+IdentifierTest.java:46:20: compiler.err.underscore.not.allowed\n+IdentifierTest.java:47:22: compiler.err.underscore.not.allowed\n+IdentifierTest.java:52:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:52:15: compiler.err.underscore.not.allowed\n+IdentifierTest.java:52:23: compiler.err.underscore.not.allowed\n+IdentifierTest.java:54:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:56:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:62:21: compiler.err.underscore.not.allowed\n+IdentifierTest.java:64:67: compiler.err.underscore.not.allowed\n+IdentifierTest.java:71:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:72:14: compiler.err.underscore.not.allowed\n+IdentifierTest.java:73:18: compiler.err.underscore.not.allowed\n+IdentifierTest.java:78:22: compiler.err.underscore.not.allowed\n+IdentifierTest.java:80:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:80:15: compiler.err.underscore.not.allowed\n+IdentifierTest.java:82:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:82:15: compiler.err.underscore.not.allowed\n+IdentifierTest.java:89:10: compiler.err.underscore.not.allowed\n+IdentifierTest.java:89:38: compiler.err.underscore.not.allowed\n+IdentifierTest.java:95:14: compiler.err.underscore.not.allowed\n+IdentifierTest.java:102:17: compiler.err.underscore.not.allowed\n+IdentifierTest.java:102:26: compiler.err.underscore.not.allowed\n+IdentifierTest.java:119:20: compiler.err.underscore.not.allowed\n+IdentifierTest.java:124:10: compiler.err.underscore.not.allowed\n+IdentifierTest.java:129:17: compiler.err.underscore.not.allowed\n+IdentifierTest.java:132:17: compiler.err.underscore.not.allowed\n+IdentifierTest.java:139:17: compiler.err.underscore.not.allowed\n+IdentifierTest.java:139:24: compiler.err.underscore.not.allowed\n+IdentifierTest.java:139:33: compiler.err.underscore.not.allowed\n+IdentifierTest.java:140:39: compiler.err.underscore.not.allowed\n+IdentifierTest.java:144:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:145:15: compiler.err.underscore.not.allowed\n+IdentifierTest.java:146:13: compiler.err.underscore.not.allowed\n+IdentifierTest.java:151:15: compiler.err.underscore.not.allowed\n+IdentifierTest.java:152:17: compiler.err.underscore.not.allowed\n+IdentifierTest.java:158:16: compiler.err.underscore.not.allowed\n+IdentifierTest.java:160:25: compiler.err.underscore.not.allowed\n+IdentifierTest.java:169:5: compiler.err.underscore.not.allowed\n+IdentifierTest.java:173:26: compiler.err.underscore.not.allowed\n+IdentifierTest.java:175:19: compiler.err.underscore.not.allowed\n+IdentifierTest.java:181:11: compiler.err.underscore.not.allowed\n+43 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest10.out","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -1,44 +1,44 @@\n-IdentifierTest.java:41:11: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:44:16: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:45:20: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:46:22: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:51:23: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:53:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:55:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:61:21: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:63:67: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:70:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:71:14: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:72:18: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:77:22: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:79:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:79:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:81:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:81:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:88:10: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:88:38: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:94:14: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:101:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:101:26: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:118:20: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:123:10: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:128:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:131:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:24: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:138:33: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:139:39: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:143:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:144:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:145:13: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:150:15: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:151:17: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:157:16: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:159:25: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:168:5: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:172:26: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:174:19: compiler.warn.underscore.as.identifier\n-IdentifierTest.java:180:11: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:42:11: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:45:16: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:46:20: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:47:22: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:52:23: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:54:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:56:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:62:21: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:63:42: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:64:67: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:71:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:72:14: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:73:18: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:78:22: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:80:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:80:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:82:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:82:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:89:10: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:89:38: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:95:14: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:102:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:102:26: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:119:20: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:124:10: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:129:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:132:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:24: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:139:33: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:140:39: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:144:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:145:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:146:13: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:151:15: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:152:17: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:158:16: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:160:25: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:169:5: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:173:26: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:175:19: compiler.warn.underscore.as.identifier\n+IdentifierTest.java:181:11: compiler.warn.underscore.as.identifier\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest8.out","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1,44 +1,44 @@\n-IdentifierTest.java:41:11: compiler.err.underscore.as.identifier\n-IdentifierTest.java:44:16: compiler.err.underscore.as.identifier\n-IdentifierTest.java:45:20: compiler.err.underscore.as.identifier\n-IdentifierTest.java:46:22: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:51:23: compiler.err.underscore.as.identifier\n-IdentifierTest.java:53:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:55:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:61:21: compiler.err.underscore.as.identifier\n-IdentifierTest.java:62:42: compiler.err.underscore.as.identifier\n-IdentifierTest.java:63:67: compiler.err.underscore.as.identifier\n-IdentifierTest.java:70:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:71:14: compiler.err.underscore.as.identifier\n-IdentifierTest.java:72:18: compiler.err.underscore.as.identifier\n-IdentifierTest.java:77:22: compiler.err.underscore.as.identifier\n-IdentifierTest.java:79:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:79:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:81:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:81:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:88:10: compiler.err.underscore.as.identifier\n-IdentifierTest.java:88:38: compiler.err.underscore.as.identifier\n-IdentifierTest.java:94:14: compiler.err.underscore.as.identifier\n-IdentifierTest.java:101:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:101:26: compiler.err.underscore.as.identifier\n-IdentifierTest.java:118:20: compiler.err.underscore.as.identifier\n-IdentifierTest.java:123:10: compiler.err.underscore.as.identifier\n-IdentifierTest.java:128:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:131:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:24: compiler.err.underscore.as.identifier\n-IdentifierTest.java:138:33: compiler.err.underscore.as.identifier\n-IdentifierTest.java:139:39: compiler.err.underscore.as.identifier\n-IdentifierTest.java:143:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:144:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:145:13: compiler.err.underscore.as.identifier\n-IdentifierTest.java:150:15: compiler.err.underscore.as.identifier\n-IdentifierTest.java:151:17: compiler.err.underscore.as.identifier\n-IdentifierTest.java:157:16: compiler.err.underscore.as.identifier\n-IdentifierTest.java:159:25: compiler.err.underscore.as.identifier\n-IdentifierTest.java:168:5: compiler.err.underscore.as.identifier\n-IdentifierTest.java:172:26: compiler.err.underscore.as.identifier\n-IdentifierTest.java:174:19: compiler.err.underscore.as.identifier\n-IdentifierTest.java:180:11: compiler.err.underscore.as.identifier\n+IdentifierTest.java:42:11: compiler.err.underscore.as.identifier\n+IdentifierTest.java:45:16: compiler.err.underscore.as.identifier\n+IdentifierTest.java:46:20: compiler.err.underscore.as.identifier\n+IdentifierTest.java:47:22: compiler.err.underscore.as.identifier\n+IdentifierTest.java:52:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:52:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:52:23: compiler.err.underscore.as.identifier\n+IdentifierTest.java:54:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:56:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:62:21: compiler.err.underscore.as.identifier\n+IdentifierTest.java:63:42: compiler.err.underscore.as.identifier\n+IdentifierTest.java:64:67: compiler.err.underscore.as.identifier\n+IdentifierTest.java:71:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:72:14: compiler.err.underscore.as.identifier\n+IdentifierTest.java:73:18: compiler.err.underscore.as.identifier\n+IdentifierTest.java:78:22: compiler.err.underscore.as.identifier\n+IdentifierTest.java:80:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:80:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:82:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:82:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:89:10: compiler.err.underscore.as.identifier\n+IdentifierTest.java:89:38: compiler.err.underscore.as.identifier\n+IdentifierTest.java:95:14: compiler.err.underscore.as.identifier\n+IdentifierTest.java:102:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:102:26: compiler.err.underscore.as.identifier\n+IdentifierTest.java:119:20: compiler.err.underscore.as.identifier\n+IdentifierTest.java:124:10: compiler.err.underscore.as.identifier\n+IdentifierTest.java:129:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:132:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:139:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:139:24: compiler.err.underscore.as.identifier\n+IdentifierTest.java:139:33: compiler.err.underscore.as.identifier\n+IdentifierTest.java:140:39: compiler.err.underscore.as.identifier\n+IdentifierTest.java:144:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:145:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:146:13: compiler.err.underscore.as.identifier\n+IdentifierTest.java:151:15: compiler.err.underscore.as.identifier\n+IdentifierTest.java:152:17: compiler.err.underscore.as.identifier\n+IdentifierTest.java:158:16: compiler.err.underscore.as.identifier\n+IdentifierTest.java:160:25: compiler.err.underscore.as.identifier\n+IdentifierTest.java:169:5: compiler.err.underscore.as.identifier\n+IdentifierTest.java:173:26: compiler.err.underscore.as.identifier\n+IdentifierTest.java:175:19: compiler.err.underscore.as.identifier\n+IdentifierTest.java:181:11: compiler.err.underscore.as.identifier\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest9.out","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-                lk.arity() > 0;\n+                lk.arity() > 0 && sk == SourceKind.SOURCE_9;\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaParserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,2 @@\n- * @compile\/fail\/ref=LambdaScope04.out -XDrawDiagnostics LambdaScope04.java\n+ * @compile\/fail\/ref=LambdaScope04_Source9.out -source 9 -Xlint:-options -XDrawDiagnostics LambdaScope04.java\n+ * @compile\/fail\/ref=LambdaScope04_Source10.out -Xlint:-options -XDrawDiagnostics LambdaScope04.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope04.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-LambdaScope04.java:23:18: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.instance.init, kindname.class, LambdaScope04\n-LambdaScope04.java:24:34: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.instance.init, kindname.class, LambdaScope04\n-LambdaScope04.java:29:18: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.static.init, kindname.class, LambdaScope04\n-LambdaScope04.java:30:34: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.static.init, kindname.class, LambdaScope04\n-LambdaScope04.java:36:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalInstance()\n-LambdaScope04.java:37:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalInstance()\n-LambdaScope04.java:43:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalStatic()\n-LambdaScope04.java:44:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalStatic()\n-LambdaScope04.java:49:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamInstance(java.lang.Object)\n-LambdaScope04.java:50:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamInstance(java.lang.Object)\n-LambdaScope04.java:55:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamStatic(java.lang.Object)\n-LambdaScope04.java:56:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamStatic(java.lang.Object)\n-LambdaScope04.java:62:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForInstance()\n-LambdaScope04.java:63:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForInstance()\n-LambdaScope04.java:70:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:71:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:78:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachInstance(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:79:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachInstance(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:86:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:87:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:94:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchInstance()\n-LambdaScope04.java:95:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchInstance()\n-LambdaScope04.java:102:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:103:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchStatic(java.lang.Iterable<java.lang.Object>)\n-LambdaScope04.java:110:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRInstance(java.lang.AutoCloseable)\n-LambdaScope04.java:111:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRInstance(java.lang.AutoCloseable)\n-LambdaScope04.java:118:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRStatic(java.lang.AutoCloseable)\n-LambdaScope04.java:119:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRStatic(java.lang.AutoCloseable)\n-LambdaScope04.java:127:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalInstance()\n-LambdaScope04.java:128:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalInstance()\n-LambdaScope04.java:136:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalStatic()\n-LambdaScope04.java:137:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalStatic()\n-LambdaScope04.java:146:26: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalInstance(int)\n-LambdaScope04.java:147:42: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalInstance(int)\n-LambdaScope04.java:157:26: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalStatic(int)\n-LambdaScope04.java:158:42: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalStatic(int)\n-36 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope04.out","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+LambdaScope04.java:110:28: compiler.err.unreported.exception.implicit.close: java.lang.Exception, local\n+LambdaScope04.java:118:28: compiler.err.unreported.exception.implicit.close: java.lang.Exception, local\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope04_Source10.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+LambdaScope04.java:24:18: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.instance.init, kindname.class, LambdaScope04\n+LambdaScope04.java:25:34: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.instance.init, kindname.class, LambdaScope04\n+LambdaScope04.java:30:18: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.static.init, kindname.class, LambdaScope04\n+LambdaScope04.java:31:34: compiler.err.already.defined.in.clinit: kindname.variable, local, kindname.static.init, kindname.class, LambdaScope04\n+LambdaScope04.java:37:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalInstance()\n+LambdaScope04.java:38:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalInstance()\n+LambdaScope04.java:44:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalStatic()\n+LambdaScope04.java:45:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testLocalStatic()\n+LambdaScope04.java:50:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamInstance(java.lang.Object)\n+LambdaScope04.java:51:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamInstance(java.lang.Object)\n+LambdaScope04.java:56:18: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamStatic(java.lang.Object)\n+LambdaScope04.java:57:34: compiler.err.already.defined: kindname.variable, local, kindname.method, testParamStatic(java.lang.Object)\n+LambdaScope04.java:63:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForInstance()\n+LambdaScope04.java:64:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForInstance()\n+LambdaScope04.java:71:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:72:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:79:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachInstance(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:80:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachInstance(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:87:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:88:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testForEachStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:95:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchInstance()\n+LambdaScope04.java:96:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchInstance()\n+LambdaScope04.java:103:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:104:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testCatchStatic(java.lang.Iterable<java.lang.Object>)\n+LambdaScope04.java:111:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRInstance(java.lang.AutoCloseable)\n+LambdaScope04.java:112:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRInstance(java.lang.AutoCloseable)\n+LambdaScope04.java:119:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRStatic(java.lang.AutoCloseable)\n+LambdaScope04.java:120:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testTWRStatic(java.lang.AutoCloseable)\n+LambdaScope04.java:128:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalInstance()\n+LambdaScope04.java:129:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalInstance()\n+LambdaScope04.java:137:22: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalStatic()\n+LambdaScope04.java:138:38: compiler.err.already.defined: kindname.variable, local, kindname.method, testBlockLocalStatic()\n+LambdaScope04.java:147:26: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalInstance(int)\n+LambdaScope04.java:148:42: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalInstance(int)\n+LambdaScope04.java:158:26: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalStatic(int)\n+LambdaScope04.java:159:42: compiler.err.already.defined: kindname.variable, local, kindname.method, testSwitchLocalStatic(int)\n+36 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope04_Source9.out","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -5,1 +5,2 @@\n- * @compile\/fail\/ref=LambdaScope05.out -XDrawDiagnostics LambdaScope05.java\n+ * @compile\/fail\/ref=LambdaScope05_Source9.out -source 9 -Xlint:-options -XDrawDiagnostics LambdaScope05.java\n+ * @compile -source 10 -Xlint:-options -XDrawDiagnostics LambdaScope05.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope05.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,7 +0,0 @@\n-LambdaScope05.java:13:47: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.static.init, kindname.class, LambdaScope05\n-LambdaScope05.java:14:40: compiler.err.already.defined: kindname.variable, p, kindname.constructor, LambdaScope05()\n-LambdaScope05.java:17:43: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.static.init, kindname.class, LambdaScope05\n-LambdaScope05.java:21:43: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.instance.init, kindname.class, LambdaScope05\n-LambdaScope05.java:25:43: compiler.err.already.defined: kindname.variable, p, kindname.method, m_static()\n-LambdaScope05.java:29:43: compiler.err.already.defined: kindname.variable, p, kindname.method, m()\n-6 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope05.out","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -0,0 +1,7 @@\n+LambdaScope05.java:14:47: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.static.init, kindname.class, LambdaScope05\n+LambdaScope05.java:15:40: compiler.err.already.defined: kindname.variable, p, kindname.constructor, LambdaScope05()\n+LambdaScope05.java:18:43: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.static.init, kindname.class, LambdaScope05\n+LambdaScope05.java:22:43: compiler.err.already.defined.in.clinit: kindname.variable, p, kindname.instance.init, kindname.class, LambdaScope05\n+LambdaScope05.java:26:43: compiler.err.already.defined: kindname.variable, p, kindname.method, m_static()\n+LambdaScope05.java:30:43: compiler.err.already.defined: kindname.variable, p, kindname.method, m()\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaScope05_Source9.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @compile\/fail\/ref=UnderscoreAsIdent9.out -XDrawDiagnostics -Werror UnderscoreAsIdent.java\n+ * @compile\/fail\/ref=UnderscoreAsIdent9.out -source 9 -Xlint:-options -XDrawDiagnostics -Werror UnderscoreAsIdent.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/UnderscoreAsIdent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,0 +169,6 @@\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1 );\n+\n+        group((Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1,\n+              (Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1 );\n@@ -177,0 +183,2 @@\n+\n+    record R(Integer i1, int i2) {}\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/Deduplication.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,0 +137,3 @@\n+            if (cf.getName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n+                continue;\n+            }\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8173061\n+ * @summary Shadowing of lambda parameters\n+ * @compile ShadowParametersTest01.java\n+ *\/\n+\n+import java.util.*;\n+\n+public class ShadowParametersTest01 {\n+    void foo() {\n+        Map<String, Integer> msi = null;\n+        String key = \"333\";\n+        msi.computeIfAbsent(key, key -> key.length());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/ShadowParametersTest01.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8173061\n+ * @summary Shadowing of lambda parameters\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @run main ShadowParametersTest02\n+ *\/\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+public class ShadowParametersTest02 {\n+    public static void main(String... args) {\n+        new ShadowParametersTest02().tests();\n+    }\n+\n+    void tests() {\n+        m(1);\n+        Assert.check(str.equals(\"Hi from lambda\"));\n+        Assert.check(b);\n+    }\n+\n+    String str = null;\n+    boolean b = false;\n+\n+    void m(int x) {\n+        Runnable r = () -> {\n+            String x = \"Hi from lambda\";\n+            str = x;\n+            Runnable r = () -> {\n+                boolean x = true;\n+                b = x;\n+            };\n+            r.run();\n+        };\n+        r.run();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/ShadowParametersTest02.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8177513\n+ * @summary underscore can't be followed by dimensions\n+ * @compile\/fail\/ref=UnderscoreCantBeFollowedByDimsTest.out -XDrawDiagnostics UnderscoreCantBeFollowedByDimsTest.java\n+ *\/\n+\n+public class UnderscoreCantBeFollowedByDimsTest {\n+    void m(String _[]) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreCantBeFollowedByDimsTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+UnderscoreCantBeFollowedByDimsTest.java:9:19: compiler.err.underscore.as.identifier.in.method\n+UnderscoreCantBeFollowedByDimsTest.java:9:20: compiler.err.underscore.cant.be.followed.by.dimensions\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreCantBeFollowedByDimsTest.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8173059\n+ * @summary Underscore for unnamed method, constructor, lambda, and catch formals\n+ * @compile\/fail\/ref=UnderscoreInCatchClauseTest.out -XDrawDiagnostics UnderscoreInCatchClauseTest.java\n+ *\/\n+\n+public class UnderscoreInCatchClauseTest {\n+    void foo() {\n+        \/\/ this use should be allowed\n+        try { } catch (Throwable _) {\n+            \/\/ this use should be forbidden\n+            throw _;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInCatchClauseTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+UnderscoreInCatchClauseTest.java:13:19: compiler.err.underscore.not.allowed\n+1 error\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInCatchClauseTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8173059\n+ * @summary Underscore for unnamed method, constructor, lambda, and catch formals\n+ * @compile\/fail\/ref=UnderscoreInLambdaTest.out -XDrawDiagnostics UnderscoreInLambdaTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class UnderscoreInLambdaTest {\n+    void foo() {\n+        \/\/ error\n+        BiFunction<Integer, String, String> biss1 =\n+                (_, _) ->\n+                    String.valueOf(_); \/\/ this use will be detected and banned by the parser\n+        \/\/ ok implicit\n+        BiFunction<Integer, String, String> biss2 =\n+                (_, _) -> \"\";\n+        \/\/ ok explicit\n+        BiFunction<Integer, String, String> biss2 =\n+                (int _, String _) -> \"\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInLambdaTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+UnderscoreInLambdaTest.java:15:36: compiler.err.underscore.not.allowed\n+1 error\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInLambdaTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8173059\n+ * @summary Underscore for unnamed method, constructor, lambda, and catch formals\n+ * @compile\/fail\/ref=UnderscoreInMethodsTest.out -XDrawDiagnostics UnderscoreInMethodsTest.java\n+ *\/\n+\n+public class UnderscoreInMethodsTest {\n+    class Super {\n+        void m(String _) {}\n+    }\n+\n+    class Child extends Super {\n+        void m(String _) {\n+            \/\/ error '_' is not in scope so it can't be used inside the method\n+            System.out.println(_);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInMethodsTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+UnderscoreInMethodsTest.java:10:23: compiler.err.underscore.as.identifier.in.method\n+UnderscoreInMethodsTest.java:14:23: compiler.err.underscore.as.identifier.in.method\n+UnderscoreInMethodsTest.java:16:32: compiler.err.underscore.not.allowed\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/lambda_leftovers\/UnderscoreInMethodsTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -17,1 +17,1 @@\n-       var y = (Function<Integer, Integer>)(Integer y) -> y; \/\/error - bad shadowing\n+       var y = (Function<Integer, Integer>)(Integer y) -> y; \/\/error - bad shadowing - but ok in lambda leftovers!\n","filename":"test\/langtools\/tools\/javac\/lvti\/SelfRefTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-SelfRefTest.java:17:53: compiler.err.already.defined: kindname.variable, y, kindname.method, test(boolean)\n@@ -4,1 +3,1 @@\n-3 errors\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/lvti\/SelfRefTest.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @summary Verify error reports for erroneous deconstruction patterns are sensible\n+ * @compile\/fail\/ref=DeconstructionPatternErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW DeconstructionPatternErrors.java\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class DeconstructionPatternErrors {\n+\n+    public static void main(String... args) throws Throwable {\n+        Object p;\n+        p = new P(42);\n+        if (p instanceof P(_));\n+        if (p instanceof P3(ArrayList<Integer> l));\n+        if (p instanceof P4(ArrayList<Integer> l));\n+        if (p instanceof P5(int i));\n+        if (p instanceof P(String s));\n+        if (p instanceof P5(P(var v)));\n+        if (p instanceof P2(var v1)); \/\/too few nested patterns\n+        if (p instanceof P2(Runnable v1)); \/\/too few nested patterns\n+        if (p instanceof P(var v1, var v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, int v2)); \/\/too many nested patterns\n+        if (p instanceof P(int v1, Unresolvable v2)); \/\/too many nested patterns\n+        if (p instanceof GenRecord<String>(var v)); \/\/incorrect generic type\n+        if (p instanceof P4(GenRecord<String>(var v))); \/\/incorrect generic type\n+        if (p instanceof GenRecord<String>(Integer v)); \/\/inconsistency in types\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(Runnable r1, Runnable r2) {}\n+    public record P3(List<String> l) {}\n+    public record P4(Object o) {}\n+    public record P5(String s) {}\n+    public record GenRecord<T>(T s) {}\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+DeconstructionPatternErrors.java:15:28: compiler.err.underscore.as.identifier\n+DeconstructionPatternErrors.java:15:29: compiler.err.expected: token.identifier\n+DeconstructionPatternErrors.java:16:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<java.lang.String>, java.util.ArrayList<java.lang.Integer>)\n+DeconstructionPatternErrors.java:17:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, java.util.ArrayList<java.lang.Integer>\n+DeconstructionPatternErrors.java:18:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+DeconstructionPatternErrors.java:19:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.String)\n+DeconstructionPatternErrors.java:20:29: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, DeconstructionPatternErrors.P)\n+DeconstructionPatternErrors.java:21:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:22:26: compiler.err.incorrect.number.of.nested.patterns: java.lang.Runnable,java.lang.Runnable, java.lang.Runnable\n+DeconstructionPatternErrors.java:23:26: compiler.err.incorrect.number.of.nested.patterns: int, int,compiler.misc.type.none\n+DeconstructionPatternErrors.java:24:26: compiler.err.incorrect.number.of.nested.patterns: int, int,int\n+DeconstructionPatternErrors.java:25:36: compiler.err.cant.resolve.location: kindname.class, Unresolvable, , , (compiler.misc.location: kindname.class, DeconstructionPatternErrors, null)\n+DeconstructionPatternErrors.java:25:26: compiler.err.incorrect.number.of.nested.patterns: int, int,Unresolvable\n+DeconstructionPatternErrors.java:26:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:27:29: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+DeconstructionPatternErrors.java:28:44: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+DeconstructionPatternErrors.java:28:13: compiler.err.instanceof.reifiable.not.safe: java.lang.Object, DeconstructionPatternErrors.GenRecord<java.lang.String>\n+- compiler.note.preview.filename: DeconstructionPatternErrors.java\n+- compiler.note.preview.recompile\n+17 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test behavior of Pretty\n+ * @modules jdk.compiler\n+ * @compile --enable-preview -source ${jdk.version} PrettyTest.java\n+ * @run main\/othervm --enable-preview PrettyTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.tools.*;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+\n+public class PrettyTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        new PrettyTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        String code = \"class Test {\\n\" +\n+                      \"    boolean t(Object o) {\\n\" +\n+                      \"         boolean b;\\n\" +\n+                      \"         b = o instanceof String s;\\n\" +\n+                      \"         b = o instanceof R(String s);\\n\" +\n+                      \"         b = o instanceof R(var s);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), String t);\\n\" +\n+                      \"         b = o instanceof R2(R(var s), var t);\\n\" +\n+                      \"    }\\n\" +\n+                      \"    record R(String s) {}\\n\" +\n+                      \"    record R2(R r, String s) {}\\n\" +\n+                      \"}\\n\";\n+        String pretty = parse(code).toString();\n+        String expected = \"\"\"\n+                          \\n\\\n+                          class Test {\n+                              \\n\\\n+                              boolean t(Object o) {\n+                                  boolean b;\n+                                  b = o instanceof String s;\n+                                  b = o instanceof R(String s);\n+                                  b = o instanceof R(\/*missing*\/ s);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), String t);\n+                                  b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                              }\n+                              \\n\\\n+                              class R {\n+                                  private final String s;\n+                              }\n+                              \\n\\\n+                              class R2 {\n+                                  private final R r;\n+                                  private final String s;\n+                              }\n+                          }\"\"\";\n+        if (!expected.equals(pretty)) {\n+            throw new AssertionError(\"Actual prettified source: \" + pretty);\n+        }\n+    }\n+\n+    private CompilationUnitTree parse(String code) throws IOException {\n+        final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n+        assert tool != null;\n+        DiagnosticListener<JavaFileObject> noErrors = d -> {};\n+\n+        StringWriter out = new StringWriter();\n+        JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,\n+            List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())), null,\n+            Arrays.asList(new MyFileObject(code)));\n+        return ct.parse().iterator().next();\n+    }\n+\n+    static class MyFileObject extends SimpleJavaFileObject {\n+        private String text;\n+\n+        public MyFileObject(String text) {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this.text = text;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return text;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/**\n+ * @test\n+ * @compile\/fail\/ref=SimpleDeconstructionPatternNoPreview.out -XDrawDiagnostics SimpleDeconstructionPattern.java\n+ * @compile --enable-preview -source ${jdk.version} SimpleDeconstructionPattern.java\n+ * @run main\/othervm --enable-preview SimpleDeconstructionPattern\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class SimpleDeconstructionPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+\/\/        if (!test1(new P(42))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test1(new P(41))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test2(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test2a(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test2a(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+\/\/        if (!test3(new P2(new P(42), \"\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test3(new P2(new P(41), \"\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (test3(new P2(new P(42), \"a\"))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test4(new P2(new P(42), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(41), \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test4(new P2(new P(42), \"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test5(new P(42))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test5(new P(41))) {\n+            throw new IllegalStateException();\n+        }\n+\/\/        if (!test6(new P(42))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (!test6(new P(41))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+\/\/        if (!((new BaseUse(new BaseSubclass(0))) instanceof BaseUse(BaseSubclass(0)))) {\n+\/\/            throw new IllegalStateException();\n+\/\/        }\n+        if (!test7(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test7a(new P3(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test7a(new P3(\"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(\"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test8a(new P4(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test8a(new P4(new P3(\"a\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!test9(new P5(new ArrayList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (test9(new P5(new LinkedList<String>(Arrays.asList(\"\"))))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testA(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testA(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testB(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testB(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testC(new P6(null))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testC(new P6(new P3(null)))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testC(new P6(new P3(\"\")))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen1(new GenRecord1<>(1L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen1(new GenRecord1<>(1L, \"a\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen2(new GenRecord1<>(3L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen2(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (testGen3(new GenRecord1<>(3L, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!testGen3(new GenRecord1<>(3, \"\"))) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+\/\/    private static boolean test1(Object o) throws Throwable {\n+\/\/        return o instanceof P(42);\n+\/\/    }\n+\/\/\n+    private static void exp(Object o) throws Throwable {\n+        if (o instanceof P(var i)) {\n+            System.err.println(\"i=\" + i);\n+        }\n+    }\n+\n+    private static boolean test2(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+    private static boolean test2a(Object o) throws Throwable {\n+        return o instanceof P(int i) && i == 42;\n+    }\n+\n+\/\/    private static boolean test3(Object o) throws Throwable {\n+\/\/        return o instanceof P2(P(42), \"\");\n+\/\/    }\n+\/\/\n+    private static boolean test4(Object o) throws Throwable {\n+        return o instanceof P2(P(var i), var s) && i == 42 && \"\".equals(s);\n+    }\n+\n+    private static boolean test5(Object o) throws Throwable {\n+        return o instanceof P(var i) && i == 42;\n+    }\n+\n+\/\/    private static boolean test6(Object o) throws Throwable {\n+\/\/        return o instanceof P(_);\n+\/\/    }\n+\n+    private static boolean test7(Object o) throws Throwable {\n+        return o instanceof P3(var s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test7a(Object o) throws Throwable {\n+        return o instanceof P3(String s) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8(Object o) throws Throwable {\n+        return o instanceof P4(P3(var s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test8a(Object o) throws Throwable {\n+        return o instanceof P4(P3(String s)) && \"\".equals(s);\n+    }\n+\n+    private static boolean test9(Object o) throws Throwable {\n+        return o instanceof P5(ArrayList<String> l) && !l.isEmpty();\n+    }\n+\n+    private static boolean testA(Object o) throws Throwable {\n+        return o instanceof P6(P3(var s));\n+    }\n+\n+    private static boolean testB(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s));\n+    }\n+\n+    private static boolean testC(Object o) throws Throwable {\n+        return o instanceof P6(P3(String s)) && s.isEmpty();\n+    }\n+\n+    private static boolean testGen1(Object o) throws Throwable {\n+        return o instanceof GenRecord1(var i, var s) && s.length() == 0;\n+    }\n+\n+    private static boolean testGen2(Object o) throws Throwable {\n+        return o instanceof GenRecord1(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    private static boolean testGen3(Object o) throws Throwable {\n+        return o instanceof GenRecord1<?, ?>(Integer i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    private static boolean testGen4(GenBase<Integer, String> o) throws Throwable {\n+        return o instanceof GenRecord1<Integer, String>(var i, var s) && i.intValue() == 3 && s.length() == 0;\n+    }\n+\n+    public record P(int i) {\n+    }\n+\n+    public record P2(P p, String s) {\n+    }\n+\n+    public record P3(String s) {\n+    }\n+\n+    public record P4(Object o) {}\n+\n+    public record P5(List<String> l) {}\n+    public record P6(P3 p) {}\n+\n+    public interface Base {}\n+    public record BaseUse(Base b) {}\n+    public record BaseSubclass(int i) implements Base {}\n+\n+    public interface GenBase<T1, T2 extends CharSequence> {}\n+    public record GenRecord1<T1, T2 extends CharSequence> (T1 i, T2 s) implements GenBase<T1, T2> {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+SimpleDeconstructionPattern.java:149:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+SimpleDeconstructionPattern.java:226:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:229:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:232:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:235:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:237:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:238:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:241:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:242:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:242:38: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:12: compiler.warn.restricted.type.not.allowed.preview: record, 14\n+SimpleDeconstructionPattern.java:245:29: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:59: compiler.err.illegal.start.of.type\n+SimpleDeconstructionPattern.java:245:71: compiler.err.expected: ';'\n+SimpleDeconstructionPattern.java:245:99: compiler.err.illegal.start.of.type\n+6 errors\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -959,0 +959,11 @@\n+\n+    public void testDoNotAllowSealedAnnotation() {\n+        for (String s : List.of(\n+            \"\"\"\n+            sealed @interface A {}\n+            non-sealed interface I extends A {}\n+            \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.expected4\", s);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}