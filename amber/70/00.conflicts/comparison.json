{"files":[{"patch":"@@ -168,0 +168,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +170,7 @@\n+=======\n+        if (feature == Feature.PATTERN_MATCHING_IN_INSTANCEOF ||\n+            feature == Feature.DECONSTRUCTION_PATTERNS ||\n+            feature == Feature.REIFIABLE_TYPES_INSTANCEOF ||\n+            feature == Feature.RECORDS ||\n+            feature == Feature.SEALED_CLASSES)\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -171,0 +171,1 @@\n+        allowShadowingOfLambdaParameters = Feature.LAMBDA_PARAMETER_SHADOWING.allowedInSource(source);\n@@ -216,0 +217,5 @@\n+    \/**\n+     * Switch: allow shadowing of lambda parameters?\n+     *\/\n+    boolean allowShadowingOfLambdaParameters;\n+\n@@ -1314,0 +1320,6 @@\n+            if (tree.name == names.underscore) {\n+                WriteableScope enclScope = enter.enterScope(env);\n+                if (enclScope != null) {\n+                    enclScope.remove(tree.sym);\n+                }\n+            }\n@@ -1410,1 +1422,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, syms.blockScopeMethodType,\n@@ -3354,0 +3366,2 @@\n+            ClassSymbol enclClass = owner.enclClass();\n+            Symbol newScopeOwner = null;\n@@ -3356,2 +3370,1 @@\n-                ClassSymbol enclClass = owner.enclClass();\n-                Symbol newScopeOwner = env.info.scope.owner;\n+                newScopeOwner = env.info.scope.owner;\n@@ -3382,0 +3395,10 @@\n+            } else {\n+                if (allowShadowingOfLambdaParameters) {\n+                    newScopeOwner = new MethodSymbol(\n+                        HYPOTHETICAL,\n+                        names.empty,\n+                        syms.lambdaScopeMethodType,\n+                        owner);\n+                }\n+            }\n+            if (newScopeOwner != null) {\n@@ -3956,10 +3979,1 @@\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);\n@@ -3981,0 +3995,1 @@\n+<<<<<<< HEAD\n@@ -3991,0 +4006,16 @@\n+=======\n+        if (tree.vartype != null) {\n+            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n+            tree.type = attribTree(tree.vartype, env, varInfo);\n+        } else {\n+            tree.type = resultInfo.pt;\n+        }\n+        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);\n+        if (chk.checkUnique(tree.pos(), v, env.info.scope)) {\n+            chk.checkTransparentVar(tree.pos(), v, env.info.scope);\n+        }\n+        if (tree.vartype != null) {\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n+            annotate.flush();\n+        }\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n@@ -3995,0 +4026,55 @@\n+    @Override\n+    public void visitDeconstructionPattern(JCDeconstructionPattern tree) {\n+        tree.type = attribType(tree.deconstructor, env);\n+        Type site = types.removeWildcards(tree.type);\n+        List<Type> expectedRecordTypes;\n+        if (site.tsym.kind == Kind.TYP && ((ClassSymbol) site.tsym).isRecord()) {\n+            ClassSymbol record = (ClassSymbol) site.tsym;\n+            expectedRecordTypes = record.getRecordComponents().stream().map(rc -> types.memberType(site, rc)).collect(List.collector());\n+            tree.record = record;\n+        } else {\n+            log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));\n+            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+                                .limit(tree.nested.size())\n+                                .collect(List.collector());\n+        }\n+        ListBuffer<BindingSymbol> outBindings = new ListBuffer<>();\n+        List<Type> recordTypes = expectedRecordTypes;\n+        List<JCPattern> nestedPatterns = tree.nested;\n+        while (recordTypes.nonEmpty() && nestedPatterns.nonEmpty()) {\n+            boolean nestedIsVarPattern = nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n+                                         ((JCBindingPattern) nestedPatterns.head).vartype == null;\n+            attribExpr(nestedPatterns.head, env, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+            verifyCastable(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);\n+            outBindings.addAll(matchBindings.bindingsWhenTrue);\n+            nestedPatterns = nestedPatterns.tail;\n+            recordTypes = recordTypes.tail;\n+        }\n+        if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {\n+            while (nestedPatterns.nonEmpty()) {\n+                attribExpr(nestedPatterns.head, env, Type.noType);\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            List<Type> nestedTypes =\n+                    tree.nested.stream().map(p -> p.type).collect(List.collector());\n+            log.error(tree.pos(),\n+                      Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,\n+                                                             nestedTypes));\n+        }\n+        result = tree.type;\n+        matchBindings = new MatchBindings(outBindings.toList(), List.nil());\n+    }\n+\n+    private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {\n+        Warner warner = new Warner();\n+        if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                      Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":100,"deletions":14,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -31,0 +32,1 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n@@ -33,1 +35,0 @@\n-import com.sun.tools.javac.code.Type;\n@@ -35,1 +36,0 @@\n-import com.sun.tools.javac.tree.JCTree;\n@@ -61,0 +61,1 @@\n+import java.util.LinkedHashMap;\n@@ -63,0 +64,2 @@\n+import com.sun.tools.javac.code.Symbol.RecordComponent;\n+import com.sun.tools.javac.code.Type;\n@@ -67,0 +70,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;\n@@ -68,0 +73,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCPattern;\n@@ -72,1 +78,0 @@\n-import java.util.HashMap;\n@@ -134,1 +139,2 @@\n-    private MethodSymbol currentMethodSym = null;\n+    private ClassSymbol currentClass;\n+    private Symbol currentOwnerSym = null;\n@@ -151,1 +157,1 @@\n-        if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {\n+        if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n@@ -153,0 +159,1 @@\n+            \/\/E instanceof T(PATT1, PATT2, ...)\n@@ -154,0 +161,1 @@\n+<<<<<<< HEAD\n@@ -157,0 +165,3 @@\n+=======\n+            \/\/(let T' N$temp = E; N$temp instanceof T && <pattern extractor>)\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n@@ -160,2 +171,2 @@\n-            VarSymbol temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,\n-                    names.fromString(pattSym.name.toString() + target.syntheticNameChar() + \"temp\"),\n+            VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"e\" + target.syntheticNameChar()),\n@@ -163,0 +174,1 @@\n+<<<<<<< HEAD\n@@ -164,0 +176,3 @@\n+=======\n+                    currentOwnerSym);\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n@@ -165,1 +180,14 @@\n-            Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));\n+            Type castTargetType;\n+            \/\/TODO: use rule switch (when boot JDK is 14):\n+            switch (tree.pattern.getTag()) {\n+                case BINDINGPATTERN:\n+                    castTargetType = ((JCBindingPattern)tree.pattern).symbol.type;\n+                    break;\n+                case DECONSTRUCTIONPATTERN:\n+                    castTargetType = ((JCDeconstructionPattern)tree.pattern).type;\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected pattern type: \" + tree.pattern.getTag());\n+            }\n+\n+            castTargetType = types.boxedTypeOrType(types.erasure(castTargetType));\n@@ -167,1 +195,10 @@\n-            result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));\n+            result = makeTypeTest(make.at(tree.pos).Ident(temp), make.Type(castTargetType));\n+            result = makeBinary(Tag.AND, (JCExpression)result,\n+                                         preparePatternExtractor(tree, tree.getPattern(), temp, castTargetType));\n+            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr),\n+                                               (JCExpression)result).setType(syms.booleanType);\n+            ((LetExpr) result).needsCond = true;\n+        } else {\n+            super.visitTypeTest(tree);\n+        }\n+    }\n@@ -169,0 +206,1 @@\n+<<<<<<< HEAD\n@@ -170,0 +208,11 @@\n+=======\n+    private JCExpression preparePatternExtractor(JCInstanceOf tree, JCPattern patt, VarSymbol temp, Type targetType) {\n+        if (targetType == syms.botType) {\n+            targetType = syms.objectType;\n+        }\n+        if (patt.hasTag(Tag.BINDINGPATTERN)) {\n+            \/\/type test already done, finish handling of type test patterns (\"T N\")\n+            \/\/=>\n+            \/\/(let N = (T) N$temp; true)\n+            VarSymbol bindingVar = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n@@ -172,1 +221,1 @@\n-                        make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));\n+                        make.Ident(bindingVar), convert(make.Ident(temp), targetType)).setType(bindingVar.erasure(types));\n@@ -177,1 +226,1 @@\n-                result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);\n+                return nestedLE;\n@@ -179,2 +228,57 @@\n-            result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);\n-            ((LetExpr) result).needsCond = true;\n+            return make.Literal(true);\n+        } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {\n+            \/\/type test already done, finish handling of deconstruction patterns (\"T(PATT1, PATT2, ...)\")\n+            \/\/=>\n+            \/\/<PATT1-handling> && <PATT2-handling> && ...\n+            JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;\n+            List<? extends RecordComponent> components = dpatt.record.getRecordComponents();\n+            List<? extends JCPattern> nestedPatterns = dpatt.nested;\n+            JCExpression test = null;\n+            while (components.nonEmpty() && nestedPatterns.nonEmpty()) {\n+                \/\/PATTn for record component COMPn of type Tn;\n+                \/\/PATTn is a type test pattern or a deconstruction pattern:\n+                \/\/=>\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null && <PATTn extractor>)\n+                \/\/or\n+                \/\/(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T' && <PATTn extractor>)\n+                RecordComponent component = components.head;\n+                JCPattern nested = nestedPatterns.head;\n+                VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(target.syntheticNameChar() + \"c\" + target.syntheticNameChar() + component.name),\n+                                     component.erasure(types),\n+                                     currentOwnerSym);\n+                Symbol accessor = dpatt.record\n+                                       .members()\n+                                       .findFirst(component.name, s -> s.kind == Kind.MTH &&\n+                                                                       ((MethodSymbol) s).params.isEmpty());\n+                JCVariableDecl nestedTempVar =\n+                        make.VarDef(nestedTemp,\n+                                    make.App(make.Select(convert(make.Ident(temp), dpatt.type),\n+                                                         accessor)));\n+                JCExpression extracted =\n+                        preparePatternExtractor(tree, nested, nestedTemp, nested.type);\n+                JCExpression extraTest = null;\n+                if (!types.isAssignable(nestedTemp.type, nested.type)) {\n+                    extraTest = makeTypeTest(make.Ident(nestedTemp),\n+                                             make.Type(nested.type));\n+                } else if (nested.type.isReference()) {\n+                    extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());\n+                }\n+                if (extraTest != null) {\n+                    extracted = makeBinary(Tag.AND, extraTest, extracted);\n+                }\n+                LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);\n+                getAndRun.needsCond = true;\n+                getAndRun.setType(syms.booleanType);\n+                if (test == null) {\n+                    test = getAndRun;\n+                } else {\n+                    test = makeBinary(Tag.AND, test, getAndRun);\n+                }\n+                components = components.tail;\n+                nestedPatterns = nestedPatterns.tail;\n+            }\n+            Assert.check(components.isEmpty() == nestedPatterns.isEmpty());\n+            return test != null ? test : make.Literal(true);\n@@ -182,1 +286,1 @@\n-            super.visitTypeTest(tree);\n+            throw new IllegalStateException();\n@@ -254,1 +358,1 @@\n-        MethodSymbol prevMethodSym = currentMethodSym;\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -256,1 +360,1 @@\n-            currentMethodSym = tree.sym;\n+            currentOwnerSym = tree.sym;\n@@ -259,1 +363,25 @@\n-            currentMethodSym = prevMethodSym;\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        Symbol prevOwnerSym = currentOwnerSym;\n+        try {\n+            if (tree.sym.owner.kind == Kind.TYP) {\n+                currentOwnerSym = tree.sym;\n+            }\n+            super.visitVarDef(tree);\n+        } finally {\n+            currentOwnerSym = prevOwnerSym;\n+        }\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n@@ -300,0 +428,1 @@\n+        Symbol prevOwnerSym = currentOwnerSym;\n@@ -301,0 +430,5 @@\n+            if (currentOwnerSym == null) {\n+                currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                 names.empty, null,\n+                                 currentClass);\n+            }\n@@ -309,0 +443,1 @@\n+            currentOwnerSym = prevOwnerSym;\n@@ -358,0 +493,16 @@\n+    \/** Make an attributed tree representing a literal. This will be an\n+     *  Ident node in the case of boolean literals, a Literal node in all\n+     *  other cases.\n+     *  @param type       The literal's type.\n+     *  @param value      The literal's value.\n+     *\/\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n+\n+    \/** Make an attributed tree representing null.\n+     *\/\n+    JCExpression makeNull() {\n+        return makeLit(syms.botType, null);\n+    }\n+\n@@ -379,1 +530,1 @@\n-            this.hoistedVarMap = new HashMap<>();\n+            this.hoistedVarMap = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":169,"deletions":18,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+     *     mode |= NOINVOCATION : method invocations are not allowed\n@@ -248,0 +249,1 @@\n+    protected static final int NOINVOCATION = 0x40;\n@@ -250,1 +252,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        mode = (mode & (NOLAMBDA | NOINVOCATION)) | EXPR;\n@@ -254,1 +256,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        mode = (mode & (NOLAMBDA|NOINVOCATION)) | TYPE;\n@@ -566,1 +568,1 @@\n-        return ident(false);\n+        return ident(false, false);\n@@ -570,0 +572,4 @@\n+        return ident(allowClass, false);\n+    }\n+\n+    protected Name ident(boolean allowClass, boolean underscoreAllowed) {\n@@ -595,4 +601,10 @@\n-            if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n-                log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n-            } else {\n-                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+            if (!underscoreAllowed) {\n+                if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {\n+                    log.error(token.pos, Errors.UnderscoreNotAllowed);\n+                } else {\n+                    if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n+                        log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n+                    } else {\n+                        log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+                    }\n+                }\n@@ -617,1 +629,5 @@\n-        JCExpression t = toP(F.at(token.pos).Ident(ident()));\n+        return qualident(allowAnnos, false);\n+    }\n+\n+    public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {\n+        JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));\n@@ -757,0 +773,25 @@\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern() {\n+        int pos = token.pos;\n+        if (token.kind == IDENTIFIER && token.name() == names.var) {\n+            nextToken();\n+            return toP(F.at(pos).BindingPattern(ident(), null));\n+        } else {\n+            JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);\n+            if (token.kind == LPAREN) {\n+                ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                do {\n+                    nextToken();\n+                    JCPattern nestedPattern = parsePattern();\n+                    nested.append(nestedPattern);\n+                } while (token.kind == COMMA);\n+                accept(RPAREN);\n+                return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));\n+            } else {\n+                return toP(F.at(pos).BindingPattern(ident(), e));\n+            }\n+        }\n+    }\n+\n@@ -940,0 +981,1 @@\n+<<<<<<< HEAD\n@@ -947,0 +989,13 @@\n+=======\n+                    pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));\n+                } else if (token.kind == LPAREN) {\n+                    checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);\n+                    ListBuffer<JCPattern> nested = new ListBuffer<>();\n+                    do {\n+                        nextToken();\n+                        JCPattern nestedPattern = parsePattern();\n+                        nested.append(nestedPattern);\n+                    } while (token.kind == COMMA);\n+                    accept(RPAREN);\n+                    pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));\n+>>>>>>> f1b02a163bf4e051db369f0202c8527b9b8dfb1f\n@@ -1276,1 +1331,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if ((mode & EXPR) != 0 && (mode & NOINVOCATION) == 0) {\n@@ -1806,1 +1861,1 @@\n-                formalParameters(true, false) :\n+                formalParameters(FormalParameterKind.LAMBDA) :\n@@ -2884,1 +2939,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);\n@@ -3381,0 +3436,29 @@\n+    \/** The kind of a formal parameter\n+     *\/\n+    enum FormalParameterKind {\n+        \/* a formal lambda parameter\n+         *\/\n+        LAMBDA {\n+            @Override\n+            boolean isLambdaParameter() {\n+                return true;\n+            }\n+        },\n+        \/* a formal catch clause parameter\n+         *\/\n+        CATCH,\n+        \/* a formal method parameter\n+         *\/\n+        METHOD,\n+        \/* a formal record parameter\n+         *\/\n+        RECORD;\n+\n+        boolean isLambdaParameter() {\n+            return false;\n+        }\n+        boolean isRecordParameter() {\n+            return false;\n+        }\n+    }\n+\n@@ -3384,1 +3468,1 @@\n-        return variableDeclaratorId(mods, type, false, false);\n+        return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);\n@@ -3386,2 +3470,2 @@\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {\n@@ -3390,1 +3474,3 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n+        boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);\n+        boolean isUnderscore = token.kind == UNDERSCORE;\n+        if (parameterKind.isLambdaParameter() && isUnderscore && !allowUnderscoreAsFormal) {\n@@ -3394,0 +3480,4 @@\n+        } else if (parameterKind == FormalParameterKind.METHOD && isUnderscore && allowUnderscoreAsFormal) {\n+            log.error(pos, Errors.UnderscoreAsIdentifierInMethod);\n+            name = token.name();\n+            nextToken();\n@@ -3396,1 +3486,1 @@\n-                !lambdaParameter ||\n+                parameterKind != FormalParameterKind.LAMBDA ||\n@@ -3400,1 +3490,1 @@\n-                JCExpression pn = qualident(false);\n+                JCExpression pn = qualident(false, allowUnderscoreAsFormal);\n@@ -3432,1 +3522,1 @@\n-        if (recordComponent && token.kind == LBRACKET) {\n+        if (parameterKind == FormalParameterKind.RECORD && token.kind == LBRACKET) {\n@@ -3435,1 +3525,0 @@\n-        type = bracketsOpt(type);\n@@ -3437,1 +3526,6 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        int dimensionsPos = token.pos;\n+        JCExpression typeWithDimensions = bracketsOpt(type);\n+        if (allowUnderscoreAsFormal && isUnderscore && typeWithDimensions != type) {\n+            log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);\n+        }\n+        return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));\n@@ -3791,1 +3885,1 @@\n-        List<JCVariableDecl> headerFields = formalParameters(false, true);\n+        List<JCVariableDecl> headerFields = formalParameters(FormalParameterKind.RECORD);\n@@ -4267,1 +4361,5 @@\n-                case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4271,1 +4369,5 @@\n-                case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4307,1 +4409,1 @@\n-                params = formalParameters();\n+                params = formalParameters(FormalParameterKind.METHOD);\n@@ -4423,4 +4525,1 @@\n-    List<JCVariableDecl> formalParameters() {\n-        return formalParameters(false, false);\n-    }\n-    List<JCVariableDecl> formalParameters(boolean lambdaParameters, boolean recordComponents) {\n+    List<JCVariableDecl> formalParameters(FormalParameterKind parameterKind) {\n@@ -4431,2 +4530,2 @@\n-            this.allowThisIdent = !lambdaParameters && !recordComponents;\n-            lastParam = formalParameter(lambdaParameters, recordComponents);\n+            this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA && parameterKind != FormalParameterKind.RECORD;\n+            lastParam = formalParameter(parameterKind);\n@@ -4444,1 +4543,1 @@\n-                params.append(lastParam = formalParameter(lambdaParameters, recordComponents));\n+                params.append(lastParam = formalParameter(parameterKind));\n@@ -4555,3 +4654,3 @@\n-    protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {\n-        JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();\n-        if (recordComponent && mods.flags != 0) {\n+    protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {\n+        JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();\n+        if (parameterKind == FormalParameterKind.RECORD && mods.flags != 0) {\n@@ -4560,1 +4659,1 @@\n-        if (recordComponent) {\n+        if (parameterKind == FormalParameterKind.RECORD) {\n@@ -4566,1 +4665,1 @@\n-        JCExpression type = parseType(lambdaParameter);\n+        JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);\n@@ -4583,1 +4682,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, parameterKind);\n@@ -4588,1 +4687,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":137,"deletions":38,"binary":false,"changes":175,"status":"modified"}]}