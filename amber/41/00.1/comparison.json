{"files":[{"patch":"@@ -1,0 +1,23 @@\n+;\n+; Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+;\n+; This code is free software; you can redistribute it and\/or modify it\n+; under the terms of the GNU General Public License version 2 only, as\n+; published by the Free Software Foundation.\n+;\n+; This code is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; version 2 for more details (a copy is included in the LICENSE file that\n+; accompanied this code).\n+;\n+; You should have received a copy of the GNU General Public License version\n+; 2 along with this work; if not, write to the Free Software Foundation,\n+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+;\n+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+; or visit www.oracle.com if you need additional information or have any\n+; questions.\n+;\n+\n@@ -2,2 +25,3 @@\n-project=jdk\n-jbs=JDK\n+project=amber\n+repository=amber\n+jbs=jdk\n@@ -6,5 +30,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace\n-\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\\\.(?:0|[1-9][0-9]*)){0,4})(?:\\\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\\\d{1,3})?-(?:(?:b\\\\d{2,3})|(?:ga)))|(?:hs\\\\d\\\\d(?:\\\\.\\\\d{1,2})?-b\\\\d\\\\d)\n-branches=\n+error=author,committer,whitespace,executable,symlink\n@@ -18,13 +38,0 @@\n-\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n-[checks \"committer\"]\n-role=committer\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n","filename":".jcheck\/conf","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+        allowShadowingOfLambdaParameters = Feature.LAMBDA_PARAMETER_SHADOWING.allowedInSource(source);\n@@ -214,0 +215,5 @@\n+    \/**\n+     * Switch: allow shadowing of lambda parameters?\n+     *\/\n+    boolean allowShadowingOfLambdaParameters;\n+\n@@ -1312,0 +1318,6 @@\n+            if (tree.name == names.underscore) {\n+                WriteableScope enclScope = enter.enterScope(env);\n+                if (enclScope != null) {\n+                    enclScope.remove(tree.sym);\n+                }\n+            }\n@@ -1408,1 +1420,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, syms.blockScopeMethodType,\n@@ -3327,0 +3339,2 @@\n+            ClassSymbol enclClass = owner.enclClass();\n+            Symbol newScopeOwner = null;\n@@ -3329,2 +3343,1 @@\n-                ClassSymbol enclClass = owner.enclClass();\n-                Symbol newScopeOwner = env.info.scope.owner;\n+                newScopeOwner = env.info.scope.owner;\n@@ -3355,0 +3368,10 @@\n+            } else {\n+                if (allowShadowingOfLambdaParameters) {\n+                    newScopeOwner = new MethodSymbol(\n+                        HYPOTHETICAL,\n+                        names.empty,\n+                        syms.lambdaScopeMethodType,\n+                        owner);\n+                }\n+            }\n+            if (newScopeOwner != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-        return ident(false);\n+        return ident(false, false);\n@@ -571,0 +571,4 @@\n+        return ident(advanceOnErrors, false);\n+    }\n+\n+    protected Name ident(boolean advanceOnErrors, boolean underscoreAllowed) {\n@@ -596,4 +600,10 @@\n-            if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n-                log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n-            } else {\n-                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+            if (!underscoreAllowed) {\n+                if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {\n+                    log.error(token.pos, Errors.UnderscoreNotAllowed);\n+                } else {\n+                    if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {\n+                        log.warning(token.pos, Warnings.UnderscoreAsIdentifier);\n+                    } else {\n+                        log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);\n+                    }\n+                }\n@@ -617,1 +627,5 @@\n-        JCExpression t = toP(F.at(token.pos).Ident(ident()));\n+        return qualident(allowAnnos, false);\n+    }\n+\n+    public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {\n+        JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));\n@@ -1798,1 +1812,1 @@\n-                formalParameters(true, false) :\n+                formalParameters(FormalParameterKind.LAMBDA) :\n@@ -2876,1 +2890,1 @@\n-        JCVariableDecl formal = variableDeclaratorId(mods, paramType);\n+        JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);\n@@ -3373,0 +3387,29 @@\n+    \/** The kind of a formal parameter\n+     *\/\n+    enum FormalParameterKind {\n+        \/* a formal lambda parameter\n+         *\/\n+        LAMBDA {\n+            @Override\n+            boolean isLambdaParameter() {\n+                return true;\n+            }\n+        },\n+        \/* a formal catch clause parameter\n+         *\/\n+        CATCH,\n+        \/* a formal method parameter\n+         *\/\n+        METHOD,\n+        \/* a formal record parameter\n+         *\/\n+        RECORD;\n+\n+        boolean isLambdaParameter() {\n+            return false;\n+        }\n+        boolean isRecordParameter() {\n+            return false;\n+        }\n+    }\n+\n@@ -3376,1 +3419,1 @@\n-        return variableDeclaratorId(mods, type, false, false);\n+        return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);\n@@ -3378,2 +3421,2 @@\n-    \/\/where\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n+\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {\n@@ -3382,1 +3425,3 @@\n-        if (lambdaParameter && token.kind == UNDERSCORE) {\n+        boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);\n+        boolean isUnderscore = token.kind == UNDERSCORE;\n+        if (parameterKind.isLambdaParameter() && isUnderscore && !allowUnderscoreAsFormal) {\n@@ -3386,0 +3431,4 @@\n+        } else if (parameterKind == FormalParameterKind.METHOD && isUnderscore && allowUnderscoreAsFormal) {\n+            log.error(pos, Errors.UnderscoreAsIdentifierInMethod);\n+            name = token.name();\n+            nextToken();\n@@ -3388,1 +3437,1 @@\n-                !lambdaParameter ||\n+                parameterKind != FormalParameterKind.LAMBDA ||\n@@ -3392,1 +3441,1 @@\n-                JCExpression pn = qualident(false);\n+                JCExpression pn = qualident(false, allowUnderscoreAsFormal);\n@@ -3424,1 +3473,1 @@\n-        if (recordComponent && token.kind == LBRACKET) {\n+        if (parameterKind == FormalParameterKind.RECORD && token.kind == LBRACKET) {\n@@ -3427,2 +3476,6 @@\n-        type = bracketsOpt(type);\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        int dimensionsPos = token.pos;\n+        JCExpression typeWithDimensions = bracketsOpt(type);\n+        if (allowUnderscoreAsFormal && isUnderscore && typeWithDimensions != type) {\n+            log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);\n+        }\n+        return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));\n@@ -3783,1 +3836,1 @@\n-        List<JCVariableDecl> headerFields = formalParameters(false, true);\n+        List<JCVariableDecl> headerFields = formalParameters(FormalParameterKind.RECORD);\n@@ -4299,1 +4352,1 @@\n-                params = formalParameters();\n+                params = formalParameters(FormalParameterKind.METHOD);\n@@ -4415,4 +4468,1 @@\n-    List<JCVariableDecl> formalParameters() {\n-        return formalParameters(false, false);\n-    }\n-    List<JCVariableDecl> formalParameters(boolean lambdaParameters, boolean recordComponents) {\n+    List<JCVariableDecl> formalParameters(FormalParameterKind parameterKind) {\n@@ -4423,2 +4473,2 @@\n-            this.allowThisIdent = !lambdaParameters && !recordComponents;\n-            lastParam = formalParameter(lambdaParameters, recordComponents);\n+            this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA && parameterKind != FormalParameterKind.RECORD;\n+            lastParam = formalParameter(parameterKind);\n@@ -4436,1 +4486,1 @@\n-                params.append(lastParam = formalParameter(lambdaParameters, recordComponents));\n+                params.append(lastParam = formalParameter(parameterKind));\n@@ -4547,3 +4597,3 @@\n-    protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {\n-        JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();\n-        if (recordComponent && mods.flags != 0) {\n+    protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {\n+        JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();\n+        if (parameterKind == FormalParameterKind.RECORD && mods.flags != 0) {\n@@ -4552,1 +4602,1 @@\n-        if (recordComponent) {\n+        if (parameterKind == FormalParameterKind.RECORD) {\n@@ -4558,1 +4608,1 @@\n-        JCExpression type = parseType(lambdaParameter);\n+        JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);\n@@ -4575,1 +4625,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n+        return variableDeclaratorId(mods, type, parameterKind);\n@@ -4580,1 +4630,1 @@\n-        return variableDeclaratorId(mods, null, true, false);\n+        return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":83,"deletions":33,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2959,0 +2959,6 @@\n+compiler.err.underscore.not.allowed=\\\n+    as of release 10, '_' can only be used as an unused formal parameter.\n+\n+compiler.err.underscore.cant.be.followed.by.dimensions=\\\n+    parameter name ''_'' cannot be followed by dimensions\n+\n@@ -2963,0 +2969,4 @@\n+compiler.err.underscore.as.identifier.in.method=\\\n+    ''_'' used as an identifier\\n\\\n+    (use of ''_'' as an identifier is forbidden for method parameters)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}