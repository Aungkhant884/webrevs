{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -2121,1 +2121,1 @@\n-            \/\/ point by roughly (scale() - precision() +1).\n+            \/\/ point by roughly (scale() - precision() + 1).\n@@ -2149,1 +2149,1 @@\n-            \/\/ (A double value might have as much many as 17 decimal\n+            \/\/ (A double value might have as many as 17 decimal\n@@ -2173,1 +2173,19 @@\n-                targetPrecision = originalPrecision;\n+                \/*\n+                 * To avoid the need for post-Newton fix-up logic, in\n+                 * the case of half-way rounding modes, double the\n+                 * target precision so that the \"2p + 2\" property can\n+                 * be relied on to accomplish the final rounding.\n+                 *\/\n+                switch (mc.getRoundingMode()) {\n+                case HALF_UP:\n+                case HALF_DOWN:\n+                case HALF_EVEN:\n+                    targetPrecision = 2 * originalPrecision;\n+                    if (targetPrecision < 0) \/\/ Overflow\n+                        targetPrecision = Integer.MAX_VALUE - 2;\n+                    break;\n+\n+                default:\n+                    targetPrecision = originalPrecision;\n+                    break;\n+                }\n@@ -2201,1 +2219,1 @@\n-                if (this.subtract(result.multiply(result)).compareTo(ZERO) != 0) {\n+                if (this.subtract(result.square()).compareTo(ZERO) != 0) {\n@@ -2206,0 +2224,42 @@\n+\n+                switch (targetRm) {\n+                case DOWN:\n+                case FLOOR:\n+                    \/\/ Check if too big\n+                    if (result.square().compareTo(this) > 0) {\n+                        BigDecimal ulp = result.ulp();\n+                        \/\/ Adjust increment down in case of 1.0 = 10^0\n+                        \/\/ since the next smaller number is only 1\/10\n+                        \/\/ as far way as the next larger at exponent\n+                        \/\/ boundaries. Test approx and *not* result to\n+                        \/\/ avoid having to detect an arbitrary power\n+                        \/\/ of ten.\n+                        if (approx.compareTo(ONE) == 0) {\n+                            ulp = ulp.multiply(ONE_TENTH);\n+                        }\n+                        result = result.subtract(ulp);\n+                    }\n+                    break;\n+\n+                case UP:\n+                case CEILING:\n+                    \/\/ Check if too small\n+                    if (result.square().compareTo(this) < 0) {\n+                        result = result.add(result.ulp());\n+                    }\n+                    break;\n+\n+                default:\n+                    \/\/ No additional work, rely on \"2p + 2\" property\n+                    \/\/ for correct rounding. Alternatively, could\n+                    \/\/ instead run the Newton iteration to around p\n+                    \/\/ digits and then do tests and fix-ups on the\n+                    \/\/ rounded value. One possible set of tests and\n+                    \/\/ fix-ups is given in the Hull and Abrham paper;\n+                    \/\/ however, additional half-way cases can occur\n+                    \/\/ for BigDecimal given the more varied\n+                    \/\/ combinations of input and output precisions\n+                    \/\/ supported.\n+                    break;\n+                }\n+\n@@ -2208,0 +2268,3 @@\n+            \/\/ Test numerical properties at full precision before any\n+            \/\/ scale adjustments.\n+            assert squareRootResultAssertions(result, mc);\n@@ -2213,2 +2276,3 @@\n-                \/\/ preferred scale rounding the correct precision will\n-                \/\/ perform the proper scale vs precision tradeoffs.\n+                \/\/ preferred scale rounding to the correct precision\n+                \/\/ will perform the proper scale vs precision\n+                \/\/ tradeoffs.\n@@ -2219,1 +2283,0 @@\n-            assert squareRootResultAssertions(result, mc);\n@@ -2222,0 +2285,1 @@\n+            BigDecimal result = null;\n@@ -2227,1 +2291,3 @@\n-                return valueOf(0L, scale()\/2);\n+                result = valueOf(0L, scale()\/2);\n+                assert squareRootResultAssertions(result, mc);\n+                return result;\n@@ -2235,0 +2301,4 @@\n+    private BigDecimal square() {\n+        return this.multiply(this);\n+    }\n+\n@@ -2243,4 +2313,10 @@\n-     * For the directed roundings, for DOWN and FLOOR, result^2 must\n-     * be {@code <=} the input and (result+ulp)^2 must be {@code >} the\n-     * input. Conversely, for UP and CEIL, result^2 must be {@code >=} the\n-     * input and (result-ulp)^2 must be {@code <} the input.\n+     * For the directed rounding modes:\n+     *\n+     * <ul>\n+     *\n+     * <li> For DOWN and FLOOR, result^2 must be {@code <=} the input\n+     * and (result+ulp)^2 must be {@code >} the input.\n+     *\n+     * <li>Conversely, for UP and CEIL, result^2 must be {@code >=}\n+     * the input and (result-ulp)^2 must be {@code <} the input.\n+     * <\/ul>\n@@ -2256,1 +2332,1 @@\n-            if (this.isPowerOfTen()) {\n+            if (result.isPowerOfTen()) {\n@@ -2262,4 +2338,3 @@\n-            if (result.signum() != 1 ||\n-                this.signum() != 1) {\n-                return false;\n-            }\n+            assert (result.signum() == 1 &&\n+                    this.signum() == 1) :\n+                \"Bad signum of this and\/or its sqrt.\";\n@@ -2270,3 +2345,5 @@\n-                return\n-                    result.multiply(result).compareTo(this)         <= 0 &&\n-                    neighborUp.multiply(neighborUp).compareTo(this) > 0;\n+                assert\n+                    result.square().compareTo(this)     <= 0 &&\n+                    neighborUp.square().compareTo(this) > 0:\n+                \"Square of result out for bounds rounding \" + rm;\n+                return true;\n@@ -2276,3 +2353,6 @@\n-                return\n-                    result.multiply(result).compareTo(this)             >= 0 &&\n-                    neighborDown.multiply(neighborDown).compareTo(this) < 0;\n+                assert\n+                    result.square().compareTo(this)       >= 0 &&\n+                    neighborDown.square().compareTo(this) < 0:\n+                \"Square of result out for bounds rounding \" + rm;\n+                return true;\n+\n@@ -2283,3 +2363,3 @@\n-                BigDecimal err = result.multiply(result).subtract(this).abs();\n-                BigDecimal errUp = neighborUp.multiply(neighborUp).subtract(this);\n-                BigDecimal errDown =  this.subtract(neighborDown.multiply(neighborDown));\n+                BigDecimal err = result.square().subtract(this).abs();\n+                BigDecimal errUp = neighborUp.square().subtract(this);\n+                BigDecimal errDown =  this.subtract(neighborDown.square());\n@@ -2292,1 +2372,1 @@\n-                return\n+                assert\n@@ -2294,5 +2374,15 @@\n-                    errDown.signum() == 1 &&\n-\n-                    err_comp_errUp   <= 0 &&\n-                    err_comp_errDown <= 0 &&\n-\n+                    errDown.signum() == 1 :\n+                \"Errors of neighbors squared don't have correct signs\";\n+\n+                \/\/ For breaking a half-way tie, the return value may\n+                \/\/ have a larger error than one of the neighbors. For\n+                \/\/ example, the square root of 2.25 to a precision of\n+                \/\/ 1 digit is either 1 or 2 depending on how the exact\n+                \/\/ value of 1.5 is rounded. If 2 is returned, it will\n+                \/\/ have a larger rounding error than its neighbor 1.\n+                assert\n+                    err_comp_errUp   <= 0 ||\n+                    err_comp_errDown <= 0 :\n+                \"Computed square root has larger error than neighbors for \" + rm;\n+\n+                assert\n@@ -2300,1 +2390,2 @@\n-                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true);\n+                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n+                        \"Incorrect error relationships\";\n@@ -2302,0 +2393,1 @@\n+                return true;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":126,"deletions":34,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4851777\n+ * @bug 4851777 8233452\n@@ -33,0 +33,5 @@\n+import static java.math.BigDecimal.ONE;\n+import static java.math.BigDecimal.TEN;\n+import static java.math.BigDecimal.ZERO;\n+import static java.math.BigDecimal.valueOf;\n+\n@@ -34,0 +39,6 @@\n+    private static BigDecimal TWO = new BigDecimal(2);\n+\n+    \/**\n+     * The value 0.1, with a scale of 1.\n+     *\/\n+    private static final BigDecimal ONE_TENTH = valueOf(1L, 1);\n@@ -40,0 +51,2 @@\n+        failures += oneDigitTests();\n+        failures += twoDigitTests();\n@@ -43,0 +56,5 @@\n+        failures += almostFourRoundingDown();\n+        failures += almostFourRoundingUp();\n+        failures += nearTen();\n+        failures += nearOne();\n+        failures += halfWay();\n@@ -86,0 +104,68 @@\n+    \/**\n+     * Probe inputs with one digit of precision, 1 ... 9 and those\n+     * values scaled by 10^-1, 0.1, ... 0.9.\n+     *\/\n+    private static int oneDigitTests() {\n+        int failures = 0;\n+\n+        List<BigDecimal> oneToNine =\n+            List.of(ONE,        TWO,        valueOf(3),\n+                    valueOf(4), valueOf(5), valueOf(6),\n+                    valueOf(7), valueOf(8), valueOf(9));\n+\n+        List<RoundingMode> modes =\n+            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n+                    RoundingMode.CEILING, RoundingMode.FLOOR,\n+                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+\n+        for (int i = 1; i < 20; i++) {\n+            for (RoundingMode rm : modes) {\n+                for (BigDecimal bd  : oneToNine) {\n+                    MathContext mc = new MathContext(i, rm);\n+\n+                    failures += compareSqrtImplementations(bd, mc);\n+                    bd = bd.multiply(ONE_TENTH);\n+                    failures += compareSqrtImplementations(bd, mc);\n+                }\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Probe inputs with two digits of precision, (10 ... 99) and\n+     * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2\n+     * (0.1 ... 0.99).\n+     *\/\n+    private static int twoDigitTests() {\n+        int failures = 0;\n+\n+        List<RoundingMode> modes =\n+            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n+                    RoundingMode.CEILING, RoundingMode.FLOOR,\n+                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+\n+        for (int i = 10; i < 100; i++) {\n+            BigDecimal bd0 = BigDecimal.valueOf(i);\n+            BigDecimal bd1 = bd0.multiply(ONE_TENTH);\n+            BigDecimal bd2 = bd1.multiply(ONE_TENTH);\n+\n+            for (BigDecimal bd : List.of(bd0, bd1, bd2)) {\n+                for (int precision = 1; i < 20; i++) {\n+                    for (RoundingMode rm : modes) {\n+                        MathContext mc = new MathContext(precision, rm);\n+                        failures += compareSqrtImplementations(bd, mc);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int compareSqrtImplementations(BigDecimal bd, MathContext mc) {\n+        return equalNumerically(BigSquareRoot.sqrt(bd, mc),\n+                                bd.sqrt(mc), \"sqrt(\" + bd + \") under \" + mc);\n+    }\n+\n@@ -95,2 +181,2 @@\n-            BigDecimal testValue       = BigDecimal.valueOf(1, 2*scale);\n-            BigDecimal expectedNumericalResult = BigDecimal.valueOf(1, scale);\n+            BigDecimal testValue               = BigDecimal.valueOf(1, 2*scale);\n+            BigDecimal expectedNumericalResult = BigDecimal.valueOf(1,   scale);\n@@ -100,1 +186,0 @@\n-\n@@ -102,2 +187,2 @@\n-                                           result = testValue.sqrt(MathContext.DECIMAL64),\n-                                           \"Even powers of 10, DECIMAL64\");\n+                                         result = testValue.sqrt(MathContext.DECIMAL64),\n+                                         \"Even powers of 10, DECIMAL64\");\n@@ -107,2 +192,3 @@\n-                                           result = testValue.sqrt(oneDigitExactly),\n-                                           \"even powers of 10, 1 digit\");\n+                                         result = testValue.sqrt(oneDigitExactly),\n+                                         \"even powers of 10, 1 digit\");\n+\n@@ -114,1 +200,0 @@\n-\n@@ -116,1 +201,0 @@\n-\n@@ -124,1 +208,0 @@\n-        BigDecimal TWO = new BigDecimal(2);\n@@ -130,1 +213,0 @@\n-\n@@ -137,3 +219,0 @@\n-        \/\/ For each iteresting rounding mode, for precisions 1 to, say\n-        \/\/ 63 numerically compare TWO.sqrt(mc) to\n-        \/\/ highPrecisionRoot2.round(mc)\n@@ -141,0 +220,4 @@\n+        \/\/ For each interesting rounding mode, for precisions 1 to, say,\n+        \/\/ 63 numerically compare TWO.sqrt(mc) to\n+        \/\/ highPrecisionRoot2.round(mc) and the alternative internal high-precision\n+        \/\/ implementation of square root.\n@@ -146,0 +229,1 @@\n+                BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);\n@@ -147,1 +231,2 @@\n-                equalNumerically(expected, computed, \"sqrt(2)\");\n+                failures += equalNumerically(expected, computed, \"sqrt(2)\");\n+                failures += equalNumerically(computed, altComputed, \"computed & altComputed\");\n@@ -184,2 +269,2 @@\n-                        System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n-                                          computedRoot.toString(), precision, rm);\n+                            System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n+                                              computedRoot.toString(), precision, rm);\n@@ -198,0 +283,128 @@\n+    \/**\n+     * Test around 3.9999 that the sqrt doesn't improperly round-up to\n+     * a numerical value of 2.\n+     *\/\n+    private static int almostFourRoundingDown() {\n+        int failures = 0;\n+        BigDecimal nearFour = new BigDecimal(\"3.999999999999999999999999999999\");\n+\n+        \/\/ Sqrt is 1.9999...\n+\n+        for (int i = 1; i < 64; i++) {\n+            MathContext mc = new MathContext(i, RoundingMode.FLOOR);\n+            BigDecimal result = nearFour.sqrt(mc);\n+            BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);\n+            failures += equalNumerically(expected, result, \"near four rounding down\");\n+            failures += (result.compareTo(TWO) < 0) ? 0  : 1 ;\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test around 4.000...1 that the sqrt doesn't improperly\n+     * round-down to a numerical value of 2.\n+     *\/\n+    private static int almostFourRoundingUp() {\n+        int failures = 0;\n+        BigDecimal nearFour = new BigDecimal(\"4.000000000000000000000000000001\");\n+\n+        \/\/ Sqrt is 2.0000....<non-zero digits>\n+\n+        for (int i = 1; i < 64; i++) {\n+            MathContext mc = new MathContext(i, RoundingMode.CEILING);\n+            BigDecimal result = nearFour.sqrt(mc);\n+            BigDecimal expected = BigSquareRoot.sqrt(nearFour, mc);\n+            failures += equalNumerically(expected, result, \"near four rounding up\");\n+            failures += (result.compareTo(TWO) > 0) ? 0  : 1 ;\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int nearTen() {\n+        int failures = 0;\n+\n+         BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n+\n+         BigDecimal near10sq = near10.multiply(near10);\n+\n+         BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n+\n+        for (int i = 10; i < 23; i++) {\n+            MathContext mc = new MathContext(i, RoundingMode.HALF_EVEN);\n+\n+            failures += equalNumerically(BigSquareRoot.sqrt(near10sq_ulp, mc),\n+                                         near10sq_ulp.sqrt(mc),\n+                                         \"near 10 rounding half even\");\n+        }\n+\n+        return failures;\n+    }\n+\n+\n+    \/*\n+     * Probe for rounding failures near a power of ten, 1 = 10^0,\n+     * where an ulp has a different size above and below the value.\n+     *\/\n+    private static int nearOne() {\n+        int failures = 0;\n+\n+         BigDecimal near1 = new BigDecimal(\".999999999999999999999\");\n+         BigDecimal near1sq = near1.multiply(near1);\n+         BigDecimal near1sq_ulp = near1sq.add(near1sq.ulp());\n+\n+         for (int i = 10; i < 23; i++) {\n+             for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,\n+                                            RoundingMode.UP,\n+                                            RoundingMode.DOWN )) {\n+                 MathContext mc = new MathContext(i, rm);\n+                 failures += equalNumerically(BigSquareRoot.sqrt(near1sq_ulp, mc),\n+                                              near1sq_ulp.sqrt(mc),\n+                                              mc.toString());\n+             }\n+         }\n+\n+         return failures;\n+    }\n+\n+\n+    private static int halfWay() {\n+        int failures = 0;\n+\n+        \/*\n+         * Use enough digits that the exact result cannot be computed\n+         * from the sqrt of a double.\n+         *\/\n+        BigDecimal[] halfWayCases = {\n+            \/\/ Odd next digit, truncate on HALF_EVEN\n+            new BigDecimal(\"123456789123456789.5\"),\n+\n+             \/\/ Even next digit, round up on HALF_EVEN\n+            new BigDecimal(\"123456789123456788.5\"),\n+        };\n+\n+        for (BigDecimal halfWayCase : halfWayCases) {\n+            \/\/ Round result to next-to-last place\n+            int precision = halfWayCase.precision() - 1;\n+            BigDecimal square = halfWayCase.multiply(halfWayCase);\n+\n+            for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,\n+                                           RoundingMode.HALF_UP,\n+                                           RoundingMode.HALF_DOWN)) {\n+                MathContext mc = new MathContext(precision, rm);\n+\n+                System.out.println(\"\\nRounding mode \" + rm);\n+                System.out.println(\"\\t\" + halfWayCase.round(mc) + \"\\t\" + halfWayCase);\n+                System.out.println(\"\\t\" + BigSquareRoot.sqrt(square, mc));\n+\n+                failures += equalNumerically(\/*square.sqrt(mc),*\/\n+                                             BigSquareRoot.sqrt(square, mc),\n+                                             halfWayCase.round(mc),\n+                                             \"Rounding halway \" + rm);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -227,0 +440,301 @@\n+    \/**\n+     * Alternative implementation of BigDecimal square root which uses\n+     * higher-precision for a simpler set of termination conditions\n+     * for the Newton iteration.\n+     *\/\n+    private static class BigSquareRoot {\n+\n+        \/**\n+         * The value 0.5, with a scale of 1.\n+         *\/\n+        private static final BigDecimal ONE_HALF = valueOf(5L, 1);\n+\n+        public static boolean isPowerOfTen(BigDecimal bd) {\n+            return BigInteger.ONE.equals(bd.unscaledValue());\n+        }\n+\n+        public static BigDecimal square(BigDecimal bd) {\n+            return bd.multiply(bd);\n+        }\n+\n+        public static BigDecimal sqrt(BigDecimal bd, MathContext mc) {\n+            int signum = bd.signum();\n+            if (signum == 1) {\n+                \/*\n+                 * The following code draws on the algorithm presented in\n+                 * \"Properly Rounded Variable Precision Square Root,\" Hull and\n+                 * Abrham, ACM Transactions on Mathematical Software, Vol 11,\n+                 * No. 3, September 1985, Pages 229-237.\n+                 *\n+                 * The BigDecimal computational model differs from the one\n+                 * presented in the paper in several ways: first BigDecimal\n+                 * numbers aren't necessarily normalized, second many more\n+                 * rounding modes are supported, including UNNECESSARY, and\n+                 * exact results can be requested.\n+                 *\n+                 * The main steps of the algorithm below are as follows,\n+                 * first argument reduce the value to the numerical range\n+                 * [1, 10) using the following relations:\n+                 *\n+                 * x = y * 10 ^ exp\n+                 * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n+                 * sqrt(x) = sqrt(y\/10) * 10 ^((exp+1)\/2) is exp is odd\n+                 *\n+                 * Then use Newton's iteration on the reduced value to compute\n+                 * the numerical digits of the desired result.\n+                 *\n+                 * Finally, scale back to the desired exponent range and\n+                 * perform any adjustment to get the preferred scale in the\n+                 * representation.\n+                 *\/\n+\n+                \/\/ The code below favors relative simplicity over checking\n+                \/\/ for special cases that could run faster.\n+\n+                int preferredScale = bd.scale()\/2;\n+                BigDecimal zeroWithFinalPreferredScale =\n+                    BigDecimal.valueOf(0L, preferredScale);\n+\n+                \/\/ First phase of numerical normalization, strip trailing\n+                \/\/ zeros and check for even powers of 10.\n+                BigDecimal stripped = bd.stripTrailingZeros();\n+                int strippedScale = stripped.scale();\n+\n+                \/\/ Numerically sqrt(10^2N) = 10^N\n+                if (isPowerOfTen(stripped) &&\n+                    strippedScale % 2 == 0) {\n+                    BigDecimal result = BigDecimal.valueOf(1L, strippedScale\/2);\n+                    if (result.scale() != preferredScale) {\n+                        \/\/ Adjust to requested precision and preferred\n+                        \/\/ scale as appropriate.\n+                        result = result.add(zeroWithFinalPreferredScale, mc);\n+                    }\n+                    return result;\n+                }\n+\n+                \/\/ After stripTrailingZeros, the representation is normalized as\n+                \/\/\n+                \/\/ unscaledValue * 10^(-scale)\n+                \/\/\n+                \/\/ where unscaledValue is an integer with the mimimum\n+                \/\/ precision for the cohort of the numerical value. To\n+                \/\/ allow binary floating-point hardware to be used to get\n+                \/\/ approximately a 15 digit approximation to the square\n+                \/\/ root, it is helpful to instead normalize this so that\n+                \/\/ the significand portion is to right of the decimal\n+                \/\/ point by roughly (scale() - precision() + 1).\n+\n+                \/\/ Now the precision \/ scale adjustment\n+                int scaleAdjust = 0;\n+                int scale = stripped.scale() - stripped.precision() + 1;\n+                if (scale % 2 == 0) {\n+                    scaleAdjust = scale;\n+                } else {\n+                    scaleAdjust = scale - 1;\n+                }\n+\n+                BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n+\n+                assert  \/\/ Verify 0.1 <= working < 10\n+                    ONE_TENTH.compareTo(working) <= 0 && working.compareTo(TEN) < 0;\n+\n+                \/\/ Use good ole' Math.sqrt to get the initial guess for\n+                \/\/ the Newton iteration, good to at least 15 decimal\n+                \/\/ digits. This approach does incur the cost of a\n+                \/\/\n+                \/\/ BigDecimal -> double -> BigDecimal\n+                \/\/\n+                \/\/ conversion cycle, but it avoids the need for several\n+                \/\/ Newton iterations in BigDecimal arithmetic to get the\n+                \/\/ working answer to 15 digits of precision. If many fewer\n+                \/\/ than 15 digits were needed, it might be faster to do\n+                \/\/ the loop entirely in BigDecimal arithmetic.\n+                \/\/\n+                \/\/ (A double value might have as much many as 17 decimal\n+                \/\/ digits of precision; it depends on the relative density\n+                \/\/ of binary and decimal numbers at different regions of\n+                \/\/ the number line.)\n+                \/\/\n+                \/\/ (It would be possible to check for certain special\n+                \/\/ cases to avoid doing any Newton iterations. For\n+                \/\/ example, if the BigDecimal -> double conversion was\n+                \/\/ known to be exact and the rounding mode had a\n+                \/\/ low-enough precision, the post-Newton rounding logic\n+                \/\/ could be applied directly.)\n+\n+                BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));\n+                int guessPrecision = 15;\n+                int originalPrecision = mc.getPrecision();\n+                int targetPrecision;\n+\n+                \/\/ If an exact value is requested, it must only need\n+                \/\/ about half of the input digits to represent since\n+                \/\/ multiplying an N digit number by itself yield a (2N\n+                \/\/ - 1) digit or 2N digit result.\n+                if (originalPrecision == 0) {\n+                    targetPrecision = stripped.precision()\/2 + 1;\n+                } else {\n+                    targetPrecision = originalPrecision;\n+                }\n+\n+                \/\/ When setting the precision to use inside the Newton\n+                \/\/ iteration loop, take care to avoid the case where the\n+                \/\/ precision of the input exceeds the requested precision\n+                \/\/ and rounding the input value too soon.\n+                BigDecimal approx = guess;\n+                int workingPrecision = working.precision();\n+                \/\/ Use \"2p + 2\" property to guarantee enough\n+                \/\/ intermediate precision so that a double-rounding\n+                \/\/ error does not occur when rounded to the final\n+                \/\/ destination precision.\n+                int loopPrecision =\n+                    Math.max(2 * Math.max(targetPrecision, workingPrecision) + 2,\n+                             34); \/\/ Force at least two Netwon\n+                                  \/\/ iterations on the Math.sqrt\n+                                  \/\/ result.\n+                do {\n+                    MathContext mcTmp = new MathContext(loopPrecision, RoundingMode.HALF_EVEN);\n+                    \/\/ approx = 0.5 * (approx + fraction \/ approx)\n+                    approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));\n+                    guessPrecision *= 2;\n+                } while (guessPrecision < loopPrecision);\n+\n+                BigDecimal result;\n+                RoundingMode targetRm = mc.getRoundingMode();\n+                if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {\n+                    RoundingMode tmpRm =\n+                        (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;\n+                    MathContext mcTmp = new MathContext(targetPrecision, tmpRm);\n+                    result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mcTmp);\n+\n+                    \/\/ If result*result != this numerically, the square\n+                    \/\/ root isn't exact\n+                    if (bd.subtract(square(result)).compareTo(ZERO) != 0) {\n+                        throw new ArithmeticException(\"Computed square root not exact.\");\n+                    }\n+                } else {\n+                    result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mc);\n+                }\n+\n+                assert squareRootResultAssertions(bd, result, mc);\n+                if (result.scale() != preferredScale) {\n+                    \/\/ The preferred scale of an add is\n+                    \/\/ max(addend.scale(), augend.scale()). Therefore, if\n+                    \/\/ the scale of the result is first minimized using\n+                    \/\/ stripTrailingZeros(), adding a zero of the\n+                    \/\/ preferred scale rounding the correct precision will\n+                    \/\/ perform the proper scale vs precision tradeoffs.\n+                    result = result.stripTrailingZeros().\n+                        add(zeroWithFinalPreferredScale,\n+                            new MathContext(originalPrecision, RoundingMode.UNNECESSARY));\n+                }\n+                return result;\n+            } else {\n+                switch (signum) {\n+                case -1:\n+                    throw new ArithmeticException(\"Attempted square root \" +\n+                                                  \"of negative BigDecimal\");\n+                case 0:\n+                    return valueOf(0L, bd.scale()\/2);\n+\n+                default:\n+                    throw new AssertionError(\"Bad value from signum\");\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * For nonzero values, check numerical correctness properties of\n+         * the computed result for the chosen rounding mode.\n+         *\n+         * For the directed roundings, for DOWN and FLOOR, result^2 must\n+         * be {@code <=} the input and (result+ulp)^2 must be {@code >} the\n+         * input. Conversely, for UP and CEIL, result^2 must be {@code >=} the\n+         * input and (result-ulp)^2 must be {@code <} the input.\n+         *\/\n+        private static boolean squareRootResultAssertions(BigDecimal input, BigDecimal result, MathContext mc) {\n+            if (result.signum() == 0) {\n+                return squareRootZeroResultAssertions(input, result, mc);\n+            } else {\n+                RoundingMode rm = mc.getRoundingMode();\n+                BigDecimal ulp = result.ulp();\n+                BigDecimal neighborUp   = result.add(ulp);\n+                \/\/ Make neighbor down accurate even for powers of ten\n+                if (isPowerOfTen(result)) {\n+                    ulp = ulp.divide(TEN);\n+                }\n+                BigDecimal neighborDown = result.subtract(ulp);\n+\n+                \/\/ Both the starting value and result should be nonzero and positive.\n+                if (result.signum() != 1 ||\n+                    input.signum() != 1) {\n+                    return false;\n+                }\n+\n+                switch (rm) {\n+                case DOWN:\n+                case FLOOR:\n+                    assert\n+                        square(result).compareTo(input)    <= 0 &&\n+                        square(neighborUp).compareTo(input) > 0:\n+                    \"Square of result out for bounds rounding \" + rm;\n+                    return true;\n+\n+                case UP:\n+                case CEILING:\n+                    assert\n+                        square(result).compareTo(input) >= 0 :\n+                    \"Square of result too small rounding \" + rm;\n+\n+                    assert\n+                        square(neighborDown).compareTo(input) < 0 :\n+                    \"Square of down neighbor too large rounding  \" + rm + \"\\n\" +\n+                        \"\\t input: \" + input + \"\\t neighborDown: \" +  neighborDown +\"\\t sqrt: \" + result +\n+                        \"\\t\" + mc;\n+                    return true;\n+\n+\n+                case HALF_DOWN:\n+                case HALF_EVEN:\n+                case HALF_UP:\n+                    BigDecimal err = square(result).subtract(input).abs();\n+                    BigDecimal errUp = square(neighborUp).subtract(input);\n+                    BigDecimal errDown =  input.subtract(square(neighborDown));\n+                    \/\/ All error values should be positive so don't need to\n+                    \/\/ compare absolute values.\n+\n+                    int err_comp_errUp = err.compareTo(errUp);\n+                    int err_comp_errDown = err.compareTo(errDown);\n+\n+                    assert\n+                        errUp.signum()   == 1 &&\n+                        errDown.signum() == 1 :\n+                    \"Errors of neighbors squared don't have correct signs\";\n+\n+                    \/\/ At least one of these must be true, but not both\n+\/\/                     assert\n+\/\/                         err_comp_errUp   <= 0 : \"Upper neighbor is closer than result: \" + rm +\n+\/\/                         \"\\t\" + input + \"\\t result\" + result;\n+\/\/                     assert\n+\/\/                         err_comp_errDown <= 0 : \"Lower neighbor is closer than result: \" + rm +\n+\/\/                         \"\\t\" + input + \"\\t result \" + result + \"\\t lower neighbor: \" + neighborDown;\n+\n+                    assert\n+                        ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n+                        ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n+                            \"Incorrect error relationships\";\n+                        \/\/ && could check for digit conditions for ties too\n+                        return true;\n+\n+                default: \/\/ Definition of UNNECESSARY already verified.\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private static boolean squareRootZeroResultAssertions(BigDecimal input,\n+                                                              BigDecimal result,\n+                                                              MathContext mc) {\n+            return input.compareTo(ZERO) == 0;\n+        }\n+    }\n@@ -228,0 +742,1 @@\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":534,"deletions":19,"binary":false,"changes":553,"status":"modified"}]}