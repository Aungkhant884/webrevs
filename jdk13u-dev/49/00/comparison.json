{"files":[{"patch":"@@ -4283,0 +4283,58 @@\n+static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {\n+  \/\/ Get required buffer size to convert to Unicode\n+  int unicode_path_len = MultiByteToWideChar(CP_THREAD_ACP,\n+                                             MB_ERR_INVALID_CHARS,\n+                                             char_path, -1,\n+                                             NULL, 0);\n+  if (unicode_path_len == 0) {\n+    return EINVAL;\n+  }\n+\n+  *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);\n+\n+  int result = MultiByteToWideChar(CP_THREAD_ACP,\n+                                   MB_ERR_INVALID_CHARS,\n+                                   char_path, -1,\n+                                   *unicode_path, unicode_path_len);\n+  assert(result == unicode_path_len, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+static errno_t get_full_path(LPCWSTR unicode_path, LPWSTR* full_path) {\n+  \/\/ Get required buffer size to convert to full path. The return\n+  \/\/ value INCLUDES the terminating null character.\n+  DWORD full_path_len = GetFullPathNameW(unicode_path, 0, NULL, NULL);\n+  if (full_path_len == 0) {\n+    return EINVAL;\n+  }\n+\n+  *full_path = NEW_C_HEAP_ARRAY(WCHAR, full_path_len, mtInternal);\n+\n+  \/\/ When the buffer has sufficient size, the return value EXCLUDES the\n+  \/\/ terminating null character\n+  DWORD result = GetFullPathNameW(unicode_path, full_path_len, *full_path, NULL);\n+  assert(result <= full_path_len, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+static void set_path_prefix(char* buf, LPWSTR* prefix, int* prefix_off, bool* needs_fullpath) {\n+  *prefix_off = 0;\n+  *needs_fullpath = true;\n+\n+  if (::isalpha(buf[0]) && !::IsDBCSLeadByte(buf[0]) && buf[1] == ':' && buf[2] == '\\\\') {\n+    *prefix = L\"\\\\\\\\?\\\\\";\n+  } else if (buf[0] == '\\\\' && buf[1] == '\\\\') {\n+    if (buf[2] == '?' && buf[3] == '\\\\') {\n+      *prefix = L\"\";\n+      *needs_fullpath = false;\n+    } else {\n+      *prefix = L\"\\\\\\\\?\\\\UNC\";\n+      *prefix_off = 1; \/\/ Overwrite the first char with the prefix, so \\\\share\\path becomes \\\\?\\UNC\\share\\path\n+    }\n+  } else {\n+    *prefix = L\"\\\\\\\\?\\\\\";\n+  }\n+}\n+\n@@ -4285,3 +4343,3 @@\n-\/\/ additional_space is the number of additionally allocated wchars after the terminating L'\\0'.\n-\/\/ This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for\n-\/\/ short paths.\n+\/\/ additional_space is the size of space, in wchar_t, the function will additionally add to\n+\/\/ the allocation of return buffer (such that the size of the returned buffer is at least\n+\/\/ wcslen(buf) + 1 + additional_space).\n@@ -4294,1 +4352,0 @@\n-  size_t path_len = strlen(path);\n@@ -4296,2 +4353,16 @@\n-  char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);\n-  wchar_t* result = NULL;\n+  size_t buf_len = 1 + MAX2((size_t)3, strlen(path));\n+  char* buf = NEW_C_HEAP_ARRAY(char, buf_len, mtInternal);\n+  strncpy(buf, path, buf_len);\n+  os::native_path(buf);\n+\n+  LPWSTR prefix = NULL;\n+  int prefix_off = 0;\n+  bool needs_fullpath = true;\n+  set_path_prefix(buf, &prefix, &prefix_off, &needs_fullpath);\n+\n+  LPWSTR unicode_path = NULL;\n+  err = convert_to_unicode(buf, &unicode_path);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+  if (err != ERROR_SUCCESS) {\n+    return NULL;\n+  }\n@@ -4299,2 +4370,3 @@\n-  if (buf == NULL) {\n-    err = ENOMEM;\n+  LPWSTR converted_path = NULL;\n+  if (needs_fullpath) {\n+    err = get_full_path(unicode_path, &converted_path);\n@@ -4302,22 +4374,2 @@\n-    memcpy(buf, path, path_len + 1);\n-    os::native_path(buf);\n-\n-    wchar_t* prefix;\n-    int prefix_off = 0;\n-    bool is_abs = true;\n-    bool needs_fullpath = true;\n-\n-    if (::isalpha(buf[0]) && !::IsDBCSLeadByte(buf[0]) && buf[1] == ':' && buf[2] == '\\\\') {\n-      prefix = L\"\\\\\\\\?\\\\\";\n-    } else if (buf[0] == '\\\\' && buf[1] == '\\\\') {\n-      if (buf[2] == '?' && buf[3] == '\\\\') {\n-        prefix = L\"\";\n-        needs_fullpath = false;\n-      } else {\n-        prefix = L\"\\\\\\\\?\\\\UNC\";\n-        prefix_off = 1; \/\/ Overwrite the first char with the prefix, so \\\\share\\path becomes \\\\?\\UNC\\share\\path\n-      }\n-    } else {\n-      is_abs = false;\n-      prefix = L\"\\\\\\\\?\\\\\";\n-    }\n+    converted_path = unicode_path;\n+  }\n@@ -4325,1 +4377,2 @@\n-    size_t buf_len = strlen(buf);\n+  LPWSTR result = NULL;\n+  if (converted_path != NULL) {\n@@ -4327,37 +4380,9 @@\n-    size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;\n-    size_t result_size = prefix_len + full_path_size - prefix_off;\n-    result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);\n-\n-    if (result == NULL) {\n-      err = ENOMEM;\n-    } else {\n-      size_t converted_chars;\n-      wchar_t* path_start = result + prefix_len - prefix_off;\n-      err = ::mbstowcs_s(&converted_chars, path_start, buf_len + 1, buf, buf_len);\n-\n-      if ((err == ERROR_SUCCESS) && needs_fullpath) {\n-        wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);\n-\n-        if (tmp == NULL) {\n-          err = ENOMEM;\n-        } else {\n-          if (!_wfullpath(tmp, path_start, full_path_size)) {\n-            err = ENOENT;\n-          } else {\n-            ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));\n-          }\n-\n-          os::free(tmp);\n-        }\n-      }\n-\n-      memcpy(result, prefix, sizeof(wchar_t) * prefix_len);\n-\n-      \/\/ Remove trailing pathsep (not for \\\\?\\<DRIVE>:\\, since it would make it relative)\n-      size_t result_len = wcslen(result);\n-\n-      if (result[result_len - 1] == L'\\\\') {\n-        if (!(::iswalpha(result[4]) && result[5] == L':' && result_len == 7)) {\n-          result[result_len - 1] = L'\\0';\n-        }\n-      }\n+    size_t result_len = prefix_len - prefix_off + wcslen(converted_path) + additional_space + 1;\n+    result = NEW_C_HEAP_ARRAY(WCHAR, result_len, mtInternal);\n+    _snwprintf(result, result_len, L\"%s%s\", prefix, &converted_path[prefix_off]);\n+\n+    \/\/ Remove trailing pathsep (not for \\\\?\\<DRIVE>:\\, since it would make it relative)\n+    result_len = wcslen(result);\n+    if ((result[result_len - 1] == L'\\\\') &&\n+        !(::iswalpha(result[4]) && result[5] == L':' && result_len == 7)) {\n+      result[result_len - 1] = L'\\0';\n@@ -4367,5 +4392,2 @@\n-  os::free(buf);\n-\n-  if (err != ERROR_SUCCESS) {\n-    os::free(result);\n-    result = NULL;\n+  if (converted_path != unicode_path) {\n+    FREE_C_HEAP_ARRAY(WCHAR, converted_path);\n@@ -4373,0 +4395,1 @@\n+  FREE_C_HEAP_ARRAY(WCHAR, unicode_path);\n@@ -4374,1 +4397,1 @@\n-  return result;\n+  return static_cast<wchar_t*>(result); \/\/ LPWSTR and wchat_t* are the same type on Windows.\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":97,"deletions":74,"binary":false,"changes":171,"status":"modified"}]}