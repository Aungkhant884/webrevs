{"files":[{"patch":"@@ -882,1 +882,1 @@\n-\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n@@ -1517,0 +1517,1 @@\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3847,1 +3847,2 @@\n-\/\/ Indicate whether it is safe to recreate VM\n+\/\/ Indicate whether it is safe to recreate VM. Recreation is only\n+\/\/ possible after a failed initial creation attempt in some cases.\n@@ -3917,0 +3918,6 @@\n+\n+  \/\/ If a previous creation attempt failed but can be retried safely,\n+  \/\/ then safe_to_recreate_vm will have been reset to 1 after being\n+  \/\/ cleared here. If a previous creation attempt succeeded and we then\n+  \/\/ destroyed that VM, we will be prevented from trying to recreate\n+  \/\/ the VM in the same process, as the value will still be 0.\n@@ -3918,1 +3925,1 @@\n-    return JNI_ERR;  \/\/ someone tried and failed and retry not allowed.\n+    return JNI_ERR;\n@@ -4111,3 +4118,8 @@\n-    \/\/ If the thread has been attached this operation is a no-op\n-    *(JNIEnv**)penv = ((JavaThread*) t)->jni_environment();\n-    return JNI_OK;\n+    \/\/ If executing from an atexit hook we may be in the VMThread.\n+    if (t->is_Java_thread()) {\n+      \/\/ If the thread has been attached this operation is a no-op\n+      *(JNIEnv**)penv = ((JavaThread*) t)->jni_environment();\n+      return JNI_OK;\n+    } else {\n+      return JNI_ERR;\n+    }\n@@ -4212,1 +4224,1 @@\n-  HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);\n+    HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);\n@@ -4225,0 +4237,4 @@\n+  if (vm_created == 0) {\n+    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);\n+    return JNI_ERR;\n+  }\n@@ -4228,0 +4244,2 @@\n+  Thread* current = Thread::current_or_null();\n+\n@@ -4229,1 +4247,1 @@\n-  if (Thread::current_or_null() == NULL) {\n+  if (current == NULL) {\n@@ -4234,0 +4252,6 @@\n+  \/\/ If executing from an atexit hook we may be in the VMThread.\n+  if (!current->is_Java_thread()) {\n+    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);\n+    return JNI_ERR;\n+  }\n+\n@@ -4236,1 +4260,1 @@\n-  JavaThread* thread = JavaThread::current();\n+  JavaThread* thread = (JavaThread*) current;\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8238676\n+ * @summary Check that attempting to use the JNI invocation API from an\n+ *          atexit handler fails as expected without crashing.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestAtExit\n+ *\/\n+\n+public class TestAtExit {\n+\n+    \/\/ Using a nested class that invokes an enclosing method makes it\n+    \/\/ easier to setup and use the native library.\n+    static class Tester {\n+        static {\n+            System.loadLibrary(\"atExit\");\n+        }\n+\n+        \/\/ Record the fact we are using System.exit for termination\n+        static native void setUsingSystemExit();\n+\n+        public static void main(String[] args) throws Exception {\n+            if (args.length > 0) {\n+                setUsingSystemExit();\n+                System.exit(0);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ We mustn't load Tester in this VM so we exec by name.\n+        String main = \"TestAtExit$Tester\";\n+\n+        String jlp = \"-Djava.library.path=\" + System.getProperty(\"test.nativepath\");\n+        \/\/ First run will terminate via DestroyJavaVM\n+        OutputAnalyzer output = ProcessTools.executeTestJvm(jlp, main);\n+        output.shouldNotContain(\"Unexpected\");\n+        output.shouldHaveExitValue(0);\n+        output.reportDiagnosticSummary();\n+\n+        \/\/ Second run will terminate via System.exit()\n+        output = ProcessTools.executeTestJvm(jlp, main, \"doExit\");\n+        output.shouldNotContain(\"Unexpected\");\n+        output.shouldHaveExitValue(0);\n+        output.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/atExit\/TestAtExit.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static JavaVM *jvm;\n+\n+static const char* jni_error_code(int ret) {\n+  switch(ret) {\n+  case JNI_OK: return \"JNI_OK\";\n+  case JNI_ERR: return \"JNI_ERR\";\n+  case JNI_EDETACHED: return \"JNI_EDETACHED\";\n+  case JNI_EVERSION: return \"JNI_EVERSION\";\n+  case JNI_ENOMEM: return \"JNI_ENOMEM\";\n+  case JNI_EEXIST: return \"JNI_EEXIST\";\n+  case JNI_EINVAL: return \"JNI_EINVAL\";\n+  default: return \"Invalid JNI error code\";\n+  }\n+}\n+\n+static void report(const char* func, int ret_actual, int ret_expected) {\n+  const char* ret = jni_error_code(ret_actual);\n+  if (ret_actual == ret_expected) {\n+    printf(\"%s returned %s as expected\\n\", func, ret);\n+  } else {\n+    printf(\"Unexpected JNI return code %s from %s\\n\", ret, func);\n+  }\n+}\n+\n+static int using_system_exit = 0; \/\/ Not System.exit by default\n+\n+JNIEXPORT\n+void JNICALL Java_TestAtExit_00024Tester_setUsingSystemExit(JNIEnv* env, jclass c) {\n+  using_system_exit = 1;\n+}\n+\n+void at_exit_handler(void) {\n+  printf(\"In at_exit_handler\\n\");\n+\n+  \/\/ We've saved the JavaVM from OnLoad time so we first try to\n+  \/\/ get a JNIEnv for the current thread.\n+  JNIEnv *env;\n+  jint res = (*jvm)->GetEnv(jvm, (void **)&env, JNI_VERSION_1_2);\n+  report(\"GetEnv\", res, JNI_EDETACHED);\n+  if (res == JNI_EDETACHED) {\n+\n+    \/\/ Test all of the Invocation API functions\n+\n+    res = (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, NULL);\n+    report(\"AttachCurrentThreadAsDaemon\", res, JNI_ERR);\n+    res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+    report(\"AttachCurrentThread\", res, JNI_ERR);\n+    res = (*jvm)->DetachCurrentThread(jvm);\n+    report(\"DetachCurrentThread\", res, JNI_ERR);\n+\n+    JavaVMInitArgs args;\n+    args.version = JNI_VERSION_1_2;\n+    res = JNI_GetDefaultJavaVMInitArgs(&args);\n+    report(\"JNI_GetDefaultJavaVMInitArgs\", res, JNI_OK);\n+\n+    JavaVM* jvm_p[1];\n+    int nVMs;\n+    res = JNI_GetCreatedJavaVMs(jvm_p, 1, &nVMs);\n+    report(\"JNI_GetCreatedJavaVMs\", res, JNI_OK);\n+    \/\/ Whether nVMs is 0 or 1 depends on the termination path\n+    if (nVMs == 0 && !using_system_exit) {\n+      printf(\"Found 0 created VMs as expected\\n\");\n+    } else if (nVMs == 1 && using_system_exit) {\n+      printf(\"Found 1 created VM as expected\\n\");\n+    } else {\n+      printf(\"Unexpected number of created VMs: %d\\n\", nVMs);\n+    }\n+\n+    res = (*jvm)->DestroyJavaVM(jvm);\n+    report(\"DestroyJavaVM\", res, JNI_ERR);\n+\n+    \/\/ Failure mode depends on the termination path\n+    res = JNI_CreateJavaVM(jvm_p, (void**)&env, &args);\n+    report(\"JNI_CreateJavaVM\", res, using_system_exit ? JNI_EEXIST : JNI_ERR);\n+  }\n+  \/\/ else test has already failed\n+}\n+\n+jint JNI_OnLoad(JavaVM *vm, void *reserved) {\n+  printf(\"JNI_OnLoad: registering atexit handler\\n\");\n+  jvm = vm;\n+  atexit(at_exit_handler);\n+\n+  return JNI_VERSION_1_1;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/atExit\/libatExit.c","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}