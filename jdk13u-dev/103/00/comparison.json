{"files":[{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/Steal\/steal001\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress gc\n- *\n- * @summary converted from VM Testbase gc\/gctests\/Steal\/steal001.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that Garbage Collector correctly uses stealing technique:\n- *     no unexpected exceptions and errors are thrown; the JVM is not crashed.\n- *     Actually, the test is intended for Parallel Collector.\n- *     The test starts just one thread and fills the memory with NonbranyTrees\n- *     (the number of nodes of the tree and its size are based on\n- *     Runtime.maxMemory() value) until OutOfMemoryError is thrown. All references\n- *     to the trees are saved in a java.util.Vector. Then the test removes a\n- *     number of trees from the vector, this number is equal to number of\n- *     processors (returned by nsk.share.gc.Algorithms.availableProcessors()).\n- *     Algorithms.eatMemory(int) is invoked after that to provoke GC to clean the\n- *     memory. Then procedure is repeated.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.Steal.steal001.steal001\n- *\/\n-\n-package gc.gctests.Steal.steal001;\n-\n-import java.util.*;\n-import java.util.concurrent.ThreadLocalRandom;\n-import nsk.share.gc.*;\n-import nsk.share.gc.gp.GarbageUtils;\n-import nsk.share.test.ExecutionController;\n-\n-public class steal001 extends ThreadedGCTest {\n-    \/\/ Preload ThreadLocalRandom class to avoid class initialization failure\n-    \/\/ due to OOM error in static class initializer\n-    final static public ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n-\n-    \/\/ Internal number of iterations to remove and create new elements\n-    \/\/ for the vector\n-    final static int INTERNAL_ITERATIONS = 10;\n-    \/\/ Approximate number of trees to fill the heap with\n-    final static int TREES = 50;\n-    \/\/ Number of nodes for each tree\n-    final static int NODES = 500;\n-\n-    private class Eater implements Runnable {\n-\n-        private int nodeSize;\n-        private List<NonbranchyTree> list;\n-        int processors = Runtime.getRuntime().availableProcessors();\n-        ExecutionController stresser;\n-\n-        public Eater(int nodeSize) {\n-            list = new ArrayList<>();\n-            this.nodeSize = nodeSize;\n-        }\n-\n-        @Override\n-        public void run() {\n-            if (stresser == null) {\n-                stresser = getExecutionController();\n-            }\n-            int counter = NODES;\n-            while (stresser.continueExecution()) {\n-                fillHeap(counter);\n-                removeElements();\n-                counter = (counter == 1) ? 1 : counter - 1;\n-            }\n-        }\n-\n-        \/\/ Fill the memory with trees of defined size until OutOfMemoryError\n-        private void fillHeap(int n) {\n-            try {\n-                while (stresser.continueExecution()) {\n-                    \/\/ Passing in the ExecutionController to make sure we\n-                    \/\/ stop allocating nodes when time is up.\n-                    list.add(new NonbranchyTree(n, 0.3f, nodeSize, stresser));\n-                }\n-            } catch (OutOfMemoryError e) {\n-            }\n-        }\n-\n-        \/\/ Remove a number of elements (equal to number of processors) from the\n-        \/\/ vector and provoke GC to clean the heap\n-        private void removeElements() {\n-            if (list.size() <= 0) {\n-                return;\n-            }\n-            list.remove(0);\n-            GarbageUtils.eatMemory(stresser);\n-        }\n-    }\n-\n-    @Override\n-    protected Runnable createRunnable(int i) {\n-        \/\/ Perform calculations specific to the test\n-        double treeSize = Runtime.getRuntime().maxMemory() \/ TREES;\n-        int nodeSize = (int) (treeSize \/ NODES - NonbranchyTree.MIN_NODE_SIZE);\n-        nodeSize = Math.max(1, nodeSize);\n-        return new Eater(nodeSize);\n-    }\n-\n-    public static void main(String args[]) {\n-        \/\/ just to preload GarbageUtils and avoid exception\n-        \/\/ in removeElements()\n-        GarbageUtils.getGarbageProducers();\n-        GC.runTest(new steal001(), args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/Steal\/steal001\/steal001.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/Steal\/steal002\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress gc\n- *\n- * @summary converted from VM Testbase gc\/gctests\/Steal\/steal002.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that Garbage Collector correctly uses stealing technique:\n- *     no unexpected exceptions and errors are thrown; the JVM is not crashed.\n- *     Actually, the test is intended for Parallel Collector.\n- *     The test starts just one thread, then creates a small NonbranyTree and a\n- *     huge one. Both trees are to fill about 80% of the memory. Then the test\n- *     drops references to both trees and invoke Algorithms.eatMemory(int) to\n- *     provoke GC to clean the memory. the GC should correctly remove both\n- *     objects. If the GC is Parallel, there are more than one GC threads, so one\n- *     will try to \"steal\" some job from others.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.Steal.steal002.steal002\n- *\/\n-\n-package gc.gctests.Steal.steal002;\n-\n-import nsk.share.gc.*;\n-import nsk.share.test.ExecutionController;\n-import nsk.share.test.Stresser;\n-\n-public class steal002 extends GCTestBase {\n-\n-    ExecutionController stresser;\n-    \/\/ Number of nodes for the small tree\n-    final static int SMALL_NODES = 10;\n-    \/\/ Size (in bytes) for a node of the small tree\n-    final static int SMALL_NODE_SIZE = 1;\n-    \/\/ Number of nodes for the huge tree\n-    final static int HUGE_NODES = 500;\n-    \/\/ Part of the heap to fill with both trees\n-    final static double PART_OF_HEAP = 0.8;\n-    final int hugeNodeSize;\n-    public static NonbranchyTree smallTree;\n-    public static NonbranchyTree hugeTree;\n-\n-    @Override\n-    public void run() {\n-        if (stresser == null) {\n-            stresser = new Stresser(runParams.getStressOptions());\n-            stresser.start(runParams.getIterations());\n-        }\n-        while (stresser.continueExecution()) {\n-            \/\/ Create a small tree and a huge one. Then drop references\n-            \/\/ to both of them.\n-            smallTree = new NonbranchyTree(SMALL_NODES, 0.3f, SMALL_NODE_SIZE);\n-            hugeTree = new NonbranchyTree(HUGE_NODES, 0.3f, hugeNodeSize);\n-\n-            \/\/ Drop references to both trees and provoke GC to clean\n-            \/\/ the memory\n-            hugeTree = null;\n-            smallTree = null;\n-\n-            \/\/ Provoke GC to clean the memory\n-            Algorithms.eatMemory(stresser);\n-        }\n-    }\n-\n-    public steal002() {\n-        hugeNodeSize = Math.max(1, (int) (PART_OF_HEAP * Runtime.getRuntime().maxMemory() \/ HUGE_NODES\n-                - NonbranchyTree.MIN_NODE_SIZE));\n-    }\n-\n-    public static void main(String args[]) {\n-        GC.runTest(new steal002(), args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/Steal\/steal002\/steal002.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"}]}