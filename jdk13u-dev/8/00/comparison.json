{"files":[{"patch":"@@ -32,0 +32,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -73,1 +76,1 @@\n-             Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n@@ -107,1 +110,1 @@\n-             Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n@@ -125,0 +128,19 @@\n+    static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -93,5 +96,3 @@\n-        try(BufferedReader bufferedReader = Files.newBufferedReader(Paths.get(subsystem.path(), parm))) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        }\n-        catch (IOException e) {\n+        try {\n+            return subsystem.readStringValue(parm);\n+        } catch (IOException e) {\n@@ -100,0 +101,1 @@\n+    }\n@@ -101,0 +103,11 @@\n+    private String readStringValue(String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            Metrics.unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n@@ -109,2 +122,2 @@\n-            List<String> lines = Files.readAllLines(Paths.get(subsystem.path(), param));\n-            for (String line: lines) {\n+            List<String> lines = subsystem.readMatchingLines(param);\n+            for (String line : lines) {\n@@ -122,0 +135,11 @@\n+    private List<String> readMatchingLines(String param) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () ->\n+                    Files.readAllLines(Paths.get(path(), param));\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            Metrics.unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n+    }\n+\n@@ -172,1 +196,1 @@\n-        try (Stream<String> lines = Files.lines(Paths.get(subsystem.path(), parm))) {\n+        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -211,0 +211,2 @@\n+    exports jdk.internal.platform to\n+        jdk.management;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,14 @@\n+\n+JNIEXPORT jdouble JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0\n+(JNIEnv *env, jobject dummy, jint cpu_number)\n+{\n+    return -1.0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,1 @@\n-    static int initialized=1;\n+    static int initialized = 0;\n@@ -205,2 +205,3 @@\n-\n-        int n = sysconf(_SC_NPROCESSORS_ONLN);\n+        \/\/ We need to allocate counters for all CPUs, including ones that\n+        \/\/ are currently offline as they could be turned online later.\n+        int n = sysconf(_SC_NPROCESSORS_CONF);\n@@ -212,0 +213,1 @@\n+        counters.nProcs = n;\n@@ -326,1 +328,1 @@\n-    if(perfInit() == 0) {\n+    if (perfInit() == 0) {\n@@ -337,1 +339,1 @@\n-    if(perfInit() == 0) {\n+    if (perfInit() == 0) {\n@@ -343,0 +345,22 @@\n+\n+JNIEXPORT jdouble JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0\n+(JNIEnv *env, jobject mbean, jint cpu_number)\n+{\n+    if (perfInit() == 0 && cpu_number >= 0 && cpu_number < counters.nProcs) {\n+        return get_cpu_load(cpu_number);\n+    } else {\n+        return -1.0;\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    if (perfInit() == 0) {\n+        return counters.nProcs;\n+    } else {\n+       return -1;\n+    }\n+}\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,14 @@\n+\n+JNIEXPORT jdouble JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0\n+(JNIEnv *env, jobject dummy, jint cpu_number)\n+{\n+    return -1.0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n","filename":"src\/jdk.management\/macosx\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,6 @@\n+ * This interface provides information about the operating environment\n+ * on which the Java virtual machine is running. That might be a native\n+ * operating system, a virtualized operating system environment, or a\n+ * container-managed environment.\n+ *\n+ * <p>\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/OperatingSystemMXBean.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,13 @@\n+JNIEXPORT jdouble JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0\n+(JNIEnv *env, jobject mbean, jint cpu_number)\n+{\n+    return -1.0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n","filename":"src\/jdk.management\/solaris\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -30,0 +31,2 @@\n+\n+import java.util.concurrent.TimeUnit;\n@@ -40,0 +43,3 @@\n+    private static final int MAX_ATTEMPTS_NUMBER = 10;\n+    private final Metrics containerMetrics;\n+\n@@ -42,0 +48,1 @@\n+        this.containerMetrics = jdk.internal.platform.Container.metrics();\n@@ -49,0 +56,11 @@\n+        if (containerMetrics != null) {\n+            long limit = containerMetrics.getMemoryAndSwapLimit();\n+            \/\/ The memory limit metrics is not available if JVM runs on Linux host (not in a docker container)\n+            \/\/ or if a docker container was started without specifying a memory limit (without '--memory='\n+            \/\/ Docker option). In latter case there is no limit on how much memory the container can use and\n+            \/\/ it can use as much memory as the host's OS allows.\n+            long memLimit = containerMetrics.getMemoryLimit();\n+            if (limit >= 0 && memLimit >= 0) {\n+                return limit - memLimit;\n+            }\n+        }\n@@ -53,0 +71,18 @@\n+        if (containerMetrics != null) {\n+            long memSwapLimit = containerMetrics.getMemoryAndSwapLimit();\n+            long memLimit = containerMetrics.getMemoryLimit();\n+            if (memSwapLimit >= 0 && memLimit >= 0) {\n+                for (int attempt = 0; attempt < MAX_ATTEMPTS_NUMBER; attempt++) {\n+                    long memSwapUsage = containerMetrics.getMemoryAndSwapUsage();\n+                    long memUsage = containerMetrics.getMemoryUsage();\n+                    if (memSwapUsage > 0 && memUsage > 0) {\n+                        \/\/ We read \"memory usage\" and \"memory and swap usage\" not atomically,\n+                        \/\/ and it's possible to get the negative value when subtracting these two.\n+                        \/\/ If this happens just retry the loop for a few iterations.\n+                        if ((memSwapUsage - memUsage) >= 0) {\n+                            return memSwapLimit - memLimit - (memSwapUsage - memUsage);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n@@ -61,0 +97,7 @@\n+        if (containerMetrics != null) {\n+            long usage = containerMetrics.getMemoryUsage();\n+            long limit = containerMetrics.getMemoryLimit();\n+            if (usage > 0 && limit >= 0) {\n+                return limit - usage;\n+            }\n+        }\n@@ -65,0 +108,6 @@\n+        if (containerMetrics != null) {\n+            long limit = containerMetrics.getMemoryLimit();\n+            if (limit >= 0) {\n+                return limit;\n+            }\n+        }\n@@ -77,0 +126,39 @@\n+        if (containerMetrics != null) {\n+            long quota = containerMetrics.getCpuQuota();\n+            if (quota > 0) {\n+                long periodLength = containerMetrics.getCpuPeriod();\n+                long numPeriods = containerMetrics.getCpuNumPeriods();\n+                long usageNanos = containerMetrics.getCpuUsage();\n+                if (periodLength > 0 && numPeriods > 0 && usageNanos > 0) {\n+                    long elapsedNanos = TimeUnit.MICROSECONDS.toNanos(periodLength * numPeriods);\n+                    double systemLoad = (double) usageNanos \/ elapsedNanos;\n+                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+                    systemLoad = Math.max(0.0, systemLoad);\n+                    systemLoad = Math.min(1.0, systemLoad);\n+                    return systemLoad;\n+                }\n+                return -1;\n+            } else {\n+                \/\/ If CPU quotas are not active then find the average system load for\n+                \/\/ all online CPUs that are allowed to run this container.\n+\n+                \/\/ If the cpuset is the same as the host's one there is no need to iterate over each CPU\n+                if (isCpuSetSameAsHostCpuSet()) {\n+                    return getSystemCpuLoad0();\n+                } else {\n+                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n+                    if (cpuSet != null && cpuSet.length > 0) {\n+                        double systemLoad = 0.0;\n+                        for (int cpu : cpuSet) {\n+                            double cpuLoad = getSingleCpuLoad0(cpu);\n+                            if (cpuLoad < 0) {\n+                                return -1;\n+                            }\n+                            systemLoad += cpuLoad;\n+                        }\n+                        return systemLoad \/ cpuSet.length;\n+                    }\n+                    return -1;\n+                }\n+            }\n+        }\n@@ -84,0 +172,7 @@\n+    private boolean isCpuSetSameAsHostCpuSet() {\n+        if (containerMetrics != null) {\n+            return containerMetrics.getCpuSetCpus().length == getHostConfiguredCpuCount0();\n+        }\n+        return false;\n+    }\n+\n@@ -95,0 +190,2 @@\n+    private native double getSingleCpuLoad0(int cpuNum);\n+    private native int getHostConfiguredCpuCount0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":98,"deletions":1,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.management.OperatingSystemMXBean;\n+import java.lang.management.ManagementFactory;\n+\n+public class CheckOperatingSystemMXBean {\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Checking OperatingSystemMXBean\");\n+\n+        OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n+        System.out.println(String.format(\"Runtime.availableProcessors: %d\", Runtime.getRuntime().availableProcessors()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getAvailableProcessors: %d\", osBean.getAvailableProcessors()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getTotalPhysicalMemorySize: %d\", osBean.getTotalPhysicalMemorySize()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getFreePhysicalMemorySize: %d\", osBean.getFreePhysicalMemorySize()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getTotalSwapSpaceSize: %d\", osBean.getTotalSwapSpaceSize()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getFreeSwapSpaceSize: %d\", osBean.getFreeSwapSpaceSize()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getSystemCpuLoad: %f\", osBean.getSystemCpuLoad()));\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/CheckOperatingSystemMXBean.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+ * @build PrintContainerInfo CheckOperatingSystemMXBean\n@@ -79,0 +80,8 @@\n+            testOperatingSystemMXBeanAwareness(\"0.5\", \"1\");\n+            testOperatingSystemMXBeanAwareness(\"1.0\", \"1\");\n+            if (availableCPUs > 2) {\n+                testOperatingSystemMXBeanAwareness(\"1.2\", \"2\");\n+                testOperatingSystemMXBeanAwareness(\"1.8\", \"2\");\n+                testOperatingSystemMXBeanAwareness(\"2.0\", \"2\");\n+            }\n+\n@@ -80,1 +89,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -209,0 +220,17 @@\n+\n+    private static void testOperatingSystemMXBeanAwareness(String cpuAllocation, String expectedCpus) throws Exception {\n+        Common.logNewTestCase(\"Check OperatingSystemMXBean\");\n+\n+        DockerRunOptions opts = Common.newOpts(imageName, \"CheckOperatingSystemMXBean\")\n+            .addDockerOpts(\n+                \"--cpus\", cpuAllocation\n+            );\n+\n+        DockerTestUtils.dockerRunJava(opts)\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"Checking OperatingSystemMXBean\")\n+            .shouldContain(\"Runtime.availableProcessors: \" + expectedCpus)\n+            .shouldContain(\"OperatingSystemMXBean.getAvailableProcessors: \" + expectedCpus)\n+            .shouldMatch(\"OperatingSystemMXBean\\\\.getSystemCpuLoad: [0-9]+\\\\.[0-9]+\")\n+            ;\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @build AttemptOOM sun.hotspot.WhiteBox PrintContainerInfo\n+ * @build AttemptOOM sun.hotspot.WhiteBox PrintContainerInfo CheckOperatingSystemMXBean\n@@ -65,0 +65,12 @@\n+            testOperatingSystemMXBeanAwareness(\n+                \"100M\", Integer.toString(((int) Math.pow(2, 20)) * 100),\n+                \"150M\", Integer.toString(((int) Math.pow(2, 20)) * (150 - 100))\n+            );\n+            testOperatingSystemMXBeanAwareness(\n+                \"128M\", Integer.toString(((int) Math.pow(2, 20)) * 128),\n+                \"256M\", Integer.toString(((int) Math.pow(2, 20)) * (256 - 128))\n+            );\n+            testOperatingSystemMXBeanAwareness(\n+                \"1G\", Integer.toString(((int) Math.pow(2, 20)) * 1024),\n+                \"1500M\", Integer.toString(((int) Math.pow(2, 20)) * (1500 - 1024))\n+            );\n@@ -66,1 +78,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -123,0 +137,20 @@\n+    private static void testOperatingSystemMXBeanAwareness(String memoryAllocation, String expectedMemory,\n+            String swapAllocation, String expectedSwap) throws Exception {\n+        Common.logNewTestCase(\"Check OperatingSystemMXBean\");\n+\n+        DockerRunOptions opts = Common.newOpts(imageName, \"CheckOperatingSystemMXBean\")\n+            .addDockerOpts(\n+                \"--memory\", memoryAllocation,\n+                \"--memory-swap\", swapAllocation\n+            );\n+\n+        DockerTestUtils.dockerRunJava(opts)\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"Checking OperatingSystemMXBean\")\n+            .shouldContain(\"OperatingSystemMXBean.getTotalPhysicalMemorySize: \" + expectedMemory)\n+            .shouldMatch(\"OperatingSystemMXBean\\\\.getFreePhysicalMemorySize: [1-9][0-9]+\")\n+            .shouldContain(\"OperatingSystemMXBean.getTotalSwapSpaceSize: \" + expectedSwap)\n+            .shouldMatch(\"OperatingSystemMXBean\\\\.getFreeSwapSpaceSize: [1-9][0-9]+\")\n+            ;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"}]}