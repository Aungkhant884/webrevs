{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,8 +60,12 @@\n-        try (Recording r = new Recording()) {\n-            r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n-            r.start();\n-            allocateThreadLocal();\n-            r.stop();\n-            List<RecordedEvent> events = Events.fromRecording(r);\n-            if (OldObjects.countMatchingEvents(events, ThreadLocalObject[].class, null, null, -1, \"allocateThreadLocal\") == 0) {\n-                throw new Exception(\"Could not find thread local object \" + ThreadLocalObject.class);\n+        while (true) {\n+            try (Recording r = new Recording()) {\n+                r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                r.start();\n+                allocateThreadLocal();\n+                r.stop();\n+                List<RecordedEvent> events = Events.fromRecording(r);\n+                if (OldObjects.countMatchingEvents(events, ThreadLocalObject[].class, null, null, -1, \"allocateThreadLocal\") > 0) {\n+                    return;\n+                }\n+                System.out.println(\"Failed to find ThreadLocalObject leak. Retrying.\");\n+                threadLocal.get().clear();\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestThreadLocalLeak.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"}]}