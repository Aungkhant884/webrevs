{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        if (res.getEndpoints().size() == 0 && res.getDomainName().isEmpty()) {\n+        if (res.getEndpoints().isEmpty() && res.getDomainName().isEmpty()) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/DefaultLdapDnsProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+ *\n+ * <p> Instances of this class are safe for use by multiple threads.\n@@ -71,1 +73,1 @@\n-     * Retrieve the singleton static instance of LdapDnsProviderService.\n+     * Retrieves the singleton instance of LdapDnsProviderService.\n@@ -75,1 +77,1 @@\n-        synchronized(LOCK) {\n+        synchronized (LOCK) {\n@@ -83,1 +85,1 @@\n-     * Retrieve result from the first provider that successfully resolves\n+     * Retrieves result from the first provider that successfully resolves\n@@ -94,2 +96,0 @@\n-        Iterator<LdapDnsProvider> iterator = providers.iterator();\n-        Hashtable<?, ?> envCopy = new Hashtable<>(env);\n@@ -97,5 +97,8 @@\n-\n-        while (result == null && iterator.hasNext()) {\n-            result = iterator.next().lookupEndpoints(url, envCopy)\n-                    .filter(r -> r.getEndpoints().size() > 0)\n-                    .orElse(null);\n+        Hashtable<?, ?> envCopy = new Hashtable<>(env);\n+        synchronized (LOCK) {\n+            Iterator<LdapDnsProvider> iterator = providers.iterator();\n+            while (result == null && iterator.hasNext()) {\n+                result = iterator.next().lookupEndpoints(url, envCopy)\n+                        .filter(r -> !r.getEndpoints().isEmpty())\n+                        .orElse(null);\n+            }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapDnsProviderService.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -947,2 +947,0 @@\n-com\/sun\/jndi\/ldap\/LdapTimeoutTest.java                          8151678 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,2 +26,4 @@\n- * @run main\/othervm LdapTimeoutTest\n- * @bug 7094377 8000487 6176036 7056489\n+ * @library \/test\/lib\n+ *          lib\/\n+ * @run testng\/othervm LdapTimeoutTest\n+ * @bug 7094377 8000487 6176036 7056489 8151678\n@@ -31,0 +33,10 @@\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.directory.InitialDirContext;\n+import javax.naming.directory.SearchControls;\n+import java.io.IOException;\n+import java.io.OutputStream;\n@@ -32,7 +44,0 @@\n-import java.net.ServerSocket;\n-import java.net.SocketTimeoutException;\n-import java.io.*;\n-import javax.naming.*;\n-import javax.naming.directory.*;\n-import java.util.List;\n-import java.util.Hashtable;\n@@ -40,0 +45,3 @@\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Objects;\n@@ -41,0 +49,1 @@\n+import java.util.concurrent.CompletableFuture;\n@@ -42,1 +51,0 @@\n-import java.util.concurrent.Executors;\n@@ -44,0 +52,1 @@\n+import java.util.concurrent.Executors;\n@@ -45,3 +54,2 @@\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.SynchronousQueue;\n@@ -49,1 +57,1 @@\n-import javax.net.ssl.SSLHandshakeException;\n+import java.util.concurrent.TimeoutException;\n@@ -51,0 +59,1 @@\n+import static java.lang.String.format;\n@@ -53,0 +62,3 @@\n+import static jdk.test.lib.Utils.adjustTimeout;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n@@ -54,0 +66,1 @@\n+public class LdapTimeoutTest {\n@@ -55,30 +68,23 @@\n-abstract class LdapTest implements Callable {\n-\n-    Hashtable env;\n-    TestServer server;\n-    ScheduledExecutorService killSwitchPool;\n-    boolean passed = false;\n-    private int HANGING_TEST_TIMEOUT = 20_000;\n-\n-    public LdapTest (TestServer server, Hashtable env) {\n-        this.server = server;\n-        this.env = env;\n-    }\n-\n-    public LdapTest(TestServer server, Hashtable env,\n-            ScheduledExecutorService killSwitchPool)\n-    {\n-        this(server, env);\n-        this.killSwitchPool = killSwitchPool;\n-    }\n-\n-    public abstract void performOp(InitialContext ctx) throws NamingException;\n-    public abstract void handleNamingException(\n-        NamingException e, long start, long end);\n-\n-    public void pass() {\n-        this.passed = true;\n-    }\n-\n-    public void fail() {\n-        throw new RuntimeException(\"Test failed\");\n+    \/\/ ------ configure test timeouts here ------\n+\n+    \/*\n+     * Practical representation of an infinite timeout.\n+     *\/\n+    private static final long INFINITY_MILLIS = adjustTimeout(20_000);\n+    \/*\n+     * The acceptable variation in timeout measurements.\n+     *\/\n+    private static final long TOLERANCE       = adjustTimeout( 3_500);\n+\n+    private static final long CONNECT_MILLIS  = adjustTimeout( 3_000);\n+    private static final long READ_MILLIS     = adjustTimeout(10_000);\n+\n+    static {\n+        \/\/ a series of checks to make sure this timeouts configuration is\n+        \/\/ consistent and the timeouts do not overlap\n+\n+        assert (TOLERANCE >= 0);\n+        \/\/ context creation\n+        assert (2 * CONNECT_MILLIS + TOLERANCE < READ_MILLIS);\n+        \/\/ context creation immediately followed by search\n+        assert (2 * CONNECT_MILLIS + READ_MILLIS + TOLERANCE < INFINITY_MILLIS);\n@@ -87,2 +93,3 @@\n-    public void fail(Exception e) {\n-        throw new RuntimeException(\"Test failed\", e);\n+    @BeforeTest\n+    public void beforeTest() {\n+        startAuxiliaryDiagnosticOutput();\n@@ -91,1 +98,13 @@\n-    boolean shutItDown(InitialContext ctx) {\n+    \/*\n+     * These are timeout tests and they are run in parallel to reduce the total\n+     * amount of run time.\n+     *\n+     * Currently it doesn't seem possible to instruct JTREG to run TestNG test\n+     * methods in parallel. That said, this JTREG test is still\n+     * a \"TestNG-flavored\" test for the sake of having org.testng.Assert\n+     * capability.\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        List<Future<?>> futures = new ArrayList<>();\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n@@ -93,4 +112,9 @@\n-            if (ctx != null) ctx.close();\n-            return true;\n-        } catch (NamingException ex) {\n-            return false;\n+            futures.add(executorService.submit(() -> { test1(); return null; }));\n+            futures.add(executorService.submit(() -> { test2(); return null; }));\n+            futures.add(executorService.submit(() -> { test3(); return null; }));\n+            futures.add(executorService.submit(() -> { test4(); return null; }));\n+            futures.add(executorService.submit(() -> { test5(); return null; }));\n+            futures.add(executorService.submit(() -> { test6(); return null; }));\n+            futures.add(executorService.submit(() -> { test7(); return null; }));\n+        } finally {\n+            executorService.shutdown();\n@@ -98,28 +122,2 @@\n-    }\n-\n-    public Boolean call() {\n-        InitialContext ctx = null;\n-        ScheduledFuture killer = null;\n-        long start = System.nanoTime();\n-\n-        try {\n-            while(!server.accepting())\n-                Thread.sleep(200); \/\/ allow the server to start up\n-            Thread.sleep(200); \/\/ to be sure\n-\n-            \/\/ if this is a hanging test, scheduled a thread to\n-            \/\/ interrupt after a certain time\n-            if (killSwitchPool != null) {\n-                final Thread current = Thread.currentThread();\n-                killer = killSwitchPool.schedule(\n-                    new Callable<Void>() {\n-                        public Void call() throws Exception {\n-                            current.interrupt();\n-                            return null;\n-                        }\n-                    }, HANGING_TEST_TIMEOUT, MILLISECONDS);\n-            }\n-\n-            env.put(Context.PROVIDER_URL, \"ldap:\/\/localhost:\" +\n-                    server.getLocalPort());\n-\n+        int failedCount = 0;\n+        for (var f : futures) {\n@@ -127,13 +125,4 @@\n-                ctx = new InitialDirContext(env);\n-                performOp(ctx);\n-                fail();\n-            } catch (NamingException e) {\n-                long end = System.nanoTime();\n-                System.out.println(this.getClass().toString() + \" - elapsed: \"\n-                        + NANOSECONDS.toMillis(end - start));\n-                handleNamingException(e, start, end);\n-            } finally {\n-                if (killer != null && !killer.isDone())\n-                    killer.cancel(true);\n-                shutItDown(ctx);\n-                server.close();\n+                f.get();\n+            } catch (ExecutionException e) {\n+                failedCount++;\n+                e.getCause().printStackTrace(System.out);\n@@ -141,3 +130,0 @@\n-            return passed;\n-        } catch (IOException|InterruptedException e) {\n-            throw new RuntimeException(e);\n@@ -145,0 +131,2 @@\n+        if (failedCount > 0)\n+            throw new RuntimeException(failedCount + \" (sub)tests failed\");\n@@ -146,3 +134,0 @@\n-}\n-\n-abstract class ReadServerTest extends LdapTest {\n@@ -150,2 +135,16 @@\n-    public ReadServerTest(Hashtable env) throws IOException {\n-        super(new BindableServer(), env);\n+    static void test1() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        \/\/ Here and in the other tests it's important to close the server as\n+        \/\/ calling `thread.interrupt` from assertion may not be enough\n+        \/\/ (depending on where the blocking call has stuck)\n+        try (TestServer server = new NotBindableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            \/\/ Here and in the other tests joining done purely to reduce timing\n+            \/\/ jitter. Commenting out or removing that should not make the test\n+            \/\/ incorrect. (ServerSocket can accept connection as soon as it is\n+            \/\/ bound, not need to call `accept` before that.)\n+            server.starting().join();\n+            assertIncompletion(INFINITY_MILLIS, () -> new InitialDirContext(env));\n+        }\n@@ -154,5 +153,14 @@\n-    public ReadServerTest(Hashtable env,\n-                          ScheduledExecutorService killSwitchPool)\n-            throws IOException\n-    {\n-        super(new BindableServer(), env, killSwitchPool);\n+    static void test2() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        try (TestServer server = new BindableButNotReadableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            InitialDirContext ctx = new InitialDirContext(env);\n+            SearchControls scl = new SearchControls();\n+            scl.setSearchScope(SearchControls.SUBTREE_SCOPE);\n+            assertIncompletion(INFINITY_MILLIS,\n+                               () -> ctx.search(\"ou=People,o=JNDITutorial\", \"(objectClass=*)\", scl));\n+        }\n@@ -161,5 +169,13 @@\n-    public void performOp(InitialContext ctx) throws NamingException {\n-        SearchControls scl = new SearchControls();\n-        scl.setSearchScope(SearchControls.SUBTREE_SCOPE);\n-        NamingEnumeration<SearchResult> answer = ((InitialDirContext)ctx)\n-            .search(\"ou=People,o=JNDITutorial\", \"(objectClass=*)\", scl);\n+    static void test3() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        try (TestServer server = new BindableButNotReadableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            InitialDirContext ctx = new InitialDirContext(env);\n+            SearchControls scl = new SearchControls();\n+            scl.setSearchScope(SearchControls.SUBTREE_SCOPE);\n+            assertIncompletion(INFINITY_MILLIS,\n+                               () -> ctx.search(\"ou=People,o=JNDITutorial\", \"(objectClass=*)\", scl));\n+        }\n@@ -167,3 +183,0 @@\n-}\n-\n-abstract class DeadServerTest extends LdapTest {\n@@ -171,2 +184,19 @@\n-    public DeadServerTest(Hashtable env) throws IOException {\n-        super(new DeadServer(), env);\n+    static void test4() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        try (TestServer server = new NotBindableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            Assert.ThrowingRunnable completion =\n+                    () -> assertCompletion(CONNECT_MILLIS,\n+                                           2 * CONNECT_MILLIS + TOLERANCE,\n+                                           () -> new InitialDirContext(env));\n+            NamingException e = expectThrows(NamingException.class, completion);\n+            String msg = e.getMessage();\n+            assertTrue(msg != null && msg.contains(\"timeout\")\n+                               && msg.contains(String.valueOf(CONNECT_MILLIS)),\n+                       msg);\n+        }\n@@ -175,5 +205,22 @@\n-    public DeadServerTest(Hashtable env,\n-                          ScheduledExecutorService killSwitchPool)\n-            throws IOException\n-    {\n-        super(new DeadServer(), env, killSwitchPool);\n+    static void test5() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        try (TestServer server = new BindableButNotReadableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            InitialDirContext ctx = new InitialDirContext(env);\n+            SearchControls scl = new SearchControls();\n+            scl.setSearchScope(SearchControls.SUBTREE_SCOPE);\n+            Assert.ThrowingRunnable completion =\n+                    () -> assertCompletion(READ_MILLIS,\n+                                           READ_MILLIS + TOLERANCE,\n+                                           () -> ctx.search(\"ou=People,o=JNDITutorial\", \"(objectClass=*)\", scl));\n+            NamingException e = expectThrows(NamingException.class, completion);\n+            String msg = e.getMessage();\n+            assertTrue(msg != null && msg.contains(\"timeout\")\n+                               && msg.contains(String.valueOf(READ_MILLIS)),\n+                       msg);\n+        }\n@@ -182,10 +229,19 @@\n-    public void performOp(InitialContext ctx) throws NamingException {}\n-}\n-\n-class DeadServerNoTimeoutTest extends DeadServerTest {\n-\n-    public DeadServerNoTimeoutTest(Hashtable env,\n-                                   ScheduledExecutorService killSwitchPool)\n-            throws IOException\n-    {\n-        super(env, killSwitchPool);\n+    static void test6() throws Exception {\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        try (TestServer server = new NotBindableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            Assert.ThrowingRunnable completion =\n+                    () -> assertCompletion(CONNECT_MILLIS,\n+                                           2 * CONNECT_MILLIS + TOLERANCE,\n+                                           () -> new InitialDirContext(env));\n+            NamingException e = expectThrows(NamingException.class, completion);\n+            String msg = e.getMessage();\n+            assertTrue(msg != null && msg.contains(\"timeout\")\n+                               && msg.contains(String.valueOf(CONNECT_MILLIS)),\n+                       msg);\n+        }\n@@ -194,11 +250,23 @@\n-    public void handleNamingException(NamingException e, long start, long end) {\n-        if (e instanceof InterruptedNamingException) Thread.interrupted();\n-\n-        if (NANOSECONDS.toMillis(end - start) < LdapTimeoutTest.MIN_TIMEOUT) {\n-            System.err.printf(\"DeadServerNoTimeoutTest fail: timeout should be \" +\n-                              \"at least %s ms, actual time is %s ms%n\",\n-                              LdapTimeoutTest.MIN_TIMEOUT,\n-                              NANOSECONDS.toMillis(end - start));\n-            fail();\n-        } else {\n-            pass();\n+    static void test7() throws Exception {\n+        \/\/ 8000487: Java JNDI connection library on ldap conn is\n+        \/\/ not honoring configured timeout\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n+        env.put(Context.SECURITY_PRINCIPAL, \"user\");\n+        env.put(Context.SECURITY_CREDENTIALS, \"password\");\n+        try (TestServer server = new NotBindableServer()) {\n+            env.put(Context.PROVIDER_URL, urlTo(server));\n+            server.start();\n+            server.starting().join();\n+            Assert.ThrowingRunnable completion =\n+                    () -> assertCompletion(CONNECT_MILLIS,\n+                                           2 * CONNECT_MILLIS + TOLERANCE,\n+                                           () -> new InitialDirContext(env));\n+            NamingException e = expectThrows(NamingException.class, completion);\n+            String msg = e.getMessage();\n+            assertTrue(msg != null && msg.contains(\"timeout\")\n+                               && msg.contains(String.valueOf(CONNECT_MILLIS)),\n+                       msg);\n@@ -207,1 +275,0 @@\n-}\n@@ -209,1 +276,1 @@\n-class DeadServerTimeoutTest extends DeadServerTest {\n+    \/\/ ------ test stub servers ------\n@@ -211,3 +278,1 @@\n-    public DeadServerTimeoutTest(Hashtable env) throws IOException {\n-        super(env);\n-    }\n+    static class TestServer extends BaseLdapServer {\n@@ -215,11 +280,1 @@\n-    public void handleNamingException(NamingException e, long start, long end)\n-    {\n-        \/\/ non SSL connect will timeout via readReply using connectTimeout\n-        if (NANOSECONDS.toMillis(end - start) < 2_900) {\n-            pass();\n-        } else {\n-            System.err.println(\"Fail: Waited too long\");\n-            fail();\n-        }\n-    }\n-}\n+        private final CompletableFuture<Void> starting = new CompletableFuture<>();\n@@ -227,0 +282,1 @@\n+        TestServer() throws IOException { }\n@@ -228,1 +284,4 @@\n-class ReadServerNoTimeoutTest extends ReadServerTest {\n+        @Override\n+        protected void beforeAcceptingConnections() {\n+            starting.completeAsync(() -> null);\n+        }\n@@ -230,5 +289,3 @@\n-    public ReadServerNoTimeoutTest(Hashtable env,\n-                                   ScheduledExecutorService killSwitchPool)\n-            throws IOException\n-    {\n-        super(env, killSwitchPool);\n+        public CompletableFuture<Void> starting() {\n+            return starting.copy();\n+        }\n@@ -237,11 +294,21 @@\n-    public void handleNamingException(NamingException e, long start, long end) {\n-        if (e instanceof InterruptedNamingException) Thread.interrupted();\n-\n-        if (NANOSECONDS.toMillis(end - start) < LdapTimeoutTest.MIN_TIMEOUT) {\n-            System.err.printf(\"ReadServerNoTimeoutTest fail: timeout should be \" +\n-                              \"at least %s ms, actual time is %s ms%n\",\n-                              LdapTimeoutTest.MIN_TIMEOUT,\n-                              NANOSECONDS.toMillis(end - start));\n-            fail();\n-        } else {\n-            pass();\n+    static class BindableButNotReadableServer extends TestServer {\n+\n+        BindableButNotReadableServer() throws IOException { }\n+\n+        private static final byte[] bindResponse = {\n+                0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,\n+                0x01, 0x00, 0x04, 0x00, 0x04, 0x00\n+        };\n+\n+        @Override\n+        protected void handleRequest(Socket socket,\n+                                     LdapMessage msg,\n+                                     OutputStream out)\n+                throws IOException {\n+            switch (msg.getOperation()) {\n+                case BIND_REQUEST:\n+                    out.write(bindResponse);\n+                    out.flush();\n+                default:\n+                    break;\n+            }\n@@ -250,1 +317,0 @@\n-}\n@@ -252,1 +318,1 @@\n-class ReadServerTimeoutTest extends ReadServerTest {\n+    static class NotBindableServer extends TestServer {\n@@ -254,3 +320,1 @@\n-    public ReadServerTimeoutTest(Hashtable env) throws IOException {\n-        super(env);\n-    }\n+        NotBindableServer() throws IOException { }\n@@ -258,6 +322,7 @@\n-    public void handleNamingException(NamingException e, long start, long end) {\n-        System.out.println(\"ReadServerTimeoutTest: end-start=\" + NANOSECONDS.toMillis(end - start));\n-        if (NANOSECONDS.toMillis(end - start) < 2_500) {\n-            fail();\n-        } else {\n-            pass();\n+        @Override\n+        protected void beforeConnectionHandled(Socket socket) {\n+            try {\n+                TimeUnit.DAYS.sleep(Integer.MAX_VALUE);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n@@ -266,10 +331,0 @@\n-}\n-\n-class TestServer extends Thread {\n-    ServerSocket serverSock;\n-    boolean accepting = false;\n-\n-    public TestServer() throws IOException {\n-        this.serverSock = new ServerSocket(0);\n-        start();\n-    }\n@@ -277,3 +332,21 @@\n-    public int getLocalPort() {\n-        return serverSock.getLocalPort();\n-    }\n+    \/\/ ------ timeouts check utilities ------\n+\n+    \/*\n+     * Asserts that the specified executable yields a result or an exception\n+     * within the specified time frame. Interrupts the executable\n+     * unconditionally.\n+     *\n+     * If the executable yields a result or an exception within the specified\n+     * time frame, the result will be returned and the exception will be\n+     * rethrown respectively in a transparent fashion as if the executable was\n+     * executed directly.\n+     *\/\n+    public static <T> T assertCompletion(long loMillis,\n+                                         long hiMillis,\n+                                         Callable<T> code)\n+            throws Throwable {\n+        if (loMillis < 0 || hiMillis < 0 || loMillis > hiMillis) {\n+            throw new IllegalArgumentException(\"loMillis=\" + loMillis +\n+                                                       \", hiMillis=\" + hiMillis);\n+        }\n+        Objects.requireNonNull(code);\n@@ -281,3 +354,2 @@\n-    public boolean accepting() {\n-        return accepting;\n-    }\n+        \/\/ this queue acts both as an exchange point and a barrier\n+        SynchronousQueue<Long> startTime = new SynchronousQueue<>();\n@@ -285,4 +357,6 @@\n-    public void close() throws IOException {\n-        serverSock.close();\n-    }\n-}\n+        Callable<T> wrappedTask = () -> {\n+            \/\/ by the time this value reaches the \"stopwatch\" thread it might be\n+            \/\/ well outdated and that's okay, we will adjust the wait time\n+            startTime.put(System.nanoTime());\n+            return code.call();\n+        };\n@@ -290,1 +364,3 @@\n-class BindableServer extends TestServer {\n+        FutureTask<T> task = new FutureTask<>(wrappedTask);\n+        Thread t = new Thread(task);\n+        t.start();\n@@ -292,3 +368,7 @@\n-    public BindableServer() throws IOException {\n-        super();\n-    }\n+        final long startNanos;\n+        try {\n+            startNanos = startTime.take(); \/\/ (1) wait for the initial time mark\n+        } catch (Throwable e) {\n+            t.interrupt();\n+            throw e;\n+        }\n@@ -296,4 +376,2 @@\n-    private byte[] bindResponse = {\n-        0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,\n-        0x01, 0x00, 0x04, 0x00, 0x04, 0x00\n-    };\n+        final long waitTime = hiMillis -\n+                NANOSECONDS.toMillis(System.nanoTime() - startNanos); \/\/ (2) adjust wait time\n@@ -301,1 +379,0 @@\n-    public void run() {\n@@ -303,9 +380,5 @@\n-            accepting = true;\n-            Socket socket = serverSock.accept();\n-            InputStream in = socket.getInputStream();\n-            OutputStream out = socket.getOutputStream();\n-\n-            \/\/ Read the LDAP BindRequest\n-            while (in.read() != -1) {\n-                in.skip(in.available());\n-                break;\n+            T r = task.get(waitTime, MILLISECONDS); \/\/ (3) wait for the task to complete\n+            long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);\n+            if (elapsed < loMillis || elapsed > hiMillis) {\n+                throw new RuntimeException(format(\n+                        \"After %s ms. (waitTime %s ms.) returned result '%s'\", elapsed, waitTime, r));\n@@ -313,6 +386,16 @@\n-\n-            \/\/ Write an LDAP BindResponse\n-            out.write(bindResponse);\n-            out.flush();\n-        } catch (IOException e) {\n-            \/\/ ignore\n+            return r;\n+        } catch (ExecutionException e) {\n+            long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);\n+            if (elapsed < loMillis || elapsed > hiMillis) {\n+                throw new RuntimeException(format(\n+                        \"After %s ms. (waitTime %s ms.) thrown exception\", elapsed, waitTime), e);\n+            }\n+            throw e.getCause();\n+        } catch (TimeoutException e) {\n+            \/\/ We trust timed get not to throw TimeoutException prematurely\n+            \/\/ (i.e. before the wait time elapses)\n+            long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);\n+            throw new RuntimeException(format(\n+                    \"After %s ms. (waitTime %s ms.) is incomplete\", elapsed, waitTime));\n+        } finally {\n+            t.interrupt();\n@@ -321,7 +404,0 @@\n-}\n-\n-class DeadServer extends TestServer {\n-\n-    public DeadServer() throws IOException {\n-        super();\n-    }\n@@ -329,8 +405,10 @@\n-    public void run() {\n-        while(true) {\n-            try {\n-                accepting = true;\n-                Socket socket = serverSock.accept();\n-            } catch (Exception e) {\n-                break;\n-            }\n+    \/*\n+     * Asserts that the specified executable yields no result and no exception\n+     * for at least the specified amount of time. Interrupts the executable\n+     * unconditionally.\n+     *\/\n+    public static void assertIncompletion(long millis, Callable<?> code)\n+            throws Exception\n+    {\n+        if (millis < 0) {\n+            throw new IllegalArgumentException(\"millis=\" + millis);\n@@ -338,2 +416,1 @@\n-    }\n-}\n+        Objects.requireNonNull(code);\n@@ -341,1 +418,2 @@\n-public class LdapTimeoutTest {\n+        \/\/ this queue acts both as an exchange point and a barrier\n+        SynchronousQueue<Long> startTime = new SynchronousQueue<>();\n@@ -343,12 +421,6 @@\n-    private static final ExecutorService testPool =\n-        Executors.newFixedThreadPool(3);\n-    private static final ScheduledExecutorService killSwitchPool =\n-        Executors.newScheduledThreadPool(3);\n-    public static int MIN_TIMEOUT = 18_000;\n-\n-    static Hashtable createEnv() {\n-        Hashtable env = new Hashtable(11);\n-        env.put(Context.INITIAL_CONTEXT_FACTORY,\n-            \"com.sun.jndi.ldap.LdapCtxFactory\");\n-        return env;\n-    }\n+        Callable<?> wrappedTask = () -> {\n+            \/\/ by the time this value reaches the \"stopwatch\" thread it might be\n+            \/\/ well outdated and that's okay, we will adjust the wait time\n+            startTime.put(System.nanoTime());\n+            return code.call();\n+        };\n@@ -356,1 +428,11 @@\n-    public static void main(String[] args) throws Exception {\n+        FutureTask<?> task = new FutureTask<>(wrappedTask);\n+        Thread t = new Thread(task);\n+        t.start();\n+\n+        final long startNanos;\n+        try {\n+            startNanos = startTime.take(); \/\/ (1) wait for the initial time mark\n+        } catch (Throwable e) {\n+            t.interrupt();\n+            throw e;\n+        }\n@@ -358,2 +440,2 @@\n-        InitialContext ctx = null;\n-        List<Future> results = new ArrayList<>();\n+        final long waitTime = millis -\n+                NANOSECONDS.toMillis(System.nanoTime() - startNanos); \/\/ (2) adjust wait time\n@@ -362,69 +444,5 @@\n-            \/\/ run the DeadServerTest with no timeouts set\n-            \/\/ this should get stuck indefinitely, so we need to kill\n-            \/\/ it after a timeout\n-            System.out.println(\"Running connect timeout test with 20s kill switch\");\n-            Hashtable env = createEnv();\n-            results.add(\n-                    testPool.submit(new DeadServerNoTimeoutTest(env, killSwitchPool)));\n-\n-            \/\/ run the ReadServerTest with connect timeout set\n-            \/\/ this should get stuck indefinitely so we need to kill\n-            \/\/ it after a timeout\n-            System.out.println(\"Running read timeout test with 10ms connect timeout & 20s kill switch\");\n-            Hashtable env1 = createEnv();\n-            env1.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-            results.add(testPool.submit(\n-                    new ReadServerNoTimeoutTest(env1, killSwitchPool)));\n-\n-            \/\/ run the ReadServerTest with no timeouts set\n-            \/\/ this should get stuck indefinitely, so we need to kill\n-            \/\/ it after a timeout\n-            System.out.println(\"Running read timeout test with 20s kill switch\");\n-            Hashtable env2 = createEnv();\n-            results.add(testPool.submit(\n-                    new ReadServerNoTimeoutTest(env2, killSwitchPool)));\n-\n-            \/\/ run the DeadServerTest with connect \/ read timeouts set\n-            \/\/ this should exit after the connect timeout expires\n-            System.out.println(\"Running connect timeout test with 10ms connect timeout, 3000ms read timeout\");\n-            Hashtable env3 = createEnv();\n-            env3.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-            env3.put(\"com.sun.jndi.ldap.read.timeout\", \"3000\");\n-            results.add(testPool.submit(new DeadServerTimeoutTest(env3)));\n-\n-\n-            \/\/ run the ReadServerTest with connect \/ read timeouts set\n-            \/\/ this should exit after the connect timeout expires\n-            \/\/\n-            \/\/ NOTE: commenting this test out as it is failing intermittently.\n-            \/\/\n-            \/\/ System.out.println(\"Running read timeout test with 10ms connect timeout, 3000ms read timeout\");\n-            \/\/ Hashtable env4 = createEnv();\n-            \/\/ env4.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-            \/\/ env4.put(\"com.sun.jndi.ldap.read.timeout\", \"3000\");\n-            \/\/ results.add(testPool.submit(new ReadServerTimeoutTest(env4)));\n-\n-            \/\/ run the DeadServerTest with connect timeout set\n-            \/\/ this should exit after the connect timeout expires\n-            System.out.println(\"Running connect timeout test with 10ms connect timeout\");\n-            Hashtable env5 = createEnv();\n-            env5.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-            results.add(testPool.submit(new DeadServerTimeoutTest(env5)));\n-\n-            \/\/ 8000487: Java JNDI connection library on ldap conn is\n-            \/\/ not honoring configured timeout\n-            System.out.println(\"Running simple auth connection test\");\n-            Hashtable env6 = createEnv();\n-            env6.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-            env6.put(\"com.sun.jndi.ldap.read.timeout\", \"3000\");\n-            env6.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n-            env6.put(Context.SECURITY_PRINCIPAL, \"user\");\n-            env6.put(Context.SECURITY_CREDENTIALS, \"password\");\n-            results.add(testPool.submit(new DeadServerTimeoutTest(env6)));\n-\n-            boolean testFailed = false;\n-            for (Future test : results) {\n-                while (!test.isDone()) {\n-                    if ((Boolean) test.get() == false)\n-                        testFailed = true;\n-                }\n+            Object r = task.get(waitTime, MILLISECONDS); \/\/ (3) wait for the task to complete\n+            long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);\n+            if (elapsed < waitTime) {\n+                throw new RuntimeException(format(\n+                        \"After %s ms. (waitTime %s ms.) returned result '%s'\", elapsed, waitTime, r));\n@@ -432,3 +450,5 @@\n-\n-            if (testFailed) {\n-                throw new AssertionError(\"some tests failed\");\n+        } catch (ExecutionException e) {\n+            long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);\n+            if (elapsed < waitTime) {\n+                throw new RuntimeException(format(\n+                        \"After %s ms. (waitTime %s ms.) thrown exception\", elapsed, waitTime), e);\n@@ -436,1 +456,1 @@\n-\n+        } catch (TimeoutException expected) {\n@@ -438,2 +458,1 @@\n-            LdapTimeoutTest.killSwitchPool.shutdown();\n-            LdapTimeoutTest.testPool.shutdown();\n+            t.interrupt();\n@@ -443,1 +462,39 @@\n-}\n+    \/\/ ------ miscellaneous utilities ------\n+\n+    private static String urlTo(TestServer server) {\n+        String hostAddress = server.getInetAddress().getHostAddress();\n+        String addr;\n+        if (hostAddress.contains(\":\")) { \/\/ IPv6\n+            addr = '[' + hostAddress + ']';\n+        } else {                         \/\/ IPv4\n+            addr = hostAddress;\n+        }\n+        return \"ldap:\/\/\" + addr + \":\" + server.getPort();\n+    }\n+\n+    \/*\n+     * A diagnostic aid that might help with debugging timeout issues. The idea\n+     * is to continuously measure accuracy and responsiveness of the system that\n+     * runs this test. If the system is overwhelmed (with something else), it\n+     * might affect the test run. At the very least we will have traces of that\n+     * in the logs.\n+     *\n+     * This utility does not automatically scale up test timeouts, it simply\n+     * gathers information.\n+     *\/\n+    private static void startAuxiliaryDiagnosticOutput() {\n+        System.out.printf(\"Starting diagnostic output (probe)%n\");\n+        Thread t = new Thread(() -> {\n+            for (int i = 0; ; i = ((i % 20) + 1)) {\n+                \/\/ 500, 1_000, 1_500, ..., 9_500, 10_000, 500, 1_000, ...\n+                long expected = i * 500;\n+                long start = System.nanoTime();\n+                try {\n+                    MILLISECONDS.sleep(expected);\n+                } catch (InterruptedException e) {\n+                    return;\n+                }\n+                long stop = System.nanoTime();\n+                long actual = NANOSECONDS.toMillis(stop - start);\n+                System.out.printf(\"(probe) expected [ms.]: %s, actual [ms.]: %s%n\",\n+                                  expected, actual);\n@@ -445,0 +502,6 @@\n+            }\n+        }, \"probe\");\n+        t.setDaemon(true);\n+        t.start();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapTimeoutTest.java","additions":403,"deletions":340,"binary":false,"changes":743,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.concurrent.RejectedExecutionException;\n@@ -47,0 +46,1 @@\n+ *     * beforeAcceptingConnections\n@@ -86,0 +86,1 @@\n+            beforeAcceptingConnections();\n@@ -100,1 +101,1 @@\n-        } catch (IOException | RejectedExecutionException e) {\n+        } catch (Throwable t) {\n@@ -103,1 +104,1 @@\n-                        \"Unexpected exception while accepting connections\", e);\n+                        \"Unexpected exception while accepting connections\", t);\n@@ -111,0 +112,7 @@\n+    \/*\n+     * Called once immediately preceding the server accepting connections.\n+     *\n+     * Override to customize the behavior.\n+     *\/\n+    protected void beforeAcceptingConnections() { }\n+\n@@ -243,0 +251,2 @@\n+     * This method can be called at any time.\n+     *\n@@ -249,0 +259,11 @@\n+    \/**\n+     * Returns the address this server is listening at.\n+     *\n+     * This method can be called at any time.\n+     *\n+     * @return the address\n+     *\/\n+    public InetAddress getInetAddress() {\n+        return serverSocket.getInetAddress();\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/lib\/BaseLdapServer.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"}]}