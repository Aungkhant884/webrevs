{"files":[{"patch":"@@ -151,0 +151,1 @@\n+Mutex*   ThreadIdTableCreate_lock     = NULL;\n@@ -352,0 +353,1 @@\n+  def(ThreadIdTableCreate_lock     , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always)\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+extern Mutex*   ThreadIdTableCreate_lock;        \/\/ Used by ThreadIdTable to lazily create the thread id table\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"services\/threadIdTable.hpp\"\n@@ -132,1 +134,0 @@\n-\n@@ -611,9 +612,19 @@\n-  for (uint i = 0; i < length(); i++) {\n-    JavaThread* thread = thread_at(i);\n-    oop tobj = thread->threadObj();\n-    \/\/ Ignore the thread if it hasn't run yet, has exited\n-    \/\/ or is starting to exit.\n-    if (tobj != NULL && !thread->is_exiting() &&\n-        java_tid == java_lang_Thread::thread_id(tobj)) {\n-      \/\/ found a match\n-      return thread;\n+  ThreadIdTable::lazy_initialize(this);\n+  JavaThread* thread = ThreadIdTable::find_thread_by_tid(java_tid);\n+  if (thread == NULL) {\n+    \/\/ If the thread is not found in the table find it\n+    \/\/ with a linear search and add to the table.\n+    for (uint i = 0; i < length(); i++) {\n+      thread = thread_at(i);\n+      oop tobj = thread->threadObj();\n+      \/\/ Ignore the thread if it hasn't run yet, has exited\n+      \/\/ or is starting to exit.\n+      if (tobj != NULL && java_tid == java_lang_Thread::thread_id(tobj)) {\n+        MutexLocker ml(Threads_lock);\n+        \/\/ Must be inside the lock to ensure that we don't add a thread to the table\n+        \/\/ that has just passed the removal point in ThreadsSMRSupport::remove_thread()\n+        if (!thread->is_exiting()) {\n+          ThreadIdTable::add_thread(java_tid, thread);\n+          return thread;\n+        }\n+      }\n@@ -621,0 +632,2 @@\n+  } else if (!thread->is_exiting()) {\n+    return thread;\n@@ -745,0 +758,4 @@\n+  if (ThreadIdTable::is_initialized()) {\n+    jlong tid = SharedRuntime::get_java_tid(thread);\n+    ThreadIdTable::add_thread(tid, thread);\n+  }\n@@ -912,0 +929,4 @@\n+  if (ThreadIdTable::is_initialized()) {\n+    jlong tid = SharedRuntime::get_java_tid(thread);\n+    ThreadIdTable::remove_thread(tid);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\n+\/*\n+* Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"services\/threadIdTable.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+\n+class ThreadIdTableEntry;\n+\n+typedef ConcurrentHashTable<ThreadIdTableEntry*, ThreadIdTableConfig, mtInternal> ThreadIdTableHash;\n+\n+\/\/ 2^24 is max size\n+static const size_t END_SIZE = 24;\n+\/\/ Default initial size 256\n+static const size_t DEFAULT_TABLE_SIZE_LOG = 8;\n+\/\/ Prefer short chains of avg 2\n+static const double PREF_AVG_LIST_LEN = 2.0;\n+static ThreadIdTableHash* volatile _local_table = NULL;\n+static volatile size_t _current_size = 0;\n+static volatile size_t _items_count = 0;\n+\n+volatile bool ThreadIdTable::_is_initialized = false;\n+\n+class ThreadIdTableEntry : public CHeapObj<mtInternal> {\n+private:\n+  jlong _tid;\n+  JavaThread* _java_thread;\n+public:\n+  ThreadIdTableEntry(jlong tid, JavaThread* java_thread) :\n+    _tid(tid), _java_thread(java_thread) {}\n+\n+  jlong tid() const { return _tid; }\n+  JavaThread* thread() const { return _java_thread; }\n+};\n+\n+class ThreadIdTableConfig : public AllStatic {\n+  public:\n+    typedef ThreadIdTableEntry* Value;\n+\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      jlong tid = value->tid();\n+      return primitive_hash(tid);\n+    }\n+    static void* allocate_node(size_t size, Value const& value) {\n+      ThreadIdTable::item_added();\n+      return AllocateHeap(size, mtInternal);\n+    }\n+    static void free_node(void* memory, Value const& value) {\n+      delete value;\n+      FreeHeap(memory);\n+      ThreadIdTable::item_removed();\n+    }\n+};\n+\n+static size_t ceil_log2(size_t val) {\n+  size_t ret;\n+  for (ret = 1; ((size_t)1 << ret) < val; ++ret);\n+  return ret;\n+}\n+\n+\/\/ Lazily creates the table and populates it with the given\n+\/\/ thread list\n+void ThreadIdTable::lazy_initialize(const ThreadsList *threads) {\n+  if (!_is_initialized) {\n+    {\n+      \/\/ There is no obvious benefits in allowing the thread table\n+      \/\/ to be concurently populated during the initalization.\n+      MutexLocker ml(ThreadIdTableCreate_lock);\n+      if (_is_initialized) {\n+        return;\n+      }\n+      create_table(threads->length());\n+      _is_initialized = true;\n+    }\n+    for (uint i = 0; i < threads->length(); i++) {\n+      JavaThread* thread = threads->thread_at(i);\n+      oop tobj = thread->threadObj();\n+      if (tobj != NULL) {\n+        jlong java_tid = java_lang_Thread::thread_id(tobj);\n+        MutexLocker ml(Threads_lock);\n+        if (!thread->is_exiting()) {\n+          \/\/ Must be inside the lock to ensure that we don't add a thread to the table\n+          \/\/ that has just passed the removal point in ThreadsSMRSupport::remove_thread()\n+          add_thread(java_tid, thread);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void ThreadIdTable::create_table(size_t size) {\n+  assert(_local_table == NULL, \"Thread table is already created\");\n+  size_t size_log = ceil_log2(size);\n+  size_t start_size_log =\n+      size_log > DEFAULT_TABLE_SIZE_LOG ? size_log : DEFAULT_TABLE_SIZE_LOG;\n+  _current_size = (size_t)1 << start_size_log;\n+  _local_table = new ThreadIdTableHash(start_size_log, END_SIZE);\n+}\n+\n+void ThreadIdTable::item_added() {\n+  Atomic::inc(&_items_count);\n+  log_trace(thread, table) (\"Thread entry added\");\n+}\n+\n+void ThreadIdTable::item_removed() {\n+  Atomic::dec(&_items_count);\n+  log_trace(thread, table) (\"Thread entry removed\");\n+}\n+\n+double ThreadIdTable::get_load_factor() {\n+  return ((double)_items_count) \/ _current_size;\n+}\n+\n+size_t ThreadIdTable::table_size() {\n+  return (size_t)1 << _local_table->get_size_log2(Thread::current());\n+}\n+\n+void ThreadIdTable::grow(JavaThread* jt) {\n+  ThreadIdTableHash::GrowTask gt(_local_table);\n+  if (!gt.prepare(jt)) {\n+    return;\n+  }\n+  log_trace(thread, table)(\"Started to grow\");\n+  TraceTime timer(\"Grow\", TRACETIME_LOG(Debug, membername, table, perf));\n+  while (gt.do_task(jt)) {\n+    gt.pause(jt);\n+    {\n+      ThreadBlockInVM tbivm(jt);\n+    }\n+    gt.cont(jt);\n+  }\n+  gt.done(jt);\n+  _current_size = table_size();\n+  log_info(thread, table)(\"Grown to size:\" SIZE_FORMAT, _current_size);\n+}\n+\n+class ThreadIdTableLookup : public StackObj {\n+private:\n+  jlong _tid;\n+  uintx _hash;\n+public:\n+  ThreadIdTableLookup(jlong tid)\n+    : _tid(tid), _hash(primitive_hash(tid)) {}\n+  uintx get_hash() const {\n+    return _hash;\n+  }\n+  bool equals(ThreadIdTableEntry** value, bool* is_dead) {\n+    bool equals = primitive_equals(_tid, (*value)->tid());\n+    if (!equals) {\n+      return false;\n+    }\n+    return true;\n+  }\n+};\n+\n+class ThreadGet : public StackObj {\n+private:\n+  JavaThread* _return;\n+public:\n+  ThreadGet(): _return(NULL) {}\n+  void operator()(ThreadIdTableEntry** val) {\n+    _return = (*val)->thread();\n+  }\n+  JavaThread* get_res_thread() {\n+    return _return;\n+  }\n+};\n+\n+void ThreadIdTable::grow_if_required() {\n+  assert(Thread::current()->is_Java_thread(),\"Must be Java thread\");\n+  assert(_is_initialized, \"Thread table is not initialized\");\n+  double load_factor = get_load_factor();\n+  log_debug(thread, table)(\"Concurrent work, load factor: %g\", load_factor);\n+  if (load_factor > PREF_AVG_LIST_LEN && !_local_table->is_max_size_reached()) {\n+    grow(JavaThread::current());\n+  }\n+}\n+\n+JavaThread* ThreadIdTable::add_thread(jlong tid, JavaThread* java_thread) {\n+  assert(_is_initialized, \"Thread table is not initialized\");\n+  Thread* thread = Thread::current();\n+  ThreadIdTableLookup lookup(tid);\n+  ThreadGet tg;\n+  while (true) {\n+    if (_local_table->get(thread, lookup, tg)) {\n+      return tg.get_res_thread();\n+    }\n+    ThreadIdTableEntry* entry = new ThreadIdTableEntry(tid, java_thread);\n+    \/\/ The hash table takes ownership of the ThreadTableEntry,\n+    \/\/ even if it's not inserted.\n+    if (_local_table->insert(thread, lookup, entry)) {\n+      grow_if_required();\n+      return java_thread;\n+    }\n+  }\n+}\n+\n+JavaThread* ThreadIdTable::find_thread_by_tid(jlong tid) {\n+  assert(_is_initialized, \"Thread table is not initialized\");\n+  Thread* thread = Thread::current();\n+  ThreadIdTableLookup lookup(tid);\n+  ThreadGet tg;\n+  _local_table->get(thread, lookup, tg);\n+  return tg.get_res_thread();\n+}\n+\n+bool ThreadIdTable::remove_thread(jlong tid) {\n+  assert(_is_initialized, \"Thread table is not initialized\");\n+  Thread* thread = Thread::current();\n+  ThreadIdTableLookup lookup(tid);\n+  return _local_table->remove(thread, lookup);\n+}\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\n+\/*\n+* Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_SERVICES_THREADIDTABLE_HPP\n+#define SHARE_SERVICES_THREADIDTABLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class JavaThread;\n+class ThreadsList;\n+class ThreadIdTableConfig;\n+\n+class ThreadIdTable : public AllStatic {\n+  friend class ThreadIdTableConfig;\n+\n+  static volatile bool _is_initialized;\n+\n+public:\n+  \/\/ Initialization\n+  static void lazy_initialize(const ThreadsList* threads);\n+  static bool is_initialized() { return _is_initialized; }\n+\n+  \/\/ Lookup and list management\n+  static JavaThread* find_thread_by_tid(jlong tid);\n+  static JavaThread* add_thread(jlong tid, JavaThread* thread);\n+  static bool remove_thread(jlong tid);\n+\n+private:\n+  static void create_table(size_t size);\n+\n+  static size_t table_size();\n+  static double get_load_factor();\n+  static void grow_if_required();\n+  static void grow(JavaThread* jt);\n+\n+  static void item_added();\n+  static void item_removed();\n+};\n+\n+#endif \/\/ SHARE_SERVICES_THREADIDTABLE_HPP\n","filename":"src\/hotspot\/share\/services\/threadIdTable.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}