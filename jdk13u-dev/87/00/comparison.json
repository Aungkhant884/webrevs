{"files":[{"patch":"@@ -52,0 +52,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"runtime\/serviceThread.hpp\"\n@@ -430,1 +432,2 @@\n-  _unload_reported            = false; \/\/ jvmti state\n+  _load_reported              = false; \/\/ jvmti state\n+  _unload_reported            = false;\n@@ -438,1 +441,0 @@\n-  _jmethod_id              = NULL;\n@@ -1574,1 +1576,1 @@\n-void nmethod::post_compiled_method_load_event() {\n+void nmethod::post_compiled_method_load_event(JvmtiThreadState* state) {\n@@ -1576,3 +1578,3 @@\n- \/\/ This is a bad time for a safepoint.  We don't want\n- \/\/ this nmethod to get unloaded while we're queueing the event.\n- NoSafepointVerifier nsv;\n+  \/\/ This is a bad time for a safepoint.  We don't want\n+  \/\/ this nmethod to get unloaded while we're queueing the event.\n+  NoSafepointVerifier nsv;\n@@ -1590,4 +1592,0 @@\n-  if (JvmtiExport::should_post_compiled_method_load() ||\n-      JvmtiExport::should_post_compiled_method_unload()) {\n-    get_and_cache_jmethod_id();\n-  }\n@@ -1596,12 +1594,13 @@\n-    \/\/ Let the Service thread (which is a real Java thread) post the event\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-    JvmtiDeferredEventQueue::enqueue(\n-      JvmtiDeferredEvent::compiled_method_load_event(this));\n-  }\n-}\n-\n-jmethodID nmethod::get_and_cache_jmethod_id() {\n-  if (_jmethod_id == NULL) {\n-    \/\/ Cache the jmethod_id since it can no longer be looked up once the\n-    \/\/ method itself has been marked for unloading.\n-    _jmethod_id = method()->jmethod_id();\n+    \/\/ Only post unload events if load events are found.\n+    set_load_reported();\n+    \/\/ Keep sweeper from turning this into zombie until it is posted.\n+    mark_as_seen_on_stack();\n+\n+    \/\/ If a JavaThread hasn't been passed in, let the Service thread\n+    \/\/ (which is a real Java thread) post the event\n+    JvmtiDeferredEvent event = JvmtiDeferredEvent::compiled_method_load_event(this);\n+    if (state == NULL) {\n+      ServiceThread::enqueue_deferred_event(&event);\n+    } else {\n+      state->enqueue_event(&event);\n+    }\n@@ -1609,1 +1608,0 @@\n-  return _jmethod_id;\n@@ -1625,3 +1623,1 @@\n-  \/\/ If the _jmethod_id is null then no load event was ever requested\n-  \/\/ so don't bother posting the unload.  The main reason for this is\n-  \/\/ that the jmethodID is a weak reference to the Method* so if\n+  \/\/ The jmethodID is a weak reference to the Method* so if\n@@ -1630,1 +1626,3 @@\n-  if (_jmethod_id != NULL && JvmtiExport::should_post_compiled_method_unload()) {\n+\n+  \/\/ Don't bother posting the unload if the load event wasn't posted.\n+  if (load_reported() && JvmtiExport::should_post_compiled_method_unload()) {\n@@ -1634,3 +1632,2 @@\n-          _jmethod_id, insts_begin());\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-    JvmtiDeferredEventQueue::enqueue(event);\n+          method()->jmethod_id(), insts_begin());\n+    ServiceThread::enqueue_deferred_event(&event);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class JvmtiThreadState;\n@@ -74,1 +75,0 @@\n-  jmethodID _jmethod_id;       \/\/ Cache of method()->jmethod_id()\n@@ -119,1 +119,1 @@\n-  \/\/ used by jvmti to track if an unload event has been posted for this nmethod.\n+  \/\/ used by jvmti to track if an event has been posted for this nmethod.\n@@ -121,0 +121,1 @@\n+  bool _load_reported;\n@@ -372,4 +373,0 @@\n-  \/\/ used by jvmti to track if the unload event has been reported\n-  bool  unload_reported()                         { return _unload_reported; }\n-  void  set_unload_reported()                     { _unload_reported = true; }\n-\n@@ -492,0 +489,6 @@\n+  \/\/ used by jvmti to track if the load and unload events has been reported\n+  bool  unload_reported() const                   { return _unload_reported; }\n+  void  set_unload_reported()                     { _unload_reported = true; }\n+  bool  load_reported() const                     { return _load_reported; }\n+  void  set_load_reported()                       { _load_reported = true; }\n+\n@@ -502,2 +505,1 @@\n-  void post_compiled_method_load_event();\n-  jmethodID get_and_cache_jmethod_id();\n+  void post_compiled_method_load_event(JvmtiThreadState* state = NULL);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-    jvmti_thread_state->oops_do(&rcl);\n+    jvmti_thread_state->oops_do(&rcl, NULL);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"prims\/jvmtiThreadState.inline.hpp\"\n@@ -222,18 +223,12 @@\n-  HandleMark hm;\n-\n-  \/\/ Walk the CodeCache notifying for live nmethods.  The code cache\n-  \/\/ may be changing while this is happening which is ok since newly\n-  \/\/ created nmethod will notify normally and nmethods which are freed\n-  \/\/ can be safely skipped.\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  \/\/ Iterate over non-profiled and profiled nmethods\n-  NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);\n-  while(iter.next()) {\n-    nmethod* current = iter.method();\n-    \/\/ Lock the nmethod so it can't be freed\n-    nmethodLocker nml(current);\n-\n-    \/\/ Don't hold the lock over the notify or jmethodID creation\n-    MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    current->get_and_cache_jmethod_id();\n-    JvmtiExport::post_compiled_method_load(env, current);\n+  JvmtiThreadState* state = JvmtiThreadState::state_for(JavaThread::current());\n+  {\n+    \/\/ Walk the CodeCache notifying for live nmethods, don't release the CodeCache_lock\n+    \/\/ because the sweeper may be running concurrently.\n+    \/\/ Save events to the queue for posting outside the CodeCache_lock.\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ Iterate over non-profiled and profiled nmethods\n+    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);\n+    while(iter.next()) {\n+      nmethod* current = iter.method();\n+      current->post_compiled_method_load_event(state);\n+    }\n@@ -241,0 +236,8 @@\n+\n+  \/\/ Now post all the events outside the CodeCache_lock.\n+  \/\/ If there's a safepoint, the queued events will be kept alive.\n+  \/\/ Adding these events to the service thread to post is something that\n+  \/\/ should work, but the service thread doesn't keep up in stress scenarios and\n+  \/\/ the os eventually kills the process with OOM.\n+  \/\/ We want this thread to wait until the events are all posted.\n+  state->post_events(env);\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/serviceThread.hpp\"\n@@ -1355,1 +1356,0 @@\n-  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n@@ -1359,1 +1359,1 @@\n-  JvmtiDeferredEventQueue::enqueue(event);\n+  ServiceThread::enqueue_deferred_event(&event);\n@@ -2236,1 +2236,0 @@\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n@@ -2239,1 +2238,1 @@\n-    JvmtiDeferredEventQueue::enqueue(event);\n+    ServiceThread::enqueue_deferred_event(&event);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-  static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;\n@@ -339,0 +338,1 @@\n+  static void post_compiled_method_load(JvmtiEnv* env, nmethod *nm) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1011,0 +1011,7 @@\n+void JvmtiDeferredEvent::post_compiled_method_load_event(JvmtiEnv* env) {\n+  assert(_type == TYPE_COMPILED_METHOD_LOAD, \"only user of this method\");\n+  nmethod* nm = _event_data.compiled_method_load;\n+  JvmtiExport::post_compiled_method_load(env, nm);\n+}\n+\n+\n@@ -1023,1 +1030,1 @@\n-  }  \/\/ May add UNLOAD event but it doesn't work yet.\n+  }\n@@ -1026,3 +1033,0 @@\n-JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_tail = NULL;\n-JvmtiDeferredEventQueue::QueueNode* JvmtiDeferredEventQueue::_queue_head = NULL;\n-\n@@ -1030,1 +1034,0 @@\n-  assert(Service_lock->owned_by_self(), \"Must own Service_lock\");\n@@ -1034,3 +1037,1 @@\n-void JvmtiDeferredEventQueue::enqueue(const JvmtiDeferredEvent& event) {\n-  assert(Service_lock->owned_by_self(), \"Must own Service_lock\");\n-\n+void JvmtiDeferredEventQueue::enqueue(JvmtiDeferredEvent event) {\n@@ -1047,1 +1048,0 @@\n-  Service_lock->notify_all();\n@@ -1053,2 +1053,0 @@\n-  assert(Service_lock->owned_by_self(), \"Must own Service_lock\");\n-\n@@ -1076,0 +1074,8 @@\n+void JvmtiDeferredEventQueue::post(JvmtiEnv* env) {\n+  \/\/ Post and destroy queue nodes\n+  while (_queue_head != NULL) {\n+     JvmtiDeferredEvent event = dequeue();\n+     event.post_compiled_method_load_event(env);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+  void post_compiled_method_load_event(JvmtiEnv* env) NOT_JVMTI_RETURN;\n@@ -500,1 +501,1 @@\n-class JvmtiDeferredEventQueue : AllStatic {\n+class JvmtiDeferredEventQueue : public CHeapObj<mtInternal> {\n@@ -518,2 +519,2 @@\n-  static QueueNode* _queue_head;             \/\/ Hold Service_lock to access\n-  static QueueNode* _queue_tail;             \/\/ Hold Service_lock to access\n+  QueueNode* _queue_head;\n+  QueueNode* _queue_tail;\n@@ -522,4 +523,9 @@\n-  \/\/ Must be holding Service_lock when calling these\n-  static bool has_events() NOT_JVMTI_RETURN_(false);\n-  static void enqueue(const JvmtiDeferredEvent& event) NOT_JVMTI_RETURN;\n-  static JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());\n+  JvmtiDeferredEventQueue() : _queue_head(NULL), _queue_tail(NULL) {}\n+\n+  bool has_events() NOT_JVMTI_RETURN_(false);\n+  JvmtiDeferredEvent dequeue() NOT_JVMTI_RETURN_(JvmtiDeferredEvent());\n+\n+  \/\/ Post all events in the queue for the current Jvmti environment\n+  void post(JvmtiEnv* env) NOT_JVMTI_RETURN_(false);\n+  void enqueue(JvmtiDeferredEvent event) NOT_JVMTI_RETURN;\n+\n@@ -527,1 +533,1 @@\n-  static void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n@@ -529,1 +535,1 @@\n-  static void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+  _jvmti_event_queue = NULL;\n+\n@@ -400,1 +402,1 @@\n-void JvmtiThreadState::oops_do(OopClosure* f) {\n+void JvmtiThreadState::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n@@ -402,0 +404,5 @@\n+\n+  \/\/ Keep nmethods from unloading on the event queue\n+  if (_jvmti_event_queue != NULL) {\n+    _jvmti_event_queue->oops_do(f, cf);\n+  }\n@@ -403,0 +410,25 @@\n+\n+void JvmtiThreadState::nmethods_do(CodeBlobClosure* cf) {\n+  \/\/ Keep nmethods from unloading on the event queue\n+  if (_jvmti_event_queue != NULL) {\n+    _jvmti_event_queue->nmethods_do(cf);\n+  }\n+}\n+\n+\/\/ Thread local event queue.\n+void JvmtiThreadState::enqueue_event(JvmtiDeferredEvent* event) {\n+  if (_jvmti_event_queue == NULL) {\n+    _jvmti_event_queue = new JvmtiDeferredEventQueue();\n+  }\n+  \/\/ copy the event\n+  _jvmti_event_queue->enqueue(*event);\n+}\n+\n+void JvmtiThreadState::post_events(JvmtiEnv* env) {\n+  if (_jvmti_event_queue != NULL) {\n+    _jvmti_event_queue->post(env);  \/\/ deletes each queue node\n+    delete _jvmti_event_queue;\n+    _jvmti_event_queue = NULL;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,3 @@\n+class JvmtiDeferredEvent;\n+class JvmtiDeferredEventQueue;\n+\n@@ -78,0 +81,2 @@\n+  \/\/ Jvmti Events that cannot be posted in their current context.\n+  JvmtiDeferredEventQueue* _jvmti_event_queue;\n@@ -387,1 +392,2 @@\n-  void oops_do(OopClosure* f) NOT_JVMTI_RETURN; \/\/ GC support\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN; \/\/ GC support\n+  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n@@ -391,0 +397,4 @@\n+\n+  \/\/ Thread local event queue, which doesn't require taking the Service_lock.\n+  void enqueue_event(JvmtiDeferredEvent* event);\n+  void post_events(JvmtiEnv* env);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+\/\/ The service thread has it's own static deferred event queue.\n+\/\/ Events can be posted before the service thread is created.\n+JvmtiDeferredEventQueue ServiceThread::_jvmti_service_queue;\n@@ -130,1 +133,1 @@\n-              (has_jvmti_events = JvmtiDeferredEventQueue::has_events()) |\n+              (has_jvmti_events = _jvmti_service_queue.has_events()) |\n@@ -145,1 +148,1 @@\n-        jvmti_event = JvmtiDeferredEventQueue::dequeue();\n+        jvmti_event = _jvmti_service_queue.dequeue();\n@@ -189,0 +192,6 @@\n+void ServiceThread::enqueue_deferred_event(JvmtiDeferredEvent* event) {\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  _jvmti_service_queue.enqueue(*event);\n+  Service_lock->notify_all();\n+ }\n+\n@@ -197,0 +206,1 @@\n+    \/\/ Requires a lock, because threads can be adding to this queue.\n@@ -198,1 +208,1 @@\n-    JvmtiDeferredEventQueue::oops_do(f, cf);\n+    _jvmti_service_queue.oops_do(f, cf);\n@@ -208,0 +218,1 @@\n+    \/\/ Requires a lock, because threads can be adding to this queue.\n@@ -209,1 +220,1 @@\n-    JvmtiDeferredEventQueue::nmethods_do(cf);\n+    _jvmti_service_queue.nmethods_do(cf);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"prims\/jvmtiImpl.hpp\"\n@@ -39,0 +40,1 @@\n+  static JvmtiDeferredEventQueue _jvmti_service_queue;\n@@ -50,0 +52,3 @@\n+  \/\/ Add event to the service thread event queue.\n+  static void enqueue_deferred_event(JvmtiDeferredEvent* event);\n+\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3035,1 +3035,1 @@\n-    jvmti_thread_state()->oops_do(f);\n+    jvmti_thread_state()->oops_do(f, cf);\n@@ -3061,0 +3061,4 @@\n+\n+  if (jvmti_thread_state() != NULL) {\n+    jvmti_thread_state()->nmethods_do(cf);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8212159\n+ * @summary Generate compiled method load events without crashing\n+ * @run main\/othervm\/native -agentlib:CompiledZombie -Xcomp -XX:ReservedCodeCacheSize=20m Zombie\n+ *\n+ * The stress test that made this fail was -jar SwingSet2.jar from demos (without DISPLAY set so it exits)\n+ *\/\n+\n+public class Zombie {\n+    public static void main(java.lang.String[] unused) {\n+        \/\/ There are plenty of compiled methods with -Xcomp even without doing much.\n+        System.out.println(\"Test passes if it doesn't crash while posting compiled method events.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/CompiledMethodLoad\/Zombie.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static int events;\n+static int total_events = 0;\n+\n+void JNICALL CompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,\n+                                jint code_size, const void* code_addr,\n+                                jint map_length, const jvmtiAddrLocationMap* map,\n+                                const void* compile_info) {\n+    events++;\n+    total_events++;\n+}\n+\n+\/\/ Continuously generate CompiledMethodLoad events for all currently compiled methods\n+void JNICALL GenerateEventsThread(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+    int count = 0;\n+\n+    while (true) {\n+        events = 0;\n+        jvmti->GenerateEvents(JVMTI_EVENT_COMPILED_METHOD_LOAD);\n+        if (events != 0 && ++count == 200) {\n+            printf(\"Generated %d events\\n\", events);\n+            count = 0;\n+        }\n+    }\n+}\n+\n+\/\/ As soon as VM starts, run a separate Agent thread that will generate CompiledMethodLoad events\n+void JNICALL VMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {\n+    jclass thread_class = jni->FindClass(\"java\/lang\/Thread\");\n+    jmethodID thread_constructor = jni->GetMethodID(thread_class, \"<init>\", \"()V\");\n+    jthread agent_thread = jni->NewObject(thread_class, thread_constructor);\n+\n+    jvmti->RunAgentThread(agent_thread, GenerateEventsThread, NULL, JVMTI_THREAD_NORM_PRIORITY);\n+}\n+\n+jint Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {\n+    jvmtiEnv* jvmti;\n+    vm->GetEnv((void**)&jvmti, JVMTI_VERSION_1_0);\n+\n+    jvmtiCapabilities capabilities;\n+    memset(&capabilities, 0, sizeof(capabilities));\n+\n+    capabilities.can_generate_compiled_method_load_events = 1;\n+    jvmti->AddCapabilities(&capabilities);\n+\n+    jvmtiEventCallbacks callbacks;\n+    memset(&callbacks, 0, sizeof(callbacks));\n+    callbacks.VMInit = VMInit;\n+    callbacks.CompiledMethodLoad = CompiledMethodLoad;\n+    jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+\n+    return 0;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/CompiledMethodLoad\/libCompiledZombie.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}