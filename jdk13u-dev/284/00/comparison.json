{"files":[{"patch":"@@ -306,1 +306,1 @@\n-                httpuc.getRequestMethod() == \"POST\") {\n+                \"POST\".equals(httpuc.getRequestMethod())) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-                httpuc.getRequestMethod() == \"POST\") {\n+                \"POST\".equals(httpuc.getRequestMethod())) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary This test checks that a broken HttpClient is not returned from the KeepAliveCache\n+ *          when the intial HttpURLConnection.setRequest method is passed a 'new String(\"POST\")'\n+ *          rather than the \"POST\" String literal\n+ * @bug 8274779\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www.protocol.http\n+ * @build java.base\/sun.net.www.http.HttpClientAccess\n+ * @run testng\/othervm RequestMethodEquality\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import sun.net.www.http.HttpClient;\n+import sun.net.www.http.HttpClientAccess;\n+import sun.net.www.http.KeepAliveCache;\n+import sun.net.www.protocol.http.HttpURLConnection;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+\n+public class RequestMethodEquality {\n+    private static final String TEST_CONTEXT = \"\/reqmethodtest\";\n+    private HttpServer server;\n+    private CustomHandler handler;\n+    private HttpClientAccess httpClientAccess;\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        handler = new CustomHandler();\n+        server = createServer(handler);\n+        httpClientAccess = new HttpClientAccess();\n+    }\n+\n+    @AfterTest\n+    public void tearDown() throws Exception {\n+        if (server != null) {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHttpClient() throws Exception {\n+        HttpURLConnection conn = null;\n+        try {\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .host(server.getAddress().getAddress())\n+                    .port(server.getAddress().getPort())\n+                    .path(TEST_CONTEXT)\n+                    .toURL();\n+\n+            conn = (HttpURLConnection) url.openConnection();\n+            conn.setChunkedStreamingMode(8); \/\/ ensures the call to HttpURLConnection.streaming() passes\n+\n+            int firstConnectTimeout = 1234;\n+            HttpClient freshClient = HttpClient.New(url, Proxy.NO_PROXY, firstConnectTimeout, true, conn);\n+            freshClient.closeServer(); \/\/ ensures that the call to HttpClient.available() fails\n+\n+            httpClientAccess.setInCache(freshClient, true); \/\/ allows the assertion in HttpClient.New to pass\n+\n+            \/\/ Injecting a mock KeepAliveCache that the HttpClient can use\n+            KeepAliveCache kac = httpClientAccess.getKeepAliveCache();\n+            kac.put(url, null, freshClient);\n+\n+            \/\/ The 'new' keyword is important here as the original code\n+            \/\/ used '==' rather than String.equals to compare request methods\n+            conn.setRequestMethod(new String(\"POST\"));\n+\n+            \/\/ Before the fix, the value returned to 'cachedClient' would have been the (broken) cached\n+            \/\/ 'freshClient' as HttpClient.available() could never be checked\n+            int secondConnectTimeout = 4321;\n+            HttpClient cachedClient = HttpClient.New(url, Proxy.NO_PROXY, secondConnectTimeout, true, conn);\n+            cachedClient.closeServer();\n+\n+            int originalConnectTimeout = freshClient.getConnectTimeout();\n+            int cachedConnectTimeout = cachedClient.getConnectTimeout();\n+\n+            \/\/ If both connectTimeout values are equal, it means the test retrieved the same broken\n+            \/\/ HttpClient from the cache and is trying to re-use it.\n+            Assert.assertNotEquals(originalConnectTimeout, cachedConnectTimeout, \"Both connectTimeout values are equal.\\nThis means the test is reusing a broken HttpClient rather than creating a new one.\");\n+        } finally {\n+            if (conn != null) {\n+                conn.disconnect();\n+            }\n+        }\n+    }\n+\n+    private static HttpServer createServer(final HttpHandler handler) throws IOException {\n+        final InetSocketAddress serverAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final int backlog = -1;\n+        final HttpServer server = HttpServer.create(serverAddress, backlog);\n+        server.createContext(TEST_CONTEXT, handler);\n+        server.start();\n+        System.out.println(\"Server started on \" + server.getAddress());\n+        return server;\n+    }\n+\n+    private static class CustomHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            \/\/ We'll always send 200 OK - We don't care about the server logic\n+            exchange.sendResponseHeaders(200, 1);\n+            exchange.close();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/RequestMethodCheck\/RequestMethodEquality.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.www.http;\n+\/\/ We can use this injected accessor class to get the KeepAliveCache from our HttpClient\n+public class HttpClientAccess {\n+    public KeepAliveCache getKeepAliveCache () {\n+        \/\/ kac is a protected static field in HttpClient\n+        return HttpClient.kac;\n+    }\n+\n+    public void setInCache(HttpClient client, boolean inCache) {\n+        client.inCache = inCache;\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/RequestMethodCheck\/java.base\/sun\/net\/www\/http\/HttpClientAccess.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}