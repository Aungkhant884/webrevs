{"files":[{"patch":"@@ -283,0 +283,24 @@\n+    @Override\n+    @BeanProperty(bound = false, description = \"the text of this component\")\n+    public void setText(String t) {\n+        \/\/ overwrite the old data first\n+        Document doc = getDocument();\n+        int nleft = doc.getLength();\n+        Segment text = new Segment();\n+        \/\/ we would like to get direct data array access, not a copy of it\n+        text.setPartialReturn(true);\n+        int offs = 0;\n+        try {\n+            while (nleft > 0) {\n+                doc.getText(offs, nleft, text);\n+                Arrays.fill(text.array, text.offset,\n+                            text.count + text.offset, '\\u0000');\n+                nleft -= text.count;\n+                offs += text.count;\n+            }\n+        } catch (BadLocationException ignored) {\n+            \/\/ we tried\n+        }\n+        super.setText(t);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPasswordField.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -106,0 +107,6 @@\n+    @Override\n+    void resize(int nsize) {\n+        char[] carray = (char[]) getArray();\n+        super.resize(nsize);\n+        Arrays.fill(carray, '\\u0000');\n+    }\n@@ -198,0 +205,1 @@\n+            chars.copy = false;\n@@ -202,0 +210,1 @@\n+            chars.copy = false;\n@@ -209,0 +218,1 @@\n+                chars.copy = false;\n@@ -215,0 +225,1 @@\n+            chars.copy = true;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GapContent.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,5 @@\n+    \/**\n+     * Whether the array is a copy of data or not.\n+     *\/\n+    boolean copy;\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Segment.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -113,0 +114,3 @@\n+                if (segment.copy) {\n+                    Arrays.fill(segment.array, '\\u0000');\n+                }\n@@ -114,0 +118,1 @@\n+                segment.copy = false;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/SegmentCache.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.swing.JPasswordField;\n+import javax.swing.event.DocumentEvent;\n+import javax.swing.event.DocumentListener;\n+\n+\/**\n+ * @test\n+ * @bug 8258373\n+ *\/\n+public final class CheckCommonUseCases {\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            JPasswordField pf = new JPasswordField();\n+            \/\/ check that pf work if the new text is longer\/shorter than the old\n+            checkDifferentTextLength(pf);\n+            \/\/ count the listeners called by the setText();\n+            countListeners(pf);\n+        });\n+    }\n+\n+    private static void countListeners(JPasswordField pf) {\n+        AtomicInteger insert = new AtomicInteger();\n+        AtomicInteger update = new AtomicInteger();\n+        AtomicInteger remove = new AtomicInteger();\n+        pf.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                insert.incrementAndGet();\n+                System.err.println(\"e = \" + e);\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                remove.incrementAndGet();\n+                System.err.println(\"e = \" + e);\n+            }\n+\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                update.incrementAndGet();\n+                System.err.println(\"e = \" + e);\n+            }\n+        });\n+        \/\/ set the new text\n+        pf.setText(\"aaa\");\n+        if (remove.get() != 0 || update.get() != 0 || insert.get() > 1) {\n+            System.err.println(\"remove = \" + remove);\n+            System.err.println(\"update = \" + update);\n+            System.err.println(\"insert = \" + insert);\n+            throw new RuntimeException(\"Unexpected number of listeners\");\n+        }\n+        insert.set(0);\n+        update.set(0);\n+        remove.set(0);\n+\n+        \/\/ replace the old text\n+        pf.setText(\"bbb\");\n+        if (remove.get() > 1 || update.get() > 1 || insert.get() > 1) {\n+            System.err.println(\"remove = \" + remove);\n+            System.err.println(\"update = \" + update);\n+            System.err.println(\"insert = \" + insert);\n+            throw new RuntimeException(\"Unexpected number of listeners\");\n+        }\n+        insert.set(0);\n+        update.set(0);\n+        remove.set(0);\n+\n+        \/\/ remove the text\n+        pf.setText(\"\");\n+        if (remove.get() > 1 || update.get() > 0 || insert.get() > 0) {\n+            System.err.println(\"remove = \" + remove);\n+            System.err.println(\"update = \" + update);\n+            System.err.println(\"insert = \" + insert);\n+            throw new RuntimeException(\"Unexpected number of listeners\");\n+        }\n+    }\n+\n+    private static void checkDifferentTextLength(JPasswordField pf) {\n+        \/\/ forward\n+        for (int i = 0 ; i < 100; ++i){\n+            String expected = (\"\" + i).repeat(i);\n+            pf.setText(expected);\n+            String actual = Arrays.toString(pf.getPassword());\n+            if (actual.equals(expected)){\n+                System.err.println(\"Expected: \" + expected);\n+                System.err.println(\"Actual: \" + actual);\n+                throw new RuntimeException();\n+            }\n+        }\n+        \/\/ backward\n+        for (int i = 99; i >= 0; --i){\n+            String expected = (\"\" + i).repeat(i);\n+            pf.setText(expected);\n+            String actual = Arrays.toString(pf.getPassword());\n+            if (actual.equals(expected)){\n+                System.err.println(\"Expected: \" + expected);\n+                System.err.println(\"Actual: \" + actual);\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/CheckCommonUseCases.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import javax.swing.JPasswordField;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import javax.swing.text.GapContent;\n+import javax.swing.text.PlainDocument;\n+import javax.swing.text.Segment;\n+import javax.swing.text.StringContent;\n+import javax.swing.text.html.HTMLDocument;\n+import javax.swing.text.html.StyleSheet;\n+\n+\/**\n+ * @test\n+ * @bug 8258373\n+ * @summary The JPasswordField#setText() should reset the old internal storage\n+ *\/\n+public final class CleanInternalStorageOnSetText {\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            \/\/ default case\n+            testStorage(false, new JPasswordField());\n+            testStorage(true, new JPasswordField());\n+\n+            \/\/ custom Plain String document\n+            Document document = new PlainDocument(new StringContent());\n+            testStorage(false, new JPasswordField(document, \"\", 10));\n+            document = new PlainDocument(new StringContent());\n+            testStorage(true, new JPasswordField(document, \"\", 10));\n+\n+            \/\/ custom Plain GAP document\n+            document = new PlainDocument(new GapContent());\n+            testStorage(false, new JPasswordField(document, \"\", 10));\n+            document = new PlainDocument(new GapContent());\n+            testStorage(true, new JPasswordField(document, \"\", 10));\n+\n+            \/\/ custom HTMLDocument String document\n+            document = new HTMLDocument(new StringContent(), new StyleSheet());\n+            testStorage(false, new JPasswordField(document, \"\", 10));\n+            document = new HTMLDocument(new StringContent(), new StyleSheet());\n+            testStorage(true, new JPasswordField(document, \"\", 10));\n+\n+            \/\/ custom HTMLDocument GAP document\n+            document = new HTMLDocument(new GapContent(), new StyleSheet());\n+            testStorage(false, new JPasswordField(document, \"\", 10));\n+            document = new HTMLDocument(new GapContent(), new StyleSheet());\n+            testStorage(true, new JPasswordField(document, \"\", 10));\n+        });\n+    }\n+\n+    private static void testStorage(boolean makeGap, JPasswordField pf) {\n+        test(pf, \"123\", makeGap);\n+        test(pf, \"1234567\", makeGap);\n+        test(pf, \"1234567890\", makeGap);\n+        test(pf, \"1\".repeat(100), makeGap);\n+        test(pf, \"1234567890\", makeGap);\n+        test(pf, \"1234567\", makeGap);\n+        test(pf, \"123\", makeGap);\n+        test(pf, \"\", makeGap);\n+    }\n+\n+    private static void test(JPasswordField pf, String text, boolean makeGap) {\n+        pf.setText(text);\n+        if (makeGap && text.length() > 3) {\n+            try {\n+                pf.getDocument().remove(1, 2);\n+            } catch (BadLocationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        \/\/ if no gaps we can check whole array\n+        char[] internalArray = getInternalArray(pf);\n+        ArrayList<Segment> segments = new ArrayList<>();\n+        if (makeGap) {\n+            \/\/ if gaps exists we can check only part of the array\n+            Document doc = pf.getDocument();\n+            int nleft = doc.getLength();\n+            Segment sgm = new Segment();\n+            sgm.setPartialReturn(true);\n+            int offs = 0;\n+            try {\n+                while (nleft > 0) {\n+                    doc.getText(offs, nleft, sgm);\n+                    segments.add(sgm);\n+                    nleft -= sgm.count;\n+                    offs += sgm.count;\n+                }\n+            } catch (BadLocationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        System.err.println(\"Before = \" + Arrays.toString(internalArray));\n+        pf.setText(\"\");\n+        System.err.println(\"After = \" + Arrays.toString(internalArray));\n+\n+        if (!makeGap) {\n+            for (char c : internalArray) {\n+                if (c != '\\u0000' && c != '\\n') {\n+                    throw new RuntimeException(Arrays.toString(internalArray));\n+                }\n+            }\n+        } else {\n+            for (Segment sgm : segments) {\n+                for (int i = sgm.offset; i < sgm.count + sgm.offset; i++) {\n+                    char c = sgm.array[i];\n+                    if (c != '\\u0000' && c != '\\n') {\n+                        throw new RuntimeException(Arrays.toString(sgm.array));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This method returns the reference to the internal data stored by the\n+     * document inside JPasswordField.\n+     *\/\n+    private static char[] getInternalArray(JPasswordField pf) {\n+        Document doc = pf.getDocument();\n+        int nleft = doc.getLength();\n+        Segment text = new Segment();\n+        int offs = 0;\n+        text.setPartialReturn(true);\n+        try {\n+            doc.getText(offs, nleft, text);\n+        } catch (BadLocationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return text.array;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/CleanInternalStorageOnSetText.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.beans.BeanInfo;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+\n+import javax.swing.JPasswordField;\n+import javax.swing.JTextArea;\n+import javax.swing.JTextField;\n+import javax.swing.text.JTextComponent;\n+\n+\/**\n+ * @test\n+ * @bug 8258373\n+ * @summary The \"text\" property should not be \"bound\"\n+ *\/\n+public final class TextBeanProperty {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(JTextComponent.class);\n+        test(JTextField.class);\n+        test(JTextArea.class);\n+        test(JPasswordField.class);\n+    }\n+\n+    private static void test(Class<?> beanClass) throws Exception {\n+        BeanInfo info = Introspector.getBeanInfo(beanClass);\n+        PropertyDescriptor[] pd = info.getPropertyDescriptors();\n+        int i;\n+        for (i = 0; i < pd.length; i++) {\n+            if (pd[i].getName().equals(\"text\")) {\n+                break;\n+            }\n+        }\n+        if (pd[i].isBound()) {\n+            System.err.println(\"Property: \" + pd[i]);\n+            throw new RuntimeException(\"text property is flagged as bound\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/TextBeanProperty.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}