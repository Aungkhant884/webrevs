{"files":[{"patch":"@@ -1576,1 +1576,5 @@\n-  Method* moop = method();\n+ \/\/ This is a bad time for a safepoint.  We don't want\n+ \/\/ this nmethod to get unloaded while we're queueing the event.\n+ NoSafepointVerifier nsv;\n+\n+  Method* m = method();\n@@ -1578,6 +1582,6 @@\n-      (char *) moop->klass_name()->bytes(),\n-      moop->klass_name()->utf8_length(),\n-      (char *) moop->name()->bytes(),\n-      moop->name()->utf8_length(),\n-      (char *) moop->signature()->bytes(),\n-      moop->signature()->utf8_length(),\n+      (char *) m->klass_name()->bytes(),\n+      m->klass_name()->utf8_length(),\n+      (char *) m->name()->bytes(),\n+      m->name()->utf8_length(),\n+      (char *) m->signature()->bytes(),\n+      m->signature()->utf8_length(),\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1957,1 +1957,1 @@\n-        MutexLocker ml(JmethodIdCreation_lock);\n+        MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n@@ -2007,1 +2007,1 @@\n-      MutexLocker ml(JmethodIdCreation_lock);\n+      MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2156,1 +2156,1 @@\n-      assert(sd->method() != NULL, \"sd->method() cannot be null.\");\n+      guarantee(sd->method() != NULL, \"sd->method() cannot be null.\");\n@@ -2167,0 +2167,1 @@\n+  guarantee(!nm->is_unloading(), \"nmethod isn't unloaded or unloading\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -923,3 +923,0 @@\n-  \/\/ Keep the nmethod alive until the ServiceThread can process\n-  \/\/ this deferred event.\n-  nmethodLocker::lock_nmethod(nm);\n@@ -958,1 +955,1 @@\n-  assert(ServiceThread::is_service_thread(Thread::current()),\n+  assert(Thread::current()->is_service_thread(),\n@@ -964,2 +961,0 @@\n-      \/\/ done with the deferred event so unlock the nmethod\n-      nmethodLocker::unlock_nmethod(nm);\n@@ -995,0 +990,15 @@\n+\/\/ Keep the nmethod for compiled_method_load from being unloaded.\n+void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }\n+}\n+\n+\/\/ The sweeper calls this and marks the nmethods here on the stack so that\n+\/\/ they cannot be turned into zombies while in the queue.\n+void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }  \/\/ May add UNLOAD event but it doesn't work yet.\n+}\n+\n@@ -1044,0 +1054,12 @@\n+\n+void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().oops_do(f, cf);\n+  }\n+}\n+\n+void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().nmethods_do(cf);\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -483,0 +483,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  void nmethods_do(CodeBlobClosure* cf);\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf);\n@@ -502,1 +506,1 @@\n-    const JvmtiDeferredEvent& event() const { return _event; }\n+    JvmtiDeferredEvent& event() { return _event; }\n@@ -516,0 +520,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  static void nmethods_do(CodeBlobClosure* cf);\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  static void oops_do(OopClosure* f, CodeBlobClosure* cf);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always); \/\/ used for creating jmethodIDs.\n+  def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never); \/\/ used for creating jmethodIDs.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+JvmtiDeferredEvent* ServiceThread::_jvmti_event = NULL;\n@@ -143,0 +144,1 @@\n+        \/\/ Get the event under the Service_lock\n@@ -144,0 +146,1 @@\n+        _jvmti_event = &jvmti_event;\n@@ -156,1 +159,2 @@\n-      jvmti_event.post();\n+      _jvmti_event->post();\n+      _jvmti_event = NULL;  \/\/ reset\n@@ -185,2 +189,22 @@\n-bool ServiceThread::is_service_thread(Thread* thread) {\n-  return thread == _instance;\n+void ServiceThread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  JavaThread::oops_do(f, cf);\n+  \/\/ The ServiceThread \"owns\" the JVMTI Deferred events, scan them here\n+  \/\/ to keep them alive until they are processed.\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->oops_do(f, cf);\n+    }\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::oops_do(f, cf);\n+  }\n+}\n+\n+void ServiceThread::nmethods_do(CodeBlobClosure* cf) {\n+  JavaThread::nmethods_do(cf);\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->nmethods_do(cf);\n+    }\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::nmethods_do(cf);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class JvmtiDeferredEvent;\n+\n@@ -35,1 +37,0 @@\n-\n@@ -37,0 +38,1 @@\n+  static JvmtiDeferredEvent* _jvmti_event;\n@@ -46,0 +48,1 @@\n+  bool is_service_thread() const                 { return true; }\n@@ -47,2 +50,3 @@\n-  \/\/ Returns true if the passed thread is the service thread.\n-  static bool is_service_thread(Thread* thread);\n+  \/\/ GC support\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf);\n+  void nmethods_do(CodeBlobClosure* cf);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -483,0 +483,1 @@\n+  virtual bool is_service_thread() const             { return false; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}