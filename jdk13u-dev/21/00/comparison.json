{"files":[{"patch":"@@ -49,0 +49,2 @@\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n@@ -50,0 +52,2 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -52,0 +56,4 @@\n+import javax.net.ssl.HandshakeCompletedEvent;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.security.sasl.SaslException;\n@@ -112,1 +120,1 @@\n-public final class Connection implements Runnable {\n+public final class Connection implements Runnable, HandshakeCompletedListener {\n@@ -352,0 +360,1 @@\n+            sslSocket.addHandshakeCompletedListener(this);\n@@ -647,0 +656,9 @@\n+                    if (isTlsConnection()) {\n+                        if (closureReason != null) {\n+                            CommunicationException ce = new CommunicationException();\n+                            ce.setRootCause(closureReason);\n+                            tlsHandshakeCompleted.completeExceptionally(ce);\n+                        } else {\n+                            tlsHandshakeCompleted.cancel(false);\n+                        }\n+                    }\n@@ -1011,0 +1029,42 @@\n+\n+    private final CompletableFuture<X509Certificate> tlsHandshakeCompleted =\n+            new CompletableFuture<>();\n+\n+    @Override\n+    public void handshakeCompleted(HandshakeCompletedEvent event) {\n+        try {\n+            X509Certificate tlsServerCert = null;\n+            Certificate[] certs;\n+            if (event.getSocket().getUseClientMode()) {\n+                certs = event.getPeerCertificates();\n+            } else {\n+                certs = event.getLocalCertificates();\n+            }\n+            if (certs != null && certs.length > 0 &&\n+                    certs[0] instanceof X509Certificate) {\n+                tlsServerCert = (X509Certificate) certs[0];\n+            }\n+            tlsHandshakeCompleted.complete(tlsServerCert);\n+        } catch (SSLPeerUnverifiedException ex) {\n+            CommunicationException ce = new CommunicationException();\n+            ce.setRootCause(closureReason);\n+            tlsHandshakeCompleted.completeExceptionally(ex);\n+        }\n+    }\n+\n+    public boolean isTlsConnection() {\n+        return sock instanceof SSLSocket;\n+    }\n+\n+    public X509Certificate getTlsServerCertificate()\n+            throws SaslException {\n+        try {\n+            if (isTlsConnection())\n+                return tlsHandshakeCompleted.get();\n+        } catch (InterruptedException iex) {\n+            throw new SaslException(\"TLS Handshake Exception \", iex);\n+        } catch (ExecutionException eex) {\n+            throw new SaslException(\"TLS Handshake Exception \", eex.getCause());\n+        }\n+        return null;\n+    }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.security.cert.X509Certificate;\n@@ -44,0 +45,1 @@\n+import com.sun.jndi.ldap.sasl.TlsChannelBinding.TlsChannelBindingType;\n@@ -113,0 +115,8 @@\n+        \/\/ Internal TLS Channel Binding property cannot be set explicitly\n+        if (env.get(TlsChannelBinding.CHANNEL_BINDING) != null) {\n+            throw new NamingException(TlsChannelBinding.CHANNEL_BINDING +\n+                    \" property cannot be set explicitly\");\n+        }\n+\n+        Hashtable<String, Object> envProps = (Hashtable<String, Object>) env;\n+\n@@ -114,0 +124,20 @@\n+            \/\/ Prepare TLS Channel Binding data\n+            if (conn.isTlsConnection()) {\n+                TlsChannelBindingType cbType =\n+                        TlsChannelBinding.parseType(\n+                                (String)env.get(TlsChannelBinding.CHANNEL_BINDING_TYPE));\n+                if (cbType == TlsChannelBindingType.TLS_SERVER_END_POINT) {\n+                    \/\/ set tls-server-end-point channel binding\n+                    X509Certificate cert = conn.getTlsServerCertificate();\n+                    if (cert != null) {\n+                        TlsChannelBinding tlsCB =\n+                                TlsChannelBinding.create(cert);\n+                        envProps = (Hashtable<String, Object>) env.clone();\n+                        envProps.put(TlsChannelBinding.CHANNEL_BINDING, tlsCB.getData());\n+                    } else {\n+                        throw new SaslException(\"No suitable certificate to generate \" +\n+                                \"TLS Channel Binding data\");\n+                    }\n+                }\n+            }\n+\n@@ -116,1 +146,1 @@\n-                mechs, authzId, \"ldap\", server, (Hashtable<String, ?>)env, cbh);\n+                mechs, authzId, \"ldap\", server, envProps, cbh);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/LdapSasl.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jndi.ldap.sasl;\n+\n+import javax.naming.NamingException;\n+import javax.security.sasl.SaslException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+\n+\/**\n+ * This class implements the Channel Binding for TLS as defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5929.txt\">\n+ *     Channel Bindings for TLS<\/a>\n+ *\n+ * Format of the Channel Binding data is also defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5056.txt\">\n+ *     On the Use of Channel Bindings to Secure Channels<\/a>\n+ * section 2.1.\n+ *\n+ *\/\n+\n+public class TlsChannelBinding {\n+\n+    \/\/ TLS channel binding type property\n+    public static final String CHANNEL_BINDING_TYPE =\n+            \"com.sun.jndi.ldap.tls.cbtype\";\n+\n+    \/\/ internal TLS channel binding property\n+    public static final String CHANNEL_BINDING =\n+            \"jdk.internal.sasl.tlschannelbinding\";\n+\n+    public enum TlsChannelBindingType {\n+\n+        \/**\n+         * Channel binding on the basis of TLS Finished message.\n+         * TLS_UNIQUE is defined by RFC 5929 but is not supported\n+         * by the current LDAP stack.\n+         *\/\n+        TLS_UNIQUE(\"tls-unique\"),\n+\n+        \/**\n+         * Channel binding on the basis of TLS server certificate.\n+         *\/\n+        TLS_SERVER_END_POINT(\"tls-server-end-point\");\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        final private String name;\n+        TlsChannelBindingType(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/**\n+     * Parse value of \"com.sun.jndi.ldap.tls.cbtype\" property\n+     * @param  cbType\n+     * @return TLS Channel Binding type or null if\n+     *         \"com.sun.jndi.ldap.tls.cbtype\" property has not been set.\n+     * @throws NamingException\n+     *\/\n+    public static TlsChannelBindingType parseType(String cbType) throws NamingException {\n+        if (cbType != null) {\n+            if (cbType.equals(TlsChannelBindingType.TLS_SERVER_END_POINT.getName())) {\n+                return TlsChannelBindingType.TLS_SERVER_END_POINT;\n+            } else {\n+                throw new NamingException(\"Illegal value for \" +\n+                        CHANNEL_BINDING_TYPE + \" property.\");\n+            }\n+        }\n+        return null;\n+    }\n+\n+    final private TlsChannelBindingType cbType;\n+    final private byte[] cbData;\n+\n+    \/**\n+     * Construct tls-server-end-point Channel Binding data\n+     * @param serverCertificate\n+     * @throws SaslException\n+     *\/\n+    public static TlsChannelBinding create(X509Certificate serverCertificate) throws SaslException {\n+        try {\n+            final byte[] prefix =\n+                TlsChannelBindingType.TLS_SERVER_END_POINT.getName().concat(\":\").getBytes();\n+            String hashAlg = serverCertificate.getSigAlgName().\n+                    replace(\"SHA\", \"SHA-\").toUpperCase();\n+            int ind = hashAlg.indexOf(\"WITH\");\n+            if (ind > 0) {\n+                hashAlg = hashAlg.substring(0, ind);\n+                if (hashAlg.equals(\"MD5\") || hashAlg.equals(\"SHA-1\")) {\n+                    hashAlg = \"SHA-256\";\n+                }\n+            } else {\n+                hashAlg = \"SHA-256\";\n+            }\n+            MessageDigest md = MessageDigest.getInstance(hashAlg);\n+            byte[] hash = md.digest(serverCertificate.getEncoded());\n+            byte[] cbData = Arrays.copyOf(prefix, prefix.length + hash.length );\n+            System.arraycopy(hash, 0, cbData, prefix.length, hash.length);\n+            return new TlsChannelBinding(TlsChannelBindingType.TLS_SERVER_END_POINT, cbData);\n+        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n+            throw new SaslException(\"Cannot create TLS channel binding data\", e);\n+        }\n+    }\n+\n+    private TlsChannelBinding(TlsChannelBindingType cbType, byte[] cbData) {\n+        this.cbType = cbType;\n+        this.cbData = cbData;\n+    }\n+\n+    public TlsChannelBindingType getType() {\n+        return cbType;\n+    }\n+\n+    public byte[] getData() {\n+        return cbData;\n+    }\n+}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/TlsChannelBinding.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -62,0 +62,14 @@\n+ *     <li>{@code com.sun.jndi.ldap.tls.cbtype}:\n+ *         <br>The value of this property is the string representing the TLS\n+ *         Channel Binding type required for an LDAP connection over SSL\/TLS.\n+ *         Possible value is :\n+ *         <ul>\n+ *             <li>\"tls-server-end-point\" - Channel Binding data is created on\n+ *                 the basis of the TLS server certificate.\n+ *             <\/li>\n+ *         <\/ul>\n+ *         <br>\"tls-unique\" TLS Channel Binding type is specified in RFC-5929\n+ *         but not supported.\n+ *         <br>If this property is not specified, the client does not send\n+ *         channel binding information to the server.\n+ *     <\/li>\n","filename":"src\/java.naming\/share\/classes\/module-info.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+    exports sun.security.jgss.krb5.internal to\n+        jdk.security.jgss;\n","filename":"src\/java.security.jgss\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\n@@ -60,0 +61,1 @@\n+    private static final int CHANNEL_BINDING_AF_UNSPEC = 0;\n@@ -336,2 +338,2 @@\n-    private int getAddrType(InetAddress addr) {\n-        int addressType = CHANNEL_BINDING_AF_NULL_ADDR;\n+    private int getAddrType(InetAddress addr, int defValue) {\n+        int addressType = defValue;\n@@ -347,1 +349,1 @@\n-        int addressType = getAddrType(addr);\n+        int addressType = getAddrType(addr, CHANNEL_BINDING_AF_NULL_ADDR);\n@@ -378,2 +380,10 @@\n-        int initiatorAddressType = getAddrType(initiatorAddress);\n-        int acceptorAddressType = getAddrType(acceptorAddress);\n+        \/\/ LDAP TLS Channel Binding requires CHANNEL_BINDING_AF_UNSPEC address type\n+        \/\/ for unspecified initiator and acceptor addresses.\n+        \/\/ CHANNEL_BINDING_AF_NULL_ADDR value should be used for unspecified address\n+        \/\/ in all other cases.\n+        int initiatorAddressType = getAddrType(initiatorAddress,\n+                (channelBinding instanceof TlsChannelBindingImpl) ?\n+                        CHANNEL_BINDING_AF_UNSPEC : CHANNEL_BINDING_AF_NULL_ADDR);\n+        int acceptorAddressType = getAddrType(acceptorAddress,\n+                (channelBinding instanceof TlsChannelBindingImpl) ?\n+                        CHANNEL_BINDING_AF_UNSPEC : CHANNEL_BINDING_AF_NULL_ADDR);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/InitialToken.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.jgss.krb5.internal;\n+\n+import org.ietf.jgss.ChannelBinding;\n+\n+\/**\n+ * TLS Channel Binding wrapper class to determine internal\n+ * tls channel binding implementation.\n+ *\/\n+public class TlsChannelBindingImpl extends ChannelBinding {\n+    public TlsChannelBindingImpl(byte[] appData) {\n+        super(appData);\n+    }\n+}\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/internal\/TlsChannelBindingImpl.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -37,0 +37,2 @@\n+static jclass tlsCBCl = NULL;\n+\n@@ -72,0 +74,11 @@\n+    if (tlsCBCl == NULL) {\n+\n+        \/* initialize TLS Channel Binding class wrapper *\/\n+        jclass cl = (*env)->FindClass(env,\n+                    \"sun\/security\/jgss\/krb5\/internal\/TlsChannelBindingImpl\");\n+        if (cl == NULL) {           \/* exception thrown *\/\n+            return JNI_FALSE;\n+        }\n+        tlsCBCl = (*env)->NewGlobalRef(env, cl);\n+    }\n+\n@@ -157,1 +170,2 @@\n-  if (cb->initiator_addrtype != GSS_C_AF_NULLADDR) {\n+  if (cb->initiator_addrtype != GSS_C_AF_NULLADDR &&\n+      cb->initiator_addrtype != GSS_C_AF_UNSPEC) {\n@@ -161,1 +175,2 @@\n-  if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR) {\n+  if (cb->acceptor_addrtype != GSS_C_AF_NULLADDR &&\n+      cb->acceptor_addrtype != GSS_C_AF_UNSPEC) {\n@@ -192,3 +207,13 @@\n-  cb->initiator_addrtype = GSS_C_AF_NULLADDR;\n-  cb->acceptor_addrtype = GSS_C_AF_NULLADDR;\n-\n+  \/\/ LDAP TLS Channel Binding requires GSS_C_AF_UNSPEC address type\n+  \/\/ for unspecified initiator and acceptor addresses.\n+  \/\/ GSS_C_AF_NULLADDR value should be used for unspecified address\n+  \/\/ in all other cases.\n+\n+  if ((*env)->IsInstanceOf(env, jcb, tlsCBCl)) {\n+      \/\/ TLS Channel Binding requires unspecified addrtype=0\n+      cb->initiator_addrtype = GSS_C_AF_UNSPEC;\n+      cb->acceptor_addrtype = GSS_C_AF_UNSPEC;\n+  } else {\n+      cb->initiator_addrtype = GSS_C_AF_NULLADDR;\n+      cb->acceptor_addrtype = GSS_C_AF_NULLADDR;\n+  }\n","filename":"src\/java.security.jgss\/share\/native\/libj2gss\/GSSLibStub.c","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\n@@ -143,0 +144,10 @@\n+            if (props != null) {\n+                \/\/ TLS Channel Binding\n+                \/\/ Property name is defined in the TLSChannelBinding class of\n+                \/\/ the java.naming module\n+                byte[] tlsCB = (byte[])props.get(\"jdk.internal.sasl.tlschannelbinding\");\n+                if (tlsCB != null) {\n+                    secCtx.setChannelBinding(new TlsChannelBindingImpl(tlsCB));\n+                }\n+            }\n+\n","filename":"src\/jdk.security.jgss\/share\/classes\/com\/sun\/security\/sasl\/gsskerb\/GssKrb5Client.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245527\n+ * @library lib\/ \/test\/lib\n+ * @run main\/othervm LdapCBPropertiesTest true  true  com.sun.jndi.ldap.tls.cbtype tls-server-end-point\n+ * @run main\/othervm LdapCBPropertiesTest false false com.sun.jndi.ldap.tls.cbtype tls-server-end-point\n+ * @run main\/othervm LdapCBPropertiesTest true  true  com.sun.jndi.ldap.tls.cbtype tls-server-end-point com.sun.jndi.ldap.connect.timeout 2000\n+ * @run main\/othervm LdapCBPropertiesTest false false com.sun.jndi.ldap.tls.cbtype tls-server-end-point com.sun.jndi.ldap.connect.timeout 2000\n+ * @run main\/othervm LdapCBPropertiesTest false true  com.sun.jndi.ldap.tls.cbtype tls-unknown\n+ * @run main\/othervm LdapCBPropertiesTest false true  jdk.internal.sasl.tlschannelbinding value\n+ * @summary test new JNDI property to control the Channel Binding data\n+ *\/\n+\n+import javax.naming.AuthenticationException;\n+import javax.naming.CommunicationException;\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.util.Hashtable;\n+\n+import org.ietf.jgss.GSSException;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.security.sasl.SaslException;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class LdapCBPropertiesTest {\n+    \/*\n+     * Where do we find the keystores?\n+     *\/\n+    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n+    static String keyStoreFile = \"keystore\";\n+    static String trustStoreFile = \"truststore\";\n+    static String passwd = \"passphrase\";\n+\n+    static boolean debug = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        String keyFilename =\n+                System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                        \"\/\" + keyStoreFile;\n+        String trustFilename =\n+                System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                        \"\/\" + trustStoreFile;\n+\n+        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n+        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+\n+        if (debug)\n+            System.setProperty(\"javax.net.debug\", \"all\");\n+\n+        \/*\n+         * Start the tests.\n+         *\/\n+        new LdapCBPropertiesTest(args);\n+    }\n+\n+    \/*\n+     * Primary constructor, used to drive remainder of the test.\n+     *\/\n+    LdapCBPropertiesTest(String[] args) throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        SSLServerSocketFactory sslssf =\n+                (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+        SSLServerSocket sslServerSocket =\n+                (SSLServerSocket) sslssf.createServerSocket(0, 0, loopback);\n+        int serverPort = sslServerSocket.getLocalPort();\n+\n+        try (var ignore = new BaseLdapServer(sslServerSocket).start()) {\n+            doClientSide(serverPort, args);\n+        }\n+    }\n+\n+    \/*\n+     * Define the client side of the test.\n+     *\n+     * The server should start at this time already\n+     *\/\n+    void doClientSide(int serverPort, String[] args) throws Exception {\n+        boolean passed = false;\n+        boolean shouldPass = Boolean.parseBoolean(args[0]);\n+        boolean shouldConnect = Boolean.parseBoolean(args[1]);\n+        \/\/ set disableEndpointIdentification to disable hostname verification\n+        if (shouldConnect) {\n+            System.setProperty(\n+                    \"com.sun.jndi.ldap.object.disableEndpointIdentification\", \"true\");\n+        }\n+\n+        \/\/ Set up the environment for creating the initial context\n+        Hashtable env = new Hashtable();\n+        URI uri = URIBuilder.newBuilder()\n+            .scheme(\"ldaps\")\n+            .loopback()\n+            .port(serverPort)\n+            .build();\n+        env.put(Context.PROVIDER_URL, uri.toString());\n+        env.put(Context.INITIAL_CONTEXT_FACTORY,\n+                \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(Context.SECURITY_AUTHENTICATION, \"GSSAPI\");\n+\n+        \/\/ read properties\n+        for (int i = 2; i < args.length; i += 2) {\n+            env.put(args[i], args[i + 1]);\n+            if (debug)\n+                System.out.println(\"Env=\" + args[i] + \"=\" + args[i + 1]);\n+        }\n+\n+        try {\n+            DirContext ctx = new InitialDirContext(env);\n+            passed = shouldPass;\n+            ctx.close();\n+        } catch (NamingException ne) {\n+            \/\/ only NamingException is allowed\n+            if (debug)\n+                System.out.println(\"Exception=\" + ne + \" cause=\" + ne.getRootCause());\n+            passed = handleNamingException(ne, shouldPass, shouldConnect);\n+        } catch(Exception e) {\n+            System.err.println(\"Failed: caught an unexpected Exception - \" + e);\n+            throw e;\n+        } finally {\n+            \/\/ test if internal property accessible to application\n+            if(shouldPass &&\n+                    env.get(\"jdk.internal.sasl.tlschannelbinding\") != null) {\n+                throw new Exception(\n+                        \"Test FAILED: jdk.internal.sasl.tlschannelbinding should not be accessible\");\n+            }\n+        }\n+        if (!passed) {\n+            throw new Exception(\n+                    \"Test FAILED: NamingException exception should be thrown\");\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    private static boolean handleNamingException(NamingException ne, boolean shouldPass, boolean shouldConnect)\n+        throws NamingException {\n+        if (ne instanceof AuthenticationException &&\n+            ne.getRootCause() instanceof SaslException) {\n+            SaslException saslEx = (SaslException) ne.getRootCause();\n+            if (shouldConnect && saslEx.getCause() instanceof GSSException) {\n+                \/\/ SSL connection successful, expected exception from SaslClient\n+                if (shouldPass)\n+                    return true;\n+            }\n+        }\n+        if (!shouldConnect) {\n+            \/\/ SSL handshake fails\n+            Exception ex = ne;\n+            while(ex != null && !(ex instanceof CommunicationException)) {\n+                ex = (Exception)ex.getCause();\n+            }\n+            if (ex != null) {\n+                if (ex.getCause() instanceof SSLException) {\n+                    if (!shouldPass)\n+                        return true;\n+                }\n+            }\n+        }\n+        if (!shouldPass && ne.getRootCause() == null) {\n+            \/\/ Expected exception caused by Channel Binding parameter inconsistency\n+            return true;\n+        }\n+        throw ne;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapCBPropertiesTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}