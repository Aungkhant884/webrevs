{"files":[{"patch":"@@ -1352,1 +1352,17 @@\n-  Thread *thread = Thread::current();\n+\n+  \/\/ postings to the service thread so that it can perform them in a safe\n+  \/\/ context and in-order.\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  ResourceMark rm;\n+  \/\/ JvmtiDeferredEvent copies the string.\n+  JvmtiDeferredEvent event = JvmtiDeferredEvent::class_unload_event(klass->name()->as_C_string());\n+  JvmtiDeferredEventQueue::enqueue(event);\n+}\n+\n+\n+void JvmtiExport::post_class_unload_internal(const char* name) {\n+  if (JvmtiEnv::get_phase() < JVMTI_PHASE_PRIMORDIAL) {\n+    return;\n+  }\n+  assert(Thread::current()->is_service_thread(), \"must be called from ServiceThread\");\n+  JavaThread *thread = JavaThread::current();\n@@ -1357,9 +1373,0 @@\n-    assert(thread->is_VM_thread(), \"wrong thread\");\n-\n-    \/\/ get JavaThread for whom we are proxy\n-    Thread *calling_thread = ((VMThread *)thread)->vm_operation()->calling_thread();\n-    if (!calling_thread->is_Java_thread()) {\n-      \/\/ cannot post an event to a non-JavaThread\n-      return;\n-    }\n-    JavaThread *real_thread = (JavaThread *)calling_thread;\n@@ -1373,15 +1380,1 @@\n-        EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (\"[?] Evt Class Unload sent %s\",\n-                  klass==NULL? \"NULL\" : klass->external_name() ));\n-\n-        \/\/ do everything manually, since this is a proxy - needs special care\n-        JNIEnv* jni_env = real_thread->jni_environment();\n-        jthread jt = (jthread)JNIHandles::make_local(real_thread, real_thread->threadObj());\n-        jclass jk = (jclass)JNIHandles::make_local(real_thread, klass->java_mirror());\n-\n-        \/\/ Before we call the JVMTI agent, we have to set the state in the\n-        \/\/ thread for which we are proxying.\n-        JavaThreadState prev_state = real_thread->thread_state();\n-        assert(((Thread *)real_thread)->is_ConcurrentGC_thread() ||\n-               (real_thread->is_Java_thread() && prev_state == _thread_blocked),\n-               \"should be ConcurrentGCThread or JavaThread at safepoint\");\n-        real_thread->set_thread_state(_thread_in_native);\n+        EVT_TRACE(EXT_EVENT_CLASS_UNLOAD, (\"[?] Evt Class Unload sent %s\", name));\n@@ -1389,0 +1382,2 @@\n+        JvmtiEventMark jem(thread);\n+        JvmtiJavaThreadEventTransition jet(thread);\n@@ -1391,1 +1386,1 @@\n-          (*callback)(env->jvmti_external(), jni_env, jt, jk);\n+          (*callback)(env->jvmti_external(), jem.jni_env(), name);\n@@ -1393,7 +1388,0 @@\n-\n-        assert(real_thread->thread_state() == _thread_in_native,\n-               \"JavaThread should be in native\");\n-        real_thread->set_thread_state(prev_state);\n-\n-        JNIHandles::destroy_local(jk);\n-        JNIHandles::destroy_local(jt);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  static void post_class_unload_internal(const char *name) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,3 +73,2 @@\n-    { (char*)\"JNI Environment\", JVMTI_KIND_IN, JVMTI_TYPE_JNIENV, JNI_FALSE },\n-    { (char*)\"Thread\", JVMTI_KIND_IN, JVMTI_TYPE_JTHREAD, JNI_FALSE },\n-    { (char*)\"Class\", JVMTI_KIND_IN, JVMTI_TYPE_JCLASS, JNI_FALSE }\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE },\n+    { (char*)\"Class\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_CCHAR, JNI_FALSE }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -954,0 +954,10 @@\n+JvmtiDeferredEvent JvmtiDeferredEvent::class_unload_event(const char* name) {\n+  JvmtiDeferredEvent event = JvmtiDeferredEvent(TYPE_CLASS_UNLOAD);\n+  \/\/ Need to make a copy of the name since we don't know how long\n+  \/\/ the event poster will keep it around after we enqueue the\n+  \/\/ deferred event and return. strdup() failure is handled in\n+  \/\/ the post() routine below.\n+  event._event_data.class_unload.name = os::strdup(name);\n+  return event;\n+}\n+\n@@ -985,0 +995,11 @@\n+    case TYPE_CLASS_UNLOAD: {\n+      JvmtiExport::post_class_unload_internal(\n+        \/\/ if strdup failed give the event a default name\n+        (_event_data.class_unload.name == NULL)\n+          ? \"unknown_class\" : _event_data.class_unload.name);\n+      if (_event_data.class_unload.name != NULL) {\n+        \/\/ release our copy\n+        os::free((void *)_event_data.class_unload.name);\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -448,1 +448,2 @@\n-    TYPE_DYNAMIC_CODE_GENERATED\n+    TYPE_DYNAMIC_CODE_GENERATED,\n+    TYPE_CLASS_UNLOAD\n@@ -464,0 +465,3 @@\n+    struct {\n+      const char* name;\n+    } class_unload;\n@@ -480,0 +484,2 @@\n+  static JvmtiDeferredEvent class_unload_event(\n+      const char* name) NOT_JVMTI_RETURN_(JvmtiDeferredEvent());\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1735,1 +1735,1 @@\n-  set_thread_state(_thread_new);\n+  _thread_state = _thread_new;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+  assert(current_or_null() == NULL || current_or_null() == this,\n+         \"state change should only be called by the current thread\");\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/extension\/EX03\/ex03t001\/TestDescription.java 8173658 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,8 +44,3 @@\n-ClassUnload(jvmtiEnv* jvmti_env, JNIEnv *jni_env, jthread thread, jclass klass, ...) {\n-    \/*\n-     * With the CMS GC the event can be posted on\n-     * a ConcurrentGC thread that is not a JavaThread.\n-     * In this case the thread argument can be NULL, so that,\n-     * we should not expect the thread argument to be non-NULL.\n-     *\/\n-    if (klass == NULL) {\n+ClassUnload(jvmtiEnv* jvmti_env, JNIEnv* jni_env, const char* name, ...) {\n+    \/\/ The name argument should never be null\n+    if (name == NULL) {\n@@ -53,2 +48,3 @@\n-        NSK_COMPLAIN0(\"ClassUnload: 'klass' input parameter is NULL.\\n\");\n-\n+        NSK_COMPLAIN0(\"ClassUnload: 'name' input parameter is NULL.\\n\");\n+    } else {\n+        NSK_DISPLAY1(\"Class unloaded %s\\n\", name);\n@@ -56,0 +52,1 @@\n+\n@@ -110,0 +107,14 @@\n+jboolean checkParams(jvmtiExtensionEventInfo event) {\n+    \/\/ Check parameters are:\n+    \/\/ JNIEnv *jni_env, const char* name\n+    if (event.param_count != 2 ||\n+          event.params[0].kind != JVMTI_KIND_IN_PTR ||\n+          event.params[0].base_type != JVMTI_TYPE_JNIENV ||\n+          event.params[1].kind != JVMTI_KIND_IN_PTR ||\n+          event.params[1].base_type != JVMTI_TYPE_CCHAR) {\n+        return JNI_FALSE;\n+    } else {\n+        return JNI_TRUE;\n+    }\n+}\n+\n@@ -125,0 +136,8 @@\n+            NSK_DISPLAY1(\"%s\", extList[i].short_description);\n+\n+            if (!checkParams(extList[i])) {\n+                NSK_COMPLAIN0(\"ClassUnload event has wrong parameters.\");\n+                nsk_jvmti_setFailStatus();\n+                return JNI_FALSE;\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/extension\/EX03\/ex03t001\/ex03t001.cpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"}]}