{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,16 +39,1 @@\n-  return is_root() ? (oop)NULL : UnifiedOop::dereference(_parent->reference());\n-}\n-\n-static const Klass* resolve_klass(const oop obj) {\n-  assert(obj != NULL, \"invariant\");\n-  return java_lang_Class::is_instance(obj) ?\n-    java_lang_Class::as_Klass(obj) : obj->klass();\n-}\n-\n-const Klass* Edge::pointee_klass() const {\n-  return resolve_klass(pointee());\n-}\n-\n-const Klass* Edge::reference_owner_klass() const {\n-  const oop ref_owner = reference_owner();\n-  return ref_owner != NULL ? resolve_klass(ref_owner) : NULL;\n+  return is_root() ? (oop)NULL : _parent->pointee();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edge.cpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-  const Klass* pointee_klass() const;\n@@ -51,1 +50,0 @@\n-  const Klass* reference_owner_klass() const;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edge.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"oops\/instanceMirrorKlass.hpp\"\n@@ -41,3 +42,8 @@\n-static int field_offset(const StoredEdge& edge) {\n-  assert(!edge.is_root(), \"invariant\");\n-  const oop ref_owner = edge.reference_owner();\n+static bool is_static_field(const oop ref_owner, const InstanceKlass* ik, int offset) {\n+  assert(ref_owner != NULL, \"invariant\");\n+  assert(ik != NULL, \"invariant\");\n+  assert(ref_owner->klass() == ik, \"invariant\");\n+  return ik->is_mirror_instance_klass() && offset >= InstanceMirrorKlass::cast(ik)->offset_of_static_fields();\n+}\n+\n+static int field_offset(const Edge& edge, const oop ref_owner) {\n@@ -45,0 +51,2 @@\n+  assert(!ref_owner->is_array(), \"invariant\");\n+  assert(ref_owner->is_instance(), \"invariant\");\n@@ -48,2 +56,0 @@\n-  assert(!ref_owner->is_array(), \"invariant\");\n-  assert(ref_owner->is_instance(), \"invariant\");\n@@ -51,1 +57,1 @@\n-  assert(offset < (ref_owner->size() * HeapWordSize), \"invariant\");\n+  assert(offset < ref_owner->size() * HeapWordSize, \"invariant\");\n@@ -55,6 +61,1 @@\n-static const InstanceKlass* field_type(const StoredEdge& edge) {\n-  assert(!edge.is_root() || !EdgeUtils::is_array_element(edge), \"invariant\");\n-  return (const InstanceKlass*)edge.reference_owner_klass();\n-}\n-\n-const Symbol* EdgeUtils::field_name_symbol(const Edge& edge) {\n+const Symbol* EdgeUtils::field_name(const Edge& edge, jshort* modifiers) {\n@@ -62,3 +63,12 @@\n-  assert(!is_array_element(edge), \"invariant\");\n-  const int offset = field_offset(edge);\n-  const InstanceKlass* ik = field_type(edge);\n+  assert(!EdgeUtils::is_array_element(edge), \"invariant\");\n+  assert(modifiers != NULL, \"invariant\");\n+  const oop ref_owner = edge.reference_owner();\n+  assert(ref_owner != NULL, \"invariant\");\n+  assert(ref_owner->klass()->is_instance_klass(), \"invariant\");\n+  const InstanceKlass* ik = InstanceKlass::cast(ref_owner->klass());\n+  const int offset = field_offset(edge, ref_owner);\n+  if (is_static_field(ref_owner, ik, offset)) {\n+    assert(ik->is_mirror_instance_klass(), \"invariant\");\n+    assert(java_lang_Class::as_Klass(ref_owner)->is_instance_klass(), \"invariant\");\n+    ik = InstanceKlass::cast(java_lang_Class::as_Klass(ref_owner));\n+  }\n@@ -69,0 +79,1 @@\n+        *modifiers = jfs.access_flags().as_short();\n@@ -73,1 +84,1 @@\n-    ik = (InstanceKlass*)ik->super();\n+    ik = (const InstanceKlass*)ik->super();\n@@ -75,0 +86,1 @@\n+  *modifiers = 0;\n@@ -78,17 +90,0 @@\n-jshort EdgeUtils::field_modifiers(const Edge& edge) {\n-  const int offset = field_offset(edge);\n-  const InstanceKlass* ik = field_type(edge);\n-\n-  while (ik != NULL) {\n-    JavaFieldStream jfs(ik);\n-    while (!jfs.done()) {\n-      if (offset == jfs.offset()) {\n-        return jfs.access_flags().as_short();\n-      }\n-      jfs.next();\n-    }\n-    ik = (InstanceKlass*)ik->super();\n-  }\n-  return 0;\n-}\n-\n@@ -103,1 +98,1 @@\n-  assert(!edge.is_root(), \"invariant\");\n+  assert(EdgeUtils::is_array_element(edge), \"invariant\");\n@@ -117,1 +112,1 @@\n-  return is_array_element(edge) ? array_offset(edge) : 0;\n+  return array_offset(edge);\n@@ -121,7 +116,5 @@\n-  if (is_array_element(edge)) {\n-    const oop ref_owner = edge.reference_owner();\n-    assert(ref_owner != NULL, \"invariant\");\n-    assert(ref_owner->is_objArray(), \"invariant\");\n-    return ((objArrayOop)(ref_owner))->length();\n-  }\n-  return 0;\n+  assert(is_array_element(edge), \"invariant\");\n+  const oop ref_owner = edge.reference_owner();\n+  assert(ref_owner != NULL, \"invariant\");\n+  assert(ref_owner->is_objArray(), \"invariant\");\n+  return ((objArrayOop)ref_owner)->length();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":36,"deletions":43,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  static const Symbol* field_name_symbol(const Edge& edge);\n-  static jshort field_modifiers(const Edge& edge);\n+  static const Symbol* field_name(const Edge& edge, jshort* modifiers);\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -301,1 +301,0 @@\n-\n@@ -303,1 +302,2 @@\n-  const Symbol* const field_name_symbol = EdgeUtils::field_name_symbol(edge);\n+  jshort field_modifiers;\n+  const Symbol* const field_name_symbol = EdgeUtils::field_name(edge, &field_modifiers);\n@@ -307,1 +307,0 @@\n-\n@@ -312,1 +311,0 @@\n-\n@@ -316,1 +314,1 @@\n-  osfi->_field_modifiers = EdgeUtils::field_modifiers(edge);\n+  osfi->_field_modifiers = field_modifiers;\n@@ -534,1 +532,1 @@\n-  oosi->_data._reference_id = current->parent() == NULL ? (traceid)0 : id;\n+  oosi->_data._reference_id = current->parent() == NULL ? 0 : id;\n@@ -549,2 +547,2 @@\n-  ri->_data._array_info_id =  !current->is_skip_edge() ? get_array_info_id(*current, id) : 0;\n-  ri->_data._field_info_id = ri->_data._array_info_id == 0 && !current->is_skip_edge() ? get_field_info_id(*current) : (traceid)0;\n+  ri->_data._array_info_id =  current->is_skip_edge() ? 0 : get_array_info_id(*current, id);\n+  ri->_data._field_info_id = ri->_data._array_info_id != 0 || current->is_skip_edge() ? 0 : get_field_info_id(*current);\n@@ -574,5 +572,5 @@\n-  } else {\n-    if (is_gc_root(edge)) {\n-      assert(edge->gc_root_id() == id, \"invariant\");\n-      add_gc_root_info(edge, id);\n-    }\n+    return;\n+  }\n+  if (is_gc_root(edge)) {\n+    assert(edge->gc_root_id() == id, \"invariant\");\n+    add_gc_root_info(edge, id);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleWriter.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-  \/\/ Casting from Klass*\n@@ -60,3 +59,6 @@\n-    assert(InstanceKlass::cast(k)->is_mirror_instance_klass(),\n-           \"cast to InstanceMirrorKlass\");\n-    return static_cast<InstanceMirrorKlass*>(k);\n+    return const_cast<InstanceMirrorKlass*>(cast(const_cast<const Klass*>(k)));\n+  }\n+\n+  static const InstanceMirrorKlass* cast(const Klass* k) {\n+    assert(InstanceKlass::cast(k)->is_mirror_instance_klass(), \"cast to InstanceMirrorKlass\");\n+    return static_cast<const InstanceMirrorKlass*>(k);\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}