{"files":[{"patch":"@@ -531,0 +531,15 @@\n+void CompiledMethod::run_nmethod_entry_barrier() {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != NULL) {\n+    \/\/ We want to keep an invariant that nmethods found through iterations of a Thread's\n+    \/\/ nmethods found in safepoints have gone through an entry barrier and are not armed.\n+    \/\/ By calling this nmethod entry barrier, it plays along and acts\n+    \/\/ like any other nmethod found on the stack of a thread (fewer surprises).\n+    nmethod* nm = as_nmethod_or_null();\n+    if (nm != NULL) {\n+      bool alive = bs_nm->nmethod_entry_barrier(nm);\n+      assert(alive, \"should be alive\");\n+    }\n+  }\n+}\n+\n@@ -539,12 +554,2 @@\n-    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-    if (bs_nm != NULL) {\n-      \/\/ We want to keep an invariant that nmethods found through iterations of a Thread's\n-      \/\/ nmethods found in safepoints have gone through an entry barrier and are not armed.\n-      \/\/ By calling this nmethod entry barrier from the sweeper, it plays along and acts\n-      \/\/ like any other nmethod found on the stack of a thread (fewer surprises).\n-      nmethod* nm = as_nmethod_or_null();\n-      if (nm != NULL) {\n-        bool alive = bs_nm->nmethod_entry_barrier(nm);\n-        assert(alive, \"should be alive\");\n-      }\n-    }\n+    \/\/ Call this nmethod entry barrier from the sweeper.\n+    run_nmethod_entry_barrier();\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -370,0 +370,3 @@\n+  \/\/ Execute nmethod barrier code, as if entering through nmethod call.\n+  void run_nmethod_entry_barrier();\n+\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1578,0 +1578,6 @@\n+  \/\/ Don't post this nmethod load event if it is already dying\n+  \/\/ because the sweeper might already be deleting this nmethod.\n+  if (is_not_entrant() && can_convert_to_zombie()) {\n+    return;\n+  }\n+\n@@ -1596,3 +1602,0 @@\n-    \/\/ Keep sweeper from turning this into zombie until it is posted.\n-    mark_as_seen_on_stack();\n-\n@@ -1603,0 +1606,3 @@\n+      \/\/ Execute any barrier code for this nmethod as if it's called, since\n+      \/\/ keeping it alive looks like stack walking.\n+      run_nmethod_entry_barrier();\n@@ -1605,0 +1611,1 @@\n+      \/\/ This enters the nmethod barrier outside in the caller.\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -225,9 +226,12 @@\n-    \/\/ Walk the CodeCache notifying for live nmethods, don't release the CodeCache_lock\n-    \/\/ because the sweeper may be running concurrently.\n-    \/\/ Save events to the queue for posting outside the CodeCache_lock.\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    \/\/ Iterate over non-profiled and profiled nmethods\n-    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);\n-    while(iter.next()) {\n-      nmethod* current = iter.method();\n-      current->post_compiled_method_load_event(state);\n+    NoSafepointVerifier nsv;  \/\/ safepoints are not safe while collecting methods to post.\n+    {\n+      \/\/ Walk the CodeCache notifying for live nmethods, don't release the CodeCache_lock\n+      \/\/ because the sweeper may be running concurrently.\n+      \/\/ Save events to the queue for posting outside the CodeCache_lock.\n+      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      \/\/ Iterate over non-profiled and profiled nmethods\n+      NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);\n+      while(iter.next()) {\n+        nmethod* current = iter.method();\n+        current->post_compiled_method_load_event(state);\n+      }\n@@ -235,0 +239,3 @@\n+\n+    \/\/ Enter nmethod barrier code if present outside CodeCache_lock\n+    state->run_nmethod_entry_barriers();\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -1017,0 +1018,6 @@\n+void JvmtiDeferredEvent::run_nmethod_entry_barriers() {\n+  if (_type == TYPE_COMPILED_METHOD_LOAD) {\n+    _event_data.compiled_method_load->run_nmethod_entry_barrier();\n+  }\n+}\n+\n@@ -1033,0 +1040,1 @@\n+\n@@ -1034,1 +1042,8 @@\n-  return _queue_head != NULL;\n+  \/\/ We save the queued events before the live phase and post them when it starts.\n+  \/\/ This code could skip saving the events on the queue before the live\n+  \/\/ phase and ignore them, but this would change how we do things now.\n+  \/\/ Starting the service thread earlier causes this to be called before the live phase begins.\n+  \/\/ The events on the queue should all be posted after the live phase so this is an\n+  \/\/ ok check.  Before the live phase, DynamicCodeGenerated events are posted directly.\n+  \/\/ If we add other types of events to the deferred queue, this could get ugly.\n+  return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE  && _queue_head != NULL;\n@@ -1082,0 +1097,7 @@\n+void JvmtiDeferredEventQueue::run_nmethod_entry_barriers() {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().run_nmethod_entry_barriers();\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -490,0 +490,1 @@\n+  void run_nmethod_entry_barriers() NOT_JVMTI_RETURN;\n@@ -531,0 +532,1 @@\n+  void run_nmethod_entry_barriers();\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -435,0 +435,5 @@\n+void JvmtiThreadState::run_nmethod_entry_barriers() {\n+  if (_jvmti_event_queue != NULL) {\n+    _jvmti_event_queue->run_nmethod_entry_barriers();\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -401,0 +401,1 @@\n+  void run_nmethod_entry_barriers();\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-\/\/ Events can be posted before the service thread is created.\n+\/\/ Events can be posted before JVMTI vm_start, so it's too early to call JvmtiThreadState::state_for\n+\/\/ to add this field to the per-JavaThread event queue.  TODO: fix this sometime later\n@@ -194,0 +195,4 @@\n+  \/\/ If you enqueue events before the service thread runs, gc and the sweeper\n+  \/\/ cannot keep the nmethod alive.  This could be restricted to compiled method\n+  \/\/ load and unload events, if we wanted to be picky.\n+  assert(_instance != NULL, \"cannot enqueue events before the service thread runs\");\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/serviceThread.hpp\"\n@@ -4036,0 +4037,4 @@\n+  \/\/ Start the service thread\n+  \/\/ The service thread enqueues JVMTI deferred events and does various hashtable\n+  \/\/ and other cleanups.  Needs to start before the compilers start posting events.\n+  ServiceThread::initialize();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/serviceThread.hpp\"\n@@ -149,3 +148,0 @@\n-  \/\/ Start the service thread\n-  ServiceThread::initialize();\n-\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- *\n- * The stress test that made this fail was -jar SwingSet2.jar from demos (without DISPLAY set so it exits)\n- *\/\n+ **\/\n+\n+ \/\/ The stress test that made this fail was -jar SwingSet2.jar from demos (without DISPLAY set so it exits)\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/CompiledMethodLoad\/Zombie.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}