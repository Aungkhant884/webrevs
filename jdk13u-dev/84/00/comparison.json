{"files":[{"patch":"@@ -51,1 +51,1 @@\n-OopMapStream::OopMapStream(OopMap* oop_map, int oop_types_mask) {\n+OopMapStream::OopMapStream(OopMap* oop_map) {\n@@ -53,1 +53,0 @@\n-  _mask = oop_types_mask;\n@@ -59,1 +58,1 @@\n-OopMapStream::OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask) {\n+OopMapStream::OopMapStream(const ImmutableOopMap* oop_map) {\n@@ -61,1 +60,0 @@\n-  _mask = oop_types_mask;\n@@ -68,1 +66,1 @@\n-  while(_position++ < _size) {\n+  if (_position++ < _size) {\n@@ -70,4 +68,2 @@\n-    if(((int)_omv.type() & _mask) > 0) {\n-      _valid_omv = true;\n-      return;\n-    }\n+    _valid_omv = true;\n+    return;\n@@ -143,10 +139,1 @@\n-  OopMapValue o(reg, x);\n-\n-  if(x == OopMapValue::callee_saved_value) {\n-    \/\/ This can never be a stack location, so we don't need to transform it.\n-    assert(optional->is_reg(), \"Trying to callee save a stack location\");\n-    o.set_content_reg(optional);\n-  } else if(x == OopMapValue::derived_oop_value) {\n-    o.set_content_reg(optional);\n-  }\n-\n+  OopMapValue o(reg, x, optional);\n@@ -163,5 +150,0 @@\n-void OopMap::set_value(VMReg reg) {\n-  \/\/ At this time, we don't need value entries in our OopMap.\n-}\n-\n-\n@@ -331,1 +313,1 @@\n-    OopMapStream oms(map,OopMapValue::derived_oop_value);\n+    OopMapStream oms(map);\n@@ -343,11 +325,13 @@\n-        oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n-        guarantee(loc != NULL, \"missing saved register\");\n-        oop *derived_loc = loc;\n-        oop *base_loc    = fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n-        \/\/ Ignore NULL oops and decoded NULL narrow oops which\n-        \/\/ equal to CompressedOops::base() when a narrow oop\n-        \/\/ implicit null check is used in compiled code.\n-        \/\/ The narrow_oop_base could be NULL or be the address\n-        \/\/ of the page below heap depending on compressed oops mode.\n-        if (base_loc != NULL && *base_loc != NULL && !CompressedOops::is_base(*base_loc)) {\n-          derived_oop_fn(base_loc, derived_loc);\n+        if (omv.type() == OopMapValue::derived_oop_value) {\n+          oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n+          guarantee(loc != NULL, \"missing saved register\");\n+          oop *derived_loc = loc;\n+          oop *base_loc    = fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n+          \/\/ Ignore NULL oops and decoded NULL narrow oops which\n+          \/\/ equal to CompressedOops::base() when a narrow oop\n+          \/\/ implicit null check is used in compiled code.\n+          \/\/ The narrow_oop_base could be NULL or be the address\n+          \/\/ of the page below heap depending on compressed oops mode.\n+          if (base_loc != NULL && *base_loc != NULL && !CompressedOops::is_base(*base_loc)) {\n+            derived_oop_fn(base_loc, derived_loc);\n+          }\n@@ -360,2 +344,0 @@\n-  \/\/ We want coop and oop oop_types\n-  int mask = OopMapValue::oop_value | OopMapValue::narrowoop_value;\n@@ -363,1 +345,2 @@\n-    for (OopMapStream oms(map,mask); !oms.is_done(); oms.next()) {\n+    \/\/ We want coop and oop oop_types\n+    for (OopMapStream oms(map); !oms.is_done(); oms.next()) {\n@@ -439,1 +422,1 @@\n-  for (OopMapStream oms(map, OopMapValue::callee_saved_value); !oms.is_done(); oms.next()) {\n+  for (OopMapStream oms(map); !oms.is_done(); oms.next()) {\n@@ -441,4 +424,6 @@\n-    VMReg reg = omv.content_reg();\n-    oop* loc = fr->oopmapreg_to_location(omv.reg(), reg_map);\n-    reg_map->set_location(reg, (address) loc);\n-    DEBUG_ONLY(nof_callee++;)\n+    if (omv.type() == OopMapValue::callee_saved_value) {\n+      VMReg reg = omv.content_reg();\n+      oop* loc = fr->oopmapreg_to_location(omv.reg(), reg_map);\n+      reg_map->set_location(reg, (address) loc);\n+      DEBUG_ONLY(nof_callee++;)\n+    }\n@@ -455,19 +440,0 @@\n-\/\/=============================================================================\n-\/\/ Non-Product code\n-\n-#ifndef PRODUCT\n-\n-bool ImmutableOopMap::has_derived_pointer() const {\n-#if !defined(TIERED) && !INCLUDE_JVMCI\n-  COMPILER1_PRESENT(return false);\n-#endif \/\/ !TIERED\n-#if COMPILER2_OR_JVMCI\n-  OopMapStream oms(this,OopMapValue::derived_oop_value);\n-  return oms.is_done();\n-#else\n-  return false;\n-#endif \/\/ COMPILER2_OR_JVMCI\n-}\n-\n-#endif \/\/PRODUCT\n-\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":29,"deletions":63,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  enum { type_bits                = 4,\n+  enum { type_bits                = 2,\n@@ -67,6 +67,7 @@\n-  enum oop_types {              \/\/ must fit in type_bits\n-         unused_value =0,       \/\/ powers of 2, for masking OopMapStream\n-         oop_value = 1,\n-         narrowoop_value = 2,\n-         callee_saved_value = 4,\n-         derived_oop_value= 8 };\n+  enum oop_types {\n+         oop_value,\n+         narrowoop_value,\n+         callee_saved_value,\n+         derived_oop_value,\n+         unused_value = -1          \/\/ Only used as a sentinel value\n+  };\n@@ -76,3 +77,4 @@\n-  OopMapValue (VMReg reg, oop_types t) { set_reg_type(reg, t); set_content_reg(VMRegImpl::Bad()); }\n-  OopMapValue (VMReg reg, oop_types t, VMReg reg2) { set_reg_type(reg, t); set_content_reg(reg2); }\n-  OopMapValue (CompressedReadStream* stream) { read_from(stream); }\n+  OopMapValue (VMReg reg, oop_types t, VMReg reg2) {\n+    set_reg_type(reg, t);\n+    set_content_reg(reg2);\n+  }\n@@ -80,0 +82,20 @@\n+ private:\n+    void set_reg_type(VMReg p, oop_types t) {\n+    set_value((p->value() << register_shift) | t);\n+    assert(reg() == p, \"sanity check\" );\n+    assert(type() == t, \"sanity check\" );\n+  }\n+\n+  void set_content_reg(VMReg r) {\n+    if (is_callee_saved()) {\n+      \/\/ This can never be a stack location, so we don't need to transform it.\n+      assert(r->is_reg(), \"Trying to callee save a stack location\");\n+    } else if (is_derived_oop()) {\n+      assert (r->is_valid(), \"must have a valid VMReg\");\n+    } else {\n+      assert (!r->is_valid(), \"valid VMReg not allowed\");\n+    }\n+    _content_reg = r->value();\n+  }\n+\n+ public:\n@@ -97,1 +119,1 @@\n-  bool is_narrowoop()           { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }\n+  bool is_narrowoop()         { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }\n@@ -101,5 +123,0 @@\n-  void set_oop()              { set_value((value() & register_mask_in_place) | oop_value); }\n-  void set_narrowoop()          { set_value((value() & register_mask_in_place) | narrowoop_value); }\n-  void set_callee_saved()     { set_value((value() & register_mask_in_place) | callee_saved_value); }\n-  void set_derived_oop()      { set_value((value() & register_mask_in_place) | derived_oop_value); }\n-\n@@ -113,7 +130,0 @@\n-  void set_reg_type(VMReg p, oop_types t) {\n-    set_value((p->value() << register_shift) | t);\n-    assert(reg() == p, \"sanity check\" );\n-    assert(type() == t, \"sanity check\" );\n-  }\n-\n-\n@@ -121,1 +131,0 @@\n-  void set_content_reg(VMReg r)   { _content_reg = r->value(); }\n@@ -159,0 +168,2 @@\n+  void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);\n+\n@@ -176,1 +187,0 @@\n-  void set_value( VMReg local);\n@@ -178,1 +188,0 @@\n-  void set_dead ( VMReg local);\n@@ -181,1 +190,0 @@\n-  void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);\n@@ -187,2 +195,0 @@\n-  bool has_derived_pointer() const PRODUCT_RETURN0;\n-\n@@ -272,1 +278,0 @@\n-  bool has_derived_pointer() const PRODUCT_RETURN0;\n@@ -337,1 +342,0 @@\n-  int _mask;\n@@ -345,2 +349,2 @@\n-  OopMapStream(OopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);\n-  OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);\n+  OopMapStream(OopMap* oop_map);\n+  OopMapStream(const ImmutableOopMap* oop_map);\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-      omap->set_value( r);\n@@ -380,1 +379,1 @@\n-  for( OopMapStream oms1(omap, OopMapValue::derived_oop_value); !oms1.is_done(); oms1.next()) {\n+  for( OopMapStream oms1(omap); !oms1.is_done(); oms1.next()) {\n@@ -382,0 +381,3 @@\n+    if (omv1.type() != OopMapValue::derived_oop_value) {\n+      continue;\n+    }\n@@ -383,2 +385,6 @@\n-    for( OopMapStream oms2(omap,OopMapValue::oop_value); !oms2.is_done(); oms2.next()) {\n-      if( omv1.content_reg() == oms2.current().reg() ) {\n+    for( OopMapStream oms2(omap); !oms2.is_done(); oms2.next()) {\n+      OopMapValue omv2 = oms2.current();\n+      if (omv2.type() != OopMapValue::oop_value) {\n+        continue;\n+      }\n+      if( omv1.content_reg() == omv2.reg() ) {\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,6 +58,0 @@\n-#ifdef COMPILER2\n-  \/\/ This option is not used by Compiler 1\n-  if (StressDerivedPointers) {\n-    InterfaceSupport::stress_derived_pointers();\n-  }\n-#endif\n@@ -229,25 +223,0 @@\n-void InterfaceSupport::stress_derived_pointers() {\n-#ifdef COMPILER2\n-  JavaThread *thread = JavaThread::current();\n-  if (!is_init_completed()) return;\n-  ResourceMark rm(thread);\n-  bool found = false;\n-  for (StackFrameStream sfs(thread); !sfs.is_done() && !found; sfs.next()) {\n-    CodeBlob* cb = sfs.current()->cb();\n-    if (cb != NULL && cb->oop_maps() ) {\n-      \/\/ Find oopmap for current method\n-      const ImmutableOopMap* map = cb->oop_map_for_return_address(sfs.current()->pc());\n-      assert(map != NULL, \"no oopmap found for pc\");\n-      found = map->has_derived_pointer();\n-    }\n-  }\n-  if (found) {\n-    \/\/ $$$ Not sure what to do here.\n-    \/*\n-    Scavenge::invoke(0);\n-    *\/\n-  }\n-#endif\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  static void stress_derived_pointers();\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  static int UNUSED_VALUE;\n@@ -73,1 +72,0 @@\n-    UNUSED_VALUE           = db.lookupIntConstant(\"OopMapValue::unused_value\").intValue();\n@@ -81,1 +79,0 @@\n-    public static final OopTypes UNUSED_VALUE       = new OopTypes() { int getValue() { return OopMapValue.UNUSED_VALUE;       }};\n@@ -114,2 +111,1 @@\n-         if (which == UNUSED_VALUE) return OopTypes.UNUSED_VALUE;\n-    else if (which == OOP_VALUE)    return OopTypes.OOP_VALUE;\n+         if (which == OOP_VALUE)    return OopTypes.OOP_VALUE;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/compiler\/OopMapValue.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}