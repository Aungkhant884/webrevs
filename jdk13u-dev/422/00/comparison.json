{"files":[{"patch":"@@ -405,3 +405,0 @@\n-            \/\/ the max protocol version this client is supporting.\n-            ProtocolVersion maxProtocolVersion = chc.maximumActiveProtocol;\n-\n@@ -541,8 +538,0 @@\n-                if (!maxProtocolVersion.equals(sessionVersion)) {\n-                    maxProtocolVersion = sessionVersion;\n-\n-                    \/\/ Update protocol version number in underlying socket and\n-                    \/\/ handshake output stream, so that the output records\n-                    \/\/ (at the record layer) have the correct version\n-                    chc.setVersion(sessionVersion);\n-                }\n@@ -583,1 +572,1 @@\n-                if (maxProtocolVersion.useTLS13PlusSpec() &&\n+                if (chc.maximumActiveProtocol.useTLS13PlusSpec() &&\n@@ -626,1 +615,1 @@\n-            ProtocolVersion clientHelloVersion = maxProtocolVersion;\n+            ProtocolVersion clientHelloVersion = chc.maximumActiveProtocol;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -502,9 +502,0 @@\n-    \/**\n-     * Set the active protocol version and propagate it to the SSLSocket\n-     * and our handshake streams. Called from ClientHandshaker\n-     * and ServerHandshaker with the negotiated protocol version.\n-     *\/\n-    void setVersion(ProtocolVersion protocolVersion) {\n-        this.conContext.protocolVersion = protocolVersion;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270344\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @summary Session resumption errors\n+ * @run main\/othervm InvalidateSession\n+ *\/\n+\n+import javax.net.*;\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+public class InvalidateSession implements SSLContextTemplate {\n+\n+    static ServerSocketFactory serverSsf = null;\n+    static SSLSocketFactory clientSsf = null;\n+\n+    static Server server;\n+    static SSLSession cacheSession;\n+    static final String[] CLIENT_VERSIONS = {\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"};\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ drop the supported_versions extension to force test to use the legacy\n+        \/\/ TLS protocol version field during handshakes\n+        System.setProperty(\"jdk.tls.client.disableExtensions\", \"supported_versions\");\n+        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1\", \"TLSv1.1\");\n+\n+        InvalidateSession test = new InvalidateSession();\n+        test.sessionTest();\n+        server.go = false;\n+    }\n+\n+    \/**\n+     * 3 test iterations\n+     * 1) Server configured with TLSv1, client with TLSv1, v1.1, v1.2\n+     * - Handshake should succeed\n+     * - Session \"A\" established\n+     * 2) 2nd iteration, server configured with TLSv1.2 only\n+     * - Connection should succeed but with a new session due to TLS protocol version change\n+     * - Session \"A\" should be invalidated\n+     * - Session \"B\" is created\n+     * 3) 3rd iteration, same server\/client config\n+     * - Session \"B\" should continue to be in use\n+     *\/\n+    private void sessionTest() throws Exception {\n+        serverSsf = createServerSSLContext().getServerSocketFactory();\n+        clientSsf = createClientSSLContext().getSocketFactory();\n+        server = startServer();\n+        while (!server.started) {\n+            Thread.yield();\n+        }\n+\n+        for (int i = 1; i <= 3; i++) {\n+            clientConnect(i);\n+            Thread.sleep(1000);\n+        }\n+    }\n+\n+    public void clientConnect(int testIterationCount) throws Exception {\n+        System.out.printf(\"Connecting to: localhost: %s, iteration count %d%n\",\n+                \"localhost:\" + server.port, testIterationCount);\n+        SSLSocket sslSocket = (SSLSocket) clientSsf.createSocket(\"localhost\", server.port);\n+        sslSocket.setEnabledProtocols(CLIENT_VERSIONS);\n+        sslSocket.startHandshake();\n+\n+        System.out.println(\"Got session: \" + sslSocket.getSession());\n+\n+        if (testIterationCount == 2 && Objects.equals(cacheSession, sslSocket.getSession())) {\n+            throw new RuntimeException(\"Same session should not have resumed\");\n+        }\n+        if (testIterationCount == 3 && !Objects.equals(cacheSession, sslSocket.getSession())) {\n+            throw new RuntimeException(\"Same session should have resumed\");\n+        }\n+\n+        cacheSession = sslSocket.getSession();\n+\n+        try (\n+        ObjectOutputStream oos = new ObjectOutputStream(sslSocket.getOutputStream());\n+        ObjectInputStream ois = new ObjectInputStream(sslSocket.getInputStream())) {\n+            oos.writeObject(\"Hello\");\n+            String serverMsg = (String) ois.readObject();\n+            System.out.println(\"Server message : \" + serverMsg);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        } finally {\n+            sslSocket.close();\n+        }\n+    }\n+\n+    private static Server startServer() {\n+        Server server = new Server();\n+        new Thread(server).start();\n+        return server;\n+    }\n+\n+    private static class Server implements Runnable {\n+        public volatile boolean go = true;\n+        public volatile int port = 0;\n+        public volatile boolean started = false;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                SSLServerSocket ssock = (SSLServerSocket)\n+                        serverSsf.createServerSocket(0);\n+                this.port = ssock.getLocalPort();\n+                ssock.setEnabledProtocols(new String[]{\"TLSv1\"});\n+                started = true;\n+                while (go) {\n+                    try {\n+                        System.out.println(\"Waiting for connection\");\n+                        Socket sock = ssock.accept();\n+                        \/\/ now flip server to TLSv1.2 mode for successive connections\n+                        ssock.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n+                        try (\n+                        ObjectInputStream ois = new ObjectInputStream(sock.getInputStream());\n+                        ObjectOutputStream oos = new ObjectOutputStream(sock.getOutputStream())) {\n+                            String recv = (String) ois.readObject();\n+                            oos.writeObject(\"Received: \" + recv);\n+                        } catch (SSLHandshakeException she) {\n+                            System.out.println(\"Server caught :\" + she);\n+                        } finally {\n+                            sock.close();\n+                        }\n+                    } catch (Exception ex) {\n+                        throw new RuntimeException(ex);\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/InvalidateSession.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}