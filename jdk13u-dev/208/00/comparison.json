{"files":[{"patch":"@@ -726,0 +726,10 @@\n+Node *CmpLNode::Ideal( PhaseGVN *phase, bool can_reshape ) {\n+  const TypeLong *t2 = phase->type(in(2))->isa_long();\n+  if (Opcode() == Op_CmpL && in(1)->Opcode() == Op_ConvI2L && t2 && t2->is_con()) {\n+    const jlong con = t2->get_con();\n+    if (con >= min_jint && con <= max_jint) {\n+      return new CmpINode(in(1)->in(1), phase->intcon((jint)con));\n+    }\n+  }\n+  return NULL;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8248043\n+ * @summary Functional test to enshure CmpL(int value, long constant) is not broken\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileOnly=compiler.c2.TestSkipLongToIntCast::cmplTest\n+ *      compiler.c2.TestSkipLongToIntCast\n+ *\/\n+public class TestSkipLongToIntCast {\n+\n+    public static int[] pos = {0, 1, 2, 3};\n+    public static int[] neg = {0, -1, -2, -3};\n+    public static int[] max = {2147483647, 2147483646, 2147483645, 2147483644};\n+    public static int[] min = {-2147483648, -2147483647, -2147483646, -2147483645};\n+    public static int[] out = {(int)2147483648L, (int)-2147483649L, (int)Long.MAX_VALUE, (int)Long.MIN_VALUE};\n+\n+    \/\/ Testing cmp(int value, long constant) expressions as they are updated\n+    \/\/ on Ideal graph level: i2l conversion is skipped when possible.\n+    public static void cmplTest() throws Exception {\n+        \/\/ values around zero\n+        if (pos[0] != 0L) { throw new Exception(\"pos[0] is \" + pos[0]); }\n+        if (pos[1] != 1L) { throw new Exception(\"pos[1] is \" + pos[1]); }\n+        if (pos[2] != 2L) { throw new Exception(\"pos[2] is \" + pos[2]); }\n+        if (pos[3] != 3L) { throw new Exception(\"pos[3] is \" + pos[3]); }\n+\n+        if (neg[0] != -0L) { throw new Exception(\"neg[0] is \" + neg[0]); }\n+        if (neg[1] != -1L) { throw new Exception(\"neg[1] is \" + neg[1]); }\n+        if (neg[2] != -2L) { throw new Exception(\"neg[2] is \" + neg[2]); }\n+        if (neg[3] != -3L) { throw new Exception(\"neg[3] is \" + neg[3]); }\n+\n+        \/\/ values near the ends of Integer range\n+        if (max[0] != 2147483647L) { throw new Exception(\"max[0] is \" + max[0]); }\n+        if (max[1] != 2147483646L) { throw new Exception(\"max[1] is \" + max[1]); }\n+        if (max[2] != 2147483645L) { throw new Exception(\"max[2] is \" + max[2]); }\n+        if (max[3] != 2147483644L) { throw new Exception(\"max[3] is \" + max[3]); }\n+\n+        if (min[0] != -2147483648L) { throw new Exception(\"min[0] is \" + min[0]); }\n+        if (min[1] != -2147483647L) { throw new Exception(\"min[1] is \" + min[1]); }\n+        if (min[2] != -2147483646L) { throw new Exception(\"min[2] is \" + min[2]); }\n+        if (min[3] != -2147483645L) { throw new Exception(\"min[3] is \" + min[3]); }\n+\n+        \/\/ constants outside of the Integer range\n+        if (out[0] == 2147483648L)  { throw new Exception(\"out[0] is \" + out[0]); }\n+        if (out[1] == -2147483649L) { throw new Exception(\"out[1] is \" + out[1]); }\n+        if (out[2] == Long.MAX_VALUE) { throw new Exception(\"out[2] is \" + out[2]); }\n+        if (out[3] == Long.MIN_VALUE) { throw new Exception(\"out[3] is \" + out[3]); }\n+    }\n+\n+    \/\/ similar test with long constant on LHS\n+    public static void cmplTest_LHS() throws Exception {\n+        \/\/ values around zero\n+        if (0L != pos[0]) { throw new Exception(\"LHS: pos[0] is \" + pos[0]); }\n+        if (1L != pos[1]) { throw new Exception(\"LHS: pos[1] is \" + pos[1]); }\n+        if (2L != pos[2]) { throw new Exception(\"LHS: pos[2] is \" + pos[2]); }\n+        if (3L != pos[3]) { throw new Exception(\"LHS: pos[3] is \" + pos[3]); }\n+\n+        if (-0L != neg[0]) { throw new Exception(\"LHS: neg[0] is \" + neg[0]); }\n+        if (-1L != neg[1]) { throw new Exception(\"LHS: neg[1] is \" + neg[1]); }\n+        if (-2L != neg[2]) { throw new Exception(\"LHS: neg[2] is \" + neg[2]); }\n+        if (-3L != neg[3]) { throw new Exception(\"LHS: neg[3] is \" + neg[3]); }\n+\n+        \/\/ values near the ends of Integer range\n+        if (2147483647L != max[0]) { throw new Exception(\"LHS: max[0] is \" + max[0]); }\n+        if (2147483646L != max[1]) { throw new Exception(\"LHS: max[1] is \" + max[1]); }\n+        if (2147483645L != max[2]) { throw new Exception(\"LHS: max[2] is \" + max[2]); }\n+        if (2147483644L != max[3]) { throw new Exception(\"LHS: max[3] is \" + max[3]); }\n+\n+        if (-2147483648L != min[0]) { throw new Exception(\"LHS: min[0] is \" + min[0]); }\n+        if (-2147483647L != min[1]) { throw new Exception(\"LHS: min[1] is \" + min[1]); }\n+        if (-2147483646L != min[2]) { throw new Exception(\"LHS: min[2] is \" + min[2]); }\n+        if (-2147483645L != min[3]) { throw new Exception(\"LHS: min[3] is \" + min[3]); }\n+\n+        \/\/ constants outside of the Integer range\n+        if (2147483648L == out[0])  { throw new Exception(\"LHS: out[0] is \" + out[0]); }\n+        if (-2147483649L == out[1]) { throw new Exception(\"LHS: out[1] is \" + out[1]); }\n+        if (Long.MAX_VALUE == out[2]) { throw new Exception(\"LHS: out[2] is \" + out[2]); }\n+        if (Long.MIN_VALUE == out[3]) { throw new Exception(\"LHS: out[3] is \" + out[3]); }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 100_000; i++) {\n+            cmplTest();\n+            cmplTest_LHS();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSkipLongToIntCast.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class SkipIntToLongCast {\n+\n+    private static final long ARRAYSIZE_L = 40L;\n+\n+    public int[] intValues;\n+\n+    @Setup\n+    public void setup() {\n+        int size = (int)ARRAYSIZE_L;\n+        intValues = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            intValues[i] = i + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int skipCastTestRight() {\n+        for (int i = 0; i < ARRAYSIZE_L; i++) {\n+            if (intValues[i] == ARRAYSIZE_L) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Benchmark\n+    public int skipCastTestLeft() {\n+        for (int i = 0; i < ARRAYSIZE_L; i++) {\n+            if (ARRAYSIZE_L == intValues[i]) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SkipIntToLongCast.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}