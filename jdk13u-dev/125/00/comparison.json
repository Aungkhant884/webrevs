{"files":[{"patch":"@@ -120,0 +120,27 @@\n+    public String readStringUntil(String sequence) {\n+        StringBuilder sb = new StringBuilder();\n+        if (!pushBackChar.isEmpty()) {\n+            pushBackChar.forEach(sb::appendCodePoint);\n+        }\n+        try {\n+            char[] buf = new char[64];\n+            while (true) {\n+                int idx = sb.indexOf(sequence, Math.max(0, sb.length() - buf.length - sequence.length()));\n+                if (idx >= 0) {\n+                    String rem = sb.substring(idx + sequence.length());\n+                    runMacro(rem);\n+                    return sb.substring(0, idx);\n+                }\n+                int l = reader.readBuffered(buf);\n+                if (l < 0) {\n+                    throw new ClosedException();\n+                }\n+                sb.append(buf, 0, l);\n+            }\n+        } catch (ClosedException e) {\n+            throw new EndOfFileException(e);\n+        } catch (IOException e) {\n+            throw new IOError(e);\n+        }\n+    }\n+\n@@ -147,0 +174,41 @@\n+    public int readCharacterBuffered() {\n+        try {\n+            if (pushBackChar.isEmpty()) {\n+                char[] buf = new char[32];\n+                int l = reader.readBuffered(buf);\n+                if (l <= 0) {\n+                    return -1;\n+                }\n+                int s = 0;\n+                for (int i = 0; i < l; ) {\n+                    int c = buf[i++];\n+                    if (Character.isHighSurrogate((char) c)) {\n+                        s = c;\n+                        if (i < l) {\n+                            c = buf[i++];\n+                            pushBackChar.addLast(Character.toCodePoint((char) s, (char) c));\n+                        } else {\n+                            break;\n+                        }\n+                    } else {\n+                        s = 0;\n+                        pushBackChar.addLast(c);\n+                    }\n+                }\n+                if (s != 0) {\n+                    int c = reader.read();\n+                    if (c >= 0) {\n+                        pushBackChar.addLast(Character.toCodePoint((char) s, (char) c));\n+                    } else {\n+                        return -1;\n+                    }\n+                }\n+            }\n+            return pushBackChar.pop();\n+        } catch (ClosedException e) {\n+            throw new EndOfFileException(e);\n+        } catch (IOException e) {\n+            throw new IOError(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/keymap\/BindingReader.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -49,3 +49,2 @@\n-        Objects.requireNonNull(value);\n-        this.value = value;\n-        this.displ = displ;\n+        this.value = Objects.requireNonNull(value);\n+        this.displ = Objects.requireNonNull(displ);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2002-2019, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package org.jline.reader;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class ConfigurationPath {\n+    private Path appConfig;\n+    private Path userConfig;\n+\n+    \/**\n+     * Configuration class constructor.\n+     * @param appConfig   Application configuration directory\n+     * @param userConfig  User private configuration directory\n+     *\/\n+    public ConfigurationPath(Path appConfig, Path userConfig) {\n+        this.appConfig = appConfig;\n+        this.userConfig = userConfig;\n+    }\n+\n+    \/**\n+     * Search configuration file first from userConfig and then appConfig directory. Returns null if file is not found.\n+     * @param  name    Configuration file name.\n+     * @return         Configuration file.\n+     *\n+     *\/\n+    public Path getConfig(String name) {\n+        Path out = null;\n+        if (userConfig != null && userConfig.resolve(name).toFile().exists()) {\n+            out = userConfig.resolve(name);\n+        } else if (appConfig != null && appConfig.resolve(name).toFile().exists()) {\n+            out = appConfig.resolve(name);\n+        }\n+        return out;\n+    }\n+\n+    \/**\n+     * Search configuration file from userConfig directory. Returns null if file is not found.\n+     * @param  name    Configuration file name.\n+     * @return         Configuration file.\n+     * @throws         IOException   When we do not have read access to the file or directory.\n+     *\n+     *\/\n+    public Path getUserConfig(String name) throws IOException {\n+        return getUserConfig(name, false);\n+    }\n+\n+    \/**\n+     * Search configuration file from userConfig directory. Returns null if file is not found.\n+     * @param  name    Configuration file name\n+     * @param  create  When true configuration file is created if not found.\n+     * @return         Configuration file.\n+     * @throws         IOException   When we do not have read\/write access to the file or directory.\n+     *\/\n+    public Path getUserConfig(String name, boolean create) throws IOException {\n+        Path out = null;\n+        if (userConfig != null) {\n+            if (!userConfig.resolve(name).toFile().exists() && create) {\n+                userConfig.resolve(name).toFile().createNewFile();\n+            }\n+            if (userConfig.resolve(name).toFile().exists()) {\n+                out = userConfig.resolve(name);\n+            }\n+        }\n+        return out;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ConfigurationPath.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+    private final int openBrackets;\n+    private final String nextClosingBracket;\n@@ -32,0 +34,4 @@\n+        this(line, column, message, missing, 0, null);\n+    }\n+\n+    public EOFError(int line, int column, String message, String missing, int openBrackets, String nextClosingBracket) {\n@@ -34,0 +40,2 @@\n+        this.openBrackets = openBrackets;\n+        this.nextClosingBracket = nextClosingBracket;\n@@ -39,0 +47,8 @@\n+\n+    public int getOpenBrackets(){\n+        return openBrackets;\n+    }\n+\n+    public String getNextClosingBracket() {\n+        return nextClosingBracket;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EOFError.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+\/*\n+ * Copyright (c) 2002-2019, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public interface Editor {\n+    public void open(List<String> files) throws IOException;\n+    public void run() throws IOException;\n+    public void setRestricted(boolean restricted);\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Editor.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -11,0 +11,2 @@\n+import java.util.regex.Pattern;\n+\n@@ -16,0 +18,2 @@\n+    public void setErrorPattern(Pattern errorPattern);\n+    public void setErrorIndex(int errorIndex);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+     * @param  file        History file\n+     * @param  incremental If true incremental write operation is performed.\n@@ -55,0 +57,2 @@\n+     * @param  file        History file\n+     * @param  incremental If true incremental append operation is performed.\n@@ -61,0 +65,2 @@\n+     * @param  file        History file\n+     * @param  incremental If true incremental read operation is performed.\n@@ -136,0 +142,5 @@\n+            @Override\n+            public void remove() {\n+                it.remove();\n+                resetIndex();\n+            }\n@@ -194,0 +205,5 @@\n+\n+    \/**\n+     * Reset index after remove\n+     *\/\n+    void resetIndex();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -11,0 +11,1 @@\n+import java.io.File;\n@@ -12,0 +13,1 @@\n+import java.util.Collection;\n@@ -60,1 +62,1 @@\n- * <dd>Insert padding at this possion, repeating the following\n+ * <dd>Insert padding at this position, repeating the following\n@@ -133,0 +135,1 @@\n+    String EDIT_AND_EXECUTE_COMMAND = \"edit-and-execute-command\";\n@@ -357,0 +360,13 @@\n+    \/**\n+     * New line automatic indentation after opening\/closing bracket.\n+     *\/\n+    String INDENTATION = \"indentation\";\n+\n+    \/**\n+     * Max buffer size for advanced features.\n+     * Once the length of the buffer reaches this threshold, no\n+     * advanced features will be enabled. This includes the undo\n+     * buffer, syntax highlighting, parsing, etc....\n+     *\/\n+    String FEATURES_MAX_BUFFER_SIZE = \"features-max-buffer-size\";\n+\n@@ -401,0 +417,1 @@\n+        USE_FORWARD_SLASH(false),\n@@ -418,0 +435,6 @@\n+\n+        \/** Automatic insertion of closing bracket *\/\n+        INSERT_BRACKET,\n+\n+        \/** Show command options tab completion candidates for zero length word *\/\n+        EMPTY_WORD_OPTIONS(true),\n@@ -442,0 +465,21 @@\n+    enum SuggestionType {\n+        \/**\n+         * As you type command line suggestions are disabled.\n+         *\/\n+        NONE,\n+        \/**\n+         * Prepare command line suggestions using command history.\n+         * Requires an additional widgets implementation.\n+         *\/\n+        HISTORY,\n+        \/**\n+         * Prepare command line suggestions using command completer data.\n+         *\/\n+        COMPLETER,\n+        \/**\n+         * Prepare command line suggestions using command completer data and\/or command positional argument descriptions.\n+         * Requires an additional widgets implementation.\n+         *\/\n+        TAIL_TIP\n+    }\n+\n@@ -658,0 +702,13 @@\n+    void addCommandsInBuffer(Collection<String> commands);\n+\n+    void editAndAddInBuffer(File file) throws Exception;\n+\n+    String getLastBinding();\n+\n+    String getTailTip();\n+\n+    void setTailTip(String tailTip);\n+\n+    void setAutosuggestion(SuggestionType type);\n+\n+    SuggestionType getAutosuggestion();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -11,0 +11,3 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n@@ -12,0 +15,2 @@\n+    static final String REGEX_VARIABLE = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*\";\n+    static final String REGEX_COMMAND = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n@@ -23,0 +28,37 @@\n+    default boolean validCommandName(String name) {\n+        return name != null && name.matches(REGEX_COMMAND);\n+    }\n+\n+    default boolean validVariableName(String name) {\n+        return name != null && name.matches(REGEX_VARIABLE);\n+    }\n+\n+    default String getCommand(final String line) {\n+        String out = \"\";\n+        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+.*|$)\");\n+        Matcher matcher = patternCommand.matcher(line);\n+        if (matcher.find()) {\n+            out = matcher.group(1);\n+        } else {\n+            out = line.trim().split(\"\\\\s+\")[0];\n+            int idx = out.indexOf(\"=\");\n+            if (idx > -1) {\n+                out = out.substring(idx + 1);\n+            }\n+            if (!out.matches(REGEX_COMMAND)) {\n+                out = \"\";\n+            }\n+        }\n+        return out;\n+    }\n+\n+    default String getVariable(final String line) {\n+        String out = null;\n+        Pattern  patternCommand = Pattern.compile(\"^\\\\s*(\" + REGEX_VARIABLE + \")\\\\s*=[^=~].*\");\n+        Matcher matcher = patternCommand.matcher(line);\n+        if (matcher.find()) {\n+            out = matcher.group(1);\n+        }\n+        return out;\n+    }\n+\n@@ -31,0 +73,6 @@\n+        \/** Parsed words will have all characters present in input line\n+         * including quotes and escape chars.\n+         * May throw EOFError in which case we have incomplete input.\n+         *\/\n+        SPLIT_LINE,\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package org.jline.reader;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/**\n+ * Manage scriptEngine variables, statements and script execution.\n+ *\n+ * @author <a href=\"mailto:matti.rintanikkola@gmail.com\">Matti Rinta-Nikkola<\/a>\n+ *\/\n+public interface ScriptEngine {\n+\n+    \/**\n+     *\n+     * @return scriptEngine name\n+     *\/\n+    String getEngineName();\n+\n+    \/**\n+     *\n+     * @return script file name extensions\n+     *\/\n+    Collection<String> getExtensions();\n+\n+    \/**\n+     * Tests if console variable exists\n+     * @param name\n+     * @return true if variable exists\n+     *\/\n+    boolean hasVariable(String name);\n+\n+    \/**\n+     * Creates variable\n+     * @param name of the variable\n+     * @param value of the variable\n+     *\/\n+    void put(String name, Object value);\n+\n+    \/**\n+     * Gets variable value\n+     * @param name of the variable\n+     * @return value of the variable\n+     *\/\n+    Object get(String name);\n+\n+    \/**\n+     * Gets all variables with values\n+     * @return map of the variables\n+     *\/\n+    default Map<String,Object> find() {\n+        return find(null);\n+    }\n+\n+    \/**\n+     * Gets all the variables that match the name. Name can contain * wild cards.\n+     * @param name of the variable\n+     * @return map of the variables\n+     *\/\n+    Map<String,Object> find(String name);\n+\n+    \/**\n+     * Deletes variables. Variable name cab contain * wild cards.\n+     * @param vars\n+     *\/\n+    void del(String... vars);\n+\n+    \/**\n+     * Converts object to JSON string.\n+     * @param object object to convert to JSON\n+     * @return formatted JSON string\n+     *\/\n+    String toJson(Object object);\n+\n+    \/**\n+     * Converts object to string.\n+     * @param object object to convert to string\n+     * @return object string value\n+     *\/\n+    String toString(Object object);\n+\n+    \/**\n+     * Substitute variable reference with its value.\n+     * @param variable\n+     * @return Substituted variable\n+     * @throws Exception\n+     *\/\n+    default Object expandParameter(String variable) {\n+        return expandParameter(variable, \"\");\n+    }\n+\n+    \/**\n+     * Substitute variable reference with its value.\n+     * @param variable\n+     * @param format serialization format\n+     * @return Substituted variable\n+     * @throws Exception\n+     *\/\n+    Object expandParameter(String variable, String format);\n+\n+    \/**\n+     * Persists object value to file.\n+     * @param file\n+     * @param object\n+     *\/\n+    default void persist(Path file, Object object) {\n+        persist(file, object, \"JSON\");\n+    }\n+\n+    \/**\n+     * Persists object value to file.\n+     * @param file\n+     * @param object\n+     * @param format\n+     *\/\n+    void persist(Path file, Object object, String format);\n+\n+    \/**\n+     * Executes scriptEngine statement\n+     * @param statement\n+     * @return result\n+     * @throws Exception\n+     *\/\n+    Object execute(String statement) throws Exception;\n+\n+    \/**\n+     * Executes scriptEngine script\n+     * @param script\n+     * @return result\n+     * @throws Exception\n+     *\/\n+    default Object execute(File script) throws Exception {\n+        return execute(script, null);\n+    }\n+\n+    \/**\n+     * Executes scriptEngine script\n+     * @param script\n+     * @param args\n+     * @return\n+     * @throws Exception\n+     *\/\n+    Object execute(File script, Object[] args) throws Exception;\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ScriptEngine.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -11,0 +11,2 @@\n+import java.util.regex.Pattern;\n+\n@@ -20,0 +22,12 @@\n+    private Pattern errorPattern;\n+    private int errorIndex = -1;\n+\n+    @Override\n+    public void setErrorPattern(Pattern errorPattern) {\n+        this.errorPattern = errorPattern;\n+    }\n+\n+    @Override\n+    public void setErrorIndex(int errorIndex) {\n+        this.errorIndex = errorIndex;\n+    }\n@@ -60,0 +74,4 @@\n+            if (i == errorIndex) {\n+                sb.style(AttributedStyle::inverse);\n+            }\n+\n@@ -80,0 +98,6 @@\n+            if (i == errorIndex) {\n+                sb.style(AttributedStyle::inverseOff);\n+            }\n+        }\n+        if (errorPattern != null) {\n+            sb.styleMatches(errorPattern, AttributedStyle.INVERSE);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultHighlighter.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -13,0 +13,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -40,0 +42,4 @@\n+    private String regexVariable = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*((.|\\\\['|\\\\[\\\\\\\"|\\\\[)[a-zA-Z0-9_-]*(|'\\\\]|\\\\\\\"\\\\]|\\\\])){0,1}\";\n+    private String regexCommand = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n+    private int commandGroup = 4;\n+\n@@ -59,1 +65,1 @@\n-    public DefaultParser eofOnUnclosedBracket(Bracket... brackets){\n+    public DefaultParser eofOnUnclosedBracket(Bracket... brackets) {\n@@ -69,0 +75,15 @@\n+    public DefaultParser regexVariable(String regexVariable) {\n+        this.regexVariable = regexVariable;\n+        return this;\n+    }\n+\n+    public DefaultParser regexCommand(String regexCommand) {\n+        this.regexCommand = regexCommand;\n+        return this;\n+    }\n+\n+    public DefaultParser commandGroup(int commandGroup) {\n+        this.commandGroup = commandGroup;\n+        return this;\n+    }\n+\n@@ -105,1 +126,1 @@\n-    public void setEofOnUnclosedBracket(Bracket... brackets){\n+    public void setEofOnUnclosedBracket(Bracket... brackets) {\n@@ -138,0 +159,54 @@\n+    public void setRegexVariable(String regexVariable) {\n+        this.regexVariable = regexVariable;\n+    }\n+\n+    public void setRegexCommand(String regexCommand) {\n+        this.regexCommand = regexCommand;\n+    }\n+\n+    public void setCommandGroup(int commandGroup) {\n+        this.commandGroup = commandGroup;\n+    }\n+\n+    @Override\n+    public boolean validCommandName(String name) {\n+        return name != null && name.matches(regexCommand);\n+    }\n+\n+    @Override\n+    public boolean validVariableName(String name) {\n+        return name != null && name.matches(regexVariable);\n+    }\n+\n+\n+    @Override\n+    public String getCommand(final String line) {\n+        String out = \"\";\n+        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + regexVariable + \"=(\" + regexCommand + \")(\\\\s+.*|$)\");\n+        Matcher matcher = patternCommand.matcher(line);\n+        if (matcher.find()) {\n+            out = matcher.group(commandGroup);\n+        } else {\n+            out = line.trim().split(\"\\\\s+\")[0];\n+            int idx = out.indexOf(\"=\");\n+            if (idx > -1) {\n+                out = out.substring(idx + 1);\n+            }\n+            if (!out.matches(regexCommand)) {\n+                out = \"\";\n+            }\n+        }\n+        return out;\n+    }\n+\n+    @Override\n+    public String getVariable(final String line) {\n+        String out = null;\n+        Pattern  patternCommand = Pattern.compile(\"^\\\\s*(\" + regexVariable + \")\\\\s*=[^=~].*\");\n+        Matcher matcher = patternCommand.matcher(line);\n+        if (matcher.find()) {\n+            out = matcher.group(1);\n+        }\n+        return out;\n+    }\n+\n@@ -147,1 +222,1 @@\n-        BracketChecker bracketChecker = new BracketChecker();\n+        BracketChecker bracketChecker = new BracketChecker(cursor);\n@@ -166,0 +241,3 @@\n+                    if (context == ParseContext.SPLIT_LINE) {\n+                        current.append(line.charAt(i));\n+                    }\n@@ -171,1 +249,1 @@\n-                if (!quotedWord) {\n+                if (!quotedWord || context == ParseContext.SPLIT_LINE) {\n@@ -194,0 +272,2 @@\n+                } else if (context == ParseContext.SPLIT_LINE) {\n+                    current.append(line.charAt(i));\n@@ -220,5 +300,12 @@\n-            if (bracketChecker.isOpeningBracketMissing()) {\n-                throw new EOFError(-1, -1, \"Missing opening bracket\", \"missing: \" + bracketChecker.getMissingOpeningBracket());\n-            }\n-            if (bracketChecker.isClosingBracketMissing()) {\n-                throw new EOFError(-1, -1, \"Missing closing brackets\", \"add: \" + bracketChecker.getMissingClosingBrackets());\n+            if (bracketChecker.isClosingBracketMissing() || bracketChecker.isOpeningBracketMissing()) {\n+                String message = null;\n+                String missing = null;\n+                if (bracketChecker.isClosingBracketMissing()) {\n+                    message = \"Missing closing brackets\";\n+                    missing = \"add: \" + bracketChecker.getMissingClosingBrackets();\n+                } else {\n+                    message = \"Missing opening bracket\";\n+                    missing = \"missing: \" + bracketChecker.getMissingOpeningBracket();\n+                }\n+                throw new EOFError(-1, -1, message, missing,\n+                        bracketChecker.getOpenBrackets(), bracketChecker.getNextClosingBracket());\n@@ -350,0 +437,3 @@\n+        private int openBrackets = 0;\n+        private int cursor;\n+        private String nextClosingBracket;\n@@ -351,1 +441,3 @@\n-        public BracketChecker(){}\n+        public BracketChecker(int cursor) {\n+            this.cursor = cursor;\n+        }\n@@ -353,1 +445,1 @@\n-        public void check(final CharSequence buffer, final int pos){\n+        public void check(final CharSequence buffer, final int pos) {\n@@ -370,0 +462,6 @@\n+            if (cursor > pos) {\n+                openBrackets = nested.size();\n+                if (nested.size() > 0) {\n+                    nextClosingBracket = String.valueOf(closingBrackets[nested.get(nested.size() - 1)]);\n+                }\n+            }\n@@ -372,1 +470,1 @@\n-        public boolean isOpeningBracketMissing(){\n+        public boolean isOpeningBracketMissing() {\n@@ -376,1 +474,1 @@\n-        public String getMissingOpeningBracket(){\n+        public String getMissingOpeningBracket() {\n@@ -383,1 +481,1 @@\n-        public boolean isClosingBracketMissing(){\n+        public boolean isClosingBracketMissing() {\n@@ -387,1 +485,1 @@\n-        public String getMissingClosingBrackets(){\n+        public String getMissingClosingBrackets() {\n@@ -398,1 +496,9 @@\n-        private int bracketId(final char[] brackets, final CharSequence buffer, final int pos){\n+        public int getOpenBrackets() {\n+            return openBrackets;\n+        }\n+\n+        public String getNextClosingBracket() {\n+            return nested.size() == 2 ? nextClosingBracket : null;\n+        }\n+\n+        private int bracketId(final char[] brackets, final CharSequence buffer, final int pos) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":123,"deletions":17,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -11,0 +11,4 @@\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n@@ -16,0 +20,1 @@\n+import java.lang.reflect.Constructor;\n@@ -20,1 +25,0 @@\n-import java.util.concurrent.locks.Lock;\n@@ -89,0 +93,2 @@\n+    public static final int    DEFAULT_INDENTATION = 0;\n+    public static final int    DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;\n@@ -112,0 +118,4 @@\n+        \/**\n+         * readLine should exit and return empty String\n+         *\/\n+        IGNORE,\n@@ -163,0 +173,2 @@\n+    protected String tailTip = \"\";\n+    protected SuggestionType autosuggestion = SuggestionType.NONE;\n@@ -178,0 +190,1 @@\n+    protected boolean doAutosuggestion;\n@@ -249,1 +262,0 @@\n-\n@@ -256,0 +268,4 @@\n+    \/*\n+     * execute commands from commandsBuffer\n+     *\/\n+    protected List<String> commandsBuffer = new ArrayList<>();\n@@ -316,0 +332,20 @@\n+    @Override\n+    public void setAutosuggestion(SuggestionType type) {\n+        this.autosuggestion = type;\n+    }\n+\n+    @Override\n+    public SuggestionType getAutosuggestion() {\n+        return autosuggestion;\n+    }\n+\n+    @Override\n+    public String getTailTip() {\n+        return tailTip;\n+    }\n+\n+    @Override\n+    public void setTailTip(String tailTip) {\n+        this.tailTip = tailTip;\n+    }\n+\n@@ -474,0 +510,26 @@\n+        if (!commandsBuffer.isEmpty()) {\n+            String cmd = commandsBuffer.remove(0);\n+            boolean done = false;\n+            do {\n+                try {\n+                    parser.parse(cmd, cmd.length() + 1, ParseContext.ACCEPT_LINE);\n+                    done = true;\n+                } catch (EOFError e) {\n+                    if (commandsBuffer.isEmpty()) {\n+                        throw new IllegalArgumentException(\"Incompleted command: \\n\" + cmd);\n+                    }\n+                    cmd += \"\\n\";\n+                    cmd += commandsBuffer.remove(0);\n+                } catch (SyntaxError e) {\n+                    done = true;\n+                } catch (Exception e) {\n+                    commandsBuffer.clear();\n+                    throw new IllegalArgumentException(e.getMessage());\n+                }\n+            } while (!done);\n+            AttributedStringBuilder sb = new AttributedStringBuilder();\n+            sb.styled(AttributedStyle::bold, cmd);\n+            sb.toAttributedString().println(terminal);\n+            terminal.flush();\n+            return finish(cmd);\n+        }\n@@ -601,1 +663,1 @@\n-                    Buffer copy = buf.copy();\n+                    Buffer copy = buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE) ? buf.copy() : null;\n@@ -606,1 +668,2 @@\n-                    if (!isUndo && !copy.toString().equals(buf.toString())) {\n+                    if (!isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                            && !copy.toString().equals(buf.toString())) {\n@@ -613,0 +676,2 @@\n+                        case IGNORE:\n+                            return \"\";\n@@ -668,1 +733,1 @@\n-    private boolean isTerminalDumb(){\n+    private boolean isTerminalDumb() {\n@@ -673,1 +738,1 @@\n-    private void doDisplay(){\n+    private void doDisplay() {\n@@ -852,0 +917,13 @@\n+    protected String doReadStringUntil(String sequence) {\n+        if (lock.isHeldByCurrentThread()) {\n+            try {\n+                lock.unlock();\n+                return bindingReader.readStringUntil(sequence);\n+            } finally {\n+                lock.lock();\n+            }\n+        } else {\n+            return bindingReader.readStringUntil(sequence);\n+        }\n+    }\n+\n@@ -892,0 +970,1 @@\n+    @Override\n@@ -896,0 +975,1 @@\n+    @Override\n@@ -986,0 +1066,4 @@\n+    @Override\n+    public void addCommandsInBuffer(Collection<String> commands) {\n+        commandsBuffer.addAll(commands);\n+    }\n@@ -987,0 +1071,15 @@\n+    @Override\n+    public void editAndAddInBuffer(File file) throws Exception {\n+        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Editor editor = (Editor) ctor.newInstance(terminal, new File(file.getParent()));\n+        editor.setRestricted(true);\n+        editor.open(Arrays.asList(file.getName()));\n+        editor.run();\n+        BufferedReader br = new BufferedReader(new FileReader(file));\n+        String line;\n+        commandsBuffer.clear();\n+        while ((line = br.readLine()) != null) {\n+            commandsBuffer.add(line);\n+        }\n+        br.close();\n+    }\n@@ -998,1 +1097,4 @@\n-        String str = buf.toString();\n+        return finish(buf.toString());\n+    }\n+\n+    protected String finish(String str) {\n@@ -1032,0 +1134,1 @@\n+        doAutosuggestion = false;\n@@ -1039,1 +1142,2 @@\n-            redrawLine();\n+            \/\/ restores prompt but also prevents scrolling in consoleZ, see #492\n+            \/\/ redrawLine();\n@@ -2075,0 +2179,1 @@\n+            removeIndentation();\n@@ -2085,1 +2190,1 @@\n-\n+        int blinkPosition = buf.cursor();\n@@ -2087,0 +2192,4 @@\n+\n+        if (blinkPosition != closePosition - 1) {\n+            removeIndentation();\n+        }\n@@ -2090,0 +2199,17 @@\n+    private void removeIndentation() {\n+        int indent = getInt(INDENTATION, DEFAULT_INDENTATION);\n+        if (indent > 0) {\n+            buf.move(-1);\n+            for (int i = 0; i < indent; i++) {\n+                buf.move(-1);\n+                if (buf.currChar() == ' ') {\n+                    buf.delete();\n+                } else {\n+                    buf.move(1);\n+                    break;\n+                }\n+            }\n+            buf.move(1);\n+        }\n+    }\n+\n@@ -2427,0 +2553,1 @@\n+            doAutosuggestion = false;\n@@ -2838,0 +2965,1 @@\n+        int curPos = 0;\n@@ -2854,0 +2982,1 @@\n+            curPos = buf.cursor();\n@@ -2856,1 +2985,10 @@\n-            buf.write(\"\\n\");\n+            StringBuilder sb = new StringBuilder(\"\\n\");\n+            indention(e.getOpenBrackets(), sb);\n+            int curMove = sb.length();\n+            if (isSet(Option.INSERT_BRACKET) && e.getOpenBrackets() > 1 && e.getNextClosingBracket() != null) {\n+                sb.append('\\n');\n+                indention(e.getOpenBrackets() - 1, sb);\n+                sb.append(e.getNextClosingBracket());\n+            }\n+            buf.write(sb.toString());\n+            buf.cursor(curPos + curMove);\n@@ -2866,0 +3004,7 @@\n+    void indention(int nb, StringBuilder sb) {\n+        int indent = getInt(INDENTATION, DEFAULT_INDENTATION)*nb;\n+        for (int i = 0; i < indent; i++) {\n+            sb.append(' ');\n+        }\n+    }\n+\n@@ -3467,0 +3612,21 @@\n+    protected boolean editAndExecute() {\n+        boolean out = true;\n+        File file = null;\n+        try {\n+            file = File.createTempFile(\"jline-execute-\", null);\n+            FileWriter writer = new FileWriter(file);\n+            writer.write(buf.toString());\n+            writer.close();\n+            editAndAddInBuffer(file);\n+        } catch (Exception e) {\n+            e.printStackTrace(terminal.writer());\n+            out = false;\n+        } finally {\n+            state = State.IGNORE;\n+            if (file != null && file.exists()) {\n+                file.delete();\n+            }\n+        }\n+        return out;\n+    }\n+\n@@ -3502,0 +3668,1 @@\n+        addBuiltinWidget(widgets, EDIT_AND_EXECUTE_COMMAND, this::editAndExecute);\n@@ -3619,1 +3786,1 @@\n-        widgets.put(name, namedWidget(name, widget));\n+        widgets.put(name, namedWidget(\".\" + name, widget));\n@@ -3794,0 +3961,32 @@\n+    private String matchPreviousCommand(String buffer) {\n+        if (buffer.length() == 0) {\n+            return \"\";\n+        }\n+        History history = getHistory();\n+        StringBuilder sb = new StringBuilder();\n+        char prev = '0';\n+        for (char c: buffer.toCharArray()) {\n+            if ((c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^') && prev != '\\\\' ) {\n+                sb.append('\\\\');\n+            }\n+            sb.append(c);\n+            prev = c;\n+        }\n+        Pattern pattern = Pattern.compile(sb.toString() + \".*\", Pattern.DOTALL);\n+        Iterator<History.Entry> iter = history.reverseIterator(history.last());\n+        String suggestion = \"\";\n+        int tot = 0;\n+        while (iter.hasNext()) {\n+            History.Entry entry = iter.next();\n+            Matcher matcher = pattern.matcher(entry.line());\n+            if (matcher.matches()) {\n+                suggestion = entry.line().substring(buffer.length());\n+                break;\n+            } else if (tot > 200) {\n+                break;\n+            }\n+            tot++;\n+        }\n+        return suggestion;\n+    }\n+\n@@ -3806,0 +4005,40 @@\n+        if (doAutosuggestion) {\n+            String lastBinding = getLastBinding() != null ? getLastBinding() : \"\";\n+            if (autosuggestion == SuggestionType.HISTORY) {\n+                AttributedStringBuilder sb = new AttributedStringBuilder();\n+                tailTip = matchPreviousCommand(buf.toString());\n+                sb.styled(AttributedStyle::faint, tailTip);\n+                full.append(sb.toAttributedString());\n+            } else if (autosuggestion == SuggestionType.COMPLETER) {\n+                if (buf.length() > 0 && buf.length() == buf.cursor()\n+                    && (!lastBinding.equals(\"\\t\") || buf.prevChar() == ' ' || buf.prevChar() == '=')) {\n+                    clearChoices();\n+                    listChoices(true);\n+                } else if (!lastBinding.equals(\"\\t\")) {\n+                    clearChoices();\n+                }\n+            } else if (autosuggestion == SuggestionType.TAIL_TIP) {\n+                if (buf.length() == buf.cursor()) {\n+                    if (!lastBinding.equals(\"\\t\") || buf.prevChar() == ' ') {\n+                        clearChoices();\n+                    }\n+                    AttributedStringBuilder sb = new AttributedStringBuilder();\n+                    if (buf.prevChar() != ' ') {\n+                        if (!tailTip.startsWith(\"[\")) {\n+                            int idx = tailTip.indexOf(' ');\n+                            int idb = buf.toString().lastIndexOf(' ');\n+                            int idd = buf.toString().lastIndexOf('-');\n+                            if (idx > 0 && ((idb == -1 && idb == idd) || (idb >= 0 && idb > idd))) {\n+                                tailTip = tailTip.substring(idx);\n+                            } else if (idb >= 0 && idb < idd) {\n+                                sb.append(\" \");\n+                            }\n+                        } else {\n+                            sb.append(\" \");\n+                        }\n+                    }\n+                    sb.styled(AttributedStyle::faint, tailTip);\n+                    full.append(sb.toAttributedString());\n+                }\n+            }\n+        }\n@@ -3810,0 +4049,1 @@\n+        doAutosuggestion = true;\n@@ -3817,1 +4057,2 @@\n-        if (highlighter != null && !isSet(Option.DISABLE_HIGHLIGHTER)) {\n+        if (highlighter != null && !isSet(Option.DISABLE_HIGHLIGHTER)\n+                && buffer.length() < getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)) {\n@@ -3939,1 +4180,2 @@\n-        boolean needsMessage = secondaryPromptPattern.contains(\"%M\");\n+        boolean needsMessage = secondaryPromptPattern.contains(\"%M\")\n+                && strAtt.length() < getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE);\n@@ -4105,1 +4347,5 @@\n-        return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);\n+        return listChoices(false);\n+    }\n+\n+    private boolean listChoices(boolean forSuggestion) {\n+        return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false, forSuggestion);\n@@ -4117,0 +4363,4 @@\n+        return doComplete(lst, useMenu, prefix, false);\n+    }\n+\n+    protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix, boolean forSuggestion) {\n@@ -4215,5 +4465,11 @@\n-            matchers = Arrays.asList(\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),\n-                    typoMatcher(wdi, errors, caseInsensitive)\n-            );\n+            if (isSet(Option.EMPTY_WORD_OPTIONS) || wd.length() > 0) {\n+                matchers = Arrays.asList(\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),\n+                        typoMatcher(wdi, errors, caseInsensitive)\n+                );\n+            } else {\n+                matchers = Arrays.asList(\n+                        simpleMatcher(s -> !s.startsWith(\"-\"))\n+                );\n+            }\n@@ -4243,1 +4499,1 @@\n-                doList(possible, line.word(), false, line::escape);\n+                doList(possible, line.word(), false, line::escape, forSuggestion);\n@@ -4326,0 +4582,1 @@\n+                callWidget(REDISPLAY);\n@@ -4390,1 +4647,0 @@\n-                .thenComparing(Candidate::value, Comparator.comparingInt(String::length))\n@@ -4599,2 +4855,4 @@\n-            if (pr.lines > size.getRows() - promptLines) {\n-                int displayed = size.getRows() - promptLines - 1;\n+            Status status = Status.getStatus(terminal, false);\n+            int displaySize = size.getRows() - (status != null ? status.size() : 0) - promptLines;\n+            if (pr.lines > displaySize) {\n+                int displayed = displaySize - 1;\n@@ -4651,1 +4909,1 @@\n-        redisplay();\n+        callWidget(REDISPLAY);\n@@ -4707,1 +4965,2 @@\n-            redisplay();\n+            doAutosuggestion = false;\n+            callWidget(REDISPLAY);\n@@ -4712,1 +4971,12 @@\n-    protected boolean doList(List<Candidate> possible, String completed, boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+    protected boolean clearChoices() {\n+        return doList(new ArrayList<Candidate>(), \"\", false, null, false);\n+    }\n+\n+    protected boolean doList(List<Candidate> possible\n+                           , String completed, boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+        return doList(possible, completed, runLoop, escaper, false);\n+    }\n+\n+    protected boolean doList(List<Candidate> possible\n+                           , String completed\n+                           , boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper, boolean forSuggestion) {\n@@ -4725,7 +4995,11 @@\n-            \/\/ prompt\n-            post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possible.size()\n-                    + \" possibilities (\" + lines + \" lines)?\");\n-            redisplay(true);\n-            int c = readCharacter();\n-            if (c != 'y' && c != 'Y' && c != '\\t') {\n-                post = null;\n+            if (!forSuggestion) {\n+                \/\/ prompt\n+                post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possible.size()\n+                        + \" possibilities (\" + lines + \" lines)?\");\n+                redisplay(true);\n+                int c = readCharacter();\n+                if (c != 'y' && c != 'Y' && c != '\\t') {\n+                    post = null;\n+                    return false;\n+                }\n+            } else {\n@@ -4792,1 +5066,1 @@\n-                    buf.write(getLastBinding());\n+                    callWidget(name);\n@@ -5373,19 +5647,1 @@\n-        final Object SELF_INSERT = new Object();\n-        final Object END_PASTE = new Object();\n-        KeyMap<Object> keyMap = new KeyMap<>();\n-        keyMap.setUnicode(SELF_INSERT);\n-        keyMap.setNomatch(SELF_INSERT);\n-        keyMap.setAmbiguousTimeout(0);\n-        keyMap.bind(END_PASTE, BRACKETED_PASTE_END);\n-        StringBuilder sb = new StringBuilder();\n-        while (true) {\n-            Object b = doReadBinding(keyMap, null);\n-            if (b == END_PASTE) {\n-                break;\n-            }\n-            String s = getLastBinding();\n-            if (\"\\r\".equals(s)) {\n-                s = \"\\n\";\n-            }\n-            sb.append(s);\n-        }\n+        String str = doReadStringUntil(BRACKETED_PASTE_END);\n@@ -5394,1 +5650,1 @@\n-        getBuffer().write(sb);\n+        getBuffer().write(str.replace('\\r', '\\n'));\n@@ -5590,0 +5846,1 @@\n+        bind(emacs, EDIT_AND_EXECUTE_COMMAND,               translate(\"^X^E\"));\n@@ -5890,1 +6147,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":312,"deletions":56,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -37,0 +37,1 @@\n+    private boolean strictCommand = true;\n@@ -67,0 +68,9 @@\n+    \/**\n+     * If true, a completion at argument index N will only succeed\n+     * if all the completions from 1-(N-1) also succeed.\n+     *\n+     * @param strictCommand the strictCommand flag\n+     *\/\n+    public void setStrictCommand(final boolean strictCommand) {\n+        this.strictCommand = strictCommand;\n+    }\n@@ -107,2 +117,6 @@\n-        for (int i = 0; isStrict() && (i < line.wordIndex()); i++) {\n-            Completer sub = completers.get(i >= completers.size() ? (completers.size() - 1) : i);\n+        for (int i = strictCommand ? 0 : 1; isStrict() && (i < line.wordIndex()); i++) {\n+            int idx = i >= completers.size() ? (completers.size() - 1) : i;\n+            if (idx == 0 && !strictCommand) {\n+                continue;\n+            }\n+            Completer sub = completers.get(idx);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/ArgumentCompleter.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -15,0 +15,1 @@\n+import java.util.function.Supplier;\n@@ -30,1 +31,2 @@\n-    protected final Collection<Candidate> candidates = new ArrayList<>();\n+    protected Collection<Candidate> candidates = new ArrayList<>();\n+    protected Supplier<Collection<String>> stringsSupplier;\n@@ -35,0 +37,6 @@\n+    public StringsCompleter(Supplier<Collection<String>> stringsSupplier) {\n+        assert stringsSupplier != null;\n+        candidates = null;\n+        this.stringsSupplier = stringsSupplier;\n+    }\n+\n@@ -47,0 +55,4 @@\n+        this(Arrays.asList(candidates));\n+    }\n+\n+    public StringsCompleter(Collection<Candidate> candidates) {\n@@ -48,1 +60,1 @@\n-        this.candidates.addAll(Arrays.asList(candidates));\n+        this.candidates.addAll(candidates);\n@@ -54,1 +66,7 @@\n-        candidates.addAll(this.candidates);\n+        if (this.candidates != null) {\n+            candidates.addAll(this.candidates);\n+        } else {\n+            for (String string : stringsSupplier.get()) {\n+                candidates.add(new Candidate(AttributedString.stripAnsi(string), string, null, null, null, null, true));\n+            }\n+        }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/StringsCompleter.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -347,1 +347,5 @@\n-        return items.get(index - offset).line();\n+        int idx = index - offset;\n+        if (idx >= items.size() || idx < 0) {\n+            throw new IllegalArgumentException(\"IndexOutOfBounds: Index:\" + idx +\", Size:\" + items.size());\n+        }\n+        return items.get(idx).line();\n@@ -439,0 +443,4 @@\n+    public void resetIndex() {\n+        index = index > items.size() ? items.size() : index;\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -25,0 +26,1 @@\n+import jdk.internal.org.jline.terminal.impl.AbstractTerminal;\n@@ -88,0 +90,2 @@\n+    private static final AtomicReference<Terminal> SYSTEM_TERMINAL = new AtomicReference<>();\n+\n@@ -321,0 +325,1 @@\n+            Terminal terminal = null;\n@@ -335,1 +340,1 @@\n-                        return new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n@@ -344,1 +349,1 @@\n-                        return load(JnaSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n+                        terminal = load(JnaSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n@@ -352,1 +357,1 @@\n-                        return load(JansiSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused);\n+                        terminal = load(JansiSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused);\n@@ -362,1 +367,1 @@\n-                        return new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n@@ -372,1 +377,1 @@\n-                        return new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n@@ -381,1 +386,1 @@\n-                        return new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n@@ -389,1 +394,18 @@\n-            if (dumb == null || dumb) {\n+            if (terminal instanceof AbstractTerminal) {\n+                AbstractTerminal t = (AbstractTerminal) terminal;\n+                if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n+                    t.setOnClose(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            SYSTEM_TERMINAL.compareAndSet(t, null);\n+                        }\n+                    });\n+                } else {\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n+                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n+                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    terminal.close();\n+                    terminal = null;\n+                }\n+            }\n+            if (terminal == null && (dumb == null || dumb)) {\n@@ -408,1 +430,1 @@\n-                return new DumbTerminal(name, color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB,\n+                terminal = new DumbTerminal(name, color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB,\n@@ -412,1 +434,2 @@\n-            } else {\n+            }\n+            if (terminal == null) {\n@@ -415,0 +438,1 @@\n+            return terminal;\n@@ -432,8 +456,1 @@\n-            Terminal terminal = new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused);\n-            if (attributes != null) {\n-                terminal.setAttributes(attributes);\n-            }\n-            if (size != null) {\n-                terminal.setSize(size);\n-            }\n-            return terminal;\n+            return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    public void close() throws IOException {\n-        super.close();\n+    protected void doClose() throws IOException {\n+        super.doClose();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPosixTerminal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+        @Override\n+        public int readBuffered(byte[] b) throws IOException {\n+            return in.read(b);\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    protected Runnable onClose;\n@@ -60,0 +61,4 @@\n+    public void setOnClose(Runnable onClose) {\n+        this.onClose = onClose;\n+    }\n+\n@@ -88,1 +93,11 @@\n-    public void close() throws IOException {\n+    public final void close() throws IOException {\n+        try {\n+            doClose();\n+        } finally {\n+            if (onClose != null) {\n+                onClose.run();\n+            }\n+        }\n+    }\n+\n+    protected void doClose() throws IOException {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractTerminal.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -217,2 +217,2 @@\n-    public void close() throws IOException {\n-        super.close();\n+    protected void doClose() throws IOException {\n+        super.doClose();\n@@ -220,1 +220,3 @@\n-        pump.interrupt();\n+        if (pump != null) {\n+            pump.interrupt();\n+        }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+import jdk.internal.org.jline.terminal.Attributes;\n@@ -12,0 +13,1 @@\n+import jdk.internal.org.jline.terminal.Size;\n@@ -60,0 +62,11 @@\n+        this(name, type, masterInput, masterOutput, encoding, signalHandler, paused, null, null);\n+    }\n+\n+    public ExternalTerminal(String name, String type,\n+                            InputStream masterInput,\n+                            OutputStream masterOutput,\n+                            Charset encoding,\n+                            SignalHandler signalHandler,\n+                            boolean paused,\n+                            Attributes attributes,\n+                            Size size) throws IOException {\n@@ -62,0 +75,6 @@\n+        if (attributes != null) {\n+            setAttributes(attributes);\n+        }\n+        if (size != null) {\n+            setSize(size);\n+        }\n@@ -67,1 +86,1 @@\n-    public void close() throws IOException {\n+    protected void doClose() throws IOException {\n@@ -70,1 +89,1 @@\n-            super.close();\n+            super.doClose();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExternalTerminal.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-    public void close() throws IOException {\n-        super.close();\n+    protected void doClose() throws IOException {\n+        super.doClose();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/LineDisciplineTerminal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-    public void close() throws IOException {\n-        super.close();\n+    protected void doClose() throws IOException {\n+        super.doClose();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    public void close() throws IOException {\n+    protected void doClose() throws IOException {\n@@ -95,1 +95,1 @@\n-        super.close();\n+        super.doClose();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -218,2 +218,1 @@\n-                    AttributedString firstChar =\n-                        newLine.columnSubSequence(0, 1);\n+                    AttributedString firstChar = newLine.substring(0, 1);\n@@ -222,7 +221,6 @@\n-                    cursorPos++;\n-                    int firstLength = firstChar.length(); \/\/ normally 1\n-                    newLine = newLine.substring(firstLength, newLength);\n-                    newLength -= firstLength;\n-                    if (oldLength >= firstLength) {\n-                        oldLine = oldLine.substring(firstLength, oldLength);\n-                        oldLength -= firstLength;\n+                    cursorPos += firstChar.columnLength(); \/\/ normally 1\n+                    newLine = newLine.substring(1, newLength);\n+                    newLength--;\n+                    if (oldLength > 0) {\n+                        oldLine = oldLine.substring(1, oldLength);\n+                        oldLength--;\n@@ -332,1 +330,0 @@\n-        int was = cursorPos;\n@@ -499,1 +496,1 @@\n-        return AttributedString.fromAnsi(str).columnLength();\n+        return str != null ? AttributedString.fromAnsi(str).columnLength() : 0;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -579,1 +579,3 @@\n-                    if (val.startsWith(\"0x\")) {\n+                    if (\"0\".equals(val)) {\n+                        iVal = 0;\n+                    } else if (val.startsWith(\"0x\")) {\n@@ -618,3 +620,3 @@\n-        for (String s : Arrays.asList(\"dumb\", \"ansi\", \"xterm\", \"xterm-256color\",\n-                                      \"windows\", \"windows-256color\", \"windows-conemu\", \"windows-vtp\",\n-                                      \"screen\", \"screen-256color\")) {\n+        for (String s : Arrays.asList(\"dumb\", \"dumb-color\", \"ansi\", \"xterm\", \"xterm-256color\",\n+                \"windows\", \"windows-256color\", \"windows-conemu\", \"windows-vtp\",\n+                \"screen\", \"screen-256color\")) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -200,0 +200,27 @@\n+        @Override\n+        public int readBuffered(char[] b) throws IOException {\n+            if (b == null) {\n+                throw new NullPointerException();\n+            } else if (b.length == 0) {\n+                return 0;\n+            } else {\n+                if (chars.hasRemaining()) {\n+                    int r = Math.min(b.length, chars.remaining());\n+                    chars.get(b);\n+                    return r;\n+                } else {\n+                    byte[] buf = new byte[b.length];\n+                    int l = input.readBuffered(buf);\n+                    if (l < 0) {\n+                        return l;\n+                    } else {\n+                        ByteBuffer bytes = ByteBuffer.wrap(buf, 0, l);\n+                        CharBuffer chars = CharBuffer.wrap(b);\n+                        decoder.decode(bytes, chars, false);\n+                        chars.flip();\n+                        return chars.remaining();\n+                    }\n+                }\n+            }\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -81,0 +81,10 @@\n+    public int readBuffered(byte[] b) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (b.length == 0) {\n+            return 0;\n+        } else {\n+            return super.read(b, 0, b.length);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -14,1 +14,3 @@\n-import java.nio.CharBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -20,3 +22,11 @@\n-    \/\/ Read and write buffer are backed by the same array\n-    private final CharBuffer readBuffer;\n-    private final CharBuffer writeBuffer;\n+    private final char[] buffer;\n+    private int read;\n+    private int write;\n+    private int count;\n+\n+    \/** Main lock guarding all access *\/\n+    final ReentrantLock lock;\n+    \/** Condition for waiting takes *\/\n+    private final Condition notEmpty;\n+    \/** Condition for waiting puts *\/\n+    private final Condition notFull;\n@@ -33,3 +43,1 @@\n-        char[] buf = new char[bufferSize];\n-        this.readBuffer = CharBuffer.wrap(buf);\n-        this.writeBuffer = CharBuffer.wrap(buf);\n+        this.buffer = new char[bufferSize];\n@@ -37,2 +45,3 @@\n-        \/\/ There are no bytes available to read after initialization\n-        readBuffer.limit(0);\n+        this.lock = new ReentrantLock();\n+        this.notEmpty = lock.newCondition();\n+        this.notFull = lock.newCondition();\n@@ -45,40 +54,0 @@\n-    private int wait(CharBuffer buffer, long timeout) throws InterruptedIOException {\n-        boolean isInfinite = (timeout <= 0L);\n-        long end = 0;\n-        if (!isInfinite) {\n-            end = System.currentTimeMillis() + timeout;\n-        }\n-        while (!closed && !buffer.hasRemaining() && (isInfinite || timeout > 0L)) {\n-            \/\/ Wake up waiting readers\/writers\n-            notifyAll();\n-            try {\n-                wait(timeout);\n-            } catch (InterruptedException e) {\n-                throw new InterruptedIOException();\n-            }\n-            if (!isInfinite) {\n-                timeout = end - System.currentTimeMillis();\n-            }\n-        }\n-        return closed\n-                ? EOF\n-                : buffer.hasRemaining()\n-                    ? 0\n-                    : READ_EXPIRED;\n-    }\n-\n-    private static boolean rewind(CharBuffer buffer, CharBuffer other) {\n-        \/\/ Extend limit of other buffer if there is additional input\/output available\n-        if (buffer.position() > other.position()) {\n-            other.limit(buffer.position());\n-        }\n-        \/\/ If we have reached the end of the buffer, rewind and set the new limit\n-        if (buffer.position() == buffer.capacity()) {\n-            buffer.rewind();\n-            buffer.limit(other.position());\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -86,2 +55,2 @@\n-    public synchronized boolean ready() {\n-        return readBuffer.hasRemaining();\n+    public boolean ready() {\n+        return available() > 0;\n@@ -90,4 +59,7 @@\n-    public synchronized int available() {\n-        int count = readBuffer.remaining();\n-        if (writeBuffer.position() < readBuffer.position()) {\n-            count += writeBuffer.position();\n+    public int available() {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            return count;\n+        } finally {\n+            lock.unlock();\n@@ -95,1 +67,0 @@\n-        return count;\n@@ -99,5 +70,31 @@\n-    protected synchronized int read(long timeout, boolean isPeek) throws IOException {\n-        \/\/ Blocks until more input is available or the reader is closed.\n-        int res = wait(readBuffer, timeout);\n-        if (res >= 0) {\n-            res = isPeek ? readBuffer.get(readBuffer.position()) : readBuffer.get();\n+    protected int read(long timeout, boolean isPeek) throws IOException {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            \/\/ Blocks until more input is available or the reader is closed.\n+            if (!closed && count == 0) {\n+                try {\n+                    notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+                } catch (InterruptedException e) {\n+                    throw (IOException) new InterruptedIOException().initCause(e);\n+                }\n+            }\n+            if (closed) {\n+                return EOF;\n+            } else if (count == 0) {\n+                return READ_EXPIRED;\n+            } else {\n+                if (isPeek) {\n+                    return buffer[read];\n+                } else {\n+                    int res = buffer[read];\n+                    if (++read == buffer.length) {\n+                        read = 0;\n+                    }\n+                    --count;\n+                    notFull.signal();\n+                    return res;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -105,2 +102,0 @@\n-        rewind(readBuffer, writeBuffer);\n-        return res;\n@@ -109,6 +104,35 @@\n-    synchronized void write(char[] cbuf, int off, int len) throws IOException {\n-        while (len > 0) {\n-            \/\/ Blocks until there is new space available for buffering or the\n-            \/\/ reader is closed.\n-            if (wait(writeBuffer, 0L) == EOF) {\n-                throw new ClosedException();\n+    @Override\n+    public int readBuffered(char[] b) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (b.length == 0) {\n+            return 0;\n+        } else {\n+            final ReentrantLock lock = this.lock;\n+            lock.lock();\n+            try {\n+                if (!closed && count == 0) {\n+                    try {\n+                        notEmpty.await();\n+                    } catch (InterruptedException e) {\n+                        throw (IOException) new InterruptedIOException().initCause(e);\n+                    }\n+                }\n+                if (closed) {\n+                    return EOF;\n+                } else if (count == 0) {\n+                    return READ_EXPIRED;\n+                } else {\n+                    int r = Math.min(b.length, count);\n+                    for (int i = 0; i < r; i++) {\n+                        b[i] = buffer[read++];\n+                        if (read == buffer.length) {\n+                            read = 0;\n+                        }\n+                    }\n+                    count -= r;\n+                    notFull.signal();\n+                    return r;\n+                }\n+            } finally {\n+                lock.unlock();\n@@ -116,7 +140,0 @@\n-            \/\/ Copy as much characters as we can\n-            int count = Math.min(len, writeBuffer.remaining());\n-            writeBuffer.put(cbuf, off, count);\n-            off += count;\n-            len -= count;\n-            \/\/ Update buffer states and rewind if necessary\n-            rewind(writeBuffer, readBuffer);\n@@ -126,5 +143,31 @@\n-    synchronized void flush() {\n-        \/\/ Avoid waking up readers when there is nothing to read\n-        if (readBuffer.hasRemaining()) {\n-            \/\/ Notify readers\n-            notifyAll();\n+    void write(char[] cbuf, int off, int len) throws IOException {\n+        if (len > 0) {\n+            final ReentrantLock lock = this.lock;\n+            lock.lock();\n+            try {\n+                while (len > 0) {\n+                    \/\/ Blocks until there is new space available for buffering or the\n+                    \/\/ reader is closed.\n+                    if (!closed && count == buffer.length) {\n+                        try {\n+                            notFull.await();\n+                        } catch (InterruptedException e) {\n+                            throw (IOException) new InterruptedIOException().initCause(e);\n+                        }\n+                    }\n+                    if (closed) {\n+                        throw new IOException(\"Closed\");\n+                    }\n+                    while (len > 0 && count < buffer.length) {\n+                        buffer[write++] = cbuf[off++];\n+                        count++;\n+                        len--;\n+                        if (write == buffer.length) {\n+                            write = 0;\n+                        }\n+                    }\n+                    notEmpty.signal();\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n@@ -135,3 +178,10 @@\n-    public synchronized void close() throws IOException {\n-        this.closed = true;\n-        notifyAll();\n+    public void close() throws IOException {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            this.closed = true;\n+            this.notEmpty.signalAll();\n+            this.notFull.signalAll();\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -149,1 +199,0 @@\n-            NonBlockingPumpReader.this.flush();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":134,"deletions":85,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    public abstract int readBuffered(char[] b) throws IOException;\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,28 @@\n+    @Override\n+    public int readBuffered(char[] b) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (b.length == 0) {\n+            return 0;\n+        } else if (exception != null) {\n+            assert ch == READ_EXPIRED;\n+            IOException toBeThrown = exception;\n+            exception = null;\n+            throw toBeThrown;\n+        } else if (ch >= -1) {\n+            b[0] = (char) ch;\n+            ch = READ_EXPIRED;\n+            return 1;\n+        } else if (!threadIsReading) {\n+            return in.read(b);\n+        } else {\n+            int c = read(-1, false);\n+            if (c >= 0) {\n+                b[0] = (char) c;\n+                return 1;\n+            } else {\n+                return -1;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n@@ -16,2 +16,0 @@\n-import jdk.internal.org.jline.terminal.Terminal.Signal;\n-import jdk.internal.org.jline.terminal.Terminal.SignalHandler;\n@@ -32,0 +30,2 @@\n+    protected AttributedString borderString;\n+    protected int border = 0;\n@@ -51,0 +51,6 @@\n+            char borderChar = '\\u2700';\n+            AttributedStringBuilder bb = new AttributedStringBuilder();\n+            for (int i = 0; i < 200; i++) {\n+                bb.append(borderChar);\n+            }\n+            borderString = bb.toAttributedString();\n@@ -55,0 +61,4 @@\n+    public void setBorder(boolean border) {\n+        this.border = border ? 1 : 0;\n+    }\n+\n@@ -71,0 +81,1 @@\n+        int b = border;\n@@ -72,0 +83,1 @@\n+        border = b;\n@@ -82,0 +94,20 @@\n+    public void clear() {\n+        privateClear(oldLines.size());\n+    }\n+\n+    private void clearAll() {\n+        int b = border;\n+        border = 0;\n+        privateClear(oldLines.size() + b);\n+    }\n+\n+    private void privateClear(int statusSize) {\n+        List<AttributedString> as = new ArrayList<>();\n+        for (int i = 0; i < statusSize; i++) {\n+            as.add(new AttributedString(\"\"));\n+        }\n+        if (!as.isEmpty()) {\n+            update(as);\n+        }\n+    }\n+\n@@ -93,0 +125,3 @@\n+        if (lines.isEmpty()) {\n+            clearAll();\n+        }\n@@ -96,1 +131,2 @@\n-        int nb = lines.size() - oldLines.size();\n+        int statusSize = lines.size() + (lines.size() == 0 ? 0 : border);\n+        int nb = statusSize - oldLines.size() - (oldLines.size() == 0 ? 0 : border);\n@@ -106,2 +142,11 @@\n-        terminal.puts(Capability.cursor_address, rows - lines.size(), 0);\n-        terminal.puts(Capability.clr_eos);\n+        terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n+        if (!terminal.puts(Capability.clr_eos)) {\n+            for (int i = rows - statusSize; i < rows; i++) {\n+                terminal.puts(Capability.cursor_address, i, 0);\n+                terminal.puts(Capability.clr_eol);\n+            }\n+        }\n+        if (border == 1 && lines.size() > 0) {\n+            terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n+            borderString.columnSubSequence(0, columns).print(terminal);\n+        }\n@@ -110,1 +155,7 @@\n-            lines.get(i).columnSubSequence(0, columns).print(terminal);\n+            if (lines.get(i).length() > columns) {\n+                AttributedStringBuilder asb = new AttributedStringBuilder();\n+                asb.append(lines.get(i).substring(0, columns - 3)).append(\"...\", new AttributedStyle(AttributedStyle.INVERSE));\n+                asb.toAttributedString().columnSubSequence(0, columns).print(terminal);\n+            } else {\n+                lines.get(i).columnSubSequence(0, columns).print(terminal);\n+            }\n@@ -112,1 +163,1 @@\n-        terminal.puts(Capability.change_scroll_region, 0, rows - 1 - lines.size());\n+        terminal.puts(Capability.change_scroll_region, 0, rows - 1 - statusSize);\n@@ -124,0 +175,1 @@\n+        int b = border;\n@@ -125,0 +177,1 @@\n+        border = b;\n@@ -138,1 +191,1 @@\n-        return oldLines.size();\n+        return oldLines.size() + border;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Status.java","additions":62,"deletions":9,"binary":false,"changes":71,"status":"modified"},{"patch":"","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/dumb-color.caps","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/dumb-colors.caps","status":"renamed"},{"patch":"@@ -11,1 +11,1 @@\n-\tel=\\E[K, ed=\\E[2K,\n+\tel=\\E[K, ed=\\E[J,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-256color.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-\tel=\\E[K, ed=\\E[2K,\n+\tel=\\E[K, ed=\\E[J,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-conemu.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-\tel=\\E[K, ed=\\E[2K,\n+\tel=\\E[K, ed=\\E[J,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-vtp.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-\tel=\\E[K, ed=\\E[2K,\n+\tel=\\E[K, ed=\\E[J,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.12.1\n+## JLine v3.14.0\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author or authors.\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaSupportImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}