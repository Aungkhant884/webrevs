{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-            0x004C, KeyExAlgorithm.ECDH_ECDSA, Protocol.TLSV1, Protocol.TLSV1_2),\n+            0x004C, KeyExAlgorithm.ECDH_ECDSA, Protocol.SSLV3, Protocol.TLSV1_2),\n@@ -162,1 +162,1 @@\n-            0x0039, KeyExAlgorithm.DHE_RSA, Protocol.TLSV1, Protocol.TLSV1_2),\n+            0x0039, KeyExAlgorithm.DHE_RSA, Protocol.SSLV3, Protocol.TLSV1_2),\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/CipherSuite.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,0 +392,8 @@\n+    public static Cert[] getCerts(String... certNames) {\n+        Cert[] certs = new Cert[certNames.length];\n+        for(int i = 0; i < certNames.length; i++) {\n+            certs[i] = Cert.valueOf(certNames[i]);\n+        }\n+        return certs;\n+    }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/Cert.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,11 +76,0 @@\n-        boolean debug = Boolean.getBoolean(\"debug\");\n-\n-        String securityPropertiesFile = System.getProperty(\n-                \"test.security.properties\",\n-                System.getProperty(\"test.src\") + \"\/java.security\");\n-        System.out.println(\"security properties: \" + securityPropertiesFile);\n-\n-        \/\/ If true, server and client CANNOT be a same JDK\n-        boolean disallowSameEndpoint = Boolean.getBoolean(\"disallowSameEndpoint\");\n-        System.out.println(\"disallowSameEndpoint: \" + disallowSameEndpoint);\n-\n@@ -95,0 +84,1 @@\n+            JdkInfo targetJdkInfo = new JdkInfo(System.getProperty(\"test.jdk\"));\n@@ -96,76 +86,5 @@\n-                for (JdkInfo serverJdk : jdkInfos) {\n-                    Map<String, String> props = new LinkedHashMap<>();\n-                    if (debug) {\n-                        props.put(\"javax.net.debug\", \"all\");\n-                    }\n-                    props.put(\"java.security.properties\", securityPropertiesFile);\n-\n-                    props.put(Utils.PROP_PROTOCOL, useCase.protocol.name);\n-                    props.put(Utils.PROP_CIPHER_SUITE, useCase.cipherSuite.name());\n-                    props.put(Utils.PROP_CLIENT_AUTH, String.valueOf(useCase.clientAuth));\n-                    if (useCase.appProtocol != UseCase.AppProtocol.NONE) {\n-                        props.put(Utils.PROP_APP_PROTOCOLS,\n-                                Utils.join(Utils.VALUE_DELIMITER,\n-                                        useCase.appProtocol.appProtocols));\n-                        props.put(Utils.PROP_NEGO_APP_PROTOCOL,\n-                                useCase.appProtocol.negoAppProtocol);\n-                    }\n-                    props.put(Utils.PROP_SERVER_JDK, serverJdk.version);\n-\n-                    props.put(Utils.PROP_SUPPORTS_SNI_ON_SERVER,\n-                            serverJdk.supportsSNI + \"\");\n-                    props.put(Utils.PROP_SUPPORTS_ALPN_ON_SERVER,\n-                            serverJdk.supportsALPN + \"\");\n-\n-                    for (JdkInfo clientJdk : jdkInfos) {\n-                        if (disallowSameEndpoint && clientJdk == serverJdk) {\n-                            continue;\n-                        }\n-\n-                        TestCase testCase = new TestCase(serverJdk, clientJdk,\n-                                useCase);\n-                        System.out.println(Utils.anchorName(testCase.toString(),\n-                                \"===== Case start =====\"));\n-                        System.out.println(testCase.toString());\n-\n-                        props.put(Utils.PROP_NEGATIVE_CASE_ON_SERVER,\n-                                testCase.negativeCaseOnServer + \"\");\n-                        props.put(Utils.PROP_NEGATIVE_CASE_ON_CLIENT,\n-                                testCase.negativeCaseOnClient + \"\");\n-\n-                        Future<OutputAnalyzer> serverFuture = executor.submit(() -> {\n-                            return runServer(serverJdk.jdkPath, props);\n-                        });\n-                        int port = waitForServerStarted();\n-                        System.out.println(\"port=\" + port);\n-\n-                        props.put(Utils.PROP_PORT, port + \"\");\n-\n-                        props.put(Utils.PROP_CLIENT_JDK, clientJdk.version);\n-\n-                        props.put(Utils.PROP_SUPPORTS_SNI_ON_CLIENT,\n-                                clientJdk.supportsSNI + \"\");\n-                        props.put(Utils.PROP_SUPPORTS_ALPN_ON_CLIENT,\n-                                clientJdk.supportsALPN + \"\");\n-                        if (useCase.serverName != UseCase.ServerName.NONE) {\n-                            props.put(Utils.PROP_SERVER_NAME,\n-                                    useCase.serverName.name);\n-                        }\n-\n-                        Status clientStatus = null;\n-                        if (port != -1) {\n-                            String clientOutput = runClient(clientJdk.jdkPath,\n-                                    props).getOutput();\n-                            clientStatus = getStatus(clientOutput);\n-                        }\n-\n-                        String serverOutput = serverFuture.get().getOutput();\n-                        Status serverStatus = getStatus(serverOutput);\n-                        testCase.setStatus(caseStatus(serverStatus, clientStatus));\n-                        testCases.add(testCase);\n-                        System.out.printf(\n-                                \"ServerStatus=%s, ClientStatus=%s, CaseStatus=%s%n\",\n-                                serverStatus, clientStatus, testCase.getStatus());\n-\n-                        System.out.println(\"===== Case end =====\");\n-                    }\n+                for (JdkInfo jdkInfo : jdkInfos) {\n+                    testCases.add(\n+                            runCase(targetJdkInfo, jdkInfo, useCase, executor));\n+                    testCases.add(\n+                            runCase(jdkInfo, targetJdkInfo, useCase, executor));\n@@ -185,0 +104,75 @@\n+    private TestCase runCase(JdkInfo serverJdk, JdkInfo clientJdk,\n+            UseCase useCase, ExecutorService executor) throws Exception {\n+        Map<String, String> props = new LinkedHashMap<>();\n+        if (Utils.DEBUG) {\n+            props.put(\"javax.net.debug\", \"all\");\n+        }\n+\n+        props.put(\"java.security.properties\", Utils.SECURITY_PROPERTIES_FILE);\n+\n+        props.put(Utils.PROP_CERTS, Utils.join(Utils.VALUE_DELIMITER,\n+                Cert.getCerts(useCase.cipherSuite)));\n+        props.put(Utils.PROP_CLIENT_AUTH, String.valueOf(useCase.clientAuth));\n+        if (useCase.appProtocol != UseCase.AppProtocol.NONE) {\n+            props.put(Utils.PROP_APP_PROTOCOLS,\n+                    Utils.join(Utils.VALUE_DELIMITER,\n+                            useCase.appProtocol.appProtocols));\n+            props.put(Utils.PROP_NEGO_APP_PROTOCOL,\n+                    useCase.appProtocol.negoAppProtocol);\n+        }\n+        props.put(Utils.PROP_SERVER_JDK, serverJdk.version);\n+\n+        props.put(Utils.PROP_SUPPORTS_SNI_ON_SERVER,\n+                serverJdk.supportsSNI + \"\");\n+        props.put(Utils.PROP_SUPPORTS_ALPN_ON_SERVER,\n+                serverJdk.supportsALPN + \"\");\n+\n+        TestCase testCase = new TestCase(serverJdk, clientJdk, useCase);\n+        System.out.println(Utils.anchorName(testCase.toString(),\n+                \"===== Case start =====\"));\n+        System.out.println(testCase.toString());\n+\n+        props.put(Utils.PROP_NEGATIVE_CASE_ON_SERVER,\n+                testCase.negativeCaseOnServer + \"\");\n+        props.put(Utils.PROP_NEGATIVE_CASE_ON_CLIENT,\n+                testCase.negativeCaseOnClient + \"\");\n+\n+        Future<OutputAnalyzer> serverFuture = executor.submit(() -> {\n+            return runServer(serverJdk.jdkPath, props);\n+        });\n+        int port = waitForServerStarted();\n+        System.out.println(\"port=\" + port);\n+\n+        props.put(Utils.PROP_PORT, port + \"\");\n+\n+        props.put(Utils.PROP_CLIENT_JDK, clientJdk.version);\n+\n+        props.put(Utils.PROP_PROTOCOL, useCase.protocol.name);\n+        props.put(Utils.PROP_CIPHER_SUITE, useCase.cipherSuite.name());\n+        props.put(Utils.PROP_SUPPORTS_SNI_ON_CLIENT,\n+                clientJdk.supportsSNI + \"\");\n+        props.put(Utils.PROP_SUPPORTS_ALPN_ON_CLIENT,\n+                clientJdk.supportsALPN + \"\");\n+        if (useCase.serverName != UseCase.ServerName.NONE) {\n+            props.put(Utils.PROP_SERVER_NAME,\n+                    useCase.serverName.name);\n+        }\n+\n+        Status clientStatus = null;\n+        if (port != -1) {\n+            String clientOutput = runClient(clientJdk.jdkPath,\n+                    props).getOutput();\n+            clientStatus = getStatus(clientOutput);\n+        }\n+\n+        String serverOutput = serverFuture.get().getOutput();\n+        Status serverStatus = getStatus(serverOutput);\n+        testCase.setStatus(caseStatus(serverStatus, clientStatus));\n+        System.out.printf(\n+                \"ServerStatus=%s, ClientStatus=%s, CaseStatus=%s%n\",\n+                serverStatus, clientStatus, testCase.getStatus());\n+\n+        System.out.println(\"===== Case end =====\");\n+        return testCase;\n+    }\n+\n@@ -195,2 +189,2 @@\n-                \"ServerJDK\",\n-                \"ClientJDK\",\n+                \"Client\",\n+                \"Server\",\n@@ -198,2 +192,2 @@\n-                \"CipherSuite\",\n-                \"ClientAuth\",\n+                \"Cipher suite\",\n+                \"Client auth\",\n@@ -202,1 +196,2 @@\n-                \"Status\"));\n+                \"Status\",\n+                \"Reason\"));\n@@ -211,1 +206,0 @@\n-                    testCase.serverJdk.version,\n@@ -213,0 +207,1 @@\n+                    testCase.serverJdk.version,\n@@ -221,4 +216,4 @@\n-                    testCase.getStatus()));\n-            failed = failed\n-                    || testCase.getStatus() == Status.FAIL\n-                    || testCase.getStatus() == Status.UNEXPECTED_SUCCESS;\n+                    testCase.getStatus(),\n+                    testCase.reason()));\n+\n+            failed = failed || testCase.isFailed();\n@@ -266,13 +261,4 @@\n-        if (clientStatus == null || clientStatus == Status.TIMEOUT) {\n-            return serverStatus == Status.EXPECTED_FAIL\n-                   ? Status.EXPECTED_FAIL\n-                   : Status.FAIL;\n-        } else if (serverStatus == Status.TIMEOUT) {\n-            return clientStatus == Status.EXPECTED_FAIL\n-                   ? Status.EXPECTED_FAIL\n-                   : Status.FAIL;\n-        } else {\n-            return serverStatus == clientStatus\n-                   ? serverStatus\n-                   : Status.FAIL;\n-        }\n+        return (serverStatus == Status.EXPECTED_FAIL && clientStatus != Status.SUCCESS)\n+                || (clientStatus == Status.EXPECTED_FAIL && serverStatus != Status.SUCCESS)\n+                ? Status.EXPECTED_FAIL\n+                : (serverStatus == clientStatus ? serverStatus : Status.FAIL);\n@@ -282,1 +268,0 @@\n-    \/\/ And the current testing JDK, which is specified by test.jdk, always be used.\n@@ -285,1 +270,0 @@\n-        jdkList.add(System.getProperty(\"test.jdk\"));\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/Compatibility.java","additions":97,"deletions":113,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -2,1 +3,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +25,3 @@\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n@@ -35,0 +39,1 @@\n+    public final String enabledProtocols;\n@@ -36,0 +41,1 @@\n+    public final String enabledCipherSuites;\n@@ -51,3 +57,5 @@\n-        supportedCipherSuites = attributes[2].replaceAll(\".*=\", \"\");\n-        supportsSNI = Boolean.valueOf(attributes[3].replaceAll(\".*=\", \"\"));\n-        supportsALPN = Boolean.valueOf(attributes[4].replaceAll(\".*=\", \"\"));\n+        enabledProtocols = attributes[2].replaceAll(\".*=\", \"\");\n+        supportedCipherSuites = attributes[3].replaceAll(\".*=\", \"\");\n+        enabledCipherSuites = attributes[4].replaceAll(\".*=\", \"\");\n+        supportsSNI = Boolean.valueOf(attributes[5].replaceAll(\".*=\", \"\"));\n+        supportsALPN = Boolean.valueOf(attributes[6].replaceAll(\".*=\", \"\"));\n@@ -58,1 +66,3 @@\n-        return ProcessUtils.java(jdkPath, null, JdkUtils.class).getOutput();\n+        Map<String, String> props = new LinkedHashMap<>();\n+        props.put(\"java.security.properties\", Utils.SECURITY_PROPERTIES_FILE);\n+        return ProcessUtils.java(jdkPath, props, JdkUtils.class).getOutput();\n@@ -92,0 +102,4 @@\n+    public boolean enablesProtocol(Protocol protocol) {\n+        return enabledProtocols.contains(protocol.name);\n+    }\n+\n@@ -95,0 +109,4 @@\n+\n+    public boolean enablesCipherSuite(CipherSuite cipherSuite) {\n+        return enabledCipherSuites.contains(cipherSuite.name());\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/JdkInfo.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.net.ssl.SSLSocketFactory;\n@@ -37,0 +36,1 @@\n+    public static final String ENABLED_PROTOCOLS = \"enabledProtocols\";\n@@ -38,0 +38,1 @@\n+    public static final String ENABLED_CIPHER_SUITES = \"enabledCipherSuites\";\n@@ -46,10 +47,5 @@\n-    private static String supportedProtocols() {\n-        StringBuilder protocols = new StringBuilder();\n-        for (String protocol : new String[] {\n-                \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\" }) {\n-            if (supportsProtocol(protocol)) {\n-                protocols.append(protocol).append(Utils.VALUE_DELIMITER);\n-            }\n-        }\n-        return protocols.toString().substring(\n-                0, protocols.toString().length() - 1);\n+    private static String supportedProtocols()\n+            throws NoSuchAlgorithmException {\n+        String[] protocols = SSLContext.getDefault()\n+                .createSSLEngine().getSupportedProtocols();\n+        return Utils.join(Utils.VALUE_DELIMITER, protocols).toString();\n@@ -58,8 +54,5 @@\n-    private static boolean supportsProtocol(String protocol) {\n-        boolean supported = true;\n-        try {\n-            SSLContext.getInstance(protocol);\n-        } catch (NoSuchAlgorithmException e) {\n-            supported = false;\n-        }\n-        return supported;\n+    private static String enabledProtocols()\n+            throws NoSuchAlgorithmException {\n+        String[] protocols = SSLContext.getDefault()\n+                .createSSLEngine().getEnabledProtocols();\n+        return Utils.join(Utils.VALUE_DELIMITER, protocols).toString();\n@@ -68,11 +61,14 @@\n-    private static String supportedCipherSuites() {\n-        StringBuilder cipherSuites = new StringBuilder();\n-        String[] supportedCipherSuites = ((SSLSocketFactory) SSLSocketFactory\n-                .getDefault()).getSupportedCipherSuites();\n-        for (int i = 0; i < supportedCipherSuites.length - 1; i++) {\n-            cipherSuites.append(supportedCipherSuites[i])\n-                    .append(Utils.VALUE_DELIMITER);\n-        }\n-        cipherSuites.append(\n-                supportedCipherSuites[supportedCipherSuites.length - 1]);\n-        return cipherSuites.toString();\n+    private static String supportedCipherSuites()\n+            throws NoSuchAlgorithmException {\n+        String[] supportedCipherSuites = SSLContext.getDefault()\n+                .createSSLEngine().getSupportedCipherSuites();\n+        return Utils.join(Utils.VALUE_DELIMITER, supportedCipherSuites)\n+                .toString();\n+    }\n+\n+    private static String enabledCipherSuites()\n+            throws NoSuchAlgorithmException {\n+        String[] enabledCipherSuites = SSLContext.getDefault()\n+                .createSSLEngine().getEnabledCipherSuites();\n+        return Utils.join(Utils.VALUE_DELIMITER, enabledCipherSuites)\n+                .toString();\n@@ -107,0 +103,1 @@\n+                attr(ENABLED_PROTOCOLS, enabledProtocols()),\n@@ -108,0 +105,1 @@\n+                attr(ENABLED_CIPHER_SUITES, enabledCipherSuites()),\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/JdkUtils.java","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,8 +57,0 @@\n-    private void setEnabledCipherSuites(String... cipherSuites) {\n-        serverSocket.setEnabledCipherSuites(cipherSuites);\n-    }\n-\n-    private void setEnabledProtocols(String... protocols) {\n-        serverSocket.setEnabledProtocols(protocols);\n-    }\n-\n@@ -103,2 +95,1 @@\n-        String protocol = System.getProperty(Utils.PROP_PROTOCOL);\n-        String cipherSuite = System.getProperty(Utils.PROP_CIPHER_SUITE);\n+        String certs = System.getProperty(Utils.PROP_CERTS);\n@@ -115,2 +106,0 @@\n-                \"Protocol=\" + protocol,\n-                \"CipherSuite=\" + cipherSuite,\n@@ -123,1 +112,2 @@\n-            server = new Server(Cert.getCerts(CipherSuite.cipherSuite(cipherSuite)));\n+            server = new Server(\n+                    Cert.getCerts(Utils.split(certs, Utils.VALUE_DELIMITER)));\n@@ -126,2 +116,0 @@\n-            server.setEnabledProtocols(protocol);\n-            server.setEnabledCipherSuites(cipherSuite);\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/Server.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,8 @@\n+    public final boolean protocolSupportsCipherSuite;\n+\n+    public final boolean serverEnablesProtocol;\n+    public final boolean serverEnablesCipherSuite;\n+\n+    public final boolean clientSupportsProtocol;\n+    public final boolean clientSupportsCipherSuite;\n+\n@@ -43,4 +51,14 @@\n-        negativeCaseOnServer = useCase.negativeCase\n-                || !serverJdk.supportsCipherSuite(useCase.cipherSuite);\n-        negativeCaseOnClient = useCase.negativeCase\n-                || !clientJdk.supportsCipherSuite(useCase.cipherSuite);\n+        serverEnablesProtocol = serverJdk.enablesProtocol(useCase.protocol);\n+        serverEnablesCipherSuite = serverJdk.enablesCipherSuite(useCase.cipherSuite);\n+\n+        clientSupportsProtocol = clientJdk.supportsProtocol(useCase.protocol);\n+        clientSupportsCipherSuite = clientJdk.supportsCipherSuite(useCase.cipherSuite);\n+\n+        protocolSupportsCipherSuite = useCase.protocolSupportsCipherSuite;\n+\n+        negativeCaseOnServer = !protocolSupportsCipherSuite\n+                || !serverEnablesProtocol\n+                || !serverEnablesCipherSuite;\n+        negativeCaseOnClient = !protocolSupportsCipherSuite\n+                || !clientSupportsProtocol\n+                || !clientSupportsCipherSuite;\n@@ -57,0 +75,39 @@\n+    public boolean isNegative() {\n+        return negativeCaseOnServer || negativeCaseOnClient;\n+    }\n+\n+    public boolean isFailed() {\n+        return status == Status.FAIL || status == Status.UNEXPECTED_SUCCESS;\n+    }\n+\n+    public String negativeCaseReason() {\n+        return Utils.join(\". \",\n+                !protocolSupportsCipherSuite\n+                        ? \"Protocol doesn't support cipher suite\"\n+                        : \"\",\n+                !serverEnablesProtocol\n+                        ? \"Server doesn't enable protocol\"\n+                        : \"\",\n+                !serverEnablesCipherSuite\n+                        ? \"Server doesn't enable cipher suite\"\n+                        : \"\",\n+                !clientSupportsProtocol\n+                        ? \"Client doesn't support protocol\"\n+                        : \"\",\n+                !clientSupportsCipherSuite\n+                        ? \"Client doesn't support cipher suite\"\n+                        : \"\");\n+    }\n+\n+    public String reason() {\n+        if (status == Status.SUCCESS) {\n+            return \"\";\n+        }\n+\n+        if (status == Status.EXPECTED_FAIL && isNegative()) {\n+            return negativeCaseReason();\n+        }\n+\n+        return \"Refer to log at case hyperlink for details...\";\n+    }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/TestCase.java","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+            Protocol.SSLV3,\n@@ -151,1 +152,1 @@\n-    public final boolean negativeCase;\n+    public final boolean protocolSupportsCipherSuite;\n@@ -165,1 +166,1 @@\n-        negativeCase = !cipherSuite.supportedByProtocol(protocol);\n+        protocolSupportsCipherSuite = cipherSuite.supportedByProtocol(protocol);\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/UseCase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+    public static final String PROP_CERTS = \"test.certs\";\n@@ -71,0 +72,5 @@\n+    public static final boolean DEBUG = Boolean.getBoolean(\"debug\");\n+    public static final String SECURITY_PROPERTIES_FILE = System.getProperty(\n+            \"test.security.properties\",\n+            System.getProperty(\"test.src\") + \"\/java.security\");\n+\n@@ -150,1 +156,2 @@\n-    public static String join(String delimiter, String... values) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> String join(String delimiter, T... values) {\n@@ -154,1 +161,8 @@\n-                result.append(values[i]).append(delimiter);\n+                if (values[i] != null && !values[i].toString().isEmpty()) {\n+                    result.append(values[i]).append(delimiter);\n+                }\n+            }\n+\n+            if (values[values.length - 1] != null\n+                    && !values[values.length - 1].toString().isEmpty()) {\n+                result.append(values[values.length - 1]);\n@@ -156,1 +170,0 @@\n-            result.append(values[values.length - 1]);\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/Utils.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"}]}