{"files":[{"patch":"@@ -2490,20 +2490,23 @@\n-\n-  if (JvmtiExport::can_maintain_original_method_order()) {\n-    \/\/ Use the original method ordering indices stored in the class, so we can emit\n-    \/\/ jmethodIDs in the order they appeared in the class file\n-    for (index = 0; index < result_length; index++) {\n-      Method* m = ik->methods()->at(index);\n-      int original_index = ik->method_ordering()->at(index);\n-      assert(original_index >= 0 && original_index < result_length, \"invalid original method index\");\n-      jmethodID id;\n-      if (jmethodids_found) {\n-        id = m->find_jmethod_id_or_null();\n-        if (id == NULL) {\n-          \/\/ If we find an uninitialized value, make sure there is\n-          \/\/ enough space for all the uninitialized values we might\n-          \/\/ find.\n-          ik->ensure_space_for_methodids(index);\n-          jmethodids_found = false;\n-          id = m->jmethod_id();\n-        }\n-      } else {\n+  int skipped = 0;  \/\/ skip overpass methods\n+\n+  for (index = 0; index < result_length; index++) {\n+    Method* m = ik->methods()->at(index);\n+    \/\/ Depending on can_maintain_original_method_order capability use the original\n+    \/\/ method ordering indices stored in the class, so we can emit jmethodIDs in\n+    \/\/ the order they appeared in the class file or just copy in current order.\n+    int result_index = JvmtiExport::can_maintain_original_method_order() ? ik->method_ordering()->at(index) : index;\n+    assert(result_index >= 0 && result_index < result_length, \"invalid original method index\");\n+    if (m->is_overpass()) {\n+      result_list[result_index] = NULL;\n+      skipped++;\n+      continue;\n+    }\n+    jmethodID id;\n+    if (jmethodids_found) {\n+      id = m->find_jmethod_id_or_null();\n+      if (id == NULL) {\n+        \/\/ If we find an uninitialized value, make sure there is\n+        \/\/ enough space for all the uninitialized values we might\n+        \/\/ find.\n+        ik->ensure_space_for_methodids(index);\n+        jmethodids_found = false;\n@@ -2512,1 +2515,2 @@\n-      result_list[original_index] = id;\n+    } else {\n+      id = m->jmethod_id();\n@@ -2514,15 +2518,11 @@\n-  } else {\n-    \/\/ otherwise just copy in any order\n-    for (index = 0; index < result_length; index++) {\n-      Method* m = ik->methods()->at(index);\n-      jmethodID id;\n-      if (jmethodids_found) {\n-        id = m->find_jmethod_id_or_null();\n-        if (id == NULL) {\n-          \/\/ If we find an uninitialized value, make sure there is\n-          \/\/ enough space for all the uninitialized values we might\n-          \/\/ find.\n-          ik->ensure_space_for_methodids(index);\n-          jmethodids_found = false;\n-          id = m->jmethod_id();\n-        }\n+    result_list[result_index] = id;\n+  }\n+\n+  \/\/ Fill in return value.\n+  if (skipped > 0) {\n+    \/\/ copy results skipping NULL methodIDs\n+    *methods_ptr = (jmethodID*)jvmtiMalloc((result_length - skipped) * sizeof(jmethodID));\n+    *method_count_ptr = result_length - skipped;\n+    for (index = 0, skipped = 0; index < result_length; index++) {\n+      if (result_list[index] == NULL) {\n+        skipped++;\n@@ -2530,1 +2530,1 @@\n-        id = m->jmethod_id();\n+        (*methods_ptr)[index - skipped] = result_list[index];\n@@ -2532,1 +2532,0 @@\n-      result_list[index] = id;\n@@ -2534,0 +2533,4 @@\n+    deallocate((unsigned char *)result_list);\n+  } else {\n+    *method_count_ptr = result_length;\n+    *methods_ptr = result_list;\n@@ -2535,3 +2538,0 @@\n-  \/\/ Fill in return value.\n-  *method_count_ptr = result_length;\n-  *methods_ptr = result_list;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8216324\n+ * @summary GetClassMethods is confused by the presence of default methods in super interfaces\n+ * @library \/test\/lib\n+ * @compile OverpassMethods.java\n+ * @run main\/othervm\/native -agentlib:OverpassMethods OverpassMethods\n+ * @run main\/othervm\/native -agentlib:OverpassMethods=maintain_original_method_order OverpassMethods\n+  *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+public class OverpassMethods {\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"OverpassMethods\");\n+        } catch (UnsatisfiedLinkError ex) {\n+            System.err.println(\"Could not load OverpassMethods library\");\n+            System.err.println(\"java.library.path:\" + System.getProperty(\"java.library.path\"));\n+            throw ex;\n+        }\n+    }\n+\n+    static private void log(Object msg) {\n+        System.out.println(String.valueOf(msg));\n+    }\n+\n+    static private native Method[] getJVMTIDeclaredMethods(Class<?> klass);\n+\n+    public interface Parent {\n+        default String def() { return \"Parent.def\"; }\n+        String method0();\n+        String method1();\n+    }\n+\n+    public interface Child extends Parent {\n+        String method2();\n+    }\n+\n+    public static class Impl implements Child {\n+        public String method0() { return \"Impl.method0\"; }\n+        public String method1() { return \"Impl.method1\"; }\n+        public String method2() { return \"Impl.method2\"; }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Impl(); \/\/ To get classes initialized\n+\n+        Method[] reflectMethods = Child.class.getDeclaredMethods();\n+        Method[] jvmtiMethods = getJVMTIDeclaredMethods(Child.class);\n+\n+        if (jvmtiMethods == null) {\n+            throw new RuntimeException(\"getJVMTIDeclaredMethods failed\");\n+        }\n+\n+        log(\"Reflection getDeclaredMethods returned: \" + Arrays.toString(reflectMethods));\n+        log(\"JVMTI GetClassMethods returned: \" + Arrays.toString(jvmtiMethods));\n+\n+        if (reflectMethods.length != jvmtiMethods.length) {\n+            throw new RuntimeException(\"OverpassMethods failed: Unexpected method count from JVMTI GetClassMethods!\");\n+        }\n+        if (!reflectMethods[0].equals(jvmtiMethods[0])) {\n+            throw new RuntimeException(\"OverpassMethods failed: Unexpected method from JVMTI GetClassMethods!\");\n+        }\n+        log(\"Test passed: Got expected output from JVMTI GetClassMethods!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassMethods\/OverpassMethods.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define ACC_STATIC 0x0008\n+\n+static jvmtiEnv *jvmti = NULL;\n+\n+JNIEXPORT\n+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  return JNI_VERSION_9;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  vm->GetEnv((void **)&jvmti, JVMTI_VERSION_11);\n+\n+  if (options != NULL && strcmp(options, \"maintain_original_method_order\") == 0) {\n+    printf(\"Enabled capability: maintain_original_method_order\\n\");\n+    jvmtiCapabilities caps = {};\n+    caps.can_maintain_original_method_order = 1;\n+\n+    jvmtiError err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Agent_OnLoad: AddCapabilities failed with error: %d\\n\", err);\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jobjectArray JNICALL Java_OverpassMethods_getJVMTIDeclaredMethods(JNIEnv *env, jclass static_klass, jclass klass) {\n+  jint method_count = 0;\n+  jmethodID* methods = NULL;\n+  jvmtiError err = jvmti->GetClassMethods(klass, &method_count, &methods);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"GetClassMethods failed with error: %d\\n\", err);\n+    return NULL;\n+  }\n+\n+  jclass method_cls = env->FindClass(\"java\/lang\/reflect\/Method\");\n+  if (method_cls == NULL) {\n+    printf(\"FindClass (Method) failed\\n\");\n+    return NULL;\n+  }\n+  jobjectArray array = env->NewObjectArray(method_count, method_cls, NULL);\n+  if (array == NULL) {\n+    printf(\"NewObjectArray failed\\n\");\n+    return NULL;\n+  }\n+\n+  for (int i = 0; i < method_count; i++) {\n+    jint modifiers = 0;\n+    err = jvmti->GetMethodModifiers(methods[i], &modifiers);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"GetMethodModifiers failed with error: %d\\n\", err);\n+      return NULL;\n+    }\n+\n+    jobject m = env->ToReflectedMethod(klass, methods[i], (modifiers & ACC_STATIC) == ACC_STATIC);\n+    if (array == NULL) {\n+      printf(\"ToReflectedMethod failed\\n\");\n+      return NULL;\n+    }\n+    env->SetObjectArrayElement(array, i, m);\n+\n+    env->DeleteLocalRef(m);\n+  }\n+  jvmti->Deallocate((unsigned char *)methods);\n+\n+  return array;\n+}\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassMethods\/libOverpassMethods.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+        default void meth_def1() {}\n@@ -112,1 +113,5 @@\n-interface OuterInterface1 {\n+interface DefaultInterface {\n+    default void default_method() { }\n+}\n+\n+interface OuterInterface1 extends DefaultInterface {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassMethods\/getclmthd007.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,2 @@\n-    { \"meth_n1\", \"()V\" }\n+    { \"meth_n1\", \"()V\" },\n+    { \"meth_def1\", \"()V\" }\n@@ -101,1 +102,1 @@\n-    { \"InnerInterface\", 1, m1 },\n+    { \"InnerInterface\", 2, m1 },\n@@ -148,0 +149,1 @@\n+    int failed = JNI_FALSE; \/\/ enable debugging on failure\n@@ -170,0 +172,2 @@\n+        failed = JNI_TRUE; \/\/ show the methods found\n+        printf(\">>> %s:\\n\", classes[i].name);\n@@ -175,1 +179,1 @@\n-        } else if (printdump == JNI_TRUE) {\n+        } else if (printdump == JNI_TRUE || failed == JNI_TRUE) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassMethods\/getclmthd007\/getclmthd007.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}