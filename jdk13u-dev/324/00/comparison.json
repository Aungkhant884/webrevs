{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.net.SocketException;\n@@ -341,1 +342,6 @@\n-            conSession.invalidate();\n+            \/\/ In the case of a low-layer transport error, we want to prevent\n+            \/\/ the session from being invalidated since this is not a TLS-level\n+            \/\/ error event.\n+            if (!(cause instanceof SocketException)) {\n+                conSession.invalidate();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    private final CountDownLatch serverCondition = new CountDownLatch(1);\n+    protected final CountDownLatch serverCondition = new CountDownLatch(1);\n@@ -217,1 +217,1 @@\n-    private final CountDownLatch clientCondition = new CountDownLatch(1);\n+    protected final CountDownLatch clientCondition = new CountDownLatch(1);\n@@ -471,1 +471,9 @@\n-    private static final boolean separateServerThread = false;\n+    private final boolean separateServerThread;\n+\n+    public SSLSocketTemplate() {\n+        this(false);\n+    }\n+\n+    public SSLSocketTemplate(boolean sepSrvThread) {\n+        this.separateServerThread = sepSrvThread;\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8274736\n+ * @summary Concurrent read\/close of SSLSockets causes SSLSessions to be\n+ *          invalidated unnecessarily\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm NoInvalidateSocketException TLSv1.3\n+ * @run main\/othervm NoInvalidateSocketException TLSv1.2\n+ * @run main\/othervm -Djdk.tls.client.enableSessionTicketExtension=false\n+ *      NoInvalidateSocketException TLSv1.2\n+ *\/\n+\n+\n+\n+import java.io.*;\n+import javax.net.ssl.*;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+public class NoInvalidateSocketException extends SSLSocketTemplate {\n+    private static final int ITERATIONS = 10;\n+\n+    \/\/ This controls how long the main thread waits before closing the socket.\n+    \/\/ This may need tweaking for different environments to get the timing\n+    \/\/ right.\n+    private static final int CLOSE_DELAY = 10;\n+\n+    private static SSLContext clientSSLCtx;\n+    private static SSLSocket theSSLSocket;\n+    private static SSLSession theSSLSession;\n+    private static InputStream theInputStream;\n+    private static String theSSLSocketHashCode;\n+    private static SSLSession lastSSLSession;\n+    private static final List<SSLSocket> serverCleanupList = new ArrayList<>();\n+    private static String tlsVersion = null;\n+\n+    private static int invalidSessCount = 0;\n+    private static volatile boolean readFromSocket = false;\n+    private static volatile boolean finished = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (System.getProperty(\"javax.net.debug\") == null) {\n+            System.setProperty(\"javax.net.debug\", \"session\");\n+        }\n+\n+        if (args != null && args.length >= 1) {\n+            tlsVersion = args[0];\n+        }\n+\n+        new NoInvalidateSocketException(true).run();\n+        if (invalidSessCount > 0) {\n+            throw new RuntimeException(\"One or more sessions were improperly \" +\n+                    \"invalidated.\");\n+        }\n+    }\n+\n+    public NoInvalidateSocketException(boolean sepSrvThread) {\n+        super(sepSrvThread);\n+    }\n+\n+    @Override\n+    public boolean isCustomizedClientConnection() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void runClientApplication(int serverPort) {\n+        Thread.currentThread().setName(\"Main Client Thread\");\n+\n+        \/\/ Create the SSLContext we'll use for client sockets for the\n+        \/\/ duration of the test.\n+        try {\n+            clientSSLCtx = createClientSSLContext();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create client ctx\", e);\n+        }\n+\n+        \/\/ Create the reader thread\n+        ReaderThread readerThread = new ReaderThread();\n+        readerThread.setName(\"Client Reader Thread\");\n+        readerThread.start();\n+\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                openSSLSocket();\n+                doHandshake();\n+                getInputStream();\n+                getAndCompareSession();\n+\n+                \/\/ Perform the Close\/Read MT collision\n+                readCloseMultiThreaded();\n+\n+                \/\/ Check to make sure that the initially negotiated session\n+                \/\/ remains intact.\n+                isSessionValid();\n+\n+                lastSSLSession = theSSLSession;\n+\n+                \/\/ Insert a short gap between iterations\n+                Thread.sleep(1000);\n+                System.out.println();\n+            }\n+        } catch (Exception e) {\n+            logToConsole(\"Unexpected Exception: \" + e);\n+        } finally {\n+            \/\/ Tell the reader thread to finish\n+            finished = true;\n+        }\n+    }\n+\n+    private void readCloseMultiThreaded() throws IOException,\n+            InterruptedException {\n+        \/\/ Tell the reader thread to start trying to read from this\n+        \/\/ socket\n+        readFromSocket = true;\n+\n+        \/\/ Short pause to give the reader thread time to start\n+        \/\/ reading.\n+        if (CLOSE_DELAY > 0) {\n+            Thread.sleep(CLOSE_DELAY);\n+        }\n+\n+        \/\/ The problem happens when the reader thread tries to read\n+        \/\/ from the socket while this thread is in the close() call\n+        closeSSLSocket();\n+\n+        \/\/ Pause to give the reader thread time to discover that the\n+        \/\/ socket is closed and throw a SocketException\n+        Thread.sleep(500);\n+    }\n+\n+    private class ReaderThread extends Thread {\n+        public void run() {\n+            \/\/ This thread runs in a tight loop until\n+            \/\/ readFromSocket == true\n+            while (!finished) {\n+                if (readFromSocket) {\n+                    int result = 0;\n+                    try {\n+                        \/\/ If the timing is just\n+                        \/\/ right, this will throw a SocketException\n+                        \/\/ and the SSLSession will be\n+                        \/\/ invalidated.\n+                        result = readFromSSLSocket();\n+                    } catch (Exception e) {\n+                        logToConsole(\"Exception reading from SSLSocket@\" +\n+                                theSSLSocketHashCode + \": \" + e);\n+                        e.printStackTrace(System.out);\n+\n+                        \/\/ Stop trying to read from\n+                        \/\/ the socket now\n+                        readFromSocket = false;\n+                    }\n+\n+                    if (result == -1) {\n+                        logToConsole(\"Reached end of stream reading from \" +\n+                                \"SSLSocket@\" + theSSLSocketHashCode);\n+\n+                        \/\/ Stop trying to read from\n+                        \/\/ the socket now\n+                        readFromSocket = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void openSSLSocket() throws IOException {\n+        theSSLSocket = (SSLSocket)clientSSLCtx.getSocketFactory().\n+                createSocket(serverAddress, serverPort);\n+        if (tlsVersion != null) {\n+            theSSLSocket.setEnabledProtocols(new String[] { tlsVersion });\n+        }\n+        theSSLSocketHashCode = String.format(\"%08x\", theSSLSocket.hashCode());\n+        logToConsole(\"Opened SSLSocket@\" + theSSLSocketHashCode);\n+    }\n+\n+    private void doHandshake() throws IOException {\n+        logToConsole(\"Started handshake on SSLSocket@\" +\n+                theSSLSocketHashCode);\n+        theSSLSocket.startHandshake();\n+        logToConsole(\"Finished handshake on SSLSocket@\" +\n+                theSSLSocketHashCode);\n+    }\n+\n+    private void getInputStream() throws IOException {\n+        theInputStream = theSSLSocket.getInputStream();\n+    }\n+\n+    private void getAndCompareSession() {\n+        theSSLSession = theSSLSocket.getSession();\n+\n+        \/\/ Have we opened a new session or re-used the last one?\n+        if (lastSSLSession == null ||\n+                !theSSLSession.equals(lastSSLSession)) {\n+            logToConsole(\"*** OPENED NEW SESSION ***: \" +\n+                    theSSLSession);\n+        } else {\n+            logToConsole(\"*** RE-USING PREVIOUS SESSION ***: \" +\n+                    theSSLSession + \")\");\n+        }\n+    }\n+\n+    private void closeSSLSocket() throws IOException {\n+        logToConsole(\"Closing SSLSocket@\" + theSSLSocketHashCode);\n+        theSSLSocket.close();\n+        logToConsole(\"Closed SSLSocket@\" + theSSLSocketHashCode);\n+    }\n+\n+    private int readFromSSLSocket() throws Exception {\n+        logToConsole(\"Started reading from SSLSocket@\" +\n+                theSSLSocketHashCode);\n+        int result = theInputStream.read();\n+        logToConsole(\"Finished reading from SSLSocket@\" +\n+                theSSLSocketHashCode + \": result = \" + result);\n+        return result;\n+    }\n+\n+    private void isSessionValid() {\n+        \/\/ Is the session still valid?\n+        if (theSSLSession.isValid()) {\n+            logToConsole(\"*** \" + theSSLSession + \" IS VALID ***\");\n+        } else {\n+            logToConsole(\"*** \" + theSSLSession + \" IS INVALID ***\");\n+            invalidSessCount++;\n+        }\n+    }\n+\n+    private static void logToConsole(String s) {\n+        System.out.println(System.nanoTime() + \": \" +\n+                Thread.currentThread().getName() + \": \" + s);\n+    }\n+\n+    protected volatile InetAddress serverAddress = null;\n+\n+    @Override\n+    public void doServerSide() throws Exception {\n+        Thread.currentThread().setName(\"Server Listener Thread\");\n+        SSLContext context = createServerSSLContext();\n+        SSLServerSocketFactory sslssf = context.getServerSocketFactory();\n+        InetAddress serverAddress = this.serverAddress;\n+        SSLServerSocket sslServerSocket = serverAddress == null ?\n+                (SSLServerSocket)sslssf.createServerSocket(serverPort)\n+                : (SSLServerSocket)sslssf.createServerSocket();\n+        if (serverAddress != null) {\n+            sslServerSocket.bind(new InetSocketAddress(serverAddress,\n+                    serverPort));\n+        }\n+        configureServerSocket(sslServerSocket);\n+        serverPort = sslServerSocket.getLocalPort();\n+        logToConsole(\"Listening on \" + sslServerSocket.getLocalSocketAddress());\n+\n+        \/\/ Signal the client, the server is ready to accept connection.\n+        serverCondition.countDown();\n+\n+        \/\/ Try to accept a connection in 5 seconds.\n+        \/\/ We will do this in a loop until the client flips the\n+        \/\/ finished variable to true\n+        SSLSocket sslSocket;\n+\n+        int timeoutCount = 0;\n+        try {\n+            do {\n+                try {\n+                    sslSocket = (SSLSocket) sslServerSocket.accept();\n+                    timeoutCount = 0;   \/\/ Reset the timeout counter;\n+                    logToConsole(\"Accepted connection from \" +\n+                            sslSocket.getRemoteSocketAddress());\n+\n+                    \/\/ Add the socket to the cleanup list so it can get\n+                    \/\/ closed at the end of the test\n+                    serverCleanupList.add(sslSocket);\n+\n+                    boolean clientIsReady =\n+                            clientCondition.await(30L, TimeUnit.SECONDS);\n+                    if (clientIsReady) {\n+                        \/\/ Handle the connection in a new thread\n+                        ServerHandlerThread sht = null;\n+                        try {\n+                             sht = new ServerHandlerThread(sslSocket);\n+                             sht.start();\n+                        } finally {\n+                            if (sht != null) {\n+                                sht.join();\n+                            }\n+                        }\n+                    }\n+                } catch (SocketTimeoutException ste) {\n+                    timeoutCount++;\n+                    \/\/ If we are finished then we can return, otherwise\n+                    \/\/ check if we've timed out too many times (an exception\n+                    \/\/ case).  One way or the other we will exit eventually.\n+                    if (finished) {\n+                        return;\n+                    } else if (timeoutCount >= 3) {\n+                        logToConsole(\"Server accept timeout exceeded\");\n+                        throw ste;\n+                    }\n+                }\n+            } while (!finished);\n+        } finally {\n+            sslServerSocket.close();\n+            \/\/ run through the server cleanup list and close those sockets\n+            \/\/ as well.\n+            for (SSLSocket sock : serverCleanupList) {\n+                try {\n+                    if (sock != null) {\n+                        sock.close();\n+                    }\n+                } catch (IOException ioe) {\n+                    \/\/ Swallow these close failures as the server itself\n+                    \/\/ is shutting down anyway.\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void configureServerSocket(SSLServerSocket socket) {\n+        try {\n+            socket.setReuseAddress(true);\n+            socket.setSoTimeout(5000);\n+        } catch (SocketException se) {\n+            \/\/ Rethrow as unchecked to satisfy the override signature\n+            throw new RuntimeException(se);\n+        }\n+    }\n+\n+    @Override\n+    public void runServerApplication(SSLSocket sslSocket) {\n+        Thread.currentThread().setName(\"Server Reader Thread\");\n+        SSLSocket sock = null;\n+        sock = sslSocket;\n+        try {\n+            BufferedReader is = new BufferedReader(\n+                    new InputStreamReader(sock.getInputStream()));\n+            PrintWriter os = new PrintWriter(new BufferedWriter(\n+                    new OutputStreamWriter(sock.getOutputStream())));\n+\n+            \/\/ Only handle a single burst of data\n+            char[] buf = new char[1024];\n+            int dataRead = is.read(buf);\n+            logToConsole(String.format(\"Received: %d bytes of data\\n\",\n+                    dataRead));\n+\n+            os.println(\"Received connection from client\");\n+            os.flush();\n+        } catch (IOException ioe) {\n+            \/\/ Swallow these exceptions for this test\n+        }\n+    }\n+\n+    private class ServerHandlerThread extends Thread {\n+        SSLSocket sock;\n+        ServerHandlerThread(SSLSocket socket) {\n+            this.sock = Objects.requireNonNull(socket, \"Illegal null socket\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                runServerApplication(sock);\n+            } catch (Exception exc) {\n+                \/\/ Wrap inside an unchecked exception to satisfy Runnable\n+                throw new RuntimeException(exc);\n+            }\n+        }\n+\n+        void close() {\n+            try {\n+                sock.close();\n+            } catch (IOException e) {\n+                \/\/ swallow this exception\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"}]}