{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,2 +169,2 @@\n-        \/\/ only needed for HTTP\/1.1 to close the connection\n-        \/\/ or return it to the pool\n+        \/\/ Needed for HTTP\/1.1 to close the connection or return it to the pool\n+        \/\/ Needed for HTTP\/2 to subscribe a dummy subscriber and close the stream\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,8 @@\n+    @Override\n+    void nullBody(HttpResponse<T> resp, Throwable t) {\n+        if (debug.on()) debug.log(\"nullBody: streamid=%d\", streamid);\n+        \/\/ We should have an END_STREAM data frame waiting in the inputQ.\n+        \/\/ We need a subscriber to force the scheduler to process it.\n+        pendingResponseSubscriber = HttpResponse.BodySubscribers.replacing(null);\n+        sched.runOrSchedule();\n+    }\n@@ -385,0 +393,1 @@\n+                    if (debug.on()) debug.log(\"handling END_STREAM: %d\", streamid);\n@@ -691,0 +700,1 @@\n+        if (debug.on()) debug.log(\"setEndStreamReceived: streamid=%d\", streamid);\n@@ -1035,0 +1045,1 @@\n+            if (debug.on()) debug.log(\"requestSent: streamid=%d\", streamid);\n@@ -1036,0 +1047,4 @@\n+        } else {\n+            if (debug.on()) {\n+                debug.log(\"requestSent: streamid=%d but response not received\", streamid);\n+            }\n@@ -1042,0 +1057,1 @@\n+            if (debug.on()) debug.log(\"responseReceived: streamid=%d\", streamid);\n@@ -1043,0 +1059,4 @@\n+        } else {\n+            if (debug.on()) {\n+                debug.log(\"responseReceived: streamid=%d but request not sent\", streamid);\n+            }\n@@ -1165,0 +1185,1 @@\n+        if (debug.on()) debug.log(\"close stream %d\", streamid);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8238270\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *       ReferenceTracker Response204V2Test\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ *                     -Djdk.httpclient.HttpClient.log=requests,responses,errors\n+ *                     Response204V2Test\n+ * @summary Tests that streams are closed after receiving a 204 response.\n+ *          This test uses the OperationsTracker and will fail in\n+ *          teardown if the tracker reports that some HTTP\/2 streams\n+ *          are still open.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.ITestContext;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import static java.lang.System.out;\n+\n+public class Response204V2Test implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+\n+    static final int RESPONSE_CODE = 204;\n+    static final int ITERATION_COUNT = 4;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    System.out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    System.err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            throw new RuntimeException(\"some tests failed\");\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests() {\n+        out.println(\"\\n=========================\");\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+                e.getValue().printStackTrace();\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                http2URI,\n+                https2URI,\n+        };\n+    }\n+\n+    static AtomicLong URICOUNT = new AtomicLong();\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            return new Object[0][];\n+        }\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(false, true)) {\n+            for (String uri : uris()) {\n+                result[i++] = new Object[]{uri, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        HttpClient client =  HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+        return TRACKER.track(client);\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient();\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+            }\n+            return shared;\n+        }\n+    }\n+\n+\n+    static void checkStatus(int expected, int found) throws Exception {\n+        if (expected != found) {\n+            System.err.printf (\"Test failed: wrong status code %d\/%d\\n\",\n+                expected, found);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static void checkStrings(String expected, String found) throws Exception {\n+        if (!expected.equals(found)) {\n+            System.err.printf (\"Test failed: wrong string %s\/%s\\n\",\n+                expected, found);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"variants\")\n+    public void test(String uri, boolean sameClient) throws Exception {\n+        System.out.println(\"Request to \" + uri);\n+\n+        HttpClient client = newHttpClient(sameClient);\n+\n+        HttpRequest request = HttpRequest.newBuilder(URI.create(uri))\n+                .GET()\n+                .build();\n+        for (int i = 0; i < ITERATION_COUNT; i++) {\n+            System.out.println(\"Iteration: \" + i);\n+            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n+            int expectedResponse =  RESPONSE_CODE;\n+            if (response.statusCode() != expectedResponse)\n+                throw new RuntimeException(\"wrong response code \" + Integer.toString(response.statusCode()));\n+        }\n+        System.out.println(\"test: DONE\");\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        \/\/ HTTP\/2\n+        HttpTestHandler handler204 = new Handler204();\n+\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(handler204, \"\/http2\/test204\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/test204\/x\";\n+\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(handler204, \"\/https2\/test204\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/test204\/x\";\n+\n+        serverCount.addAndGet(4);\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    System.err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+\n+    static class Handler204 implements HttpTestHandler {\n+\n+        public Handler204() {}\n+\n+        volatile int invocation = 0;\n+\n+        @Override\n+        public void handle(HttpTestExchange t)\n+                throws IOException {\n+            try {\n+                URI uri = t.getRequestURI();\n+                System.err.printf(\"Handler received request for %s\\n\", uri);\n+                String type = uri.getScheme().toLowerCase();\n+                InputStream is = t.getRequestBody();\n+                while (is.read() != -1);\n+                is.close();\n+\n+\n+                if ((invocation++ % 2) == 1) {\n+                    System.err.printf(\"Server sending %d - chunked\\n\", RESPONSE_CODE);\n+                    t.sendResponseHeaders(RESPONSE_CODE, -1);\n+                    OutputStream os = t.getResponseBody();\n+                    os.close();\n+                } else {\n+                    System.err.printf(\"Server sending %d - 0 length\\n\", RESPONSE_CODE);\n+                    t.sendResponseHeaders(RESPONSE_CODE, 0);\n+                }\n+            } catch (Throwable e) {\n+                e.printStackTrace(System.err);\n+                throw new IOException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/Response204V2Test.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-        if (responseLength < 0) {\n+        if (responseLength < 0 || rCode == 204) {\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestExchangeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}