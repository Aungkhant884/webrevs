{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Map;\n@@ -588,1 +589,2 @@\n-            this.signatureScheme = SignatureScheme.getPreferableAlgorithm(\n+            Map.Entry<SignatureScheme, Signature> schemeAndSigner =\n+                    SignatureScheme.getSignerOfPreferableAlgorithm(\n@@ -593,1 +595,1 @@\n-            if (signatureScheme == null) {\n+            if (schemeAndSigner == null) {\n@@ -597,1 +599,3 @@\n-                    \"No preferred signature algorithm for CertificateVerify\");\n+                    \"No supported CertificateVerify signature algorithm for \" +\n+                    x509Possession.popPrivateKey.getAlgorithm() +\n+                    \"  key\");\n@@ -600,0 +604,1 @@\n+            this.signatureScheme = schemeAndSigner.getKey();\n@@ -602,2 +607,1 @@\n-                Signature signer =\n-                    signatureScheme.getSignature(x509Possession.popPrivateKey);\n+                Signature signer = schemeAndSigner.getValue();\n@@ -606,7 +610,1 @@\n-            } catch (NoSuchAlgorithmException |\n-                    InvalidAlgorithmParameterException nsae) {\n-                throw chc.conContext.fatal(Alert.INTERNAL_ERROR,\n-                        \"Unsupported signature algorithm (\" +\n-                        signatureScheme.name +\n-                        \") used in CertificateVerify handshake message\", nsae);\n-            } catch (InvalidKeyException | SignatureException ikse) {\n+            } catch (SignatureException ikse) {\n@@ -672,1 +670,1 @@\n-                    signatureScheme.getSignature(x509Credentials.popPublicKey);\n+                    signatureScheme.getVerifier(x509Credentials.popPublicKey);\n@@ -901,1 +899,2 @@\n-            this.signatureScheme = SignatureScheme.getPreferableAlgorithm(\n+            Map.Entry<SignatureScheme, Signature> schemeAndSigner =\n+                    SignatureScheme.getSignerOfPreferableAlgorithm(\n@@ -906,1 +905,1 @@\n-            if (signatureScheme == null) {\n+            if (schemeAndSigner == null) {\n@@ -910,1 +909,3 @@\n-                    \"No preferred signature algorithm for CertificateVerify\");\n+                    \"No supported CertificateVerify signature algorithm for \" +\n+                    x509Possession.popPrivateKey.getAlgorithm() +\n+                    \"  key\");\n@@ -913,0 +914,2 @@\n+            this.signatureScheme = schemeAndSigner.getKey();\n+\n@@ -929,2 +932,1 @@\n-                Signature signer =\n-                    signatureScheme.getSignature(x509Possession.popPrivateKey);\n+                Signature signer = schemeAndSigner.getValue();\n@@ -933,7 +935,1 @@\n-            } catch (NoSuchAlgorithmException |\n-                    InvalidAlgorithmParameterException nsae) {\n-                throw context.conContext.fatal(Alert.INTERNAL_ERROR,\n-                        \"Unsupported signature algorithm (\" +\n-                        signatureScheme.name +\n-                        \") used in CertificateVerify handshake message\", nsae);\n-            } catch (InvalidKeyException | SignatureException ikse) {\n+            } catch (SignatureException ikse) {\n@@ -1010,1 +1006,1 @@\n-                    signatureScheme.getSignature(x509Credentials.popPublicKey);\n+                    signatureScheme.getVerifier(x509Credentials.popPublicKey);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateVerify.java","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Map;\n@@ -127,6 +128,7 @@\n-                    signatureScheme = SignatureScheme.getPreferableAlgorithm(\n-                            shc.algorithmConstraints,\n-                            shc.peerRequestedSignatureSchemes,\n-                            x509Possession,\n-                            shc.negotiatedProtocol);\n-                    if (signatureScheme == null) {\n+                    Map.Entry<SignatureScheme, Signature> schemeAndSigner =\n+                            SignatureScheme.getSignerOfPreferableAlgorithm(\n+                                    shc.algorithmConstraints,\n+                                    shc.peerRequestedSignatureSchemes,\n+                                    x509Possession,\n+                                    shc.negotiatedProtocol);\n+                    if (schemeAndSigner == null) {\n@@ -136,10 +138,6 @@\n-                            \"No preferred signature algorithm\");\n-                    }\n-                    try {\n-                        signer = signatureScheme.getSignature(\n-                                x509Possession.popPrivateKey);\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException |\n-                            InvalidAlgorithmParameterException nsae) {\n-                        throw shc.conContext.fatal(Alert.INTERNAL_ERROR,\n-                            \"Unsupported signature algorithm: \" +\n-                            signatureScheme.name, nsae);\n+                                \"No supported signature algorithm for \" +\n+                                x509Possession.popPrivateKey.getAlgorithm() +\n+                                \"  key\");\n+                    } else {\n+                        signatureScheme = schemeAndSigner.getKey();\n+                        signer = schemeAndSigner.getValue();\n@@ -244,1 +242,1 @@\n-                    signer = signatureScheme.getSignature(\n+                    signer = signatureScheme.getVerifier(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHServerKeyExchange.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.security.ssl.NamedGroup.NamedGroupSpec;\n+import java.util.Map;\n@@ -138,6 +138,7 @@\n-                    signatureScheme = SignatureScheme.getPreferableAlgorithm(\n-                            shc.algorithmConstraints,\n-                            shc.peerRequestedSignatureSchemes,\n-                            x509Possession,\n-                            shc.negotiatedProtocol);\n-                    if (signatureScheme == null) {\n+                    Map.Entry<SignatureScheme, Signature> schemeAndSigner =\n+                            SignatureScheme.getSignerOfPreferableAlgorithm(\n+                                shc.algorithmConstraints,\n+                                shc.peerRequestedSignatureSchemes,\n+                                x509Possession,\n+                                shc.negotiatedProtocol);\n+                    if (schemeAndSigner == null) {\n@@ -147,1 +148,1 @@\n-                                \"No preferred signature algorithm for \" +\n+                                \"No supported signature algorithm for \" +\n@@ -150,9 +151,3 @@\n-                    }\n-                    try {\n-                        signer = signatureScheme.getSignature(\n-                                x509Possession.popPrivateKey);\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException |\n-                            InvalidAlgorithmParameterException nsae) {\n-                        throw shc.conContext.fatal(Alert.INTERNAL_ERROR,\n-                            \"Unsupported signature algorithm: \" +\n-                            signatureScheme.name, nsae);\n+                    } else {\n+                        signatureScheme = schemeAndSigner.getKey();\n+                        signer = schemeAndSigner.getValue();\n@@ -279,1 +274,1 @@\n-                    signer = signatureScheme.getSignature(\n+                    signer = signatureScheme.getVerifier(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHServerKeyExchange.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.AbstractMap.SimpleImmutableEntry;\n@@ -40,0 +41,1 @@\n+import java.util.Map;\n@@ -461,1 +463,1 @@\n-    static SignatureScheme getPreferableAlgorithm(\n+    static Map.Entry<SignatureScheme, Signature> getSignerOfPreferableAlgorithm(\n@@ -488,1 +490,4 @@\n-                        return ss;\n+                        Signature signer = ss.getSigner(signingKey);\n+                        if (signer != null) {\n+                            return new SimpleImmutableEntry<>(ss, signer);\n+                        }\n@@ -513,1 +518,4 @@\n-                            return ss;\n+                            Signature signer = ss.getSigner(signingKey);\n+                            if (signer != null) {\n+                                return new SimpleImmutableEntry<>(ss, signer);\n+                            }\n@@ -524,1 +532,4 @@\n-                    return ss;\n+                    Signature signer = ss.getSigner(signingKey);\n+                    if (signer != null) {\n+                        return new SimpleImmutableEntry<>(ss, signer);\n+                    }\n@@ -545,1 +556,6 @@\n-    Signature getSignature(Key key) throws NoSuchAlgorithmException,\n+    \/\/ This method is used to get the signature instance of this signature\n+    \/\/ scheme for the specific public key.  Unlike getSigner(), the exception\n+    \/\/ is bubbled up.  If the public key does not support this signature\n+    \/\/ scheme, it normally means the TLS handshaking cannot continue and\n+    \/\/ the connection should be terminated.\n+    Signature getVerifier(PublicKey publicKey) throws NoSuchAlgorithmException,\n@@ -551,10 +567,14 @@\n-        Signature signer = Signature.getInstance(algorithm);\n-        if (key instanceof PublicKey) {\n-            SignatureUtil.initVerifyWithParam(signer, (PublicKey)key,\n-                    (signAlgParams != null ?\n-                            signAlgParams.parameterSpec : null));\n-        } else {\n-            SignatureUtil.initSignWithParam(signer, (PrivateKey)key,\n-                    (signAlgParams != null ?\n-                            signAlgParams.parameterSpec : null),\n-                    null);\n+        Signature verifier = Signature.getInstance(algorithm);\n+        SignatureUtil.initVerifyWithParam(verifier, publicKey,\n+                (signAlgParams != null ? signAlgParams.parameterSpec : null));\n+\n+        return verifier;\n+    }\n+\n+    \/\/ This method is also used to choose preferable signature scheme for the\n+    \/\/ specific private key.  If the private key does not support the signature\n+    \/\/ scheme, {@code null} is returned, and the caller may fail back to next\n+    \/\/ available signature scheme.\n+    private Signature getSigner(PrivateKey privateKey) {\n+        if (!isAvailable) {\n+            return null;\n@@ -563,1 +583,17 @@\n-        return signer;\n+        try {\n+            Signature signer = Signature.getInstance(algorithm);\n+            SignatureUtil.initSignWithParam(signer, privateKey,\n+                (signAlgParams != null ? signAlgParams.parameterSpec : null),\n+                null);\n+            return signer;\n+        } catch (NoSuchAlgorithmException | InvalidKeyException |\n+                InvalidAlgorithmParameterException nsae) {\n+            if (SSLLogger.isOn &&\n+                    SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                SSLLogger.finest(\n+                    \"Ignore unsupported signature algorithm (\" +\n+                    this.name + \")\", nsae);\n+            }\n+        }\n+\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":52,"deletions":16,"binary":false,"changes":68,"status":"modified"}]}