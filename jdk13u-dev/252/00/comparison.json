{"files":[{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.cert.X509Certificate;\n+import java.text.MessageFormat;\n+import java.util.*;\n+import javax.net.ssl.SSLProtocolException;\n+import javax.security.auth.x500.X500Principal;\n+import sun.security.ssl.SSLExtension.ExtensionConsumer;\n+import sun.security.ssl.SSLExtension.SSLExtensionSpec;\n+import sun.security.ssl.SSLHandshake.HandshakeMessage;\n+\n+\/**\n+ * Pack of the \"certificate_authorities\" extensions.\n+ *\/\n+final class CertificateAuthoritiesExtension {\n+    static final HandshakeProducer chNetworkProducer =\n+            new CHCertificateAuthoritiesProducer();\n+    static final ExtensionConsumer chOnLoadConsumer =\n+            new CHCertificateAuthoritiesConsumer();\n+\n+    static final HandshakeProducer crNetworkProducer =\n+            new CRCertificateAuthoritiesProducer();\n+    static final ExtensionConsumer crOnLoadConsumer =\n+            new CRCertificateAuthoritiesConsumer();\n+\n+    static final SSLStringizer ssStringizer =\n+            new CertificateAuthoritiesStringizer();\n+\n+    \/**\n+     * The \"certificate_authorities\" extension.\n+     *\/\n+    static final class CertificateAuthoritiesSpec implements SSLExtensionSpec {\n+        final List<byte[]> authorities;     \/\/ certificate authorities\n+\n+        private CertificateAuthoritiesSpec(List<byte[]> authorities) {\n+            this.authorities = authorities;\n+        }\n+\n+        private CertificateAuthoritiesSpec(HandshakeContext hc,\n+                ByteBuffer m) throws IOException  {\n+            if (m.remaining() < 3) {        \/\/ 2: the length of the list\n+                                            \/\/ 1: at least one byte authorities\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                        new SSLProtocolException(\n+                    \"Invalid certificate_authorities extension: \" +\n+                    \"insufficient data\"));\n+            }\n+\n+            int listLen = Record.getInt16(m);\n+            if (listLen == 0) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                    \"Invalid certificate_authorities extension: \" +\n+                    \"no certificate authorities\");\n+            }\n+\n+            if (listLen > m.remaining()) {\n+                throw hc.conContext.fatal(Alert.DECODE_ERROR,\n+                    \"Invalid certificate_authorities extension: \" +\n+                    \"insufficient data\");\n+            }\n+\n+            this.authorities = new LinkedList<>();\n+            while (listLen > 0) {\n+                \/\/ opaque DistinguishedName<1..2^16-1>;\n+                byte[] encoded = Record.getBytes16(m);\n+                listLen -= (2 + encoded.length);\n+                authorities.add(encoded);\n+            }\n+        }\n+\n+        private static List<byte[]> getEncodedAuthorities(\n+                X509Certificate[] trustedCerts) {\n+            List<byte[]> authorities = new ArrayList<>(trustedCerts.length);\n+            int sizeAccount = 0;\n+            for (X509Certificate cert : trustedCerts) {\n+                X500Principal x500Principal = cert.getSubjectX500Principal();\n+                byte[] encodedPrincipal = x500Principal.getEncoded();\n+                sizeAccount += encodedPrincipal.length;\n+                if (sizeAccount > 0xFFFF) {  \/\/ the size limit of this extension\n+                    \/\/ If there too many trusts CAs such that they exceed the\n+                    \/\/ size limit of the extension, enabling this extension\n+                    \/\/ does not really make sense as there is no way to\n+                    \/\/ indicate the peer certificate selection accurately.\n+                    \/\/ In such cases, the extension is just ignored, rather\n+                    \/\/ than fatal close, for better compatibility and\n+                    \/\/ interoperability.\n+                    return Collections.emptyList();\n+                }\n+\n+                if (encodedPrincipal.length != 0) {\n+                    authorities.add(encodedPrincipal);\n+                }\n+            }\n+\n+            return authorities;\n+        }\n+\n+        X500Principal[] getAuthorities() {\n+            X500Principal[] principals = new X500Principal[authorities.size()];\n+            int i = 0;\n+            for (byte[] encoded : authorities) {\n+                principals[i++] = new X500Principal(encoded);\n+            }\n+\n+            return principals;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            MessageFormat messageFormat = new MessageFormat(\n+                \"\\\"certificate authorities\\\": '['\\n{0}']'\", Locale.ENGLISH);\n+            StringBuilder builder = new StringBuilder(512);\n+            for (byte[] encoded : authorities) {\n+                X500Principal principal = new X500Principal(encoded);\n+                builder.append(principal.toString());\n+                builder.append(\"\\n\");\n+            }\n+            Object[] messageFields = {\n+                Utilities.indent(builder.toString())\n+            };\n+\n+            return messageFormat.format(messageFields);\n+        }\n+    }\n+\n+    private static final\n+            class CertificateAuthoritiesStringizer implements SSLStringizer {\n+        @Override\n+        public String toString(HandshakeContext hc, ByteBuffer buffer) {\n+            try {\n+                return (new CertificateAuthoritiesSpec(hc, buffer))\n+                        .toString();\n+            } catch (IOException ioe) {\n+                \/\/ For debug logging only, so please swallow exceptions.\n+                return ioe.getMessage();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"certificate_authorities\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+        class CHCertificateAuthoritiesProducer implements HandshakeProducer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CHCertificateAuthoritiesProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in client side only.\n+            ClientHandshakeContext chc = (ClientHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!chc.sslConfig.isAvailable(\n+                    SSLExtension.CH_CERTIFICATE_AUTHORITIES)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore unavailable \" +\n+                            \"certificate_authorities extension\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            \/\/ Produce the extension.\n+            X509Certificate[] caCerts =\n+                    chc.sslContext.getX509TrustManager().getAcceptedIssuers();\n+            if (caCerts.length == 0) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"No available certificate authorities\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            List<byte[]> encodedCAs =\n+                    CertificateAuthoritiesSpec.getEncodedAuthorities(caCerts);\n+            if (encodedCAs.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                            \"The number of CAs exceeds the maximum size\" +\n+                            \"of the certificate_authorities extension\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            CertificateAuthoritiesSpec spec =\n+                    new CertificateAuthoritiesSpec(encodedCAs);\n+\n+            int vectorLen = 0;\n+            for (byte[] encoded : spec.authorities) {\n+                vectorLen += encoded.length + 2;\n+            }\n+\n+            byte[] extData = new byte[vectorLen + 2];\n+            ByteBuffer m = ByteBuffer.wrap(extData);\n+            Record.putInt16(m, vectorLen);\n+            for (byte[] encoded : spec.authorities) {\n+                Record.putBytes16(m, encoded);\n+            }\n+\n+            \/\/ Update the context.\n+            chc.handshakeExtensions.put(\n+                    SSLExtension.CH_CERTIFICATE_AUTHORITIES, spec);\n+\n+            return extData;\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"certificate_authorities\" extension in\n+     * the ClientHello handshake message.\n+     *\/\n+    private static final\n+        class CHCertificateAuthoritiesConsumer implements ExtensionConsumer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CHCertificateAuthoritiesConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+            HandshakeMessage message, ByteBuffer buffer) throws IOException {\n+\n+            \/\/ The consuming happens in server side only.\n+            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!shc.sslConfig.isAvailable(\n+                    SSLExtension.CH_CERTIFICATE_AUTHORITIES)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore unavailable \" +\n+                            \"certificate_authorities extension\");\n+                }\n+\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            \/\/ Parse the extension.\n+            CertificateAuthoritiesSpec spec =\n+                    new CertificateAuthoritiesSpec(shc, buffer);\n+\n+            \/\/ Update the context.\n+            shc.peerSupportedAuthorities = spec.getAuthorities();\n+            shc.handshakeExtensions.put(\n+                    SSLExtension.CH_CERTIFICATE_AUTHORITIES, spec);\n+\n+            \/\/ No impact on session resumption.\n+        }\n+    }\n+\n+    \/**\n+     * Network data producer of a \"certificate_authorities\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+        class CRCertificateAuthoritiesProducer implements HandshakeProducer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CRCertificateAuthoritiesProducer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public byte[] produce(ConnectionContext context,\n+                HandshakeMessage message) throws IOException {\n+            \/\/ The producing happens in server side only.\n+            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!shc.sslConfig.isAvailable(\n+                    SSLExtension.CR_CERTIFICATE_AUTHORITIES)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore unavailable \" +\n+                            \"certificate_authorities extension\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            \/\/ Produce the extension.\n+            X509Certificate[] caCerts =\n+                    shc.sslContext.getX509TrustManager().getAcceptedIssuers();\n+            if (caCerts.length == 0) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"No available certificate authorities\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            List<byte[]> encodedCAs =\n+                    CertificateAuthoritiesSpec.getEncodedAuthorities(caCerts);\n+            if (encodedCAs.isEmpty()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\n+                        \"Too many certificate authorities to use \" +\n+                            \"the certificate_authorities extension\");\n+                }\n+\n+                return null;    \/\/ ignore the extension\n+            }\n+\n+            CertificateAuthoritiesSpec spec =\n+                    new CertificateAuthoritiesSpec(encodedCAs);\n+\n+            int vectorLen = 0;\n+            for (byte[] encoded : spec.authorities) {\n+                vectorLen += encoded.length + 2;\n+            }\n+\n+            byte[] extData = new byte[vectorLen + 2];\n+            ByteBuffer m = ByteBuffer.wrap(extData);\n+            Record.putInt16(m, vectorLen);\n+            for (byte[] encoded : spec.authorities) {\n+                Record.putBytes16(m, encoded);\n+            }\n+\n+            \/\/ Update the context.\n+            shc.handshakeExtensions.put(\n+                    SSLExtension.CR_CERTIFICATE_AUTHORITIES, spec);\n+\n+            return extData;\n+        }\n+    }\n+\n+    \/**\n+     * Network data consumer of a \"certificate_authorities\" extension in\n+     * the CertificateRequest handshake message.\n+     *\/\n+    private static final\n+        class CRCertificateAuthoritiesConsumer implements ExtensionConsumer {\n+\n+        \/\/ Prevent instantiation of this class.\n+        private CRCertificateAuthoritiesConsumer() {\n+            \/\/ blank\n+        }\n+\n+        @Override\n+        public void consume(ConnectionContext context,\n+            HandshakeMessage message, ByteBuffer buffer) throws IOException {\n+\n+            \/\/ The consuming happens in client side only.\n+            ClientHandshakeContext chc = (ClientHandshakeContext)context;\n+\n+            \/\/ Is it a supported and enabled extension?\n+            if (!chc.sslConfig.isAvailable(\n+                    SSLExtension.CR_CERTIFICATE_AUTHORITIES)) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore unavailable \" +\n+                            \"certificate_authorities extension\");\n+                }\n+\n+                return;     \/\/ ignore the extension\n+            }\n+\n+            \/\/ Parse the extension.\n+            CertificateAuthoritiesSpec spec =\n+                    new CertificateAuthoritiesSpec(chc, buffer);\n+\n+            \/\/ Update the context.\n+            chc.peerSupportedAuthorities = spec.getAuthorities();\n+            chc.handshakeExtensions.put(\n+                    SSLExtension.CR_CERTIFICATE_AUTHORITIES, spec);\n+\n+            \/\/ No impact on session resumption.\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateAuthoritiesExtension.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,2 +203,2 @@\n-            List<X500Principal> principals =\n-                    new ArrayList<>(authorities.size());\n+            X500Principal[] principals = new X500Principal[authorities.size()];\n+            int i = 0;\n@@ -206,2 +206,1 @@\n-                X500Principal principal = new X500Principal(encoded);\n-                principals.add(principal);\n+                principals[i++] = new X500Principal(encoded);\n@@ -210,1 +209,1 @@\n-            return principals.toArray(new X500Principal[0]);\n+            return principals;\n@@ -507,2 +506,2 @@\n-            List<X500Principal> principals =\n-                    new ArrayList<>(authorities.size());\n+            X500Principal[] principals = new X500Principal[authorities.size()];\n+            int i = 0;\n@@ -510,2 +509,1 @@\n-                X500Principal principal = new X500Principal(encoded);\n-                principals.add(principal);\n+                principals[i++] = new X500Principal(encoded);\n@@ -514,1 +512,1 @@\n-            return principals.toArray(new X500Principal[0]);\n+            return principals;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -410,1 +410,21 @@\n-    CERTIFICATE_AUTHORITIES (0x002F, \"certificate_authorities\"),\n+\n+    CH_CERTIFICATE_AUTHORITIES (0x002F, \"certificate_authorities\",\n+                                SSLHandshake.CLIENT_HELLO,\n+                                ProtocolVersion.PROTOCOLS_OF_13,\n+                                CertificateAuthoritiesExtension.chNetworkProducer,\n+                                CertificateAuthoritiesExtension.chOnLoadConsumer,\n+                                null,\n+                                null,\n+                                null,\n+                                CertificateAuthoritiesExtension.ssStringizer),\n+\n+    CR_CERTIFICATE_AUTHORITIES (0x002F, \"certificate_authorities\",\n+                                SSLHandshake.CERTIFICATE_REQUEST,\n+                                ProtocolVersion.PROTOCOLS_OF_13,\n+                                CertificateAuthoritiesExtension.crNetworkProducer,\n+                                CertificateAuthoritiesExtension.crOnLoadConsumer,\n+                                null,\n+                                null,\n+                                null,\n+                                CertificateAuthoritiesExtension.ssStringizer),\n+\n@@ -728,0 +748,44 @@\n+            \/\/ To switch on certificate_authorities extension in ClientHello.\n+            \/\/\n+            \/\/ Note: Please be careful to enable this extension in ClientHello.\n+            \/\/\n+            \/\/ In practice, if the server certificate cannot be validated by\n+            \/\/ the underlying programs, the user may manually check the\n+            \/\/ certificate in order to access the service.  The certificate\n+            \/\/ could be accepted manually, and the handshake continues.  For\n+            \/\/ example, the browsers provide the manual option to accept\n+            \/\/ untrusted server certificate. If this extension is enabled in\n+            \/\/ the ClientHello handshake message, and the server's certificate\n+            \/\/ does not chain back to any of the CAs in the extension, then the\n+            \/\/ server will terminate the handshake and close the connection.\n+            \/\/ There is no chance for the client to perform the manual check.\n+            \/\/ Therefore, enabling this extension in ClientHello may lead to\n+            \/\/ unexpected compatibility issues for such cases.\n+            \/\/\n+            \/\/ According to TLS 1.3 specification [RFC 8446] the maximum size\n+            \/\/ of the certificate_authorities extension is 2^16 bytes.  The\n+            \/\/ maximum TLS record size is 2^14 bytes.  If the handshake\n+            \/\/ message is bigger than maximum TLS record size, it should be\n+            \/\/ splitted into several records.  In fact, some server\n+            \/\/ implementations do not allow ClientHello messages bigger than\n+            \/\/ the maximum TLS record size and will immediately abort the\n+            \/\/ connection with a fatal alert.  Therefore, if the client trusts\n+            \/\/ too many certificate authorities, there may be unexpected\n+            \/\/ interoperability issues.\n+            \/\/\n+            \/\/ Furthermore, if the client trusts more CAs such that it exceeds\n+            \/\/ the size limit of the extension, enabling this extension in\n+            \/\/ client side does not really make sense any longer as there is\n+            \/\/ no way to indicate the server certificate selection accurately.\n+            \/\/\n+            \/\/ In general, a server does not use multiple certificates issued\n+            \/\/ from different CAs.  It is not expected to use this extension a\n+            \/\/ lot in practice.  When there is a need to use this extension\n+            \/\/ in ClientHello handshake message, please take care of the\n+            \/\/ potential compatibility and interoperability issues above.\n+            enableExtension = Utilities.getBooleanProperty(\n+                    \"jdk.tls.client.enableCAExtension\", false);\n+            if (!enableExtension) {\n+                extensions.remove(CH_CERTIFICATE_AUTHORITIES);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,2 @@\n-                        chc.peerSupportedAuthorities,\n+                        chc.peerSupportedAuthorities == null ? null :\n+                                chc.peerSupportedAuthorities.clone(),\n@@ -238,1 +239,2 @@\n-                        chc.peerSupportedAuthorities,\n+                        chc.peerSupportedAuthorities == null ? null :\n+                                chc.peerSupportedAuthorities.clone(),\n@@ -287,1 +289,3 @@\n-                        null, (SSLSocket)shc.conContext.transport);\n+                        shc.peerSupportedAuthorities == null ? null :\n+                                shc.peerSupportedAuthorities.clone(),\n+                        (SSLSocket)shc.conContext.transport);\n@@ -290,1 +294,3 @@\n-                        null, (SSLEngine)shc.conContext.transport);\n+                        shc.peerSupportedAuthorities == null ? null :\n+                                shc.peerSupportedAuthorities.clone(),\n+                        (SSLEngine)shc.conContext.transport);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,1 @@\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.*;\n@@ -49,4 +47,3 @@\n-        return createSSLContext(trustedCertStrs,\n-                endEntityCertStrs, endEntityPrivateKeys,\n-                endEntityPrivateKeyAlgs,\n-                endEntityPrivateKeyNames,\n+        return createSSLContext(\n+                createClientKeyManager(),\n+                createClientTrustManager(),\n@@ -60,2 +57,33 @@\n-        return createSSLContext(trustedCertStrs,\n-                endEntityCertStrs, endEntityPrivateKeys,\n+        return createSSLContext(\n+                createServerKeyManager(),\n+                createServerTrustManager(),\n+                getServerContextParameters());\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager for client use.\n+     *\/\n+    default KeyManager createClientKeyManager() throws Exception {\n+        return createKeyManager(\n+                endEntityCertStrs,\n+                endEntityPrivateKeys,\n+                endEntityPrivateKeyAlgs,\n+                endEntityPrivateKeyNames,\n+                getServerContextParameters());\n+    }\n+\n+    \/*\n+     * Create an instance of TrustManager for client use.\n+     *\/\n+    default TrustManager createClientTrustManager() throws Exception {\n+        return createTrustManager(\n+                trustedCertStrs,\n+                getServerContextParameters());\n+    }\n+    \/*\n+     * Create an instance of KeyManager for server use.\n+     *\/\n+    default KeyManager createServerKeyManager() throws Exception {\n+        return createKeyManager(\n+                endEntityCertStrs,\n+                endEntityPrivateKeys,\n@@ -67,0 +95,9 @@\n+    \/*\n+     * Create an instance of TrustManager for server use.\n+     *\/\n+    default TrustManager createServerTrustManager() throws Exception {\n+        return createTrustManager(\n+                trustedCertStrs,\n+                getServerContextParameters());\n+    }\n+\n@@ -424,1 +461,21 @@\n-            String[] trustedMaterials,\n+            KeyManager keyManager,\n+            TrustManager trustManager,\n+            ContextParameters params) throws Exception {\n+\n+        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+        context.init(\n+                new KeyManager[] {\n+                        keyManager\n+                    },\n+                new TrustManager[] {\n+                        trustManager\n+                    },\n+                null);\n+\n+        return  context;\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager with the specified key materials.\n+     *\/\n+    private KeyManager createKeyManager(\n@@ -431,3 +488,1 @@\n-        KeyStore ts = null;     \/\/ trust store\n-        KeyStore ks = null;     \/\/ key store\n-        char passphrase[] = \"passphrase\".toCharArray();\n+        char[] passphrase = \"passphrase\".toCharArray();\n@@ -438,22 +493,0 @@\n-        \/\/ Import the trused certs.\n-        ByteArrayInputStream is;\n-        if (trustedMaterials != null && trustedMaterials.length != 0) {\n-            ts = KeyStore.getInstance(\"JKS\");\n-            ts.load(null, null);\n-\n-            Certificate[] trustedCert =\n-                    new Certificate[trustedMaterials.length];\n-            for (int i = 0; i < trustedMaterials.length; i++) {\n-                String trustedCertStr = trustedMaterials[i];\n-\n-                is = new ByteArrayInputStream(trustedCertStr.getBytes());\n-                try {\n-                    trustedCert[i] = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n-                ts.setCertificateEntry(\"trusted-cert-\" + i, trustedCert[i]);\n-            }\n-        }\n-\n@@ -462,16 +495,9 @@\n-        \/\/ Note that certification pathes bigger than one are not supported yet.\n-        boolean hasKeyMaterials =\n-            (keyMaterialCerts != null) && (keyMaterialCerts.length != 0) &&\n-            (keyMaterialKeys != null) && (keyMaterialKeys.length != 0) &&\n-            (keyMaterialKeyAlgs != null) && (keyMaterialKeyAlgs.length != 0) &&\n-            (keyMaterialCerts.length == keyMaterialKeys.length) &&\n-            (keyMaterialCerts.length == keyMaterialKeyAlgs.length);\n-        if (hasKeyMaterials) {\n-            ks = KeyStore.getInstance(\"JKS\");\n-            ks.load(null, null);\n-\n-            for (int i = 0; i < keyMaterialCerts.length; i++) {\n-                String keyCertStr = keyMaterialCerts[i];\n-\n-                \/\/ generate the private key.\n-                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+        \/\/ Note that certification paths bigger than one are not supported yet.\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        ks.load(null, null);\n+        ByteArrayInputStream is;\n+        for (int i = 0; i < keyMaterialCerts.length; i++) {\n+            String keyCertStr = keyMaterialCerts[i];\n+\n+            \/\/ generate the private key.\n+            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n@@ -479,1 +505,1 @@\n-                KeyFactory kf =\n+            KeyFactory kf =\n@@ -481,16 +507,52 @@\n-                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n-\n-                \/\/ generate certificate chain\n-                is = new ByteArrayInputStream(keyCertStr.getBytes());\n-                Certificate keyCert = null;\n-                try {\n-                    keyCert = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n-                Certificate[] chain = new Certificate[] { keyCert };\n-\n-                \/\/ import the key entry.\n-                ks.setKeyEntry(\"cert-\" + keyMaterialKeyNames[i],\n-                        priKey, passphrase, chain);\n+            PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+\n+            \/\/ generate certificate chain\n+            is = new ByteArrayInputStream(keyCertStr.getBytes());\n+            Certificate keyCert = null;\n+            try {\n+                keyCert = cf.generateCertificate(is);\n+            } finally {\n+                is.close();\n+            }\n+\n+            Certificate[] chain = new Certificate[] { keyCert };\n+\n+            \/\/ import the key entry.\n+            ks.setKeyEntry(\"cert-\" + keyMaterialKeyNames[i],\n+                    priKey, passphrase, chain);\n+        }\n+\n+        KeyManagerFactory kmf =\n+                KeyManagerFactory.getInstance(params.kmAlgorithm);\n+        kmf.init(ks, passphrase);\n+\n+        KeyManager[] km = kmf.getKeyManagers();\n+\n+        return km[0];\n+    }\n+\n+    \/*\n+     * Create an instance of TrustManager with the specified trust materials.\n+     *\/\n+    private TrustManager createTrustManager(\n+            String[] trustedMaterials,\n+            ContextParameters params) throws Exception {\n+\n+        \/\/ Generate certificate from cert string.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        \/\/ Import the trusted certs.\n+        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n+        ts.load(null, null);\n+\n+        Certificate[] trustedCert =\n+                new Certificate[trustedMaterials.length];\n+        ByteArrayInputStream is;\n+        for (int i = 0; i < trustedMaterials.length; i++) {\n+            String trustedCertStr = trustedMaterials[i];\n+\n+            is = new ByteArrayInputStream(trustedCertStr.getBytes());\n+            try {\n+                trustedCert[i] = cf.generateCertificate(is);\n+            } finally {\n+                is.close();\n@@ -498,0 +560,2 @@\n+\n+            ts.setCertificateEntry(\"trusted-cert-\" + i, trustedCert[i]);\n@@ -505,12 +569,2 @@\n-        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n-        if (hasKeyMaterials && ks != null) {\n-            KeyManagerFactory kmf =\n-                    KeyManagerFactory.getInstance(params.kmAlgorithm);\n-            kmf.init(ks, passphrase);\n-\n-            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-        } else {\n-            context.init(null, tmf.getTrustManagers(), null);\n-        }\n-\n-        return context;\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        return tms[0];\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":135,"deletions":81,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8206925\n+ * @summary Support the \"certificate_authorities\" extension\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm CertificateAuthorities\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=false\n+ *     CertificateAuthorities\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=true\n+ *     CertificateAuthorities\n+ *\n+ * @run main\/othervm CertificateAuthorities NEED_CLIENT_AUTH\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=false\n+ *     CertificateAuthorities NEED_CLIENT_AUTH\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=true\n+ *     CertificateAuthorities NEED_CLIENT_AUTH\n+ *\n+ * @run main\/othervm CertificateAuthorities WANT_CLIENT_AUTH\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=false\n+ *     CertificateAuthorities WANT_CLIENT_AUTH\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=true\n+ *     CertificateAuthorities WANT_CLIENT_AUTH\n+ *\/\n+\n+import javax.net.ssl.SSLServerSocket;\n+\n+public final class CertificateAuthorities extends SSLSocketTemplate {\n+    final ClientAuthMode clientAuthMode;\n+\n+    \/*\n+     * Run the test case.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        CertificateAuthorities testCase;\n+        if (args.length != 0) {\n+            testCase = new CertificateAuthorities(\n+                    ClientAuthMode.valueOf(args[0]));\n+        } else {\n+            testCase = new CertificateAuthorities(\n+                    ClientAuthMode.NO_CLIENT_AUTH);\n+        }\n+\n+        testCase.run();\n+    }\n+\n+    CertificateAuthorities(ClientAuthMode mode) {\n+        this.clientAuthMode = mode;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        if (clientAuthMode == ClientAuthMode.NEED_CLIENT_AUTH) {\n+            socket.setNeedClientAuth(true);\n+        } else if (clientAuthMode == ClientAuthMode.WANT_CLIENT_AUTH) {\n+            socket.setWantClientAuth(true);\n+        }\n+    }\n+\n+    private static enum ClientAuthMode {\n+        NEED_CLIENT_AUTH,\n+        WANT_CLIENT_AUTH,\n+        NO_CLIENT_AUTH\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertificateAuthorities.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8206925\n+ * @library \/javax\/net\/ssl\/templates\n+ * @summary Support the certificate_authorities extension\n+ *\/\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import javax.security.auth.x500.X500Principal;\n+import java.security.KeyStore;\n+import java.security.cert.X509Certificate;\n+\n+public class CacertsLimit {\n+    public static void main(String[] args) throws Exception {\n+        for (String algorithm : new String[] {\"SunX509\", \"PKIX\"}) {\n+            CacertsLimit.ensureLimit(algorithm);\n+        }\n+    }\n+\n+    private static void ensureLimit(String algorithm) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);\n+        tmf.init((KeyStore)null);\n+        TrustManager[] tms = tmf.getTrustManagers();\n+\n+        if (tms == null || tms.length == 0) {\n+            throw new Exception(\"No default key store used for trust manager\");\n+        }\n+\n+        if (!(tms[0] instanceof X509TrustManager)) {\n+            throw new Exception(\n+                \"The trust manger is not an instance of X509TrustManager\");\n+        }\n+\n+        checkLimit(((X509TrustManager)tms[0]).getAcceptedIssuers());\n+    }\n+\n+    private static void checkLimit(\n+            X509Certificate[] trustedCerts) throws Exception {\n+        int sizeAccount = 0;\n+        for (X509Certificate cert : trustedCerts) {\n+            X500Principal x500Principal = cert.getSubjectX500Principal();\n+            byte[] encodedPrincipal = x500Principal.getEncoded();\n+            sizeAccount += encodedPrincipal.length;\n+            if (sizeAccount > 0xFFFF) {\n+                throw new Exception(\n+                        \"There are too many trusted CAs in cacerts. The \" +\n+                        \"certificate_authorities extension cannot be used \" +\n+                        \"for TLS connections.  Please rethink about the size\" +\n+                        \"of the cacerts, or have a release note for the \" +\n+                        \"impacted behaviors\");\n+            } else if (sizeAccount > 0x4000) {\n+                throw new Exception(\n+                        \"There are too many trusted CAs in cacerts. The \" +\n+                        \"certificate_authorities extension cannot be \" +\n+                        \"packaged in one TLS record, which would result in \" +\n+                        \"interoperability issues.  Please rethink about the \" +\n+                        \"size of the cacerts, or have a release note for \" +\n+                        \"the impacted behaviors\");\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/CacertsLimit.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8206925\n+ * @library \/javax\/net\/ssl\/templates\n+ * @summary Support the certificate_authorities extension\n+ * @run main\/othervm TooManyCAs\n+ * @run main\/othervm -Djdk.tls.client.enableCAExtension=true TooManyCAs\n+ *\/\n+import javax.net.ssl.*;\n+import javax.security.auth.x500.X500Principal;\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check if the connection can be established if the client or server trusts\n+ * more CAs such that it exceeds the size limit of the certificate_authorities\n+ * extension (2^16).\n+ *\/\n+public class TooManyCAs implements SSLContextTemplate {\n+\n+    private static final String[][][] protocols = {\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\", \"TLSv1.2\"}, {\"TLSv1.3\"}},\n+            {{\"TLSv1.3\"}, {\"TLSv1.3\", \"TLSv1.2\"}},\n+    };\n+\n+    private final String[] clientProtocols;\n+    private final String[] serverProtocols;\n+    private final boolean needClientAuth;\n+\n+    TooManyCAs(int index, boolean needClientAuth) {\n+        this.clientProtocols = protocols[index][0];\n+        this.serverProtocols = protocols[index][1];\n+        this.needClientAuth = needClientAuth;\n+    }\n+\n+    \/\/ Servers are configured before clients, increment test case after.\n+    void configureClientSocket(SSLSocket clientSocket) {\n+        System.err.print(\"Setting client protocol(s): \");\n+        Arrays.stream(clientProtocols).forEachOrdered(System.err::print);\n+        System.err.println();\n+\n+        clientSocket.setEnabledProtocols(clientProtocols);\n+    }\n+\n+    void configureServerSocket(SSLServerSocket serverSocket) {\n+        System.err.print(\"Setting server protocol(s): \");\n+        Arrays.stream(serverProtocols).forEachOrdered(System.err::print);\n+        System.err.println();\n+\n+        serverSocket.setEnabledProtocols(serverProtocols);\n+        if (needClientAuth) {\n+            serverSocket.setNeedClientAuth(true);\n+        }\n+    }\n+\n+    @Override\n+    public TrustManager createClientTrustManager() throws Exception {\n+        TrustManager trustManager =\n+                SSLContextTemplate.super.createClientTrustManager();\n+        return new BogusX509TrustManager(\n+                (X509TrustManager)trustManager);\n+    }\n+\n+    @Override\n+    public TrustManager createServerTrustManager() throws Exception {\n+        TrustManager trustManager =\n+                SSLContextTemplate.super.createServerTrustManager();\n+        return new BogusX509TrustManager(\n+                (X509TrustManager)trustManager);\n+    }\n+\n+    \/*\n+     * Run the test case.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < protocols.length; i++) {\n+            (new TooManyCAs(i, false)).run();\n+            (new TooManyCAs(i, true)).run();\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        SSLServerSocket listenSocket = null;\n+        SSLSocket serverSocket = null;\n+        ClientSocket clientSocket = null;\n+        try {\n+            SSLServerSocketFactory serversocketfactory =\n+                    createServerSSLContext().getServerSocketFactory();\n+            listenSocket =\n+                    (SSLServerSocket)serversocketfactory.createServerSocket(0);\n+            listenSocket.setNeedClientAuth(false);\n+            listenSocket.setEnableSessionCreation(true);\n+            listenSocket.setUseClientMode(false);\n+            configureServerSocket(listenSocket);\n+\n+            System.err.println(\"Starting client\");\n+            clientSocket = new ClientSocket(listenSocket.getLocalPort());\n+            clientSocket.start();\n+\n+            System.err.println(\"Accepting client requests\");\n+            serverSocket = (SSLSocket)listenSocket.accept();\n+\n+            if (!clientSocket.isDone) {\n+                System.err.println(\"Waiting 3 seconds for client \");\n+                Thread.sleep(3000);\n+            }\n+\n+            System.err.println(\"Sending data to client ...\");\n+            String serverData = \"Hi, I am server\";\n+            BufferedWriter os = new BufferedWriter(\n+                    new OutputStreamWriter(serverSocket.getOutputStream()));\n+            os.write(serverData, 0, serverData.length());\n+            os.newLine();\n+            os.flush();\n+        } finally {\n+            if (listenSocket != null) {\n+                listenSocket.close();\n+            }\n+\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+\n+        if (clientSocket != null && clientSocket.clientException != null) {\n+            throw clientSocket.clientException;\n+        }\n+    }\n+\n+    private class ClientSocket extends Thread{\n+        boolean isDone = false;\n+        int serverPort = 0;\n+        Exception clientException;\n+\n+        public ClientSocket(int serverPort) {\n+            this.serverPort = serverPort;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SSLSocket clientSocket = null;\n+            String clientData = \"Hi, I am client\";\n+            try {\n+                System.err.println(\n+                        \"Connecting to server at port \" + serverPort);\n+                SSLSocketFactory sslSocketFactory =\n+                        createClientSSLContext().getSocketFactory();\n+                clientSocket = (SSLSocket)sslSocketFactory.createSocket(\n+                        InetAddress.getLocalHost(), serverPort);\n+                configureClientSocket(clientSocket);\n+\n+                System.err.println(\"Sending data to server ...\");\n+\n+                BufferedWriter os = new BufferedWriter(\n+                        new OutputStreamWriter(clientSocket.getOutputStream()));\n+                os.write(clientData, 0, clientData.length());\n+                os.newLine();\n+                os.flush();\n+\n+                System.err.println(\"Reading data from server\");\n+                BufferedReader is = new BufferedReader(\n+                        new InputStreamReader(clientSocket.getInputStream()));\n+                String data = is.readLine();\n+                System.err.println(\"Received Data from server: \" + data);\n+            } catch (Exception e) {\n+                clientException = e;\n+                System.err.println(\"unexpected client exception: \" + e);\n+            } finally {\n+                if (clientSocket != null) {\n+                    try {\n+                        clientSocket.close();\n+                        System.err.println(\"client socket closed\");\n+                    } catch (IOException ioe) {\n+                        clientException = ioe;\n+                    }\n+                }\n+\n+                isDone = true;\n+            }\n+        }\n+    }\n+\n+    \/\/ Construct a bogus trust manager which has more CAs such that exceed\n+    \/\/ the size limit of the certificate_authorities extension (2^16).\n+    private static final class BogusX509TrustManager\n+            extends X509ExtendedTrustManager implements X509TrustManager {\n+        private final X509ExtendedTrustManager tm;\n+\n+        private BogusX509TrustManager(X509TrustManager trustManager) {\n+            this.tm = (X509ExtendedTrustManager)trustManager;\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate[] chain,\n+               String authType, Socket socket) throws CertificateException {\n+            tm.checkClientTrusted(chain, authType, socket);\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate[] chain,\n+               String authType, Socket socket) throws CertificateException {\n+            tm.checkServerTrusted(chain, authType, socket);\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate[] chain,\n+            String authType, SSLEngine sslEngine) throws CertificateException {\n+\n+            tm.checkClientTrusted(chain, authType, sslEngine);\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate[] chain,\n+            String authType, SSLEngine sslEngine) throws CertificateException {\n+\n+            tm.checkServerTrusted(chain, authType, sslEngine);\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate[] chain,\n+               String authType) throws CertificateException {\n+            tm.checkServerTrusted(chain, authType);\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate[] chain,\n+               String authType) throws CertificateException {\n+            tm.checkServerTrusted(chain, authType);\n+        }\n+\n+        @Override\n+        public X509Certificate[] getAcceptedIssuers() {\n+            X509Certificate[] trustedCerts = tm.getAcceptedIssuers();\n+            int sizeAccount = 0;\n+            for (X509Certificate cert: trustedCerts) {\n+                X500Principal x500Principal = cert.getSubjectX500Principal();\n+                byte[] encodedPrincipal = x500Principal.getEncoded();\n+                sizeAccount += encodedPrincipal.length;\n+            }\n+\n+            \/\/ 0xFFFF: the size limit of the certificate_authorities extension\n+            int duplicated = (0xFFFF + sizeAccount) \/ sizeAccount;\n+            X509Certificate[] returnedCAs =\n+                    new X509Certificate[trustedCerts.length * duplicated];\n+            for (int i = 0; i < duplicated; i++) {\n+                System.arraycopy(trustedCerts, 0,\n+                    returnedCAs,\n+                    i * trustedCerts.length + 0, trustedCerts.length);\n+            }\n+\n+            return returnedCAs;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/TooManyCAs.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"}]}