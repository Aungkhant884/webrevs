{"files":[{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2015, Oracle America, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *  * Redistributions of source code must retain the above copyright notice,\n+ *    this list of conditions and the following disclaimer.\n+ *\n+ *  * Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ *  * Neither the name of Oracle nor the names of its contributors may be used\n+ *    to endorse or promote products derived from this software without\n+ *    specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmh.samples;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(5)\n+@State(Scope.Benchmark)\n+public class JMHSample_39_MemoryAccess {\n+    public static final int N = 1_000_000;\n+\n+    \/*\n+     * This example highlights the pitfall of accidentally measuring memory access instead of processing time.\n+     *\n+     * An int array has got a different memory layout than an ArrayList of boxed ints.\n+     * This can lead to useless results because the memory access is completely different.\n+     * Arrays save all their ints in one block on the heap while ArrayLists don't.\n+     * They save only references to the boxed ints in one block.\n+     * All the references point to the boxed ints which are usually spread all over the heap.\n+     * This leads to many cache misses with a big error:\n+     *\n+     * Benchmark                               Mode  Cnt        Score      Error  Units\n+     * JMHSample_39_MemoryAccess.sumArray      avgt   25        5.117 ±    0.039  ns\/op\n+     * JMHSample_39_MemoryAccess.sumArrayList  avgt   25  1587140.451 ± 2025.538  ns\/op\n+     *\n+     * The Java Object Layout (JOL) is a tool with which the different memory layouts of arrays and ArrayLists can be\n+     * examined in more detail.\n+     *\/\n+\n+    private int[] intArray = new int[N];\n+    private List<Integer> intList = new ArrayList<>(N);\n+\n+    @Setup\n+    public void setup() {\n+        Random random = new Random(1234);\n+        for (int i = 0; i < N; i++) {\n+            intArray[i] = random.nextInt();\n+            intList.add(intArray[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public long sumArray() {\n+        long sum = 0;\n+        for (int i = 0; i < N; i++) {\n+            sum = intArray[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long sumArrayList() {\n+        long sum = 0;\n+        for (int i = 0; i < N; i++) {\n+            sum = intList.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    \/*\n+     * ============================== HOW TO RUN THIS TEST: ====================================\n+     *\n+     * You can run this test:\n+     *\n+     * a) Via the command line:\n+     *    $ mvn clean install\n+     *    $ java -jar target\/benchmarks.jar JMHSample_39\n+     *\n+     * b) Via the Java API:\n+     *    (see the JMH homepage for possible caveats when running from IDE:\n+     *      http:\/\/openjdk.java.net\/projects\/code-tools\/jmh\/)\n+     *\/\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(\".*\" + JMHSample_39_MemoryAccess.class.getSimpleName() + \".*\")\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"jmh-samples\/src\/main\/java\/org\/openjdk\/jmh\/samples\/JMHSample_39_MemoryAccess.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}