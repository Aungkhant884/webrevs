{"files":[{"patch":"@@ -48,0 +48,2 @@\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n@@ -57,1 +59,0 @@\n-    private static final String DEFAULT_EVENT = \"cpu\";\n@@ -65,1 +66,1 @@\n-    private final String event;\n+    private final String outputFilePrefix;\n@@ -67,0 +68,1 @@\n+    private File trialOutDir;\n@@ -70,2 +72,4 @@\n-    private boolean warmupStarted = false;\n-    private boolean measurementStarted = false;\n+    private boolean isVersion1x;\n+\n+    private boolean warmupStarted;\n+    private boolean measurementStarted;\n@@ -73,1 +77,1 @@\n-    private final List<File> generated = new ArrayList<>();\n+    private final LinkedHashSet<File> generated = new LinkedHashSet<>();\n@@ -81,2 +85,2 @@\n-                \"Output format(s). Supported: \" + EnumSet.allOf(OutputType.class).toString() + \".\")\n-                .withRequiredArg().ofType(OutputType.class).withValuesSeparatedBy(\",\").describedAs(\"format+\").defaultsTo(OutputType.text);\n+                \"Output format(s). Supported: \" + EnumSet.allOf(OutputType.class) + \".\")\n+                .withRequiredArg().ofType(OutputType.class).withValuesSeparatedBy(\",\").describedAs(\"format+\");\n@@ -95,2 +99,10 @@\n-                \"Event to sample: cpu, alloc, wall, lock, cache-misses, etc.\")\n-                .withRequiredArg().ofType(String.class).describedAs(\"event\").defaultsTo(DEFAULT_EVENT);\n+                \"Event to sample: cpu, alloc, lock, wall, itimer; com.foo.Bar.methodName; any event from `perf list` e.g. cache-misses\")\n+                .withRequiredArg().ofType(String.class).describedAs(\"event\").defaultsTo(\"cpu\");\n+\n+        String secondaryEventOk = \"May be captured as a secondary event under output=jfr.\";\n+        OptionSpec<String> optAlloc = parser.accepts(\"alloc\",\n+                \"Enable allocation profiling. Optional argument (e.g. =512k) reduces sampling from the default of one-sample-per-TLAB. \" + secondaryEventOk)\n+                .withOptionalArg().ofType(String.class).describedAs(\"sample bytes\");\n+        OptionSpec<String> optLock = parser.accepts(\"lock\",\n+                \"Enable lock profiling. Optional argument (e.g. =1ms) limits capture based on lock duration. \" + secondaryEventOk)\n+                .withOptionalArg().ofType(String.class).describedAs(\"duration\");\n@@ -190,2 +202,1 @@\n-            this.event = optEvent.value(set);\n-            builder.append(optEvent);\n+\n@@ -223,4 +234,2 @@\n-            this.traces = optTraces.value(set);\n-            this.flat = optFlat.value(set);\n-\n-            this.profilerConfig = profilerOptions.toString();\n+            traces = optTraces.value(set);\n+            flat = optFlat.value(set);\n@@ -239,3 +248,63 @@\n-            this.direction = optDirection.value(set);\n-            this.output = optOutput.values(set);\n-            this.verbose = optVerbose.value(set);\n+            verbose = optVerbose.value(set);\n+            try {\n+                String version = instance.execute(\"version\");\n+                if (verbose) {\n+                    System.out.println(\"[async-profiler] version=\" + version);\n+                }\n+                isVersion1x = version.startsWith(\"1.\");\n+            } catch (IOException e) {\n+                throw new ProfilerException(e);\n+            }\n+            direction = optDirection.value(set);\n+\n+            \/\/ Secondary events are those that may be collected simultaneously with a primary event in a JFR profile.\n+            \/\/ To be used as such, we require they are specifed with the lock and alloc option, rather than event=lock,\n+            \/\/ event=alloc.\n+            HashSet<String> secondaryEvents = new HashSet<>();\n+\n+            if (set.has(optAlloc)) {\n+                secondaryEvents.add(\"alloc\");\n+                builder.append(optAlloc);\n+            }\n+\n+            if (set.has(optLock)) {\n+                secondaryEvents.add(\"lock\");\n+                builder.append(optLock);\n+            }\n+\n+            if (set.has(optEvent)) {\n+                builder.append(optEvent);\n+                outputFilePrefix = set.valueOf(optEvent);\n+            } else {\n+                if (secondaryEvents.size() == 0) {\n+                    \/\/ Default to the cpu event if no events at all are selected.\n+                    builder.appendRaw(\"event=cpu\");\n+                    outputFilePrefix = \"cpu\";\n+                } else if (secondaryEvents.size() == 1) {\n+                    \/\/ No primary event, one secondary -- promote it to the primary event. This means any output\n+                    \/\/ format is allowed and the event name will be included in the output file name.\n+                    outputFilePrefix = secondaryEvents.iterator().next();\n+                    secondaryEvents.clear();\n+                } else {\n+                    outputFilePrefix = \"profile\";\n+                }\n+            }\n+\n+            List<OutputType> output = new ArrayList<>(optOutput.values(set));\n+            if (secondaryEvents.isEmpty()) {\n+                if (output.isEmpty()) {\n+                    output.add(OutputType.text);\n+                }\n+            } else {\n+                if (isVersion1x) {\n+                    throw new ProfilerException(\"Multiple event capture not supported on async-profiler 1.x\");\n+                }\n+                if (output.isEmpty()) {\n+                    output.add(OutputType.jfr);\n+                } else if (output.size() > 1 || output.get(0) != OutputType.jfr) {\n+                    throw new ProfilerException(\"When multiple events are selected, only output=\" + OutputType.jfr.name() + \" is supported, found: \" + output);\n+                }\n+            }\n+            builder.appendMulti(optOutput, output);\n+            this.output = output;\n+            profilerConfig = profilerOptions.toString();\n@@ -249,0 +318,3 @@\n+        if (trialOutDir == null) {\n+            createTrialOutDir(benchmarkParams);\n+        }\n@@ -252,1 +324,1 @@\n-                execute(\"start,\" + profilerConfig);\n+                start();\n@@ -262,2 +334,1 @@\n-                \/\/ ...and start collecting again.\n-                execute(\"start,\" + profilerConfig);\n+                start();\n@@ -269,0 +340,8 @@\n+    private void start() {\n+        String fileConfig = \"\";\n+        if (output.contains(OutputType.jfr)) {\n+            fileConfig = \",file=\" + outputFile(trialOutDir, \"%s.jfr\").getAbsolutePath();\n+        }\n+        execute(\"start,\" + profilerConfig + fileConfig);\n+    }\n+\n@@ -275,2 +354,1 @@\n-                File trialOutDir = createTrialOutDir(benchmarkParams);\n-                return Collections.singletonList(stopAndDump(trialOutDir));\n+                return Collections.singletonList(stopAndDump());\n@@ -283,5 +361,8 @@\n-    private File createTrialOutDir(BenchmarkParams benchmarkParams) {\n-        String fileName = benchmarkParams.id();\n-        File trialOutDir = new File(this.outDir, fileName);\n-        trialOutDir.mkdirs();\n-        return trialOutDir;\n+    private void createTrialOutDir(BenchmarkParams benchmarkParams) {\n+        if (trialOutDir == null) {\n+            \/\/ async-profiler expands %p to PID and %t to timestamp, make sure we don't\n+            \/\/ include % in the file name.\n+            String fileName = benchmarkParams.id().replace(\"%\", \"_\");\n+            trialOutDir = new File(outDir, fileName);\n+            trialOutDir.mkdirs();\n+        }\n@@ -290,1 +371,1 @@\n-    private TextResult stopAndDump(File trialOutDir) {\n+    private TextResult stopAndDump() {\n@@ -293,3 +374,3 @@\n-        StringWriter output = new StringWriter();\n-        PrintWriter pw = new PrintWriter(output);\n-        for (OutputType outputType : this.output) {\n+        StringWriter outputWriter = new StringWriter();\n+        PrintWriter printWriter = new PrintWriter(outputWriter);\n+        for (OutputType outputType : output) {\n@@ -298,2 +379,8 @@\n-                    String textOutput = dump(trialOutDir, \"summary-%s.txt\", \"summary,flat=\" + flat + \",traces=\" + traces);\n-                    pw.println(textOutput);\n+                    File textOutput = dump(trialOutDir, \"summary-%s.txt\", \"summary,flat=\" + flat + \",traces=\" + traces);\n+                    try {\n+                        for (String line : FileUtils.readAllLines(textOutput)) {\n+                            printWriter.println(line);\n+                        }\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n@@ -306,2 +393,1 @@\n-                    String ver = execute(\"version\");\n-                    String ext = ver.startsWith(\"1.\") ? \"svg\" : \"html\";\n+                    String ext = isVersion1x ? \"svg\" : \"html\";\n@@ -319,1 +405,1 @@\n-                    dump(trialOutDir, \"%s.jfr\", \"jfr\");\n+                    \/\/ JFR is already dumped into file by async-profiler.\n@@ -324,1 +410,1 @@\n-        pw.println(\"Async profiler results:\");\n+        printWriter.println(\"Async profiler results:\");\n@@ -326,2 +412,2 @@\n-            pw.print(\"  \");\n-            pw.println(file.getPath());\n+            printWriter.print(\"  \");\n+            printWriter.println(file.getPath());\n@@ -329,2 +415,5 @@\n-        pw.flush();\n-        pw.close();\n+        printWriter.flush();\n+        printWriter.close();\n+\n+        return new TextResult(outputWriter.toString(), \"async\");\n+    }\n@@ -332,1 +421,4 @@\n-        return new TextResult(output.toString(), \"async\");\n+    private File dump(File specificOutDir, String fileNameFormatString, String content) {\n+        File output = outputFile(specificOutDir, fileNameFormatString);\n+        execute(content + \",\" + profilerConfig + \",file=\" + output.getAbsolutePath());\n+        return output;\n@@ -335,2 +427,2 @@\n-    private String dump(File specificOutDir, String fileNameFormatString, String content) {\n-        File output = new File(specificOutDir, String.format(fileNameFormatString, event));\n+    private File outputFile(File specificOutDir, String fileNameFormatString) {\n+        File output = new File(specificOutDir, String.format(fileNameFormatString, outputFilePrefix));\n@@ -338,7 +430,1 @@\n-        String result = execute(content + \",\" + profilerConfig);\n-        try {\n-            FileUtils.writeLines(output, Collections.singletonList(result));\n-            return result;\n-        } catch (IOException e) {\n-            return \"N\/A\";\n-        }\n+        return output;\n@@ -397,1 +483,5 @@\n-            profilerOptions.append(optionName).append('=').append(optionSet.valueOf(option).toString());\n+            profilerOptions.append(optionName);\n+            T arg = optionSet.valueOf(option);\n+            if (arg != null) {\n+                profilerOptions.append('=').append(arg);\n+            }\n@@ -417,1 +507,1 @@\n-        private <T> void appendMulti(OptionSpec<T> option) {\n+        <T> void appendMulti(OptionSpec<T> option) {\n@@ -420,4 +510,9 @@\n-                String optionName = option.options().iterator().next();\n-                for (T value : optionSet.valuesOf(option)) {\n-                    profilerOptions.append(',').append(optionName).append('=').append(value.toString());\n-                }\n+                List<T> ts = optionSet.valuesOf(option);\n+                appendMulti(option, ts);\n+            }\n+        }\n+\n+        private <T> void appendMulti(OptionSpec<T> option, List<T> ts) {\n+            String optionName = option.options().iterator().next();\n+            for (T value : ts) {\n+                profilerOptions.append(',').append(optionName).append('=').append(value.toString());\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AsyncProfiler.java","additions":153,"deletions":58,"binary":false,"changes":211,"status":"modified"}]}