{"files":[{"patch":"@@ -44,5 +44,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.EnumSet;\n-import java.util.List;\n+import java.util.*;\n@@ -57,1 +53,0 @@\n-    private static final String DEFAULT_EVENT = \"cpu\";\n@@ -65,1 +60,1 @@\n-    private final String event;\n+    private final String outputFilePrefix;\n@@ -67,0 +62,1 @@\n+    private File trialOutDir;\n@@ -70,2 +66,4 @@\n-    private boolean warmupStarted = false;\n-    private boolean measurementStarted = false;\n+    private boolean isVersion1x;\n+\n+    private boolean warmupStarted;\n+    private boolean measurementStarted;\n@@ -73,1 +71,1 @@\n-    private final List<File> generated = new ArrayList<>();\n+    private final LinkedHashSet<File> generated = new LinkedHashSet<>();\n@@ -81,1 +79,1 @@\n-                \"Output format(s). Supported: \" + EnumSet.allOf(OutputType.class).toString() + \".\")\n+                \"Output format(s). Supported: \" + EnumSet.allOf(OutputType.class) + \".\")\n@@ -95,2 +93,11 @@\n-                \"Event to sample: cpu, alloc, wall, lock, cache-misses, etc.\")\n-                .withRequiredArg().ofType(String.class).describedAs(\"event\").defaultsTo(DEFAULT_EVENT);\n+                \"Event to sample: cpu, alloc, lock, wall, itimer; com.foo.Bar.methodName; any event from `perf list` e.g. cache-misses\")\n+                .withRequiredArg().ofType(String.class).describedAs(\"event\").defaultsTo(\"cpu\");\n+\n+        String secondaryEventOk = \"May be captured as a secondary event under output=jfr.\";\n+        OptionSpec<String> optAlloc = parser.accepts(\"alloc\",\n+                \"Enable allocation profiling. Optional argument (e.g. =512k) reduces sampling from the default of one-sample-per-TLAB. \" + secondaryEventOk)\n+                .withOptionalArg().ofType(String.class).describedAs(\"sample bytes\");\n+\n+        OptionSpec<String> optLock = parser.accepts(\"lock\",\n+                \"Enable lock profiling. Optional argument (e.g. =1ms) limits capture based on lock duration. \" + secondaryEventOk)\n+                .withOptionalArg().ofType(String.class).describedAs(\"duration\");\n@@ -186,2 +193,0 @@\n-        StringBuilder profilerOptions = new StringBuilder();\n-\n@@ -189,3 +194,2 @@\n-            ProfilerOptionsBuilder builder = new ProfilerOptionsBuilder(set, profilerOptions);\n-            this.event = optEvent.value(set);\n-            builder.append(optEvent);\n+            ProfilerOptionsBuilder builder = new ProfilerOptionsBuilder(set);\n+\n@@ -223,4 +227,2 @@\n-            this.traces = optTraces.value(set);\n-            this.flat = optFlat.value(set);\n-\n-            this.profilerConfig = profilerOptions.toString();\n+            traces = optTraces.value(set);\n+            flat = optFlat.value(set);\n@@ -239,3 +241,62 @@\n-            this.direction = optDirection.value(set);\n-            this.output = optOutput.values(set);\n-            this.verbose = optVerbose.value(set);\n+            verbose = optVerbose.value(set);\n+            try {\n+                String version = instance.execute(\"version\");\n+                if (verbose) {\n+                    System.out.println(\"[async-profiler] version=\" + version);\n+                }\n+                isVersion1x = version.startsWith(\"1.\");\n+            } catch (IOException e) {\n+                throw new ProfilerException(e);\n+            }\n+            direction = optDirection.value(set);\n+\n+            output = optOutput.values(set);\n+            builder.appendMulti(optOutput);\n+\n+            \/\/ Secondary events are those that may be collected simultaneously with a primary event in a JFR profile.\n+            \/\/ To be used as such, we require they are specifed with the lock and alloc option, rather than event=lock,\n+            \/\/ event=alloc.\n+            Set<String> secondaryEvents = new HashSet<>();\n+\n+            if (set.has(optAlloc)) {\n+                secondaryEvents.add(\"alloc\");\n+                builder.append(optAlloc);\n+            }\n+\n+            if (set.has(optLock)) {\n+                secondaryEvents.add(\"lock\");\n+                builder.append(optLock);\n+            }\n+\n+            if (set.has(optEvent)) {\n+                String evName = set.valueOf(optEvent);\n+                if (evName.contains(\",\")) {\n+                    throw new ProfilerException(\"Event name should not contain commas: \" + evName);\n+                }\n+                outputFilePrefix = evName;\n+                builder.append(optEvent);\n+            } else {\n+                if (secondaryEvents.isEmpty()) {\n+                    \/\/ Default to the cpu event if no events at all are selected.\n+                    builder.appendRaw(\"event=cpu\");\n+                    outputFilePrefix = \"cpu\";\n+                } else if (secondaryEvents.size() == 1) {\n+                    \/\/ No primary event, one secondary -- promote it to the primary event. This means any output\n+                    \/\/ format is allowed and the event name will be included in the output file name.\n+                    outputFilePrefix = secondaryEvents.iterator().next();\n+                    secondaryEvents.clear();\n+                } else {\n+                    outputFilePrefix = \"profile\";\n+                }\n+            }\n+\n+            if (!secondaryEvents.isEmpty()) {\n+                if (isVersion1x) {\n+                    throw new ProfilerException(\"Secondary event capture not supported on async-profiler 1.x\");\n+                }\n+                if (output.size() > 1 || output.get(0) != OutputType.jfr) {\n+                    throw new ProfilerException(\"Secondary event capture is only supported with output=\" + OutputType.jfr.name());\n+                }\n+            }\n+\n+            profilerConfig = builder.profilerOptions();\n@@ -249,0 +310,3 @@\n+        if (trialOutDir == null) {\n+            createTrialOutDir(benchmarkParams);\n+        }\n@@ -252,1 +316,1 @@\n-                execute(\"start,\" + profilerConfig);\n+                start();\n@@ -263,1 +327,1 @@\n-                execute(\"start,\" + profilerConfig);\n+                start();\n@@ -269,0 +333,8 @@\n+    private void start() {\n+        if (output.contains(OutputType.jfr)) {\n+            execute(\"start,\" + profilerConfig + \",file=\" + outputFile(\"jfr-%s.jfr\").getAbsolutePath());\n+        } else {\n+            execute(\"start,\" + profilerConfig);\n+        }\n+    }\n+\n@@ -275,2 +347,1 @@\n-                File trialOutDir = createTrialOutDir(benchmarkParams);\n-                return Collections.singletonList(stopAndDump(trialOutDir));\n+                return Collections.singletonList(stopAndDump());\n@@ -283,5 +354,8 @@\n-    private File createTrialOutDir(BenchmarkParams benchmarkParams) {\n-        String fileName = benchmarkParams.id();\n-        File trialOutDir = new File(this.outDir, fileName);\n-        trialOutDir.mkdirs();\n-        return trialOutDir;\n+    private void createTrialOutDir(BenchmarkParams benchmarkParams) {\n+        if (trialOutDir == null) {\n+            \/\/ async-profiler expands %p to PID and %t to timestamp, make sure we don't\n+            \/\/ include % in the file name.\n+            String fileName = benchmarkParams.id().replace(\"%\", \"_\");\n+            trialOutDir = new File(outDir, fileName);\n+            trialOutDir.mkdirs();\n+        }\n@@ -290,1 +364,1 @@\n-    private TextResult stopAndDump(File trialOutDir) {\n+    private TextResult stopAndDump() {\n@@ -293,3 +367,3 @@\n-        StringWriter output = new StringWriter();\n-        PrintWriter pw = new PrintWriter(output);\n-        for (OutputType outputType : this.output) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        for (OutputType outputType : output) {\n@@ -298,2 +372,9 @@\n-                    String textOutput = dump(trialOutDir, \"summary-%s.txt\", \"summary,flat=\" + flat + \",traces=\" + traces);\n-                    pw.println(textOutput);\n+                    File out = outputFile(\"summary-%s.txt\");\n+                    dump(out, \"summary,flat=\" + flat + \",traces=\" + traces);\n+                    try {\n+                        for (String line : FileUtils.readAllLines(out)) {\n+                            pw.println(line);\n+                        }\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n@@ -302,1 +383,1 @@\n-                    dump(trialOutDir, \"collapsed-%s.csv\", \"collapsed\");\n+                    dump(outputFile(\"collapsed-%s.csv\"), \"collapsed\");\n@@ -306,2 +387,1 @@\n-                    String ver = execute(\"version\");\n-                    String ext = ver.startsWith(\"1.\") ? \"svg\" : \"html\";\n+                    String ext = isVersion1x ? \"svg\" : \"html\";\n@@ -309,1 +389,1 @@\n-                        dump(trialOutDir, \"flame-%s-forward.\" + ext, \"flamegraph\");\n+                        dump(outputFile(\"flame-%s-forward.\" + ext), \"flamegraph\");\n@@ -312,1 +392,1 @@\n-                        dump(trialOutDir, \"flame-%s-reverse.\" + ext, \"flamegraph,reverse\");\n+                        dump(outputFile(\"flame-%s-reverse.\" + ext), \"flamegraph,reverse\");\n@@ -316,1 +396,1 @@\n-                    dump(trialOutDir, \"tree-%s.html\", \"tree\");\n+                    dump(outputFile(\"tree-%s.html\"), \"tree\");\n@@ -319,1 +399,1 @@\n-                    dump(trialOutDir, \"%s.jfr\", \"jfr\");\n+                    \/\/ JFR is already dumped into file by async-profiler.\n@@ -332,1 +412,1 @@\n-        return new TextResult(output.toString(), \"async\");\n+        return new TextResult(sw.toString(), \"async\");\n@@ -335,2 +415,6 @@\n-    private String dump(File specificOutDir, String fileNameFormatString, String content) {\n-        File output = new File(specificOutDir, String.format(fileNameFormatString, event));\n+    private void dump(File target, String command) {\n+        execute(command + \",\" + profilerConfig + \",file=\" + target.getAbsolutePath());\n+    }\n+\n+    private File outputFile(String fileNameFormat) {\n+        File output = new File(trialOutDir, String.format(fileNameFormat, outputFilePrefix));\n@@ -338,7 +422,1 @@\n-        String result = execute(content + \",\" + profilerConfig);\n-        try {\n-            FileUtils.writeLines(output, Collections.singletonList(result));\n-            return result;\n-        } catch (IOException e) {\n-            return \"N\/A\";\n-        }\n+        return output;\n@@ -382,1 +460,1 @@\n-        ProfilerOptionsBuilder(OptionSet optionSet, StringBuilder profilerOptions) {\n+        ProfilerOptionsBuilder(OptionSet optionSet) {\n@@ -384,1 +462,1 @@\n-            this.profilerOptions = profilerOptions;\n+            this.profilerOptions = new StringBuilder();\n@@ -397,1 +475,5 @@\n-            profilerOptions.append(optionName).append('=').append(optionSet.valueOf(option).toString());\n+            profilerOptions.append(optionName);\n+            T arg = optionSet.valueOf(option);\n+            if (arg != null) {\n+                profilerOptions.append('=').append(arg);\n+            }\n@@ -417,1 +499,1 @@\n-        private <T> void appendMulti(OptionSpec<T> option) {\n+        <T> void appendMulti(OptionSpec<T> option) {\n@@ -422,1 +504,2 @@\n-                    profilerOptions.append(',').append(optionName).append('=').append(value.toString());\n+                    separate();\n+                    profilerOptions.append(optionName).append('=').append(value.toString());\n@@ -426,0 +509,4 @@\n+\n+        public String profilerOptions() {\n+            return profilerOptions.toString();\n+        }\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AsyncProfiler.java","additions":149,"deletions":62,"binary":false,"changes":211,"status":"modified"}]}