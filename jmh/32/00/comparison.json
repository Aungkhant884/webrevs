{"files":[{"patch":"@@ -780,2 +780,1 @@\n-            Pattern pWriterThread = Pattern.compile(\"(.*)<writer thread='(.*)'>(.*)\");\n-            String line;\n+            final Pattern writerThreadPattern = Pattern.compile(\"(.*)<writer thread='(.*)'>(.*)\");\n@@ -783,0 +782,1 @@\n+            String line;\n@@ -787,1 +787,1 @@\n-                    Matcher m = pWriterThread.matcher(line);\n+                    Matcher m = writerThreadPattern.matcher(line);\n@@ -819,0 +819,23 @@\n+        \/\/ Parsing the interpreter\/runtime stub:\n+        \/\/ ----------------------------------------------------------------------\n+        \/\/ invokehandle  233 invokehandle  [0x00007f631d023100, 0x00007f631d0233c0]  704 bytes\n+        \/\/ StubRoutines::catch_exception [0x00007feb43fa7b27, 0x00007feb43fa7b46[ (31 bytes)\n+\n+        \/\/ JDK 13 adds another \"-------\" line after StubRoutines line, so we need to filter out\n+        \/\/ mismatched lines that follow it. This is why regexp is anchored at the start of the line.\n+        \/\/ Example:\n+        \/\/\n+        \/\/ StubRoutines::updateBytesCRC32 [0x0000ffff6c819700, 0x0000ffff6c819870] (368 bytes)\n+        \/\/ --------------------------------------------------------------------------------\n+        \/\/  0x0000ffff6c819700:   stp     x29, x30, [sp, #-16]!  <--- do not match this\n+        \/\/  0x0000ffff6c819704:   mov     x29, sp\n+        \/\/  0x0000ffff6c819708:   mvn     w0, w0\n+        final Pattern interpreterStubPattern = Pattern.compile(\"^(\\\\S.*)( +)\\\\[(.+), (.+)[\\\\]\\\\[](.*)\");\n+\n+        \/\/ <nmethod compile_id='481' compiler='C1' level='3' entry='0x00007f26f51fb640' size='1392'\n+        \/\/   address='0x00007f26f51fb4d0' relocation_offset='296' insts_offset='368' stub_offset='976'\n+        \/\/   scopes_data_offset='1152' scopes_pcs_offset='1208' dependencies_offset='1368' nul_chk_table_offset='1376'\n+        \/\/   method='java\/lang\/reflect\/Constructor getParameterTypes ()[Ljava\/lang\/Class;' bytes='11'\n+        \/\/   count='258' iicount='258' stamp='8.590'\/>\n+        final Pattern nmethodPattern = Pattern.compile(\"(.*?)<nmethod (.*?)\/>(.*?)\");\n+\n@@ -857,17 +880,1 @@\n-                    \/\/ Try parsing the interpreter\/runtime stub:\n-                    \/\/ ----------------------------------------------------------------------\n-                    \/\/ invokehandle  233 invokehandle  [0x00007f631d023100, 0x00007f631d0233c0]  704 bytes\n-                    \/\/ StubRoutines::catch_exception [0x00007feb43fa7b27, 0x00007feb43fa7b46[ (31 bytes)\n-\n-                    \/\/ JDK 13 adds another \"-------\" line after StubRoutines line, so we need to filter out\n-                    \/\/ mismatched lines that follow it. This is why regexp is anchored at the start of the line.\n-                    \/\/ Example:\n-                    \/\/\n-                    \/\/ StubRoutines::updateBytesCRC32 [0x0000ffff6c819700, 0x0000ffff6c819870] (368 bytes)\n-                    \/\/ --------------------------------------------------------------------------------\n-                    \/\/  0x0000ffff6c819700:   stp     x29, x30, [sp, #-16]!  <--- do not match this\n-                    \/\/  0x0000ffff6c819704:   mov     x29, sp\n-                    \/\/  0x0000ffff6c819708:   mvn     w0, w0\n-\n-                    Pattern pattern = Pattern.compile(\"^(\\\\S.*)( +)\\\\[(.+), (.+)[\\\\]\\\\[](.*)\");\n-                    Matcher matcher = pattern.matcher(line);\n+                    Matcher matcher = interpreterStubPattern.matcher(line);\n@@ -894,7 +901,1 @@\n-                    \/\/ <nmethod compile_id='481' compiler='C1' level='3' entry='0x00007f26f51fb640' size='1392'\n-                    \/\/   address='0x00007f26f51fb4d0' relocation_offset='296' insts_offset='368' stub_offset='976'\n-                    \/\/   scopes_data_offset='1152' scopes_pcs_offset='1208' dependencies_offset='1368' nul_chk_table_offset='1376'\n-                    \/\/   method='java\/lang\/reflect\/Constructor getParameterTypes ()[Ljava\/lang\/Class;' bytes='11'\n-                    \/\/   count='258' iicount='258' stamp='8.590'\/>\n-\n-                    Matcher matcher = Pattern.compile(\"(.*?)<nmethod (.*?)\/>(.*?)\").matcher(line);\n+                    Matcher matcher = nmethodPattern.matcher(line);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AbstractPerfAsmProfiler.java","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -144,0 +144,2 @@\n+        final Pattern hashLinePattern = Pattern.compile(\"(.*)#(.*)\");\n+\n@@ -160,1 +162,1 @@\n-                Matcher m = Pattern.compile(\"(.*)#(.*)\").matcher(line);\n+                Matcher m = hashLinePattern.matcher(line);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/LinuxPerfProfiler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.regex.Pattern;\n@@ -58,11 +57,0 @@\n-    private static final ConcurrentMap<String, Pattern> PATTERNS = new ConcurrentHashMap<>();\n-\n-    public static Pattern lazyCompile(String pattern) {\n-        Pattern patt = PATTERNS.get(pattern);\n-        if (patt == null) {\n-            patt = Pattern.compile(pattern);\n-            PATTERNS.put(pattern, patt);\n-        }\n-        return patt;\n-    }\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/util\/Utils.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}