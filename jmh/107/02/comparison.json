{"files":[{"patch":"@@ -21,1 +21,1 @@\n-        profile: [default, reflection, asm]\n+        profile: [default, reflection, asm, executor-virtual-tpe, executor-fjp, executor-custom]\n@@ -33,3 +33,1 @@\n-    - name: Run build with tests\n-      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n-      if: (runner.os == 'Linux') || (matrix.profile == 'default')\n+\n@@ -39,0 +37,24 @@\n+\n+    - name: Run build with tests\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (matrix.profile == 'default')\n+\n+    - name: Run build with tests (Reflection)\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (runner.os == 'Linux') && (matrix.profile == 'reflection')\n+\n+    - name: Run build with tests (ASM)\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (runner.os == 'Linux') && (matrix.profile == 'asm')\n+\n+    - name: Run build with tests (FJP Executor)\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (runner.os == 'Linux') && (matrix.profile == 'executor-fjp')\n+\n+    - name: Run build with tests (Custom Executor)\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (runner.os == 'Linux') && (matrix.profile == 'executor-custom')\n+\n+    - name: Run build with tests (Virtual Executor)\n+      run: mvn clean install -P ${{ matrix.profile }} -B --file pom.xml\n+      if: (runner.os == 'Linux') && (matrix.java == '21-ea') && (matrix.profile == 'executor-virtual-tpe')\n","filename":".github\/workflows\/pre-integration.yml","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+        <!-- Integration tests are not measuring performance, OK to run them concurrently -->\n+        <jmh.testjvmargs>-Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=${jmh.core.it.profile}<\/jmh.testjvmargs>\n@@ -69,2 +71,1 @@\n-                    <!-- Integration tests are not measuring performance, OK to run them concurrently -->\n-                    <argLine>-Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=${jmh.core.it.profile}<\/argLine>\n+                    <argLine>${jmh.testjvmargs}<\/argLine>\n@@ -125,0 +126,90 @@\n+            <\/build>\n+        <\/profile>\n+\n+        <profile>\n+            <id>executor-virtual-tpe<\/id>\n+            <properties>\n+                <jmh.core.it.profile>executor-virtual-tpe<\/jmh.core.it.profile>\n+            <\/properties>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>org.openjdk.jmh<\/groupId>\n+                    <artifactId>jmh-generator-annprocess<\/artifactId>\n+                    <version>${project.version}<\/version>\n+                    <scope>provided<\/scope>\n+                <\/dependency>\n+            <\/dependencies>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <\/plugin>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-surefire-plugin<\/artifactId>\n+                        <configuration>\n+                            <argLine>${jmh.testjvmargs} -Djmh.executor=VIRTUAL_TPE<\/argLine>\n+                        <\/configuration>\n+                    <\/plugin>\n+                <\/plugins>\n+            <\/build>\n+        <\/profile>\n+\n+        <profile>\n+            <id>executor-fjp<\/id>\n+            <properties>\n+                <jmh.core.it.profile>executor-fjp<\/jmh.core.it.profile>\n+            <\/properties>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>org.openjdk.jmh<\/groupId>\n+                    <artifactId>jmh-generator-annprocess<\/artifactId>\n+                    <version>${project.version}<\/version>\n+                    <scope>provided<\/scope>\n+                <\/dependency>\n+            <\/dependencies>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <\/plugin>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-surefire-plugin<\/artifactId>\n+                        <configuration>\n+                            <argLine>${jmh.testjvmargs} -Djmh.executor=FJP<\/argLine>\n+                        <\/configuration>\n+                    <\/plugin>\n+                <\/plugins>\n+            <\/build>\n+        <\/profile>\n+\n+        <profile>\n+            <id>executor-custom<\/id>\n+            <properties>\n+                <jmh.core.it.profile>executor-custom<\/jmh.core.it.profile>\n+            <\/properties>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>org.openjdk.jmh<\/groupId>\n+                    <artifactId>jmh-generator-annprocess<\/artifactId>\n+                    <version>${project.version}<\/version>\n+                    <scope>provided<\/scope>\n+                <\/dependency>\n+            <\/dependencies>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-compiler-plugin<\/artifactId>\n+                    <\/plugin>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins<\/groupId>\n+                        <artifactId>maven-surefire-plugin<\/artifactId>\n+                        <configuration>\n+                            <argLine>${jmh.testjvmargs} -Djmh.executor=CUSTOM -Djmh.executor.class=org.openjdk.jmh.it.CustomExecutorService<\/argLine>\n+                        <\/configuration>\n+                    <\/plugin>\n+                <\/plugins>\n","filename":"jmh-core-it\/pom.xml","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.it;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+\/**\n+ * Synthetic executor service to test the corner case where executor always starts\n+ * the task in the separate thread. Tests JMH invariants to the limit.\n+ *\/\n+public class CustomExecutorService implements ExecutorService {\n+    public CustomExecutorService(int maxThreads, String prefix) {\n+        \/\/ Do nothing\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        \/\/ Do nothing\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long timeout, TimeUnit unit) {\n+        return true;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+        FutureTask<T> ft = new FutureTask<>(task);\n+        new Thread(ft).start();\n+        return ft;\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+        new Thread(command).start();\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n","filename":"jmh-core-it\/src\/main\/java\/org\/openjdk\/jmh\/it\/CustomExecutorService.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -31,1 +33,15 @@\n-    private static final int REPS = Integer.getInteger(\"jmh.it.reps\", 1);\n+    private static final int REPS;\n+    private static final String PROFILE;\n+\n+    static {\n+        REPS = AccessController.doPrivileged(new PrivilegedAction<Integer>() {\n+            public Integer run() {\n+                return Integer.getInteger(\"jmh.it.reps\", 1);\n+            }\n+        });\n+        PROFILE = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+            public String run() {\n+                return System.getProperty(\"jmh.core.it.profile\");\n+            }\n+        });\n+    }\n@@ -50,0 +66,8 @@\n+    public static boolean expectStableThreads() {\n+        return isDefaultProfile();\n+    }\n+\n+    public static boolean isDefaultProfile() {\n+        return PROFILE.equals(\"default\");\n+    }\n+\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/Fixtures.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,11 +29,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Group;\n-import org.openjdk.jmh.annotations.GroupThreads;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.*;\n@@ -64,1 +54,5 @@\n-        Assert.assertEquals(2, test2threads.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(2, test2threads.size());\n+        } else {\n+            Assert.assertTrue(test2threads.size() >= 2);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/asymm\/Zero1ThreadCountTest.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,1 +63,5 @@\n-        Assert.assertEquals(1, test1threads.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(1, test1threads.size());\n+        } else {\n+            Assert.assertTrue(test1threads.size() >= 1);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/asymm\/Zero2ThreadCountTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,6 @@\n+        if (!Fixtures.expectStableThreads()) {\n+            \/\/ This test assumes threads survive until the end of run to get their\n+            \/\/ allocation data.\n+            return;\n+        }\n+\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/GCProfilerAllocRateTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,5 @@\n-        Assert.assertEquals(\"All the threads have visited this state\", 2, visitors.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(2, visitors.size());\n+        } else {\n+            Assert.assertTrue(visitors.size() >= 2);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/BenchmarkBenchSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-            Assert.assertEquals(\"All the threads have visited this state\", 2, visitors.size());\n+            if (Fixtures.expectStableThreads()) {\n+                Assert.assertEquals(2, visitors.size());\n+            } else {\n+                Assert.assertTrue(visitors.size() >= 2);\n+            }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/BenchmarkStateSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-        Assert.assertEquals(\"All the threads have visited this state\", 4, visitors.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(4, visitors.size());\n+        } else {\n+            Assert.assertTrue(visitors.size() >= 4);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/GroupBenchSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-        Assert.assertEquals(\"All the threads have visited this state\", 2, visitors.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(2, visitors.size());\n+        } else {\n+            Assert.assertTrue(visitors.size() >= 2);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/GroupDefaultBenchSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,5 @@\n-            Assert.assertEquals(\"All the threads have visited this state\", 2, visitors.size());\n+            if (Fixtures.expectStableThreads()) {\n+                Assert.assertEquals(2, visitors.size());\n+            } else {\n+                Assert.assertTrue(visitors.size() >= 2);\n+            }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/GroupDefaultStateSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,5 @@\n-            Assert.assertEquals(\"All the threads have visited this state\", 4, visitors.size());\n+            if (Fixtures.expectStableThreads()) {\n+                Assert.assertEquals(4, visitors.size());\n+            } else {\n+                Assert.assertTrue(visitors.size() >= 4);\n+            }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/GroupStateSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,5 @@\n-        Assert.assertEquals(\"Single thread have visited this state\", 1, visitors.size());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(1, visitors.size());\n+        } else {\n+            Assert.assertTrue(visitors.size() >= 1);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/ThreadBenchSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-            Assert.assertEquals(\"Single thread has visited this state\", 1, visitors.size());\n+            if (Fixtures.expectStableThreads()) {\n+                Assert.assertEquals(1, visitors.size());\n+            } else {\n+                Assert.assertTrue(visitors.size() >= 1);\n+            }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/sharing\/ThreadStateSharingTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-        Assert.assertEquals(\"amount of threads should be Runtime.getRuntime().availableProcessors()\", threads.size(), Runtime.getRuntime().availableProcessors());\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(threads.size(), Runtime.getRuntime().availableProcessors());\n+        } else {\n+            Assert.assertTrue(threads.size() >= Runtime.getRuntime().availableProcessors());\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/MaxThreadCountTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-        Assert.assertEquals(\"amount of threads should be 1\", threads.size(), 1);\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(1, threads.size());\n+        } else {\n+            Assert.assertTrue(threads.size() >= 1);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/OneThreadCountTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    private Thread tearDownInvocationThread;\n+    private Thread teardownInvocationThread;\n@@ -65,4 +65,1 @@\n-        if (setupRunThread == null) {\n-            setupRunThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"setupRun\", setupRunThread, Thread.currentThread());\n+        setupRunThread = Thread.currentThread();\n@@ -73,4 +70,1 @@\n-        if (setupIterationThread == null) {\n-            setupIterationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"setupIteration\", setupIterationThread, Thread.currentThread());\n+        setupIterationThread = Thread.currentThread();\n@@ -81,4 +75,1 @@\n-        if (setupInvocationThread == null) {\n-            setupInvocationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"setupInvocation\", setupInvocationThread, Thread.currentThread());\n+        setupInvocationThread = Thread.currentThread();\n@@ -89,2 +80,6 @@\n-        if (teardownRunThread == null) {\n-            teardownRunThread = Thread.currentThread();\n+        teardownRunThread = Thread.currentThread();\n+\n+        \/\/ Threads can change iteration to iteration\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(\"test == setupRun\",      testInvocationThread, setupRunThread);\n+            Assert.assertEquals(\"test == teardownRun\",   testInvocationThread, teardownRunThread);\n@@ -92,1 +87,0 @@\n-        Assert.assertEquals(\"teardownRun\", teardownRunThread, Thread.currentThread());\n@@ -97,4 +91,7 @@\n-        if (teardownIterationThread == null) {\n-            teardownIterationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"teardownIteration\", teardownIterationThread, Thread.currentThread());\n+        teardownIterationThread = Thread.currentThread();\n+\n+        \/\/ Within iteration, expect the same thread\n+        Assert.assertEquals(\"test == setupIteration\",     testInvocationThread, setupIterationThread);\n+        Assert.assertEquals(\"test == teardownIteration\",  testInvocationThread, teardownIterationThread);\n+        Assert.assertEquals(\"test == setupInvocation\",    testInvocationThread, setupInvocationThread);\n+        Assert.assertEquals(\"test == teardownInvocation\", testInvocationThread, teardownInvocationThread);\n@@ -105,14 +102,1 @@\n-        if (tearDownInvocationThread == null) {\n-            tearDownInvocationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"tearDownInvocation\", tearDownInvocationThread, Thread.currentThread());\n-    }\n-\n-    @TearDown(Level.Trial)\n-    public void teardownZZZ() { \/\/ should perform last\n-        Assert.assertEquals(\"test != setupRun\",           testInvocationThread, setupRunThread);\n-        Assert.assertEquals(\"test != setupIteration\",     testInvocationThread, setupIterationThread);\n-        Assert.assertEquals(\"test != setupInvocation\",    testInvocationThread, setupInvocationThread);\n-        Assert.assertEquals(\"test != teardownRun\",        testInvocationThread, teardownRunThread);\n-        Assert.assertEquals(\"test != teardownIteration\",  testInvocationThread, teardownIterationThread);\n-        Assert.assertEquals(\"test != teardownInvocation\", testInvocationThread, tearDownInvocationThread);\n+        teardownInvocationThread = Thread.currentThread();\n@@ -128,4 +112,1 @@\n-        if (testInvocationThread == null) {\n-            testInvocationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"test\", testInvocationThread, Thread.currentThread());\n+        testInvocationThread = Thread.currentThread();\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/ThreadBenchSameThreadTest.java","additions":19,"deletions":38,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -67,4 +67,1 @@\n-            if (setupRunThread == null) {\n-                setupRunThread = Thread.currentThread();\n-            }\n-            Assert.assertEquals(\"setupRun\", setupRunThread, Thread.currentThread());\n+            setupRunThread = Thread.currentThread();\n@@ -75,4 +72,1 @@\n-            if (setupIterationThread == null) {\n-                setupIterationThread = Thread.currentThread();\n-            }\n-            Assert.assertEquals(\"setupIteration\", setupIterationThread, Thread.currentThread());\n+            setupIterationThread = Thread.currentThread();\n@@ -83,4 +77,1 @@\n-            if (setupInvocationThread == null) {\n-                setupInvocationThread = Thread.currentThread();\n-            }\n-            Assert.assertEquals(\"setupInvocation\", setupInvocationThread, Thread.currentThread());\n+            setupInvocationThread = Thread.currentThread();\n@@ -91,2 +82,6 @@\n-            if (teardownRunThread == null) {\n-                teardownRunThread = Thread.currentThread();\n+            teardownRunThread = Thread.currentThread();\n+\n+            \/\/ Threads can change iteration to iteration\n+            if (Fixtures.expectStableThreads()) {\n+                Assert.assertEquals(\"test == setupRun\",      testInvocationThread, setupRunThread);\n+                Assert.assertEquals(\"test == teardownRun\",   testInvocationThread, teardownRunThread);\n@@ -94,1 +89,0 @@\n-            Assert.assertEquals(\"teardownRun\", teardownRunThread, Thread.currentThread());\n@@ -99,4 +93,7 @@\n-            if (teardownIterationThread == null) {\n-                teardownIterationThread = Thread.currentThread();\n-            }\n-            Assert.assertEquals(\"teardownIteration\", teardownIterationThread, Thread.currentThread());\n+            teardownIterationThread = Thread.currentThread();\n+\n+            \/\/ Within iteration, expect the same thread\n+            Assert.assertEquals(\"test == setupIteration\",     testInvocationThread, setupIterationThread);\n+            Assert.assertEquals(\"test == teardownIteration\",  testInvocationThread, teardownIterationThread);\n+            Assert.assertEquals(\"test == setupInvocation\",    testInvocationThread, setupInvocationThread);\n+            Assert.assertEquals(\"test == teardownInvocation\", testInvocationThread, teardownInvocationThread);\n@@ -107,14 +104,1 @@\n-            if (teardownInvocationThread == null) {\n-                teardownInvocationThread = Thread.currentThread();\n-            }\n-            Assert.assertEquals(\"tearDownInvocation\", teardownInvocationThread, Thread.currentThread());\n-        }\n-\n-        @TearDown(Level.Trial)\n-        public void teardownZZZ() { \/\/ should perform last\n-            Assert.assertEquals(\"test != setupRun\", testInvocationThread, setupRunThread);\n-            Assert.assertEquals(\"test != setupIteration\", testInvocationThread, setupIterationThread);\n-            Assert.assertEquals(\"test != setupInvocation\", testInvocationThread, setupInvocationThread);\n-            Assert.assertEquals(\"test != teardownRun\", testInvocationThread, teardownRunThread);\n-            Assert.assertEquals(\"test != teardownIteration\", testInvocationThread, teardownIterationThread);\n-            Assert.assertEquals(\"test != teardownInvocation\", testInvocationThread, teardownInvocationThread);\n+            teardownInvocationThread = Thread.currentThread();\n@@ -131,4 +115,1 @@\n-        if (state.testInvocationThread == null) {\n-            state.testInvocationThread = Thread.currentThread();\n-        }\n-        Assert.assertEquals(\"test\", state.testInvocationThread, Thread.currentThread());\n+        state.testInvocationThread = Thread.currentThread();\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/ThreadStateSameThreadTest.java","additions":18,"deletions":37,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -59,1 +59,5 @@\n-        Assert.assertEquals(\"amount of threads should be 2\", threads.size(), 2);\n+        if (Fixtures.expectStableThreads()) {\n+            Assert.assertEquals(2, threads.size());\n+        } else {\n+            Assert.assertTrue(threads.size() >= 2);\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/TwoThreadCountTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -254,1 +256,1 @@\n-    private static final boolean COMPILER_BLACKHOLE = Boolean.getBoolean(\"compilerBlackholesEnabled\");\n+    private static final boolean COMPILER_BLACKHOLE;\n@@ -257,0 +259,6 @@\n+        COMPILER_BLACKHOLE = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+            public Boolean run() {\n+                return Boolean.getBoolean(\"compilerBlackholesEnabled\");\n+            }\n+        });\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/Blackhole.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+            boolean isFirstIteration = (i == 1);\n@@ -261,1 +262,1 @@\n-            IterationResult ir = handler.runIteration(benchParams, wp, isLastIteration);\n+            IterationResult ir = handler.runIteration(benchParams, wp, isFirstIteration, isLastIteration);\n@@ -280,0 +281,1 @@\n+            boolean isFirstIteration = (benchParams.getWarmup().getCount() == 0) && (i == 1);\n@@ -281,1 +283,1 @@\n-            IterationResult ir = handler.runIteration(benchParams, mp, isLastIteration);\n+            IterationResult ir = handler.runIteration(benchParams, mp, isFirstIteration, isLastIteration);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/BaseRunner.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-            addSuppressed(err);\n+            if (err != null) {\n+                addSuppressed(err);\n+            }\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/BenchmarkException.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    private final CyclicBarrier workerDataBarrier;\n@@ -57,0 +58,2 @@\n+    private final BlockingQueue<WorkerData> unusedWorkerData;\n+\n@@ -77,2 +80,4 @@\n-        tps = new ArrayBlockingQueue<>(executionParams.getThreads());\n-        tps.addAll(distributeThreads(executionParams.getThreads(), executionParams.getThreadGroups()));\n+        int threads = executionParams.getThreads();\n+\n+        tps = new ArrayBlockingQueue<>(threads);\n+        tps.addAll(distributeThreads(threads, executionParams.getThreadGroups()));\n@@ -80,0 +85,1 @@\n+        workerDataBarrier = new CyclicBarrier(threads, this::captureUnusedWorkerData);\n@@ -81,0 +87,1 @@\n+        unusedWorkerData = new ArrayBlockingQueue<>(threads);\n@@ -84,1 +91,1 @@\n-            executor = EXECUTOR_TYPE.createExecutor(executionParams.getThreads(), executionParams.getBenchmark());\n+            executor = EXECUTOR_TYPE.createExecutor(threads, executionParams.getBenchmark());\n@@ -195,0 +202,5 @@\n+\n+            @Override\n+            boolean hasStableThreads() {\n+                return true;\n+            }\n@@ -223,2 +235,0 @@\n-                \/\/ (Aleksey):\n-                \/\/ requires some of the reflection magic to untie from JDK 8 compile-time dependencies\n@@ -253,0 +263,2 @@\n+\n+        boolean hasStableThreads() { return false; }\n@@ -308,1 +320,2 @@\n-     * @param last    Should this iteration considered to be the last\n+     * @param isFirstIteration   Should this iteration considered to be the first\n+     * @param isLastIteration    Should this iteration considered to be the last\n@@ -311,1 +324,2 @@\n-    public IterationResult runIteration(BenchmarkParams benchmarkParams, IterationParams params, boolean last) {\n+    public IterationResult runIteration(BenchmarkParams benchmarkParams, IterationParams params,\n+                                        boolean isFirstIteration, boolean isLastIteration) {\n@@ -322,1 +336,2 @@\n-                preSetupBarrier, preTearDownBarrier, last,\n+                preSetupBarrier, preTearDownBarrier,\n+                isFirstIteration, isLastIteration,\n@@ -413,2 +428,8 @@\n-                \/\/ unwrap: ExecutionException -> Throwable-wrapper -> InvocationTargetException\n-                Throwable cause = ex.getCause().getCause().getCause();\n+                \/\/ Unwrap at most three exceptions through benchmark-thrown exception:\n+                \/\/  ExecutionException -> Throwable-wrapper -> InvocationTargetException\n+                \/\/\n+                \/\/ Infrastructural exceptions come with shorter causal chains.\n+                Throwable cause = ex;\n+                for (int c = 0; (c < 3) && (cause.getCause() != null); c++) {\n+                    cause = cause.getCause();\n+                }\n@@ -440,4 +461,12 @@\n-    private WorkerData newWorkerData(Thread worker) {\n-        WorkerData wd = workerData.get(worker);\n-        if (wd != null) {\n-            return wd;\n+\n+    private WorkerData getWorkerData(Thread worker) {\n+        \/\/ See if there is a good worker data for us already, use it.\n+        WorkerData wd = workerData.remove(worker);\n+\n+        \/\/ Wait for all threads to roll to this synchronization point.\n+        \/\/ If there is any thread without assignment, the barrier action\n+        \/\/ would dump the unused worker data for claiming.\n+        try {\n+            workerDataBarrier.await();\n+        } catch (InterruptedException | BrokenBarrierException e) {\n+            throw new IllegalStateException(\"Worker data barrier error \", e);\n@@ -446,0 +475,26 @@\n+        if (wd == null) {\n+            \/\/ Odd mode, no worker task recorded for the thread. Pull the worker data\n+            \/\/ from the unused queue. This can only happen with executors with unstable threads.\n+            if (EXECUTOR_TYPE.hasStableThreads()) {\n+                throw new IllegalStateException(\"Worker data assignment failed for executor with stable threads\");\n+            }\n+\n+            wd = unusedWorkerData.poll();\n+            if (wd == null) {\n+                throw new IllegalStateException(\"Cannot get another thread working data\");\n+            }\n+        }\n+\n+        WorkerData exist = workerData.put(worker, wd);\n+        if (exist != null) {\n+            throw new IllegalStateException(\"Duplicate thread data\");\n+        }\n+        return wd;\n+    }\n+\n+    private void captureUnusedWorkerData() {\n+        unusedWorkerData.addAll(workerData.values());\n+        workerData.clear();\n+    }\n+\n+    private WorkerData newWorkerData(Thread worker) {\n@@ -453,1 +508,1 @@\n-            wd = new WorkerData(o, t);\n+            WorkerData wd = new WorkerData(o, t);\n@@ -483,1 +538,1 @@\n-                WorkerData wd = newWorkerData(runner);\n+                WorkerData wd = control.firstIteration ? newWorkerData(runner) : getWorkerData(runner);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/BenchmarkHandler.java","additions":71,"deletions":16,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        Utils.check(InfraControl.class, \"firstIteration\");\n@@ -59,1 +60,2 @@\n-                        CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                        CountDownLatch preSetup, CountDownLatch preTearDown,\n+                        boolean firstIteration, boolean lastIteration,\n@@ -61,1 +63,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n@@ -164,0 +166,1 @@\n+    public final boolean firstIteration;\n@@ -178,1 +181,2 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown,\n+                          boolean firstIteration, boolean lastIteration,\n@@ -196,0 +200,1 @@\n+        this.firstIteration = firstIteration;\n@@ -277,1 +282,2 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown,\n+                          boolean firstIteration, boolean lastIteration,\n@@ -279,1 +285,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n@@ -287,1 +293,2 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown,\n+                          boolean firstIteration, boolean lastIteration,\n@@ -289,1 +296,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/InfraControl.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"}]}