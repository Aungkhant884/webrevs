{"files":[{"patch":"@@ -58,0 +58,10 @@\n+        <dependency>\n+            <groupId>net.java.dev.jna<\/groupId>\n+            <artifactId>jna<\/artifactId>\n+            <version>5.8.0<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>net.java.dev.jna<\/groupId>\n+            <artifactId>jna-platform<\/artifactId>\n+            <version>5.8.0<\/version>\n+        <\/dependency>\n","filename":"jmh-core-benchmarks\/pom.xml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.benchmarks;\n+\n+import org.openjdk.jmh.validation.SpinWaitSupport;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.validation.AffinitySupport;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class RoundTripLatencyBench {\n+\n+    static final boolean SPINWAIT = Boolean.getBoolean(\"spinWait\");\n+\n+    @Param(\"-1\")\n+    int p;\n+\n+    @Param(\"-1\")\n+    int c;\n+\n+    Thread t;\n+\n+    volatile boolean ping;\n+\n+    @Setup\n+    public void setup() {\n+        if (c != -1) AffinitySupport.bind(c);\n+        t = new Thread(() -> {\n+            if (p != -1) AffinitySupport.bind(p);\n+            Thread t = Thread.currentThread();\n+            while (!t.isInterrupted()) {\n+                while (!ping) {\n+                    if (SPINWAIT) SpinWaitSupport.onSpinWait();\n+                }\n+                ping = false;\n+            }\n+        });\n+        t.start();\n+    }\n+\n+    @TearDown\n+    public void tearDown() throws InterruptedException {\n+        t.interrupt();\n+        ping = true;\n+        t.join();\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        ping = true;\n+        while (ping) {\n+            if (SPINWAIT) SpinWaitSupport.onSpinWait();\n+        }\n+    }\n+}\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/benchmarks\/RoundTripLatencyBench.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.validation;\n+\n+import com.sun.jna.*;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AffinitySupport {\n+\n+    public static boolean isLinux() {\n+        return System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n+    }\n+\n+    public static boolean isSupported() {\n+        return isLinux();\n+    }\n+\n+    public static void bind(int cpu) {\n+        if (isLinux()) {\n+            Linux.bind(cpu);\n+        } else {\n+            throw new IllegalStateException(\"Not implemented\");\n+        }\n+    }\n+\n+    public static void tryBind() {\n+        if (isLinux()) {\n+            Linux.tryBind();\n+        } else {\n+            throw new IllegalStateException(\"Not implemented\");\n+        }\n+    }\n+\n+    public static List<String> prepare() {\n+        if (isLinux()) {\n+            return Linux.prepare();\n+        } else {\n+            throw new IllegalStateException(\"Not implemented\");\n+        }\n+    }\n+\n+    public static void tryInit() {\n+        if (isLinux()) {\n+            Linux.tryInit();\n+        }\n+    }\n+\n+    static class Linux {\n+        private static volatile CLibrary INSTANCE;\n+        private static boolean BIND_TRIED;\n+\n+        \/*\n+           Unpacks the libraries, and replies additional options for forked VMs.\n+         *\/\n+        public static List<String> prepare() {\n+            System.setProperty(\"jnidispatch.preserve\", \"true\");\n+            Native.load(\"c\", CLibrary.class);\n+\n+            File file = new File(System.getProperty(\"jnidispatch.path\"));\n+            String bootLibraryPath = file.getParent();\n+\n+            \/\/ Need to rename the file to the proper name, otherwise JNA would not discover it\n+            File proper = new File(bootLibraryPath + '\/' + System.mapLibraryName(\"jnidispatch\"));\n+            file.renameTo(proper);\n+\n+            return Arrays.asList(\n+                    \"-Djna.nounpack=true\",    \/\/ Should not unpack itself, but use predefined path\n+                    \"-Djna.nosys=true\",       \/\/ Should load from explicit path\n+                    \"-Djna.noclasspath=true\", \/\/ Should load from explicit path\n+                    \"-Djna.boot.library.path=\" + bootLibraryPath,\n+                    \"-Djna.platform.library.path=\" + System.getProperty(\"jna.platform.library.path\")\n+            );\n+        }\n+\n+        public static void tryInit() {\n+            if (INSTANCE == null) {\n+                synchronized (Linux.class) {\n+                    if (INSTANCE == null) {\n+                        INSTANCE = Native.load(\"c\", CLibrary.class);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public static void bind(int cpu) {\n+            tryInit();\n+\n+            final cpu_set_t cpuset = new cpu_set_t();\n+            cpuset.set(cpu);\n+\n+            set(cpuset);\n+        }\n+\n+        public static void tryBind() {\n+            if (BIND_TRIED) return;\n+\n+            synchronized (Linux.class) {\n+                if (BIND_TRIED) return;\n+\n+                tryInit();\n+\n+                cpu_set_t cs = new cpu_set_t();\n+                get(cs);\n+                set(cs);\n+\n+                BIND_TRIED = true;\n+            }\n+        }\n+\n+        private static void get(cpu_set_t cpuset) {\n+            if (INSTANCE.sched_getaffinity(0, cpu_set_t.SIZE_OF, cpuset) != 0) {\n+                throw new IllegalStateException(\"Failed: \" + Native.getLastError());\n+            }\n+        }\n+\n+        private static void set(cpu_set_t cpuset) {\n+            if (INSTANCE.sched_setaffinity(0, cpu_set_t.SIZE_OF, cpuset) != 0) {\n+                throw new IllegalStateException(\"Failed: \" + Native.getLastError());\n+            }\n+        }\n+\n+        interface CLibrary extends Library {\n+            int sched_getaffinity(int pid, int size, cpu_set_t cpuset);\n+            int sched_setaffinity(int pid, int size, cpu_set_t cpuset);\n+        }\n+\n+        public static class cpu_set_t extends Structure {\n+            private static final int CPUSET_SIZE = 1024;\n+            private static final int NCPU_BITS = 8 * NativeLong.SIZE;\n+            private static final int SIZE_OF = (CPUSET_SIZE \/ NCPU_BITS) * NativeLong.SIZE;\n+\n+            public NativeLong[] __bits = new NativeLong[CPUSET_SIZE \/ NCPU_BITS];\n+\n+            public cpu_set_t() {\n+                for (int i = 0; i < __bits.length; i++) {\n+                    __bits[i] = new NativeLong(0);\n+                }\n+            }\n+\n+            public void set(int cpu) {\n+                int cIdx = cpu \/ NCPU_BITS;\n+                long mask = 1L << (cpu % NCPU_BITS);\n+                NativeLong bit = __bits[cIdx];\n+                bit.setValue(bit.longValue() | mask);\n+            }\n+\n+            @Override\n+            protected List<String> getFieldOrder() {\n+                return Collections.singletonList(\"__bits\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/AffinitySupport.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import org.openjdk.jmh.util.JDKVersion;\n@@ -232,0 +231,4 @@\n+                case roundtrip_latency:\n+                    new RoundTripLatencyTest(false).runWith(pw, opts);\n+                    new RoundTripLatencyTest(true).runWith(pw, opts);\n+                    break;\n@@ -249,0 +252,1 @@\n+        roundtrip_latency,\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/Main.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.validation;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class SpinWaitSupport {\n+\n+    \/\/ All critical code should fold with C2 compilation.\n+    \/\/ This provides us with JDK 8 compatibility.\n+\n+    static final MethodHandle MH;\n+\n+    static {\n+        MethodHandle mh;\n+        try {\n+            mh = MethodHandles.lookup().findStatic(Thread.class, \"onSpinWait\", MethodType.methodType(void.class));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            mh = null;\n+        }\n+        MH = mh;\n+    }\n+\n+    public static boolean available() {\n+        return MH != null;\n+    }\n+\n+    public static void onSpinWait() {\n+        if (MH != null) {\n+            try {\n+                MH.invokeExact();\n+            } catch (Throwable e) {\n+                throw new IllegalStateException(\"Should not happen\", e);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/SpinWaitSupport.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.validation.tests;\n+\n+import org.openjdk.jmh.benchmarks.RoundTripLatencyBench;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+import org.openjdk.jmh.validation.AffinitySupport;\n+import org.openjdk.jmh.validation.SpinWaitSupport;\n+import org.openjdk.jmh.validation.ValidationTest;\n+\n+import java.io.PrintWriter;\n+\n+public class RoundTripLatencyTest extends ValidationTest {\n+\n+    private boolean spinWaitHints;\n+\n+    public RoundTripLatencyTest(boolean spinWaitHints) {\n+        this.spinWaitHints = spinWaitHints;\n+    }\n+\n+    @Override\n+    public void runWith(PrintWriter pw, Options parent) throws RunnerException {\n+        pw.println(\"--------- ROUND-TRIP LATENCY TEST\" + (spinWaitHints ? \" (SPIN-WAIT HINTS)\" : \"\"));\n+        pw.println();\n+\n+        org.openjdk.jmh.util.Utils.reflow(pw,\n+                \"This test tries to run latency benchmark across the entire system. \" +\n+                    \"For many-core systems, it is normal to see large latency variations between CPU threads pairs. \" +\n+                    \"This gives the idea how much the tests with communicating threads would differ when scheduled differently.\",\n+                80, 2);\n+        pw.println();\n+\n+        pw.println(\"  Scores are nanoseconds per round-trip.\");\n+        pw.println(\"  Axes are CPU numbers as presented by OS.\");\n+        pw.println();\n+\n+        if (!AffinitySupport.isSupported()) {\n+            pw.println(\"  Affinity control is not available on this machine, skipping the test.\");\n+            pw.println();\n+            return;\n+        }\n+\n+        if (spinWaitHints && !SpinWaitSupport.available()) {\n+            pw.println(\"  Spin-wait hints are not supported, skipping the test.\");\n+            pw.println();\n+            return;\n+        }\n+\n+        Options basic = new OptionsBuilder()\n+                .parent(parent)\n+                .include(RoundTripLatencyBench.class.getCanonicalName())\n+                .threads(1)\n+                .jvmArgsAppend(\"-Xms512m\", \"-Xmx512m\", \"-XX:+AlwaysPreTouch\", \"-XX:+UseParallelGC\", \"-XX:+UseNUMA\", \"-DspinWait=\" + spinWaitHints)\n+                .verbosity(VerboseMode.SILENT)\n+                .build();\n+\n+        int blockSize = 16;\n+\n+        int threads = Utils.figureOutHotCPUs();\n+        int blocks = (threads \/ blockSize);\n+        if (blocks*blockSize < threads) blocks++;\n+\n+        for (int pBlock = 0; pBlock < blocks; pBlock++) {\n+            int fromP = pBlock*blockSize;\n+            int toP = Math.min(threads, (pBlock+1)*blockSize);\n+\n+            for (int cBlock = 0; cBlock < blocks; cBlock++) {\n+                int fromC = cBlock*blockSize;\n+                int toC = Math.min(threads, (cBlock+1)*blockSize);\n+                pw.printf(\"%5s  \", \"\");\n+                for (int c = fromC; c < toC; c++) {\n+                    pw.printf(\"%5d:\", c);\n+                }\n+                pw.println();\n+\n+                for (int p = fromP; p < toP; p++) {\n+                    pw.printf(\"%5d: \", p);\n+\n+                    for (int c = fromC; c < toC; c++) {\n+                        if (p == c) {\n+                            pw.print(\" ----,\");\n+                            continue;\n+                        }\n+                        Options opts = new OptionsBuilder()\n+                                .parent(basic)\n+                                .param(\"p\", String.valueOf(p))\n+                                .param(\"c\", String.valueOf(c))\n+                                .build();\n+                        Result r = new Runner(opts).runSingle().getPrimaryResult();\n+                        pw.print(String.format(\"%5.0f,\", r.getScore()));\n+                        pw.flush();\n+                    }\n+                    pw.println();\n+                }\n+                pw.println();\n+            }\n+        }\n+\n+    }\n+\n+}\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/tests\/RoundTripLatencyTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}