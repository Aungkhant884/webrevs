{"files":[{"patch":"@@ -63,1 +63,0 @@\n-    private final long highPassFilter;\n@@ -65,1 +64,1 @@\n-    private final boolean isIncrementable;\n+    private final boolean doFilter;\n@@ -90,3 +89,3 @@\n-        OptionSpec<Long> optHighPassFilter = parser.accepts(\"highPassFilter\",\n-                        \"Ignore event increments larger that this.\")\n-                .withRequiredArg().ofType(Long.class).describedAs(\"#\").defaultsTo(100_000_000_000L);\n+        OptionSpec<Boolean> optFilter = parser.accepts(\"filter\",\n+                        \"Filter problematic samples from infrastructure and perf itself.\")\n+                .withRequiredArg().ofType(Boolean.class).describedAs(\"bool\").defaultsTo(true);\n@@ -106,1 +105,1 @@\n-            highPassFilter = set.valueOf(optHighPassFilter);\n+            doFilter = set.valueOf(optFilter);\n@@ -119,1 +118,3 @@\n-        isIncrementable = incremental.isEmpty();\n+        if (!incremental.isEmpty()) {\n+            throw new ProfilerException(\"\\\\\\\"perf\\\\\\\" is too old, needs incremental mode (-I).\");\n+        }\n@@ -129,1 +130,1 @@\n-        if (supportedEvents.isEmpty()) {\n+        if (candidateEvents.isEmpty()) {\n@@ -157,3 +158,1 @@\n-        if (isIncrementable) {\n-            cmd.addAll(Arrays.asList(\"-I\", String.valueOf(incrementInterval)));\n-        }\n+        cmd.addAll(Arrays.asList(\"-I\", String.valueOf(incrementInterval)));\n@@ -193,0 +192,9 @@\n+    private static class EventRecord {\n+        final double time;\n+        final double value;\n+        public EventRecord(double time, double value) {\n+            this.time = time;\n+            this.value = value;\n+        }\n+    }\n+\n@@ -194,1 +202,1 @@\n-        Multiset<String> events = new HashMultiset<>();\n+        Multimap<String, EventRecord> eventRecords = new HashMultimap<>();\n@@ -214,1 +222,0 @@\n-            double softTo = (skipMs + lenMs) \/ 1000D;\n@@ -221,1 +228,0 @@\n-            nextline:\n@@ -225,21 +231,20 @@\n-                if (isIncrementable) {\n-                    String[] split = line.split(\",\");\n-\n-                    String time;\n-                    String count;\n-                    String event;\n-\n-                    if (split.length == 3) {\n-                        \/\/ perf 3.13: time,count,event\n-                        time  = split[0].trim();\n-                        count = split[1].trim();\n-                        event = split[2].trim();\n-                    } else if (split.length >= 4) {\n-                        \/\/ perf >3.13: time,count,<other>,event,<others>\n-                        time  = split[0].trim();\n-                        count = split[1].trim();\n-                        event = split[3].trim();\n-                    } else {\n-                        \/\/ Malformed line, ignore\n-                        continue nextline;\n-                    }\n+                String[] split = line.split(\",\");\n+\n+                String time;\n+                String count;\n+                String event;\n+\n+                if (split.length == 3) {\n+                    \/\/ perf 3.13: time,count,event\n+                    time = split[0].trim();\n+                    count = split[1].trim();\n+                    event = split[2].trim();\n+                } else if (split.length >= 4) {\n+                    \/\/ perf >3.13: time,count,<other>,event,<others>\n+                    time = split[0].trim();\n+                    count = split[1].trim();\n+                    event = split[3].trim();\n+                } else {\n+                    \/\/ Malformed line, ignore\n+                    continue;\n+                }\n@@ -247,42 +252,6 @@\n-                    double multiplier = 1D;\n-                    try {\n-                        double timeSec = nf.parse(time).doubleValue();\n-                        if (timeSec < readFrom) {\n-                            \/\/ warmup, ignore\n-                            continue nextline;\n-                        }\n-                        if (timeSec > readTo) {\n-                            \/\/ post-run, ignore\n-                            continue nextline;\n-                        }\n-\n-                        \/\/ Handle partial events:\n-                        double intervalSec = incrementInterval \/ 1000D;\n-                        if (timeSec - intervalSec < readFrom) {\n-                            \/\/ Event _starts_ before the measurement window\n-                            \/\/     .............[============|============\n-                            \/\/               readFrom     timeSec\n-                            \/\/           [<----------------->|  \/\/ event\n-                            \/\/             incrementInterval\n-                            \/\/\n-                            \/\/ Only count the tail after readFrom:\n-\n-                            multiplier = (timeSec - readFrom) \/ intervalSec;\n-                        }\n-                        if (timeSec > softTo) {\n-                            \/\/ Event is past the measurement window\n-                            \/\/    =============].............|............\n-                            \/\/               softTo       timeSec\n-                            \/\/           [<----------------->|  \/\/ event\n-                            \/\/             incrementInterval\n-                            \/\/\n-                            \/\/ Only count the head before softTo:\n-                            multiplier = 1 - (timeSec - softTo) \/ intervalSec;\n-                        }\n-\n-                        \/\/ Defensive, keep multiplier in bounds:\n-                        multiplier = Math.max(1D, Math.min(0D, multiplier));\n-                    } catch (ParseException e) {\n-                        \/\/ don't care then, continue\n-                        continue nextline;\n-                    }\n+                double timeSec = 0D;\n+                try {\n+                    timeSec = nf.parse(time).doubleValue();\n+                } catch (ParseException e) {\n+                    continue;\n+                }\n@@ -290,10 +259,4 @@\n-                    try {\n-                        long lValue = nf.parse(count).longValue();\n-                        if (lValue > highPassFilter) {\n-                            \/\/ anomalous value, pretend we did not see it\n-                            continue nextline;\n-                        }\n-                        events.add(event, (long) (lValue * multiplier));\n-                    } catch (ParseException e) {\n-                        \/\/ do nothing, continue\n-                        continue nextline;\n+                if (timeSec < readFrom || timeSec > readTo) {\n+                    \/\/ Outside measurement window, ignore\n+                    continue;\n+                }\n@@ -301,3 +264,6 @@\n-                    }\n-                } else {\n-                    int idx = line.lastIndexOf(\",\");\n+                long lValue = 0L;\n+                try {\n+                    lValue = nf.parse(count).longValue();\n+                } catch (ParseException e) {\n+                    continue;\n+                }\n@@ -305,2 +271,2 @@\n-                    \/\/ Malformed line, ignore\n-                    if (idx == -1) continue nextline;\n+                eventRecords.put(event, new EventRecord(timeSec, lValue));\n+            }\n@@ -308,2 +274,17 @@\n-                    String count = line.substring(0, idx).trim();\n-                    String event = line.substring(idx + 1).trim();\n+            Map<String, Double> finalThroughputs = new HashMap<>();\n+            for (String key : eventRecords.keys()) {\n+                List<EventRecord> countedEvents = new ArrayList<>(eventRecords.get(key));\n+\n+                \/\/ If needed and possible, filter out a few head and tail iterations.\n+                \/\/ Head iteration potentially contains the infrastructure startup.\n+                \/\/ That iteration would only be handled for getting time, not the counter itself.\n+                \/\/ Trailing iterations come with both infrastructure rampdown, and the final\n+                \/\/ profiler output on shutdown. Sometimes these manifest as two separate iterations.\n+                final int filteredCount = countedEvents.size() - 2;\n+                if (doFilter && filteredCount > 0) {\n+                    countedEvents = countedEvents.subList(0, filteredCount);\n+                }\n+\n+                double s = 0;\n+                double minTime = Double.MAX_VALUE;\n+                double maxTime = Double.MIN_VALUE;\n@@ -311,6 +292,6 @@\n-                    try {\n-                        long lValue = nf.parse(count).longValue();\n-                        events.add(event, lValue);\n-                    } catch (ParseException e) {\n-                        \/\/ do nothing, continue\n-                        continue nextline;\n+                for (int i = 0; i < countedEvents.size(); i++) {\n+                    EventRecord v = countedEvents.get(i);\n+                    if (i != 0) {\n+                        \/\/ Do not count the first event in the series, since time interval\n+                        \/\/ does not actually include it.\n+                        s += v.value;\n@@ -318,0 +299,2 @@\n+                    minTime = Math.min(minTime, v.time);\n+                    maxTime = Math.max(maxTime, v.time);\n@@ -319,0 +302,3 @@\n+                double thr = s \/ (maxTime - minTime);\n+                finalThroughputs.put(key, thr);\n+            }\n@@ -320,0 +306,3 @@\n+            BenchmarkResultMetaData md = br.getMetadata();\n+            if (md == null) {\n+                return emptyResults();\n@@ -322,5 +311,8 @@\n-            if (!isIncrementable) {\n-                System.out.println();\n-                System.out.println();\n-                System.out.println(\"WARNING: Your system uses old \\\"perf\\\", which cannot print data incrementally (-I).\\n\" +\n-                        \"Therefore, perf performance data includes benchmark warmup.\");\n+            long timeMs = md.getStopTime() - md.getMeasurementTime();\n+            if (timeMs == 0) {\n+                return emptyResults();\n+\n+            }\n+            double opsThroughput = 1000D * md.getMeasurementOps() \/ timeMs;\n+            if (opsThroughput == 0) {\n+                return emptyResults();\n@@ -329,1 +321,4 @@\n-            long totalOpts;\n+            Collection<Result> results = new ArrayList<>();\n+            for (String key : finalThroughputs.keySet()) {\n+                results.add(new PerfResult(key, \"#\/op\", finalThroughputs.get(key) \/ opsThroughput));\n+            }\n@@ -331,11 +326,4 @@\n-            BenchmarkResultMetaData md = br.getMetadata();\n-            if (md != null) {\n-                if (isIncrementable) {\n-                    totalOpts = md.getMeasurementOps();\n-                } else {\n-                    totalOpts = md.getWarmupOps() + md.getMeasurementOps();\n-                }\n-                Collection<Result> results = new ArrayList<>();\n-                for (String key : events.keys()) {\n-                    results.add(new PerfResult(key, \"#\/op\", events.count(key) * 1.0 \/ totalOpts));\n-                }\n+            \/\/ Also figure out IPC\/CPI, if enough counters available:\n+            {\n+                Double c1 = finalThroughputs.get(\"cycles\");\n+                Double c2 = finalThroughputs.get(\"cycles:u\");\n@@ -343,4 +331,2 @@\n-                \/\/ Also figure out IPC\/CPI, if enough counters available:\n-                {\n-                    long c1 = events.count(\"cycles\");\n-                    long c2 = events.count(\"cycles:u\");\n+                Double i1 = finalThroughputs.get(\"instructions\");\n+                Double i2 = finalThroughputs.get(\"instructions:u\");\n@@ -348,2 +334,2 @@\n-                    long i1 = events.count(\"instructions\");\n-                    long i2 = events.count(\"instructions:u\");\n+                Double cycles = (c1 != null) ? c1 : c2;\n+                Double instructions = (i1 != null) ? i1 : i2;\n@@ -351,6 +337,4 @@\n-                    long cycles = (c1 != 0) ? c1 : c2;\n-                    long instructions = (i1 != 0) ? i1 : i2;\n-                    if (cycles != 0 && instructions != 0) {\n-                        results.add(new PerfResult(\"CPI\", \"clks\/insn\", 1.0 * cycles \/ instructions));\n-                        results.add(new PerfResult(\"IPC\", \"insns\/clk\", 1.0 * instructions \/ cycles));\n-                    }\n+                if (cycles != null && instructions != null &&\n+                       cycles != 0 && instructions != 0) {\n+                    results.add(new PerfResult(\"CPI\", \"clks\/insn\", cycles \/ instructions));\n+                    results.add(new PerfResult(\"IPC\", \"insns\/clk\", instructions \/ cycles));\n@@ -358,4 +342,0 @@\n-\n-                return results;\n-            } else {\n-                return Collections.singleton(new PerfResult(\"N\/A\", \"\", Double.NaN));\n@@ -364,0 +344,1 @@\n+            return results;\n@@ -369,0 +350,4 @@\n+    private static Set<PerfResult> emptyResults() {\n+        return Collections.singleton(new PerfResult(\"N\/A\", \"\", Double.NaN));\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/LinuxPerfNormProfiler.java","additions":118,"deletions":133,"binary":false,"changes":251,"status":"modified"}]}