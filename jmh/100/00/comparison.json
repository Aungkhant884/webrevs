{"files":[{"patch":"@@ -911,4 +911,1 @@\n-                String trim = line.trim();\n-\n-                if (trim.isEmpty()) continue;\n-                String[] elements = trim.split(\" \");\n+                List<Long> addrs = parseAddresses(line, true);\n@@ -919,20 +916,11 @@\n-                if (elements.length > 0 && maybeAddress(elements[0])) {\n-                    \/\/ Seems to be line with address.\n-                    try {\n-                        long addr = parseAddress(elements[0]);\n-                        int idx = lines.size();\n-                        addressMap.put(addr, idx);\n-\n-                        asmLine = new ASMLine(addr, line);\n-\n-                        if (elements.length > 1 && (drawInterJumps || drawIntraJumps)) {\n-                            for (int c = 1; c < elements.length; c++) {\n-                                if (maybeAddress(elements[c])) {\n-                                    try {\n-                                        long target = parseAddress(elements[c]);\n-                                        intervals.add(new Interval(addr, target));\n-                                    } catch (NumberFormatException e) {\n-                                        \/\/ Nope, not the address.\n-                                    }\n-                                }\n-                            }\n+                if (addrs.size() > 0) {\n+                    long startAddr = addrs.get(0);\n+                    int idx = lines.size();\n+                    addressMap.put(startAddr, idx);\n+\n+                    asmLine = new ASMLine(startAddr, line);\n+\n+                    if (addrs.size() > 1 && (drawInterJumps || drawIntraJumps)) {\n+                        for (int c = 1; c < addrs.size(); c++) {\n+                            long targetAddr = addrs.get(c);\n+                            intervals.add(new Interval(startAddr, targetAddr));\n@@ -940,2 +928,0 @@\n-                    } catch (NumberFormatException e) {\n-                        \/\/ Nope, not the address line.\n@@ -950,2 +936,0 @@\n-                        String startS = matcher.group(3);\n-                        String endS = matcher.group(4);\n@@ -953,3 +937,4 @@\n-                        if (maybeAddress(startS) && maybeAddress(endS)) {\n-                            long startAddr = parseAddress(startS);\n-                            long endAddr = parseAddress(endS);\n+                        List<Long> stubAddrs = parseAddresses(line, false);\n+                        if (stubAddrs.size() == 2) {\n+                            long startAddr = stubAddrs.get(0);\n+                            long endAddr = stubAddrs.get(1);\n@@ -986,1 +971,2 @@\n-                        long addr = parseAddress(map.get(\"entry\"));\n+                        List<Long> entryAddrs = parseAddresses(map.get(\"entry\"), true);\n+                        long addr = entryAddrs.get(0);\n@@ -1017,3 +1003,1 @@\n-    private boolean maybeAddress(String str) {\n-        return str.startsWith(\"0x\") || str.endsWith(\"h\");\n-    }\n+    private static final List<Long> EMPTY_LIST_LONGS = Collections.unmodifiableList(new ArrayList<>());\n@@ -1021,7 +1005,6 @@\n-    private long parseAddress(String address) {\n-        if (address.startsWith(\"0x\")) { \/\/ AT&T\n-            return Long.parseLong(address.replace(\"0x\", \"\").replace(\":\", \"\"), 16);\n-        } else if (address.endsWith(\"h\")) { \/\/ Intel\n-            return Long.parseLong(address.replace(\"h\", \"\"), 16);\n-        } else {\n-            throw new NumberFormatException(\"Address format not recognized: \" + address);\n+    private static final Pattern ADDR_LINE_SPLIT = Pattern.compile(\"\\\\W+\");\n+\n+    static List<Long> parseAddresses(String line, boolean shouldStartWithAddr) {\n+        line = line.trim();\n+        if (line.isEmpty()) {\n+            return EMPTY_LIST_LONGS;\n@@ -1029,1 +1012,0 @@\n-    }\n@@ -1031,0 +1013,29 @@\n+        List<Long> addrs = new ArrayList<>();\n+\n+        String[] elements = ADDR_LINE_SPLIT.split(line);\n+        for (int i = 0; i < elements.length; i++) {\n+            String el = elements[i];\n+\n+            String str = null;\n+            if (el.startsWith(\"0x\")) {\n+                \/\/ AT&T address format\n+                str = el.replace(\"0x\", \"\").replace(\":\", \"\");\n+            } else if (el.endsWith(\"h\")) {\n+                \/\/ Intel address format\n+                str = el.replace(\"h\", \"\");\n+            } else if (shouldStartWithAddr && (i == 0)) {\n+                \/\/ First element is not address, the line is wrong\n+                return EMPTY_LIST_LONGS;\n+            }\n+\n+            if (str != null) {\n+                try {\n+                    addrs.add(Long.parseLong(str, 16));\n+                } catch (NumberFormatException nfe) {\n+                    \/\/ It looked like an address, but was not.\n+                }\n+            }\n+        }\n+\n+        return Collections.unmodifiableList(addrs);\n+    }\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AbstractPerfAsmProfiler.java","additions":54,"deletions":43,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.profile;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class PerfAsmAddressTest {\n+\n+    static final HashMap<String, List<Long>> TESTS = new HashMap<>();\n+\n+    static long addr(String s) {\n+        return Long.parseLong(s, 16);\n+    }\n+\n+    static {\n+        TESTS.put(\"0x00007f815c65724e:   test   %eax,(%r8)\",\n+                Arrays.asList(addr(\"7f815c65724e\")));\n+\n+        TESTS.put(\"0x00007f815c657239:   je     0x00007f815c657290\",\n+                Arrays.asList(addr(\"7f815c657239\"), addr(\"7f815c657290\")));\n+\n+        TESTS.put(\"0x00007f815c657256:   movabs $0x7f8171798570,%r10\",\n+                Arrays.asList(addr(\"7f815c657256\"), addr(\"7f8171798570\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d2c:   b   0x0000ffff685c7cf0\",\n+                Arrays.asList(addr(\"ffff685c7d2c\"), addr(\"ffff685c7cf0\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d1c:   b.ne        0x0000ffff685c7cb4  \/\/ b.any\",\n+                Arrays.asList(addr(\"ffff685c7d1c\"), addr(\"ffff685c7cb4\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d1c:   b.ne        0x0000ffff685c7cb4\/\/ b.any\",\n+                Arrays.asList(addr(\"ffff685c7d1c\"), addr(\"ffff685c7cb4\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d1c:   b.ne        0x0000ffff685c7cb4;comment\",\n+                Arrays.asList(addr(\"ffff685c7d1c\"), addr(\"ffff685c7cb4\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d1c:b.ne        0x0000ffff685c7cb4\",\n+                Arrays.asList(addr(\"ffff685c7d1c\"), addr(\"ffff685c7cb4\")));\n+\n+        TESTS.put(\"0x0000ffff685c7d1c: b.ne\\t0x0000ffff685c7cb4\",\n+                Arrays.asList(addr(\"ffff685c7d1c\"), addr(\"ffff685c7cb4\")));\n+    }\n+\n+    @Test\n+    public void testNoPrefix() {\n+        for (String line : TESTS.keySet()) {\n+            List<Long> actual = AbstractPerfAsmProfiler.parseAddresses(line, true);\n+            List<Long> expected = TESTS.get(line);\n+            Assert.assertEquals(line, expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrefix() {\n+        for (String line : TESTS.keySet()) {\n+            String testLine = \"something \" + line;\n+            Assert.assertEquals(new ArrayList<>(), AbstractPerfAsmProfiler.parseAddresses(testLine, true));\n+\n+            List<Long> actual = AbstractPerfAsmProfiler.parseAddresses(testLine, false);\n+            List<Long> expected = TESTS.get(line);\n+            Assert.assertEquals(line, expected, actual);\n+        }\n+    }\n+\n+}\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/profile\/PerfAsmAddressTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}