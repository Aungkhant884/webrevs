{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,0 +48,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -49,0 +53,1 @@\n+import java.util.List;\n@@ -50,0 +55,7 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n@@ -51,0 +63,3 @@\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -54,0 +69,1 @@\n+ * Also tests if all workers are platform or virtual threads.\n@@ -58,0 +74,8 @@\n+    public enum ExecutorType {\n+        CACHED_TPE, FIXED_TPE, VIRTUAL_TPE, FJP, CUSTOM\n+\n+    }\n+\n+    @Param(\"FIXED_TPE\")\n+    ExecutorType benchmarkExecutorType;\n+\n@@ -99,6 +123,35 @@\n-        Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n-        Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n-        Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n-        Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n-        Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n-        Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        if (benchmarkExecutorType == ExecutorType.FIXED_TPE ||\n+                benchmarkExecutorType == ExecutorType.VIRTUAL_TPE) { \/\/ only fixed and virtual guarantee same thread rule\n+            Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n+            Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n+            Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n+            Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n+            Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n+            Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        }\n+        if (benchmarkExecutorType == ExecutorType.VIRTUAL_TPE) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+        } else {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+        }\n+        if (benchmarkExecutorType == ExecutorType.FJP) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+        }\n@@ -119,1 +172,64 @@\n-    public void invokeAPI() throws RunnerException {\n+    public void invokeAPI_default() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fixed() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FIXED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"FIXED_TPE\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_cached() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=CACHED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"CACHED_TPE\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fjp() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FJP\")\n+                    .param(\"benchmarkExecutorType\", \"FJP\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fjp_common() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FJP_COMMON\")\n+                    .param(\"benchmarkExecutorType\", \"FJP\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_custom() throws RunnerException {\n@@ -123,0 +239,3 @@\n+                    .jvmArgsAppend(\"-Djmh.executor=CUSTOM\")\n+                    .jvmArgsAppend(\"-Djmh.executor.class=\" + CustomExecutor.class.getName())\n+                    .param(\"benchmarkExecutorType\", \"CUSTOM\")\n@@ -129,0 +248,134 @@\n+    @Test\n+    public void invokeAPI_virtual() throws RunnerException {\n+        if(VirtualAPI.hasVirtualThreads()) {\n+            for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+                Options opt = new OptionsBuilder()\n+                        .include(Fixtures.getTestMask(this.getClass()))\n+                        .jvmArgsAppend(\"-Djmh.executor=VIRTUAL_TPE\")\n+                        .param(\"benchmarkExecutorType\", \"VIRTUAL_TPE\")\n+                        .shouldFailOnError(true)\n+                        .build();\n+                new Runner(opt).run();\n+            }\n+        }\n+    }\n+\n+    public static class VirtualAPI {\n+        \/\/ provide access to new Threads API via reflection\n+\n+        private static final Method IS_VIRTUAL = getIsVirtual();\n+\n+        private static Method getIsVirtual() {\n+            try {\n+                Method m = Class.forName(\"java.lang.Thread\").getMethod(\"isVirtual\");\n+                m.invoke(Thread.currentThread());\n+                \/\/ isVirtual check is not enough, have to check running virtual thread\n+                Method start = Class.forName(\"java.lang.Thread\").getMethod(\"startVirtualThread\", Runnable.class);\n+                start.invoke(null, (Runnable) (() -> {}));\n+                return m;\n+            } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException |\n+                     IllegalAccessException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static boolean hasVirtualThreads() {\n+            return IS_VIRTUAL != null;\n+        }\n+\n+        public static boolean isVirtual(Thread t) {\n+            if (!hasVirtualThreads()) {\n+                return false;\n+            }\n+            try {\n+                return (boolean) IS_VIRTUAL.invoke(t);\n+            } catch (IllegalAccessException | InvocationTargetException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    static class CustomExecutor implements ExecutorService {\n+        private final ExecutorService e;\n+\n+        public CustomExecutor(int maxThreads, String prefix) {\n+            e = Executors.newFixedThreadPool(maxThreads, new CustomThreadFactory(prefix));\n+        }\n+\n+        public void execute(Runnable command) {\n+            e.execute(command);\n+        }\n+\n+        public void shutdown() {\n+            e.shutdown();\n+        }\n+\n+        public List<Runnable> shutdownNow() {\n+            return e.shutdownNow();\n+        }\n+\n+        public boolean isShutdown() {\n+            return e.isShutdown();\n+        }\n+\n+        public boolean isTerminated() {\n+            return e.isTerminated();\n+        }\n+\n+        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.awaitTermination(timeout, unit);\n+        }\n+\n+        public Future<?> submit(Runnable task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Callable<T> task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Runnable task, T result) {\n+            return e.submit(task, result);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n+            return e.invokeAll(tasks);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.invokeAll(tasks, timeout, unit);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n+            return e.invokeAny(tasks);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+            return e.invokeAny(tasks, timeout, unit);\n+        }\n+    }\n+\n+    static class CustomThreadFactory implements ThreadFactory {\n+\n+        private final AtomicInteger counter;\n+        private final String prefix;\n+\n+        public CustomThreadFactory(String prefix) {\n+            this.counter = new AtomicInteger();\n+            this.prefix = prefix;\n+        }\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            CustomThread t = new CustomThread(r, prefix + \"-jmh-worker-\" + counter.incrementAndGet());\n+            t.setDaemon(true);\n+            return t;\n+        }\n+    }\n+\n+    static class CustomThread extends Thread {\n+        public CustomThread(Runnable r, String name) {\n+            super(r, name);\n+        }\n+    }\n+\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/BenchmarkBenchSameThreadTest.java","additions":260,"deletions":7,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+        boolean isFirstIteration = true;\n@@ -261,1 +262,1 @@\n-            IterationResult ir = handler.runIteration(benchParams, wp, isLastIteration);\n+            IterationResult ir = handler.runIteration(benchParams, wp, isFirstIteration, isLastIteration);\n@@ -263,0 +264,1 @@\n+            isFirstIteration = false;\n@@ -281,1 +283,1 @@\n-            IterationResult ir = handler.runIteration(benchParams, mp, isLastIteration);\n+            IterationResult ir = handler.runIteration(benchParams, mp, isFirstIteration, isLastIteration);\n@@ -283,0 +285,1 @@\n+            isFirstIteration = false;\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/BaseRunner.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+    private final BlockingQueue<WorkerData> orphanedWokerData;\n+\n+    private final CyclicBarrier wdBarrier;\n@@ -77,2 +80,6 @@\n-        tps = new ArrayBlockingQueue<>(executionParams.getThreads());\n-        tps.addAll(distributeThreads(executionParams.getThreads(), executionParams.getThreadGroups()));\n+        int threads = executionParams.getThreads();\n+        wdBarrier = new CyclicBarrier(threads, this::adoptWorkerData);\n+\n+        orphanedWokerData = new ArrayBlockingQueue<>(threads);\n+        tps = new ArrayBlockingQueue<>(threads);\n+        tps.addAll(distributeThreads(threads, executionParams.getThreadGroups()));\n@@ -84,1 +91,1 @@\n-            executor = EXECUTOR_TYPE.createExecutor(executionParams.getThreads(), executionParams.getBenchmark());\n+            executor = EXECUTOR_TYPE.createExecutor(threads, executionParams.getBenchmark());\n@@ -311,1 +318,1 @@\n-    public IterationResult runIteration(BenchmarkParams benchmarkParams, IterationParams params, boolean last) {\n+    public IterationResult runIteration(BenchmarkParams benchmarkParams, IterationParams params, boolean first, boolean last) {\n@@ -322,1 +329,1 @@\n-                preSetupBarrier, preTearDownBarrier, last,\n+                preSetupBarrier, preTearDownBarrier, first, last,\n@@ -440,5 +447,4 @@\n-    private WorkerData newWorkerData(Thread worker) {\n-        WorkerData wd = workerData.get(worker);\n-        if (wd != null) {\n-            return wd;\n-        }\n+    private void adoptWorkerData() {\n+        orphanedWokerData.addAll(workerData.values());\n+        workerData.clear();\n+    }\n@@ -446,0 +452,1 @@\n+    private WorkerData newWorkerData(Thread worker) {\n@@ -453,1 +460,1 @@\n-            wd = new WorkerData(o, t);\n+            WorkerData wd = new WorkerData(o, t);\n@@ -465,0 +472,20 @@\n+    private WorkerData findWorkerData(Thread worker) {\n+        WorkerData wd = workerData.remove(worker);\n+        try {\n+            wdBarrier.await();\n+        } catch (InterruptedException | BrokenBarrierException e) {\n+            throw new RuntimeException(\"Worker data barrier error \", e);\n+        }\n+        if (wd == null) {\n+            wd = orphanedWokerData.poll();\n+            if (wd == null) {\n+                throw new IllegalStateException(\"Cannot get another thread working data\");\n+            }\n+        }\n+        WorkerData exist = workerData.put(worker, wd);\n+        if (exist != null) {\n+            throw new IllegalStateException(\"Duplicate thread data\");\n+        }\n+        return wd;\n+    }\n+\n@@ -483,1 +510,1 @@\n-                WorkerData wd = newWorkerData(runner);\n+                WorkerData wd = control.isFirstIteration() ? newWorkerData(runner) : findWorkerData(runner);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/BenchmarkHandler.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                        CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                        CountDownLatch preSetup, CountDownLatch preTearDown, boolean firstIteration, boolean lastIteration,\n@@ -61,1 +61,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n@@ -113,0 +113,4 @@\n+    public boolean isFirstIteration() {\n+        return firstIteration;\n+    }\n+\n@@ -164,0 +168,1 @@\n+    public final boolean firstIteration;\n@@ -178,1 +183,1 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean firstIteration, boolean lastIteration,\n@@ -196,0 +201,1 @@\n+        this.firstIteration = firstIteration;\n@@ -277,1 +283,1 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean firstIteration, boolean lastIteration,\n@@ -279,1 +285,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n@@ -287,1 +293,1 @@\n-                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean lastIteration,\n+                          CountDownLatch preSetup, CountDownLatch preTearDown, boolean firstIteration, boolean lastIteration,\n@@ -289,1 +295,1 @@\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, lastIteration, notifyControl);\n+        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, notifyControl);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/InfraControl.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}