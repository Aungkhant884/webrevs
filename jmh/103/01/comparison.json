{"files":[{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.it.threads;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.it.Fixtures;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests if harness executes setup, run, and tearDown in the virtual or platform threads.\n+ *\/\n+@State(Scope.Benchmark)\n+public class BenchVirtualThreadExecutorTest {\n+\n+    @Param(\"false\")\n+    boolean isVirtual;\n+\n+    private final Set<Boolean> setupRunThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> setupIterationThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> setupInvocationThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> teardownRunThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> teardownIterationThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> teardownInvocationThread = Collections.synchronizedSet(new HashSet<>());\n+    private final Set<Boolean> testInvocationThread = Collections.synchronizedSet(new HashSet<>());\n+\n+    @Setup(Level.Trial)\n+    public void setupRun() {\n+        setupRunThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @Setup(Level.Iteration)\n+    public void setupIteration() {\n+        setupIterationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation() {\n+        setupInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void tearDownRun() {\n+        teardownRunThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @TearDown(Level.Iteration)\n+    public void tearDownIteration() {\n+        teardownIterationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDownInvocation() {\n+        teardownInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void teardownZZZ() { \/\/ should perform last\n+        Set<Boolean> expected = new HashSet<>();\n+        expected.add(this.isVirtual);\n+        Assert.assertEquals(\"test <: testInvocationThread\", expected, testInvocationThread);\n+        Assert.assertEquals(\"test <: setupRun\", expected, setupRunThread);\n+        Assert.assertEquals(\"test <: setupIterationThread\", expected, setupIterationThread);\n+        Assert.assertEquals(\"test <: setupInvocationThread\", expected, setupInvocationThread);\n+        Assert.assertEquals(\"test <: teardownRunThread\", expected, teardownRunThread);\n+        Assert.assertEquals(\"test <: teardownIterationThread\", expected, teardownIterationThread);\n+        Assert.assertEquals(\"test <: teardownInvocationThread\", expected, teardownInvocationThread);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.All)\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 5, time = 100, timeUnit = TimeUnit.MILLISECONDS)\n+    @Fork(1)\n+    @Threads(4)\n+    public void test() {\n+        testInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n+        Fixtures.work();\n+    }\n+\n+    @Test\n+    public void invokeAPI_default() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .param(\"isVirtual\", \"false\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fixed() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FIXED_TPE\")\n+                    .param(\"isVirtual\", \"false\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_virtual() throws RunnerException {\n+        if (VirtualAPI.hasVirtualThreads()) {\n+            for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+                Options opt = new OptionsBuilder()\n+                        .include(Fixtures.getTestMask(this.getClass()))\n+                        .jvmArgsAppend(\"-Djmh.executor=VIRTUAL_TPE\")\n+                        .param(\"isVirtual\", \"true\")\n+                        .shouldFailOnError(true)\n+                        .build();\n+                new Runner(opt).run();\n+            }\n+        }\n+    }\n+\n+    public static class VirtualAPI {\n+        \/\/ provide access to new Threads API via reflection\n+\n+        private static final Method IS_VIRTUAL = getIsVirtual();\n+\n+        private static Method getIsVirtual() {\n+            try {\n+                Method m = Class.forName(\"java.lang.Thread\").getMethod(\"isVirtual\");\n+                m.invoke(Thread.currentThread());\n+                \/\/ isVirtual check is not enough, have to check running virtual thread\n+                Method start = Class.forName(\"java.lang.Thread\").getMethod(\"startVirtualThread\", Runnable.class);\n+                start.invoke(null, (Runnable) (() -> {}));\n+                return m;\n+            } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException |\n+                     IllegalAccessException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static boolean hasVirtualThreads() {\n+            return IS_VIRTUAL != null;\n+        }\n+\n+        public static boolean isVirtual(Thread t) {\n+            if (!hasVirtualThreads()) {\n+                return false;\n+            }\n+            try {\n+                return (boolean) IS_VIRTUAL.invoke(t);\n+            } catch (IllegalAccessException | InvocationTargetException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/BenchVirtualThreadExecutorTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}