{"files":[{"patch":"@@ -1,201 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jmh.it.threads;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Level;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.it.Fixtures;\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.RunnerException;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Tests if harness executes setup, run, and tearDown in the virtual or platform threads.\n- *\/\n-@State(Scope.Benchmark)\n-public class BenchVirtualThreadExecutorTest {\n-\n-    @Param(\"false\")\n-    boolean isVirtual;\n-\n-    private final Set<Boolean> setupRunThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> setupIterationThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> setupInvocationThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> teardownRunThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> teardownIterationThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> teardownInvocationThread = Collections.synchronizedSet(new HashSet<>());\n-    private final Set<Boolean> testInvocationThread = Collections.synchronizedSet(new HashSet<>());\n-\n-    @Setup(Level.Trial)\n-    public void setupRun() {\n-        setupRunThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @Setup(Level.Iteration)\n-    public void setupIteration() {\n-        setupIterationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @Setup(Level.Invocation)\n-    public void setupInvocation() {\n-        setupInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @TearDown(Level.Trial)\n-    public void tearDownRun() {\n-        teardownRunThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @TearDown(Level.Iteration)\n-    public void tearDownIteration() {\n-        teardownIterationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @TearDown(Level.Invocation)\n-    public void tearDownInvocation() {\n-        teardownInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-    }\n-\n-    @TearDown(Level.Trial)\n-    public void teardownZZZ() { \/\/ should perform last\n-        Set<Boolean> expected = new HashSet<>();\n-        expected.add(this.isVirtual);\n-        Assert.assertEquals(\"test <: testInvocationThread\", expected, testInvocationThread);\n-        Assert.assertEquals(\"test <: setupRun\", expected, setupRunThread);\n-        Assert.assertEquals(\"test <: setupIterationThread\", expected, setupIterationThread);\n-        Assert.assertEquals(\"test <: setupInvocationThread\", expected, setupInvocationThread);\n-        Assert.assertEquals(\"test <: teardownRunThread\", expected, teardownRunThread);\n-        Assert.assertEquals(\"test <: teardownIterationThread\", expected, teardownIterationThread);\n-        Assert.assertEquals(\"test <: teardownInvocationThread\", expected, teardownInvocationThread);\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.All)\n-    @Warmup(iterations = 0)\n-    @Measurement(iterations = 5, time = 100, timeUnit = TimeUnit.MILLISECONDS)\n-    @Fork(1)\n-    @Threads(4)\n-    public void test() {\n-        testInvocationThread.add(VirtualAPI.isVirtual(Thread.currentThread()));\n-        Fixtures.work();\n-    }\n-\n-    @Test\n-    public void invokeAPI_default() throws RunnerException {\n-        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n-            Options opt = new OptionsBuilder()\n-                    .include(Fixtures.getTestMask(this.getClass()))\n-                    .param(\"isVirtual\", \"false\")\n-                    .shouldFailOnError(true)\n-                    .build();\n-            new Runner(opt).run();\n-        }\n-    }\n-\n-    @Test\n-    public void invokeAPI_fixed() throws RunnerException {\n-        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n-            Options opt = new OptionsBuilder()\n-                    .include(Fixtures.getTestMask(this.getClass()))\n-                    .jvmArgsAppend(\"-Djmh.executor=FIXED_TPE\")\n-                    .param(\"isVirtual\", \"false\")\n-                    .shouldFailOnError(true)\n-                    .build();\n-            new Runner(opt).run();\n-        }\n-    }\n-\n-    @Test\n-    public void invokeAPI_virtual() throws RunnerException {\n-        if (VirtualAPI.hasVirtualThreads()) {\n-            for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n-                Options opt = new OptionsBuilder()\n-                        .include(Fixtures.getTestMask(this.getClass()))\n-                        .jvmArgsAppend(\"-Djmh.executor=VIRTUAL_TPE\")\n-                        .param(\"isVirtual\", \"true\")\n-                        .shouldFailOnError(true)\n-                        .build();\n-                new Runner(opt).run();\n-            }\n-        }\n-    }\n-\n-    public static class VirtualAPI {\n-        \/\/ provide access to new Threads API via reflection\n-\n-        private static final Method IS_VIRTUAL = getIsVirtual();\n-\n-        private static Method getIsVirtual() {\n-            try {\n-                Method m = Class.forName(\"java.lang.Thread\").getMethod(\"isVirtual\");\n-                m.invoke(Thread.currentThread());\n-                \/\/ isVirtual check is not enough, have to check running virtual thread\n-                Method start = Class.forName(\"java.lang.Thread\").getMethod(\"startVirtualThread\", Runnable.class);\n-                start.invoke(null, (Runnable) (() -> {}));\n-                return m;\n-            } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException |\n-                     IllegalAccessException e) {\n-                return null;\n-            }\n-        }\n-\n-        public static boolean hasVirtualThreads() {\n-            return IS_VIRTUAL != null;\n-        }\n-\n-        public static boolean isVirtual(Thread t) {\n-            if (!hasVirtualThreads()) {\n-                return false;\n-            }\n-            try {\n-                return (boolean) IS_VIRTUAL.invoke(t);\n-            } catch (IllegalAccessException | InvocationTargetException e) {\n-                return false;\n-            }\n-        }\n-    }\n-\n-}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/BenchVirtualThreadExecutorTest.java","additions":0,"deletions":201,"binary":false,"changes":201,"status":"deleted"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,0 +48,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -49,0 +53,1 @@\n+import java.util.List;\n@@ -50,0 +55,7 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n@@ -51,0 +63,3 @@\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -54,0 +69,1 @@\n+ * Also tests if all workers are platform or virtual threads.\n@@ -58,0 +74,8 @@\n+    public enum ExecutorType {\n+        CACHED_TPE, FIXED_TPE, VIRTUAL_TPE, FJP, CUSTOM\n+\n+    }\n+\n+    @Param(\"FIXED_TPE\")\n+    ExecutorType benchmarkExecutorType;\n+\n@@ -99,6 +123,34 @@\n-        Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n-        Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n-        Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n-        Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n-        Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n-        Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        if(benchmarkExecutorType != ExecutorType.CACHED_TPE) { \/\/ CachedThreadPool doesn't guarantee same thread rule\n+            Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n+            Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n+            Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n+            Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n+            Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n+            Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        }\n+        if(benchmarkExecutorType == ExecutorType.VIRTUAL_TPE) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+        } else {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+        }\n+        if(benchmarkExecutorType == ExecutorType.FJP) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+        }\n@@ -119,1 +171,25 @@\n-    public void invokeAPI() throws RunnerException {\n+    public void invokeAPI_default() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fixed() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FIXED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"FIXED_TPE\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_cached() throws RunnerException {\n@@ -123,0 +199,2 @@\n+                    .jvmArgsAppend(\"-Djmh.executor=CACHED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"CACHED_TPE\")\n@@ -129,0 +207,161 @@\n+    @Test\n+    public void invokeAPI_fjp() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FJP\")\n+                    .param(\"benchmarkExecutorType\", \"FJP\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_custom() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=CUSTOM\")\n+                    .jvmArgsAppend(\"-Djmh.executor.class=\"+CustomExecutor.class.getName())\n+                    .param(\"benchmarkExecutorType\", \"CUSTOM\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_virtual() throws RunnerException {\n+        if(VirtualAPI.hasVirtualThreads()) {\n+            for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+                Options opt = new OptionsBuilder()\n+                        .include(Fixtures.getTestMask(this.getClass()))\n+                        .jvmArgsAppend(\"-Djmh.executor=VIRTUAL_TPE\")\n+                        .param(\"benchmarkExecutorType\", \"VIRTUAL_TPE\")\n+                        .shouldFailOnError(true)\n+                        .build();\n+                new Runner(opt).run();\n+            }\n+        }\n+    }\n+\n+    public static class VirtualAPI {\n+        \/\/ provide access to new Threads API via reflection\n+\n+        private static final Method IS_VIRTUAL = getIsVirtual();\n+\n+        private static Method getIsVirtual() {\n+            try {\n+                Method m = Class.forName(\"java.lang.Thread\").getMethod(\"isVirtual\");\n+                m.invoke(Thread.currentThread());\n+                \/\/ isVirtual check is not enough, have to check running virtual thread\n+                Method start = Class.forName(\"java.lang.Thread\").getMethod(\"startVirtualThread\", Runnable.class);\n+                start.invoke(null, (Runnable) (() -> {}));\n+                return m;\n+            } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException |\n+                     IllegalAccessException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static boolean hasVirtualThreads() {\n+            return IS_VIRTUAL != null;\n+        }\n+\n+        public static boolean isVirtual(Thread t) {\n+            if (!hasVirtualThreads()) {\n+                return false;\n+            }\n+            try {\n+                return (boolean) IS_VIRTUAL.invoke(t);\n+            } catch (IllegalAccessException | InvocationTargetException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    static class CustomExecutor implements ExecutorService {\n+        private final ExecutorService e;\n+\n+        public CustomExecutor(int maxThreads, String prefix) {\n+            e = Executors.newFixedThreadPool(maxThreads, new CustomThreadFactory(prefix));\n+        }\n+\n+        public void execute(Runnable command) {\n+            e.execute(command);\n+        }\n+\n+        public void shutdown() {\n+            e.shutdown();\n+        }\n+\n+        public List<Runnable> shutdownNow() {\n+            return e.shutdownNow();\n+        }\n+\n+        public boolean isShutdown() {\n+            return e.isShutdown();\n+        }\n+\n+        public boolean isTerminated() {\n+            return e.isTerminated();\n+        }\n+\n+        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.awaitTermination(timeout, unit);\n+        }\n+\n+        public Future<?> submit(Runnable task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Callable<T> task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Runnable task, T result) {\n+            return e.submit(task, result);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n+            return e.invokeAll(tasks);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.invokeAll(tasks, timeout, unit);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n+            return e.invokeAny(tasks);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+            return e.invokeAny(tasks, timeout, unit);\n+        }\n+    }\n+\n+    static class CustomThreadFactory implements ThreadFactory {\n+\n+        private final AtomicInteger counter;\n+        private final String prefix;\n+\n+        public CustomThreadFactory(String prefix) {\n+            this.counter = new AtomicInteger();\n+            this.prefix = prefix;\n+        }\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            CustomThread t = new CustomThread(r, prefix + \"-jmh-worker-\" + counter.incrementAndGet());\n+            t.setDaemon(true);\n+            return t;\n+        }\n+    }\n+\n+    static class CustomThread extends Thread {\n+        public CustomThread(Runnable r, String name) {\n+            super(r, name);\n+        }\n+    }\n+\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/BenchmarkBenchSameThreadTest.java","additions":246,"deletions":7,"binary":false,"changes":253,"status":"modified"}]}