{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,0 +48,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -49,0 +53,1 @@\n+import java.util.List;\n@@ -50,0 +55,7 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n@@ -51,0 +63,3 @@\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -54,0 +69,1 @@\n+ * Also tests if all workers are platform or virtual threads.\n@@ -58,0 +74,8 @@\n+    public enum ExecutorType {\n+        CACHED_TPE, FIXED_TPE, VIRTUAL_TPE, FJP, CUSTOM\n+\n+    }\n+\n+    @Param(\"FIXED_TPE\")\n+    ExecutorType benchmarkExecutorType;\n+\n@@ -99,6 +123,34 @@\n-        Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n-        Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n-        Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n-        Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n-        Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n-        Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        if(benchmarkExecutorType != ExecutorType.CACHED_TPE) { \/\/ CachedThreadPool doesn't guarantee same thread rule\n+            Assert.assertTrue(\"test <: setupRun\", testInvocationThread.containsAll(setupRunThread));\n+            Assert.assertTrue(\"test <: setupIteration\", testInvocationThread.containsAll(setupIterationThread));\n+            Assert.assertTrue(\"test <: setupInvocation\", testInvocationThread.containsAll(setupInvocationThread));\n+            Assert.assertTrue(\"test <: teardownRun\", testInvocationThread.containsAll(teardownRunThread));\n+            Assert.assertTrue(\"test <: teardownIteration\", testInvocationThread.containsAll(teardownIterationThread));\n+            Assert.assertTrue(\"test <: teardownInvocation\", testInvocationThread.containsAll(teardownInvocationThread));\n+        }\n+        if(benchmarkExecutorType == ExecutorType.VIRTUAL_TPE) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(VirtualAPI::isVirtual));\n+        } else {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().noneMatch(VirtualAPI::isVirtual));\n+        }\n+        if(benchmarkExecutorType == ExecutorType.FJP) {\n+            Assert.assertTrue(\"setupRun thread kind\", setupRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupIteration thread kind\", setupIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"setupInvocation thread kind\", setupInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownRun thread kind\", teardownRunThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownIteration thread kind\", teardownIterationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"teardownInvocation thread kind\", teardownInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+            Assert.assertTrue(\"testInvocation thread kind\", testInvocationThread.stream().allMatch(t -> t instanceof ForkJoinWorkerThread));\n+        }\n@@ -119,1 +171,25 @@\n-    public void invokeAPI() throws RunnerException {\n+    public void invokeAPI_default() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_fixed() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FIXED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"FIXED_TPE\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_cached() throws RunnerException {\n@@ -123,0 +199,2 @@\n+                    .jvmArgsAppend(\"-Djmh.executor=CACHED_TPE\")\n+                    .param(\"benchmarkExecutorType\", \"CACHED_TPE\")\n@@ -129,0 +207,161 @@\n+    @Test\n+    public void invokeAPI_fjp() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=FJP\")\n+                    .param(\"benchmarkExecutorType\", \"FJP\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_custom() throws RunnerException {\n+        for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+            Options opt = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .jvmArgsAppend(\"-Djmh.executor=CUSTOM\")\n+                    .jvmArgsAppend(\"-Djmh.executor.class=\"+CustomExecutor.class.getName())\n+                    .param(\"benchmarkExecutorType\", \"CUSTOM\")\n+                    .shouldFailOnError(true)\n+                    .build();\n+            new Runner(opt).run();\n+        }\n+    }\n+\n+    @Test\n+    public void invokeAPI_virtual() throws RunnerException {\n+        if(VirtualAPI.hasVirtualThreads()) {\n+            for (int c = 0; c < Fixtures.repetitionCount(); c++) {\n+                Options opt = new OptionsBuilder()\n+                        .include(Fixtures.getTestMask(this.getClass()))\n+                        .jvmArgsAppend(\"-Djmh.executor=VIRTUAL_TPE\")\n+                        .param(\"benchmarkExecutorType\", \"VIRTUAL_TPE\")\n+                        .shouldFailOnError(true)\n+                        .build();\n+                new Runner(opt).run();\n+            }\n+        }\n+    }\n+\n+    public static class VirtualAPI {\n+        \/\/ provide access to new Threads API via reflection\n+\n+        private static final Method IS_VIRTUAL = getIsVirtual();\n+\n+        private static Method getIsVirtual() {\n+            try {\n+                Method m = Class.forName(\"java.lang.Thread\").getMethod(\"isVirtual\");\n+                m.invoke(Thread.currentThread());\n+                \/\/ isVirtual check is not enough, have to check running virtual thread\n+                Method start = Class.forName(\"java.lang.Thread\").getMethod(\"startVirtualThread\", Runnable.class);\n+                start.invoke(null, (Runnable) (() -> {}));\n+                return m;\n+            } catch (NoSuchMethodException | ClassNotFoundException | InvocationTargetException |\n+                     IllegalAccessException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static boolean hasVirtualThreads() {\n+            return IS_VIRTUAL != null;\n+        }\n+\n+        public static boolean isVirtual(Thread t) {\n+            if (!hasVirtualThreads()) {\n+                return false;\n+            }\n+            try {\n+                return (boolean) IS_VIRTUAL.invoke(t);\n+            } catch (IllegalAccessException | InvocationTargetException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    static class CustomExecutor implements ExecutorService {\n+        private final ExecutorService e;\n+\n+        public CustomExecutor(int maxThreads, String prefix) {\n+            e = Executors.newFixedThreadPool(maxThreads, new CustomThreadFactory(prefix));\n+        }\n+\n+        public void execute(Runnable command) {\n+            e.execute(command);\n+        }\n+\n+        public void shutdown() {\n+            e.shutdown();\n+        }\n+\n+        public List<Runnable> shutdownNow() {\n+            return e.shutdownNow();\n+        }\n+\n+        public boolean isShutdown() {\n+            return e.isShutdown();\n+        }\n+\n+        public boolean isTerminated() {\n+            return e.isTerminated();\n+        }\n+\n+        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.awaitTermination(timeout, unit);\n+        }\n+\n+        public Future<?> submit(Runnable task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Callable<T> task) {\n+            return e.submit(task);\n+        }\n+\n+        public <T> Future<T> submit(Runnable task, T result) {\n+            return e.submit(task, result);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n+            return e.invokeAll(tasks);\n+        }\n+\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n+            return e.invokeAll(tasks, timeout, unit);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n+            return e.invokeAny(tasks);\n+        }\n+\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+            return e.invokeAny(tasks, timeout, unit);\n+        }\n+    }\n+\n+    static class CustomThreadFactory implements ThreadFactory {\n+\n+        private final AtomicInteger counter;\n+        private final String prefix;\n+\n+        public CustomThreadFactory(String prefix) {\n+            this.counter = new AtomicInteger();\n+            this.prefix = prefix;\n+        }\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            CustomThread t = new CustomThread(r, prefix + \"-jmh-worker-\" + counter.incrementAndGet());\n+            t.setDaemon(true);\n+            return t;\n+        }\n+    }\n+\n+    static class CustomThread extends Thread {\n+        public CustomThread(Runnable r, String name) {\n+            super(r, name);\n+        }\n+    }\n+\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/threads\/BenchmarkBenchSameThreadTest.java","additions":246,"deletions":7,"binary":false,"changes":253,"status":"modified"}]}