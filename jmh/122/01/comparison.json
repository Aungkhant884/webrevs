{"files":[{"patch":"@@ -266,0 +266,1 @@\n+                opts.add(\"-XX:+PrintMethodHandleStubs\");\n@@ -349,1 +350,1 @@\n-        Assembly assembly = readAssembly(hsLog.file());\n+        Assembly assembly = readAssembly();\n@@ -838,2 +839,2 @@\n-    private Collection<Collection<String>> splitAssembly(File stdOut) {\n-        try (FileReader in = new FileReader(stdOut);\n+    private Collection<Collection<String>> splitAssembly() {\n+        try (FileReader in = new FileReader(hsLog.file());\n@@ -874,1 +875,1 @@\n-    private Assembly readAssembly(File stdOut) {\n+    Assembly readAssembly() {\n@@ -901,0 +902,9 @@\n+        \/\/ Parsing runtime stubs. These come in different shapes and sizes:\n+        \/\/\n+        \/\/ Decoding ExceptionBlob 0x0000ffff7ff1bb10 [0x0000ffff7ff1bb80, 0x0000ffff7ff1bbd0] (80 bytes)\n+        \/\/\n+        \/\/ Decoding VtableStub itbl[0]@281473229238259 [0x0000ffff7ff1d210, 0x0000ffff7ff1d29c] (140 bytes)\n+        \/\/\n+        \/\/ Decoding RuntimeStub - _complete_monitor_locking_Java 0x0000ffff8bf20f90 [0x0000ffff8bf21000, 0x0000ffff8bf21080] (128 bytes)\n+        final Pattern runtimeStubPattern = Pattern.compile(\"Decoding (.+?) \\\\[(.+), (.+)\\\\](.*)\");\n+\n@@ -908,1 +918,1 @@\n-        for (Collection<String> cs : splitAssembly(stdOut)) {\n+        for (Collection<String> cs : splitAssembly()) {\n@@ -958,0 +968,16 @@\n+                if (line.contains(\"Decoding\")) {\n+                    Matcher matcher = runtimeStubPattern.matcher(line);\n+                    if (matcher.matches()) {\n+                        String name = matcher.group(1);\n+                        if (name.startsWith(\"RuntimeStub - \")) {\n+                            name = name.substring(\"RuntimeStub - \".length());\n+                        }\n+                        Long startAddr = parseOneAddress(matcher.group(2));\n+                        Long endAddr = parseOneAddress(matcher.group(3));\n+\n+                        if (startAddr != null && endAddr != null) {\n+                            stubs.add(MethodDesc.runtimeStub(name), startAddr, endAddr);\n+                        }\n+                    }\n+                }\n+\n@@ -983,1 +1009,1 @@\n-                                map.get(\"compiler\"),\n+                                (map.get(\"compiler\") != null) ? map.get(\"compiler\").toUpperCase() : null,\n@@ -1014,0 +1040,9 @@\n+    static Long parseOneAddress(String src) {\n+        List<Long> addrs = parseAddresses(src, true, true);\n+        if (addrs.size() == 1) {\n+            return addrs.get(0);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n@@ -1437,4 +1472,1 @@\n-            return \"MethodDesc{\" +\n-                    \"name='\" + name + '\\'' +\n-                    \", source='\" + source + '\\'' +\n-                    '}';\n+            return source + \": \" + name;\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AbstractPerfAsmProfiler.java","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    private final boolean useSudo;\n@@ -61,0 +62,1 @@\n+\n@@ -62,0 +64,1 @@\n+    private OptionSpec<Boolean> optSudo;\n@@ -66,6 +69,0 @@\n-        \/\/ Check DTrace availability\n-        Collection<String> messages = Utils.tryWith(\"sudo\", \"-n\", \"dtrace\", \"-V\");\n-        if (!messages.isEmpty()) {\n-            throw new ProfilerException(messages.toString());\n-        }\n-\n@@ -74,0 +71,1 @@\n+            useSudo = set.valueOf(optSudo);\n@@ -77,0 +75,11 @@\n+\n+        \/\/ Check DTrace availability\n+        Collection<String> messages;\n+        if (useSudo) {\n+            messages = Utils.tryWith(\"sudo\", \"-n\", \"dtrace\", \"-V\");\n+        } else {\n+            messages = Utils.tryWith(\"dtrace\", \"-V\");\n+        }\n+        if (!messages.isEmpty()) {\n+            throw new ProfilerException(messages.toString());\n+        }\n@@ -118,3 +127,6 @@\n-        dtraceProcess = Utils.runAsync(\"sudo\", \"-n\", \"dtrace\", \"-n\", \"profile-\" + sampleFrequency +\n-                        \" \/arg1\/ { printf(\\\"%d 0x%lx %d\\\", pid, arg1, timestamp); ufunc(arg1)}\", \"-o\",\n-                perfBinData.getAbsolutePath());\n+        String dtraceLine = \"profile-\" + sampleFrequency + \" \/arg1\/ { printf(\\\"%d 0x%lx %d\\\", pid, arg1, timestamp); ufunc(arg1)}\";\n+        if (useSudo) {\n+            dtraceProcess = Utils.runAsync(\"sudo\", \"-n\", \"dtrace\", \"-n\", dtraceLine, \"-o\", perfBinData.getAbsolutePath());\n+        } else {\n+            dtraceProcess = Utils.runAsync(\"dtrace\", \"-n\", dtraceLine, \"-o\", perfBinData.getAbsolutePath());\n+        }\n@@ -134,0 +146,3 @@\n+\n+        optSudo = parser.accepts(\"sudo\", \"Use sudo to access dtrace.\")\n+                .withRequiredArg().ofType(Boolean.class).defaultsTo(true);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/DTraceAsmProfiler.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Collection;\n@@ -102,0 +103,4 @@\n+    public Collection<T> allValues() {\n+        return from.values();\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/util\/IntervalMap.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -396,0 +396,8 @@\n+    public static boolean isLinux() {\n+        return System.getProperty(\"os.name\").contains(\"Linux\");\n+    }\n+\n+    public static boolean isMacos() {\n+        return System.getProperty(\"os.name\").contains(\"Mac\");\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/util\/Utils.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.profile;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmh.util.JDKVersion;\n+import org.openjdk.jmh.util.Utils;\n+\n+import java.util.*;\n+\n+public class PerfAsmMethodParsingTest {\n+\n+    private static final String PAYLOAD_CLASS_NAME = PerfAsmMethodPayload.class.getName();\n+\n+    private static AbstractPerfAsmProfiler selectProfiler() throws ProfilerException {\n+        if (Utils.isWindows()) {\n+            return new WinPerfAsmProfiler(\"\");\n+        } else if (Utils.isMacos()) {\n+            return new DTraceAsmProfiler(\"sudo=false\");\n+        } else if (Utils.isLinux()) {\n+            return new LinuxPerfAsmProfiler(\"\");\n+        }\n+        throw new RuntimeException(\"Unknown OS: \" + System.getProperty(\"os.name\"));\n+    }\n+\n+    public static void checkFor(String log, String... msgs) {\n+        for (String msg : msgs) {\n+            if (log.contains(msg)) return;\n+        }\n+        System.out.println(log);\n+        Assert.fail(\"Cannot find any entry: \" + Arrays.toString(msgs));\n+    }\n+\n+    @Test\n+    public void checkJDK() {\n+        AbstractPerfAsmProfiler profiler;\n+        try {\n+            profiler = selectProfiler();\n+        } catch (ProfilerException e) {\n+            \/\/ Profiler exception in the test, not available?\n+            e.printStackTrace();\n+            return;\n+        }\n+\n+        List<String> args = new ArrayList<>();\n+        args.add(Utils.getCurrentJvm());\n+        args.add(\"-cp\");\n+        args.add(System.getProperty(\"java.class.path\"));\n+        args.addAll(profiler.addJVMOptions(null));\n+        args.add(PAYLOAD_CLASS_NAME);\n+\n+        Collection<String> out = Utils.runWith(args);\n+        System.out.println(out);\n+\n+        AbstractPerfAsmProfiler.Assembly assembly = profiler.readAssembly();\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (AbstractPerfAsmProfiler.MethodDesc md : assembly.methodMap.allValues()) {\n+            sb.append(md);\n+            sb.append(System.lineSeparator());\n+        }\n+\n+        String methods = sb.toString();\n+\n+        if (JDKVersion.parseMajor(System.getProperty(\"java.version\")) >= 22) {\n+            \/\/ These rely on logging available in up-to-date JDKs.\n+            \/\/ At the time of writing, only JDK 22 contained all these fixes.\n+            \/\/ TODO: As the relevant JDK updates get backported, consider bumping the versions down.\n+\n+            \/\/ Added by JDK-8316514\n+            checkFor(methods, \"runtime stub: VtableStub vtbl[\");\n+            checkFor(methods, \"runtime stub: VtableStub itbl[\");\n+\n+            \/\/ Added by JDK-8316178\n+            checkFor(methods, \"runtime stub: ExceptionBlob\");\n+            checkFor(methods, \"runtime stub: _complete_monitor_locking_Java\");\n+            checkFor(methods, \"runtime stub: StackOverflowError throw_exception\");\n+        }\n+\n+        \/\/ StubRoutines\n+        checkFor(methods, \"runtime stub: StubRoutines::call_stub\");\n+\n+        \/\/ Interpreter: bytecode stub\n+        checkFor(methods, \"interpreter: iconst_0\");\n+\n+        \/\/ Interpreter: auxiliary stubs\n+        checkFor(methods, \"interpreter: native method entry point (kind = native)\",\n+                          \"interpreter: method entry point (kind = native)\");\n+        checkFor(methods, \"interpreter: exception handling\");\n+\n+        \/\/ Native method\n+        checkFor(methods, \"Unknown, level 0: java.lang.System::currentTimeMillis\");\n+\n+        \/\/ Hot Java method passing the tiered compilation pipeline\n+        checkFor(methods, \"C1, level 2: \" + PAYLOAD_CLASS_NAME + \"$C1::doWork\",\n+                          \"C1, level 3: \" + PAYLOAD_CLASS_NAME + \"$C1::doWork\");\n+        checkFor(methods, \"C1, level 2: \" + PAYLOAD_CLASS_NAME + \"$C2::doWork\",\n+                          \"C1, level 3: \" + PAYLOAD_CLASS_NAME + \"$C2::doWork\");\n+        checkFor(methods, \"C1, level 2: \" + PAYLOAD_CLASS_NAME + \"$C3::doWork\",\n+                          \"C1, level 3: \" + PAYLOAD_CLASS_NAME + \"$C3::doWork\");\n+\n+        checkFor(methods, \"C2, level 4: \" + PAYLOAD_CLASS_NAME + \"$C1::doWork\");\n+        checkFor(methods, \"C2, level 4: \" + PAYLOAD_CLASS_NAME + \"$C2::doWork\");\n+        checkFor(methods, \"C2, level 4: \" + PAYLOAD_CLASS_NAME + \"$C3::doWork\");\n+    }\n+\n+}\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/profile\/PerfAsmMethodParsingTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.profile;\n+\n+public class PerfAsmMethodPayload {\n+    public static void main(String... args) throws Exception {\n+        Thread.sleep(1000); \/\/ let stubs print\n+        long s = 0;\n+        for (int c = 0; c < 100_000; c++) {\n+            doInterface(new C1());\n+            doInterface(new C2());\n+            doInterface(new C3());\n+            doVirtual(new C1());\n+            doVirtual(new C2());\n+            doVirtual(new C3());\n+            s += System.currentTimeMillis();\n+        }\n+        System.out.println(\"Hello \" + s);\n+    }\n+\n+    public static void doInterface(I i) {\n+        while (!i.doWork());\n+    }\n+\n+    public static void doVirtual(B b) {\n+        while (!b.doWork());\n+    }\n+\n+    interface I {\n+        boolean doWork();\n+    }\n+\n+    static class B {\n+        int count = 100;\n+\n+        public boolean doWork() {\n+            return (count-- < 0);\n+        }\n+    }\n+\n+    static class C1 extends B implements I {\n+        public boolean doWork() {\n+            return super.doWork();\n+        }\n+    }\n+\n+    static class C2 extends B implements I {\n+        public boolean doWork() {\n+            return super.doWork();\n+        }\n+    }\n+\n+    static class C3 extends B implements I {\n+        public boolean doWork() {\n+            return super.doWork();\n+        }\n+    }\n+}\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/profile\/PerfAsmMethodPayload.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}