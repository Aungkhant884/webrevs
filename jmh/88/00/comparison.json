{"files":[{"patch":"@@ -56,1 +56,15 @@\n-    public void test() throws RunnerException {\n+    public void testDefault() throws RunnerException {\n+        testWith(\"\");\n+    }\n+\n+    @Test\n+    public void testAlloc() throws RunnerException {\n+        testWith(\"alloc=true\");\n+    }\n+\n+    @Test\n+    public void testAll() throws RunnerException {\n+        testWith(\"alloc=true;churn=true\");\n+    }\n+\n+    private void testWith(String initLine) throws RunnerException {\n@@ -59,1 +73,1 @@\n-                .addProfiler(GCProfiler.class)\n+                .addProfiler(GCProfiler.class, initLine)\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/GCProfilerAllocRateTest.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-\/**\n- * Tests allocation profiler.\n- *\/\n@@ -48,1 +45,1 @@\n-    @Measurement(iterations = 20, time = 10, timeUnit = TimeUnit.MILLISECONDS)\n+    @Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.MILLISECONDS)\n@@ -55,1 +52,1 @@\n-    @Warmup(iterations = 2)\n+    @Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n@@ -71,1 +68,1 @@\n-    @Warmup(iterations = 2)\n+    @Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n@@ -79,1 +76,1 @@\n-    public void testAllocationProfiler() throws RunnerException {\n+    public void testDefault() throws RunnerException {\n@@ -86,0 +83,27 @@\n+\n+    @Test\n+    public void testAlloc() throws RunnerException {\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .addProfiler(GCProfiler.class, \"alloc=true\")\n+                .build();\n+        new Runner(opts).run();\n+    }\n+\n+    @Test\n+    public void testChurn() throws RunnerException {\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .addProfiler(GCProfiler.class, \"churn=true;churnWait=1\")\n+                .build();\n+        new Runner(opts).run();\n+    }\n+\n+    @Test\n+    public void testAll() throws RunnerException {\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .addProfiler(GCProfiler.class, \"alloc=true;churn=true;churnWait=1\")\n+                .build();\n+        new Runner(opts).run();\n+    }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/GCProfilerTest.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import joptsimple.OptionException;\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import joptsimple.OptionSpec;\n@@ -30,0 +34,1 @@\n+import org.openjdk.jmh.runner.options.IntegerValueConverter;\n@@ -51,0 +56,4 @@\n+    private boolean churnEnabled;\n+    private boolean allocEnabled;\n+    private long churnWait;\n+\n@@ -56,0 +65,36 @@\n+    public GCProfiler(String initLine) throws ProfilerException {\n+        OptionParser parser = new OptionParser();\n+        parser.formatHelpWith(new ProfilerOptionFormatter(PausesProfiler.class.getCanonicalName()));\n+\n+        OptionSpec<Boolean> optAllocEnable = parser.accepts(\"alloc\", \"Enable GC allocation measurement.\")\n+                .withRequiredArg().ofType(Boolean.class).describedAs(\"bool\").defaultsTo(true);\n+\n+        OptionSpec<Boolean> optChurnEnable = parser.accepts(\"churn\", \"Enable GC churn measurement.\")\n+                .withRequiredArg().ofType(Boolean.class).describedAs(\"bool\").defaultsTo(false);\n+\n+        OptionSpec<Integer> optChurnWait = parser.accepts(\"churnWait\", \"Time to wait for churn notifications to arrive.\")\n+                .withRequiredArg().withValuesConvertedBy(IntegerValueConverter.POSITIVE).describedAs(\"ms\").defaultsTo(500);\n+\n+        OptionSet set = ProfilerUtils.parseInitLine(initLine, parser);\n+\n+        try {\n+            churnWait = set.valueOf(optChurnWait);\n+            churnEnabled = set.valueOf(optChurnEnable);\n+            allocEnabled = set.valueOf(optAllocEnable);\n+        } catch (OptionException e) {\n+            throw new ProfilerException(e.getMessage());\n+        }\n+\n+        if (churnEnabled) {\n+            if (!VMSupport.tryInitChurn()) {\n+                churnEnabled = false;\n+            }\n+        }\n+\n+        if (allocEnabled) {\n+            if (!VMSupport.tryInitAlloc()) {\n+                allocEnabled = false;\n+            }\n+        }\n+    }\n+\n@@ -58,1 +103,3 @@\n-        VMSupport.startChurnProfile();\n+        if (churnEnabled) {\n+            VMSupport.startChurnProfile();\n+        }\n@@ -68,1 +115,4 @@\n-        this.beforeAllocated = VMSupport.getSnapshot();\n+\n+        if (allocEnabled) {\n+            this.beforeAllocated = VMSupport.getSnapshot();\n+        }\n@@ -76,1 +126,5 @@\n-        VMSupport.finishChurnProfile();\n+        if (churnEnabled) {\n+            VMSupport.finishChurnProfile(churnWait);\n+        }\n+\n+        List<ScalarResult> results = new ArrayList<>();\n@@ -85,26 +139,0 @@\n-        List<ScalarResult> results = new ArrayList<>();\n-\n-        if (beforeAllocated == HotspotAllocationSnapshot.EMPTY) {\n-            \/\/ When allocation profiling fails, make sure it is distinguishable in report\n-            results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate\",\n-                    Double.NaN,\n-                    \"MB\/sec\", AggregationPolicy.AVG));\n-        } else {\n-            HotspotAllocationSnapshot newSnapshot = VMSupport.getSnapshot();\n-            long allocated = newSnapshot.subtract(beforeAllocated);\n-            \/\/ When no allocations measured, we still need to report results to avoid user confusion\n-            results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate\",\n-                            (afterTime != beforeTime) ?\n-                                    1.0 * allocated \/ 1024 \/ 1024 * TimeUnit.SECONDS.toNanos(1) \/ (afterTime - beforeTime) :\n-                                    Double.NaN,\n-                            \"MB\/sec\", AggregationPolicy.AVG));\n-            if (allocated != 0) {\n-                long allOps = iResult.getMetadata().getAllOps();\n-                results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate.norm\",\n-                                (allOps != 0) ?\n-                                        1.0 * allocated \/ allOps :\n-                                        Double.NaN,\n-                                \"B\/op\", AggregationPolicy.AVG));\n-            }\n-        }\n-\n@@ -125,5 +153,25 @@\n-        Multiset<String> churn = VMSupport.getChurn();\n-        for (String space : churn.keys()) {\n-            double churnRate = (afterTime != beforeTime) ?\n-                    1.0 * churn.count(space) * TimeUnit.SECONDS.toNanos(1) \/ (afterTime - beforeTime) \/ 1024 \/ 1024 :\n-                    Double.NaN;\n+        if (allocEnabled) {\n+            if (beforeAllocated != HotspotAllocationSnapshot.EMPTY) {\n+                HotspotAllocationSnapshot newSnapshot = VMSupport.getSnapshot();\n+                long allocated = newSnapshot.subtract(beforeAllocated);\n+                \/\/ When no allocations measured, we still need to report results to avoid user confusion\n+                results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate\",\n+                        (afterTime != beforeTime) ?\n+                                1.0 * allocated \/ 1024 \/ 1024 * TimeUnit.SECONDS.toNanos(1) \/ (afterTime - beforeTime) :\n+                                Double.NaN,\n+                        \"MB\/sec\", AggregationPolicy.AVG));\n+                if (allocated != 0) {\n+                    long allOps = iResult.getMetadata().getAllOps();\n+                    results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate.norm\",\n+                            (allOps != 0) ?\n+                                    1.0 * allocated \/ allOps :\n+                                    Double.NaN,\n+                            \"B\/op\", AggregationPolicy.AVG));\n+                }\n+            } else {\n+                \/\/ When allocation profiling fails, make sure it is distinguishable in report\n+                results.add(new ScalarResult(Defaults.PREFIX + \"gc.alloc.rate\",\n+                        Double.NaN,\n+                        \"MB\/sec\", AggregationPolicy.AVG));\n+            }\n+        }\n@@ -131,1 +179,6 @@\n-            double churnNorm = 1.0 * churn.count(space) \/ iResult.getMetadata().getAllOps();\n+        if (churnEnabled) {\n+            Multiset<String> churn = VMSupport.getChurn();\n+            for (String space : churn.keys()) {\n+                double churnRate = (afterTime != beforeTime) ?\n+                        1.0 * churn.count(space) * TimeUnit.SECONDS.toNanos(1) \/ (afterTime - beforeTime) \/ 1024 \/ 1024 :\n+                        Double.NaN;\n@@ -133,1 +186,1 @@\n-            String spaceName = space.replaceAll(\" \", \"_\");\n+                double churnNorm = 1.0 * churn.count(space) \/ iResult.getMetadata().getAllOps();\n@@ -135,5 +188,1 @@\n-            results.add(new ScalarResult(\n-                    Defaults.PREFIX + \"gc.churn.\" + spaceName + \"\",\n-                    churnRate,\n-                    \"MB\/sec\",\n-                    AggregationPolicy.AVG));\n+                String spaceName = space.replaceAll(\" \", \"_\");\n@@ -141,5 +190,12 @@\n-            results.add(new ScalarResult(\n-                    Defaults.PREFIX + \"gc.churn.\" + spaceName + \".norm\",\n-                    churnNorm,\n-                    \"B\/op\",\n-                    AggregationPolicy.AVG));\n+                results.add(new ScalarResult(\n+                        Defaults.PREFIX + \"gc.churn.\" + spaceName + \"\",\n+                        churnRate,\n+                        \"MB\/sec\",\n+                        AggregationPolicy.AVG));\n+\n+                results.add(new ScalarResult(\n+                        Defaults.PREFIX + \"gc.churn.\" + spaceName + \".norm\",\n+                        churnNorm,\n+                        \"B\/op\",\n+                        AggregationPolicy.AVG));\n+            }\n@@ -200,1 +256,0 @@\n-        private static final boolean ALLOC_AVAILABLE;\n@@ -203,9 +258,2 @@\n-        private static final boolean CHURN_AVAILABLE;\n-        private static NotificationListener listener;\n-        private static Multiset<String> churn;\n-        private static boolean started;\n-\n-        static {\n-            ALLOC_AVAILABLE = tryInitAlloc();\n-            CHURN_AVAILABLE = tryInitChurn();\n-        }\n+        private static NotificationListener LISTENER;\n+        private static Multiset<String> CHURN;\n@@ -244,2 +292,2 @@\n-                churn = new HashMultiset<>();\n-                listener = newListener();\n+                CHURN = new HashMultiset<>();\n+                LISTENER = newListener();\n@@ -286,1 +334,1 @@\n-                                        churn.add(name, c);\n+                                        CHURN.add(name, c);\n@@ -301,1 +349,0 @@\n-            if (!ALLOC_AVAILABLE) return HotspotAllocationSnapshot.EMPTY;\n@@ -308,6 +355,1 @@\n-            if (!CHURN_AVAILABLE) return;\n-            if (started) {\n-                throw new IllegalStateException(\"Churn profile already started\");\n-            }\n-            started = true;\n-            churn.clear();\n+            CHURN.clear();\n@@ -316,1 +358,1 @@\n-                    ((NotificationEmitter) bean).addNotificationListener(listener, null, null);\n+                    ((NotificationEmitter) bean).addNotificationListener(LISTENER, null, null);\n@@ -323,6 +365,1 @@\n-        public static synchronized void finishChurnProfile() {\n-            if (!CHURN_AVAILABLE) return;\n-            if (!started) {\n-                throw new IllegalStateException(\"Churn profile already stopped\");\n-            }\n-\n+        public static synchronized void finishChurnProfile(long churnWait) {\n@@ -331,1 +368,1 @@\n-                Thread.sleep(500);\n+                Thread.sleep(churnWait);\n@@ -338,1 +375,1 @@\n-                    ((NotificationEmitter) bean).removeNotificationListener(listener);\n+                    ((NotificationEmitter) bean).removeNotificationListener(LISTENER);\n@@ -343,1 +380,0 @@\n-            started = false;\n@@ -347,1 +383,1 @@\n-            return (churn != null) ? churn : new HashMultiset<String>();\n+            return (CHURN != null) ? CHURN : new HashMultiset<String>();\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/GCProfiler.java","additions":113,"deletions":77,"binary":false,"changes":190,"status":"modified"}]}