{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -157,2 +158,0 @@\n-        boolean testCompilerBlackhole = JDKVersion.parseMajor(System.getProperty(\"java.version\")) >= 16;\n-\n@@ -198,1 +197,9 @@\n-                    new BlackholeSingleTest().runWith(pw, opts);\n+                    setBlackholeOpts(BlackholeTestMode.normal);\n+                    new BlackholeSingleTest(BlackholeTestMode.normal).runWith(pw, opts);\n+                    setBlackholeOpts(BlackholeTestMode.compiler);\n+                    new BlackholeSingleTest(BlackholeTestMode.compiler).runWith(pw, opts);\n+                    setBlackholeOpts(BlackholeTestMode.full_dontinline);\n+                    new BlackholeSingleTest(BlackholeTestMode.full_dontinline).runWith(pw, opts);\n+                    setBlackholeOpts(BlackholeTestMode.full);\n+                    new BlackholeSingleTest(BlackholeTestMode.full).runWith(pw, opts);\n+                    setBlackholeOpts(BlackholeTestMode.normal);\n@@ -204,5 +211,3 @@\n-                    if (testCompilerBlackhole) {\n-                        setBlackholeOpts(BlackholeTestMode.compiler);\n-                        new BlackholePipelinedTest(false, BlackholeTestMode.compiler).runWith(pw, opts);\n-                        new BlackholePipelinedTest(true, BlackholeTestMode.compiler).runWith(pw, opts);\n-                    }\n+                    setBlackholeOpts(BlackholeTestMode.compiler);\n+                    new BlackholePipelinedTest(false, BlackholeTestMode.compiler).runWith(pw, opts);\n+                    new BlackholePipelinedTest(true, BlackholeTestMode.compiler).runWith(pw, opts);\n@@ -220,4 +225,2 @@\n-                    if (testCompilerBlackhole) {\n-                        setBlackholeOpts(BlackholeTestMode.compiler);\n-                        new BlackholeConsecutiveTest(BlackholeTestMode.compiler).runWith(pw, opts);\n-                    }\n+                    setBlackholeOpts(BlackholeTestMode.compiler);\n+                    new BlackholeConsecutiveTest(BlackholeTestMode.compiler).runWith(pw, opts);\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/Main.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,0 +40,6 @@\n+    private final BlackholeTestMode mode;\n+\n+    public BlackholeSingleTest(BlackholeTestMode mode) {\n+        this.mode = mode;\n+    }\n+\n@@ -42,1 +48,1 @@\n-        pw.println(\"--------- BLACKHOLE SINGLE INVOCATION TEST\");\n+        pw.println(\"--------- BLACKHOLE SINGLE INVOCATION TEST (\" + blackholeModeString(mode) + \")\");\n@@ -52,0 +58,2 @@\n+        blackholeModeMessage(pw, mode);\n+\n","filename":"jmh-core-benchmarks\/src\/main\/java\/org\/openjdk\/jmh\/validation\/tests\/BlackholeSingleTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    \/**\n+    \/*\n@@ -239,0 +239,5 @@\n+     * There is an experimental compiler support for Blackholes that instructs compilers\n+     * to treat specific methods as blackholes: keeping their arguments alive. At some\n+     * point in the future, we hope to switch to that mode by default, thus greatly\n+     * simplifying the Blackhole code.\n+     *\n@@ -249,0 +254,2 @@\n+    private static final boolean COMPILER_BLACKHOLE = Boolean.getBoolean(\"compilerBlackholesEnabled\");\n+\n@@ -307,6 +314,4 @@\n-        int tlrMask = this.tlrMask; \/\/ volatile read\n-        int tlr = (this.tlr = (this.tlr * 1664525 + 1013904223));\n-        if ((tlr & tlrMask) == 0) {\n-            \/\/ SHOULD ALMOST NEVER HAPPEN IN MEASUREMENT\n-            this.obj1 = new WeakReference<>(obj);\n-            this.tlrMask = (tlrMask << 1) + 1;\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(obj);\n+        } else {\n+            consumeFull(obj);\n@@ -322,5 +327,4 @@\n-        byte b1 = this.b1; \/\/ volatile read\n-        byte b2 = this.b2;\n-        if ((b ^ b1) == (b ^ b2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.b1 = b; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(b);\n+        } else {\n+            consumeFull(b);\n@@ -336,5 +340,4 @@\n-        boolean bool1 = this.bool1; \/\/ volatile read\n-        boolean bool2 = this.bool2;\n-        if ((bool ^ bool1) == (bool ^ bool2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.bool1 = bool; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(bool);\n+        } else {\n+            consumeFull(bool);\n@@ -350,5 +353,4 @@\n-        char c1 = this.c1; \/\/ volatile read\n-        char c2 = this.c2;\n-        if ((c ^ c1) == (c ^ c2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.c1 = c; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(c);\n+        } else {\n+            consumeFull(c);\n@@ -364,5 +366,4 @@\n-        short s1 = this.s1; \/\/ volatile read\n-        short s2 = this.s2;\n-        if ((s ^ s1) == (s ^ s2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.s1 = s; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(s);\n+        } else {\n+            consumeFull(s);\n@@ -378,5 +379,4 @@\n-        int i1 = this.i1; \/\/ volatile read\n-        int i2 = this.i2;\n-        if ((i ^ i1) == (i ^ i2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.i1 = i; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(i);\n+        } else {\n+            consumeFull(i);\n@@ -392,5 +392,4 @@\n-        long l1 = this.l1; \/\/ volatile read\n-        long l2 = this.l2;\n-        if ((l ^ l1) == (l ^ l2)) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.l1 = l; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(l);\n+        } else {\n+            consumeFull(l);\n@@ -406,5 +405,4 @@\n-        float f1 = this.f1; \/\/ volatile read\n-        float f2 = this.f2;\n-        if (f == f1 & f == f2) {\n-            \/\/ SHOULD NEVER HAPPEN\n-            nullBait.f1 = f; \/\/ implicit null pointer exception\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(f);\n+        } else {\n+            consumeFull(f);\n@@ -420,0 +418,86 @@\n+        if (COMPILER_BLACKHOLE) {\n+            consumeCompiler(d);\n+        } else {\n+            consumeFull(d);\n+        }\n+    }\n+\n+    \/\/ Compiler blackholes block: let compilers figure out how to deal with it.\n+\n+    private static void consumeCompiler(boolean v) {}\n+    private static void consumeCompiler(byte v)    {}\n+    private static void consumeCompiler(short v)   {}\n+    private static void consumeCompiler(char v)    {}\n+    private static void consumeCompiler(int v)     {}\n+    private static void consumeCompiler(float v)   {}\n+    private static void consumeCompiler(double v)  {}\n+    private static void consumeCompiler(long v)    {}\n+    private static void consumeCompiler(Object v)  {}\n+\n+    \/\/ Full blackholes block: confuse compilers to get blackholing effects.\n+    \/\/ See implementation comments at the top to understand what this code is doing.\n+\n+    private void consumeFull(byte b) {\n+        byte b1 = this.b1; \/\/ volatile read\n+        byte b2 = this.b2;\n+        if ((b ^ b1) == (b ^ b2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.b1 = b; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(boolean bool) {\n+        boolean bool1 = this.bool1; \/\/ volatile read\n+        boolean bool2 = this.bool2;\n+        if ((bool ^ bool1) == (bool ^ bool2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.bool1 = bool; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(char c) {\n+        char c1 = this.c1; \/\/ volatile read\n+        char c2 = this.c2;\n+        if ((c ^ c1) == (c ^ c2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.c1 = c; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(short s) {\n+        short s1 = this.s1; \/\/ volatile read\n+        short s2 = this.s2;\n+        if ((s ^ s1) == (s ^ s2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.s1 = s; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(int i) {\n+        int i1 = this.i1; \/\/ volatile read\n+        int i2 = this.i2;\n+        if ((i ^ i1) == (i ^ i2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.i1 = i; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(long l) {\n+        long l1 = this.l1; \/\/ volatile read\n+        long l2 = this.l2;\n+        if ((l ^ l1) == (l ^ l2)) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.l1 = l; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(float f) {\n+        float f1 = this.f1; \/\/ volatile read\n+        float f2 = this.f2;\n+        if (f == f1 & f == f2) {\n+            \/\/ SHOULD NEVER HAPPEN\n+            nullBait.f1 = f; \/\/ implicit null pointer exception\n+        }\n+    }\n+\n+    private void consumeFull(double d) {\n@@ -428,0 +512,10 @@\n+    private void consumeFull(Object obj) {\n+        int tlrMask = this.tlrMask; \/\/ volatile read\n+        int tlr = (this.tlr = (this.tlr * 1664525 + 1013904223));\n+        if ((tlr & tlrMask) == 0) {\n+            \/\/ SHOULD ALMOST NEVER HAPPEN IN MEASUREMENT\n+            this.obj1 = new WeakReference<>(obj);\n+            this.tlrMask = (tlrMask << 1) + 1;\n+        }\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/Blackhole.java","additions":136,"deletions":42,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+\n+                \/\/ Set up Blackholes\n@@ -65,0 +67,2 @@\n+                hints.add(\"inline,org\/openjdk\/jmh\/infra\/Blackhole.consume\");\n+                hints.add(\"dontinline,org\/openjdk\/jmh\/infra\/Blackhole.consumeCPU\");\n@@ -66,1 +70,1 @@\n-                    hints.add(\"blackhole,org\/openjdk\/jmh\/infra\/Blackhole.consume\");\n+                    hints.add(\"blackhole,org\/openjdk\/jmh\/infra\/Blackhole.consumeCompiler\");\n@@ -69,1 +73,1 @@\n-                    hints.add(\"dontinline,org\/openjdk\/jmh\/infra\/Blackhole.consume\");\n+                    hints.add(\"dontinline,org\/openjdk\/jmh\/infra\/Blackhole.consumeFull\");\n@@ -71,1 +75,0 @@\n-                hints.add(\"dontinline,org\/openjdk\/jmh\/infra\/Blackhole.consumeCPU\");\n@@ -198,1 +201,1 @@\n-        if (needsDiagnosticUnlock()) {\n+        if (blackholeMode() == BlackholeMode.COMPILER) {\n@@ -200,0 +203,2 @@\n+            command.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            command.add(\"-DcompilerBlackholesEnabled=true\");\n@@ -249,9 +254,1 @@\n-        out.print(\"# JMH blackhole mode: \" + mode.desc());\n-\n-        \/\/ Experimental: since JDK 16, Compiler blackholing is available.\n-        \/\/ Tell user they can enable it explicitly. We need to consider enabling\n-        \/\/ this by default when JDK 16 stabilizes.\n-        if (!mode.shouldBlackhole() && compilerBlackholeAvailable()) {\n-            out.print(\"; set -D\" + BLACKHOLE_PROP_NAME + \"=\" + BlackholeMode.COMPILER.name() + \" to get compiler-assisted ones\");\n-        }\n-\n+        out.print(\"# Blackhole mode: \" + mode.desc());\n@@ -261,9 +258,0 @@\n-    private static boolean compilerBlackholeAvailable() {\n-        \/\/ See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8252505.\n-        return JDKVersion.parseMajor(System.getProperty(\"java.version\")) >= 16;\n-    }\n-\n-    private static boolean needsDiagnosticUnlock() {\n-        return blackholeMode() == BlackholeMode.COMPILER;\n-    }\n-\n@@ -271,3 +259,3 @@\n-        COMPILER(true, false, \"compiler-assisted blackhole\"),\n-        FULL_DONTINLINE(false, true, \"full blackhole + dont-inline hint\"),\n-        FULL(false, false, \"full blackhole\"),\n+        COMPILER(true, false, \"compiler-assisted (EXPERIMENTAL, check generated code)\"),\n+        FULL_DONTINLINE(false, true, \"full + dont-inline hint\"),\n+        FULL(false, false, \"full (DIAGNOSTIC)\"),\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/CompilerHints.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"}]}