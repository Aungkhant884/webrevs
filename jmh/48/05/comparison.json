{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import org.openjdk.jmh.util.JDKVersion;\n+import org.openjdk.jmh.util.Utils;\n@@ -49,1 +49,8 @@\n-    static final String BLACKHOLE_PROP_NAME = \"jmh.blackhole.mode\";\n+    static final String BLACKHOLE_MODE_NAME       = \"jmh.blackhole.mode\";\n+    static final String BLACKHOLE_AUTODETECT_NAME = \"jmh.blackhole.autoDetect\";\n+    static final String BLACKHOLE_DEBUG_NAME      = \"jmh.blackhole.debug\";\n+\n+    static final boolean BLACKHOLE_MODE_AUTODETECT =\n+            Boolean.parseBoolean(System.getProperty(BLACKHOLE_AUTODETECT_NAME, \"true\"));\n+    static final boolean BLACKHOLE_MODE_DEBUG =\n+            Boolean.parseBoolean(System.getProperty(BLACKHOLE_DEBUG_NAME, \"false\"));\n@@ -240,0 +247,3 @@\n+    private static BlackholeMode blackholeMode;\n+    private static BlackholeSelect blackholeSelect;\n+\n@@ -241,2 +251,7 @@\n-        String prop = System.getProperty(BLACKHOLE_PROP_NAME);\n-        if (prop != null) {\n+        if (blackholeMode != null) {\n+            return blackholeMode;\n+        }\n+\n+        \/\/ Forced mode takes precedence.\n+        String propMode = System.getProperty(BLACKHOLE_MODE_NAME);\n+        if (propMode != null) {\n@@ -244,1 +259,10 @@\n-                return BlackholeMode.valueOf(prop);\n+                blackholeMode = BlackholeMode.valueOf(propMode);\n+                blackholeSelect = BlackholeSelect.FORCED;\n+\n+                \/\/ Extra safety: If user requested compiler blackholes, check\n+                \/\/ if they are available and fail otherwise.\n+                if (blackholeMode.shouldBlackhole() && !compilerBlackholesAvailable()) {\n+                    throw new IllegalStateException(\"Compiler Blackholes are not available in current VM\");\n+                }\n+\n+                return blackholeMode;\n@@ -246,1 +270,10 @@\n-                throw new IllegalStateException(\"Unknown Blackhole mode: \" + prop);\n+                throw new IllegalStateException(\"Unknown Blackhole mode: \" + propMode);\n+            }\n+        }\n+\n+        \/\/ Try to autodetect blackhole mode\n+        if (BLACKHOLE_MODE_AUTODETECT) {\n+            if (compilerBlackholesAvailable()) {\n+                blackholeMode = BlackholeMode.COMPILER;\n+                blackholeSelect = BlackholeSelect.AUTO;\n+                return blackholeMode;\n@@ -249,1 +282,5 @@\n-        return BlackholeMode.FULL_DONTINLINE;\n+\n+        \/\/ No dice, fallback to older mode\n+        blackholeMode = BlackholeMode.FULL_DONTINLINE;\n+        blackholeSelect = BlackholeSelect.FALLBACK;\n+        return blackholeMode;\n@@ -252,4 +289,3 @@\n-    public static void printBlackholeMode(PrintStream out) {\n-        BlackholeMode mode = blackholeMode();\n-        out.print(\"# Blackhole mode: \" + mode.desc());\n-        out.println();\n+    private static BlackholeSelect blackholeSelect() {\n+        blackholeMode();\n+        return blackholeSelect;\n@@ -259,1 +295,1 @@\n-        COMPILER(true, false, \"compiler-assisted (EXPERIMENTAL, check generated code)\"),\n+        COMPILER(true, false, \"compiler\"),\n@@ -261,1 +297,1 @@\n-        FULL(false, false, \"full (DIAGNOSTIC)\"),\n+        FULL(false, false, \"full\"),\n@@ -285,0 +321,87 @@\n+    private enum BlackholeSelect {\n+        FALLBACK(\"fallback, use -D\" + BLACKHOLE_MODE_NAME + \" to force another mode\"),\n+        AUTO(\"auto-detected, use -D\" + BLACKHOLE_AUTODETECT_NAME + \"=false to disable\"),\n+        FORCED(\"forced\"),\n+        ;\n+\n+        final String desc;\n+\n+        BlackholeSelect(String desc) {\n+            this.desc = desc;\n+        }\n+\n+        public String desc() {\n+            return desc;\n+        }\n+    }\n+\n+    private static boolean compilerBlackholesAvailable() {\n+        \/\/ Step 1. See if there were any error messages from CompilerOracle\n+        {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(Utils.getCurrentJvm());\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            cmd.add(\"-XX:CompileCommand=quiet\");\n+            cmd.add(\"-XX:CompileCommand=blackhole,some\/fake\/Class.method\");\n+            cmd.add(\"-version\");\n+\n+            debug(\"Blackhole command errors test:\");\n+\n+            Collection<String> log = Utils.runWith(cmd);\n+            for (String l : log) {\n+                debug(l);\n+                if (l.contains(\"CompilerOracle\") || l.contains(\"CompileCommand\")) {\n+                    debug(\"Found the suspected error line, no compiler blackholes.\");\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        \/\/ Step 2. See that CompilerOracle accepted the command explicitly\n+        {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(Utils.getCurrentJvm());\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            cmd.add(\"-XX:CompileCommand=blackhole,some\/fake\/Class.method\");\n+            cmd.add(\"-version\");\n+\n+            debug(\"Blackhole command acceptance test:\");\n+\n+            Collection<String> log = Utils.runWith(cmd);\n+            for (String l : log) {\n+                debug(l);\n+                if (l.contains(\"CompilerOracle\") || l.contains(\"CompileCommand\")) {\n+                    debug(\"Found the acceptance line, compiler blackholes are available.\");\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        \/\/ Err on the side of the caution: compiler blackholes are not available.\n+        debug(\"Compiler blackholes are not available.\");\n+        return false;\n+    }\n+\n+    private static void debug(String msg) {\n+        if (BLACKHOLE_MODE_DEBUG) {\n+            System.out.println(msg);\n+        }\n+    }\n+\n+    public static void printBlackhole(PrintStream out) {\n+        BlackholeMode mode = blackholeMode();\n+        out.print(\"# Blackhole: \" + mode.desc() + \" (\" + blackholeSelect().desc() + \")\");\n+        out.println();\n+    }\n+\n+    public static void printWarnings(PrintStream out) {\n+        if (blackholeMode() == BlackholeMode.COMPILER) {\n+            out.println(\"NOTE: Current JVM experimentally supports Compiler Blackholes, and they are in use. Please exercise\");\n+            out.println(\"extra caution when trusting the results, look into the generated code to check the benchmark still\");\n+            out.println(\"works, and factor in a small probability of new VM bugs. Additionally, while comparisons between\");\n+            out.println(\"different JVMs are already problematic, the performance difference caused by different Blackhole\");\n+            out.println(\"modes can be very significant. Please make sure you use the consistent Blackhole mode for comparisons.\");\n+            out.println();\n+        }\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/CompilerHints.java","additions":136,"deletions":13,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        CompilerHints.printBlackholeMode(out);\n+        CompilerHints.printBlackhole(out);\n@@ -244,0 +244,2 @@\n+        CompilerHints.printWarnings(out);\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/format\/TextReportFormat.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}