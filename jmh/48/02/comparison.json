{"files":[{"patch":"@@ -28,1 +28,1 @@\n-import org.openjdk.jmh.util.JDKVersion;\n+import org.openjdk.jmh.util.Utils;\n@@ -49,1 +49,2 @@\n-    static final String BLACKHOLE_PROP_NAME = \"jmh.blackhole.mode\";\n+    static final String BLACKHOLE_MODE_PROP_NAME = \"jmh.blackhole.mode\";\n+    static final String BLACKHOLE_MODE_AUTODETECT_NAME = \"jmh.blackhole.autoDetect\";\n@@ -240,0 +241,3 @@\n+    private static BlackholeMode blackholeMode;\n+    private static BlackholeDetectMode blackholeDetectMode;\n+\n@@ -241,2 +245,7 @@\n-        String prop = System.getProperty(BLACKHOLE_PROP_NAME);\n-        if (prop != null) {\n+        if (blackholeMode != null) {\n+            return blackholeMode;\n+        }\n+\n+        \/\/ Forced mode takes precedence.\n+        String propMode = System.getProperty(BLACKHOLE_MODE_PROP_NAME);\n+        if (propMode != null) {\n@@ -244,1 +253,10 @@\n-                return BlackholeMode.valueOf(prop);\n+                blackholeMode = BlackholeMode.valueOf(propMode);\n+                blackholeDetectMode = BlackholeDetectMode.FORCED;\n+\n+                \/\/ Extra safety: If user requested compiler blackholes, check\n+                \/\/ if they are available and fail otherwise.\n+                if (blackholeMode.shouldBlackhole() && !compilerBlackholesAvailable()) {\n+                    throw new IllegalStateException(\"Compiler Blackholes are not available in current VM\");\n+                }\n+\n+                return blackholeMode;\n@@ -246,1 +264,1 @@\n-                throw new IllegalStateException(\"Unknown Blackhole mode: \" + prop);\n+                throw new IllegalStateException(\"Unknown Blackhole mode: \" + propMode);\n@@ -249,1 +267,19 @@\n-        return BlackholeMode.FULL_DONTINLINE;\n+\n+        \/\/ Try to autodetect blackhole mode\n+        if (Boolean.getBoolean(BLACKHOLE_MODE_AUTODETECT_NAME)) {\n+            if (compilerBlackholesAvailable()) {\n+                blackholeMode = BlackholeMode.COMPILER;\n+                blackholeDetectMode = BlackholeDetectMode.AUTO;\n+                return blackholeMode;\n+            }\n+        }\n+\n+        \/\/ No dice, fallback to older mode\n+        blackholeMode = BlackholeMode.FULL_DONTINLINE;\n+        blackholeDetectMode = BlackholeDetectMode.FALLBACK;\n+        return blackholeMode;\n+    }\n+\n+    private static BlackholeDetectMode blackholeDetectMode() {\n+        blackholeMode();\n+        return blackholeDetectMode;\n@@ -254,1 +290,1 @@\n-        out.print(\"# Blackhole mode: \" + mode.desc());\n+        out.print(\"# Blackhole mode: \" + mode.desc() + \" (\" + blackholeDetectMode().desc() + \")\");\n@@ -259,1 +295,1 @@\n-        COMPILER(true, false, \"compiler-assisted (EXPERIMENTAL, check generated code)\"),\n+        COMPILER(true, false, \"compiler-assisted\"),\n@@ -261,1 +297,1 @@\n-        FULL(false, false, \"full (DIAGNOSTIC)\"),\n+        FULL(false, false, \"full\"),\n@@ -285,0 +321,53 @@\n+    private enum BlackholeDetectMode {\n+        FALLBACK(\"fallback, use -D\" + BLACKHOLE_MODE_PROP_NAME + \" to force another mode\"),\n+        AUTO(\"auto-detected, use -D\" + BLACKHOLE_MODE_AUTODETECT_NAME + \"=false to disable\"),\n+        FORCED(\"forced\"),\n+        ;\n+\n+        final String desc;\n+\n+        BlackholeDetectMode(String desc) {\n+            this.desc = desc;\n+        }\n+\n+        public String desc() {\n+            return desc;\n+        }\n+    }\n+\n+    private static boolean compilerBlackholesAvailable() {\n+        \/\/ Step 1. See if there were any error messages from CompilerOracle\n+        {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(Utils.getCurrentJvm());\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            cmd.add(\"-XX:CompileCommand=quiet\");\n+            cmd.add(\"-XX:CompileCommand=blackhole,some\/fake\/Class.method\");\n+            cmd.add(\"-version\");\n+\n+            Collection<String> log = Utils.runWith(cmd);\n+            for (String l : log) {\n+                if (l.contains(\"CompilerOracle\")) return false;\n+                if (l.contains(\"CompileCommand\")) return false;\n+            }\n+        }\n+\n+        \/\/ Step 2. See that CompilerOracle accepted the command explicitly\n+        {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(Utils.getCurrentJvm());\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            cmd.add(\"-XX:CompileCommand=blackhole,some\/fake\/Class.method\");\n+            cmd.add(\"-version\");\n+\n+            Collection<String> log = Utils.runWith(cmd);\n+            for (String l : log) {\n+                if (l.contains(\"CompilerOracle\")) return true;\n+                if (l.contains(\"CompileCommand\")) return true;\n+            }\n+        }\n+\n+        \/\/ Err on the side of the caution: compiler blackholes are not available.\n+        return false;\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/CompilerHints.java","additions":99,"deletions":10,"binary":false,"changes":109,"status":"modified"}]}