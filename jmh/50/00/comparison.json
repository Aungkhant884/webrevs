{"files":[{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.it.params;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.it.Fixtures;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Measurement(iterations = 1, time = 100, timeUnit = TimeUnit.MICROSECONDS)\n+@Warmup(iterations = 1, time = 100, timeUnit = TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+public class JavaIntegerLiteralTest {\n+\n+    @Param({\"0b01_10__0\", \"0B01_10__0\"})\n+    public int binary;\n+\n+    @Param({\"0B01_10__0\"})\n+    public int binary2;\n+\n+    @Param({\"01_23\"})\n+    public byte oct;\n+\n+    @Param({\"1__0____9\"})\n+    public short dec;\n+\n+    @Param({\"0__1234___5\"})\n+    public int oct2;\n+\n+    @Param({\"0x12_34\"})\n+    public long hex;\n+\n+    @Param({\"0XF__F_FF\"})\n+    public int hex2;\n+\n+    @Benchmark\n+    public void test() {\n+        Assert.assertEquals(0b01_10__0, binary);\n+        Assert.assertEquals(0B01_10__0, binary2);\n+        Assert.assertEquals(01_23, oct);\n+        Assert.assertEquals(0__1234___5, oct2);\n+        Assert.assertEquals(1__0____9, dec);\n+        Assert.assertEquals(0x12_34, hex);\n+        Assert.assertEquals(0XF__F_FF, hex2);\n+    }\n+\n+    @Test\n+    public void testValidArguments() throws RunnerException {\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .shouldFailOnError(true)\n+                .build();\n+\n+        new Runner(opts).run();\n+    }\n+\n+    @Test\n+    public void testInvalidArguments() {\n+        testFailsOnInvalidLiteral(\"dec\", \"0_\");\n+        testFailsOnInvalidLiteral(\"dec\", \"_\");\n+        testFailsOnInvalidLiteral(\"dec\", \"_0\");\n+        testFailsOnInvalidLiteral(\"hex\", \"0x_F\");\n+        testFailsOnInvalidLiteral(\"hex\", \"0_xF\");\n+    }\n+\n+    private void testFailsOnInvalidLiteral(String name, String value) {\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .param(name, value)\n+                .shouldFailOnError(true)\n+                .build();\n+\n+        try {\n+            new Runner(opts).run();\n+            Assert.fail();\n+        } catch (RunnerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/params\/JavaIntegerLiteralTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -513,1 +513,2 @@\n-                FailureAssistException.class\n+                FailureAssistException.class,\n+                NumericLiteralsParser.class\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/generators\/core\/BenchmarkGenerator.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.generators.core;\n+\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Java literals support for benchmark generator.\n+ * <p>\n+ * This class is designed for JMH-specific usages and is not\n+ * supposed to be stable, backwards-compatible or usable outside JMH machinery.\n+ *\/\n+public final class NumericLiteralsParser {\n+    \/*\n+     * Regexes are written looking at JLS 3.10.x grammar.\n+     * Trailing 'L' in long literals is not supported.\n+     *\n+     * Grammar:\n+     *\n+     * ### Integers\n+     * IntegerLiteral = (DecimalNumeral | HexNumeral | OctalNumeral | BinaryNumeral) [lL]?\n+     * Digits = [0-9] ([0-9_]* [0-9])? \/\/ Same pattern for others\n+     * DecimalNumeral = 0 | [1-9] [0-9]* | [1-9] [_]+ Digits\n+     *\n+     * HexNumeral = 0 [xX] HexDigits\n+     * BinaryNumeral = 0 [bB] BinaryDigits\n+     * OctalNumeral = 0 [_]* OctalDigits\n+     *\n+     * ### Floating points\n+     * FloatingPointLiteral = (DecimalFloatingPointLiteral | HexadecimalFloatingPointLiteral) [fFdD]?\n+     *\n+     * DecimalFloatingPointLiteral =\n+     *     Digits . Digits? Exponent?\n+     *     . Digits Exponent?\n+     *     Digits Exponent?\n+     *\n+     * Exponent = [eE] [+-]? Digits\n+     *\n+     * HexadecimalFloatingPointLiteral = HexSignificand BinaryExponent\n+     * BinaryExponent = [pP] [+-]? Digits\n+     * HexSignificand = HexNumeral (. HexDigits)?\n+     *\/\n+\n+    \/*\n+     * Regex that checks whether the given string is a valid Java integer (not FP!) literal.\n+     *\/\n+    private static final Pattern INTEGRAL_PATTERN = Pattern.compile(\"(\" +\n+            \"0[bB][01]([01_]*[01])?|\" + \/\/ Binary literals\n+            \"0_*[0-7]([0-7_]*[0-7])?|\" + \/\/ Oct literals\n+            \"(0|[1-9]([0-9_]*[0-9])?)|\" + \/\/ Dec literals\n+            \"0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?\" + \/\/ Hex literals\n+            \")\"\n+    );\n+\n+    private NumericLiteralsParser() {\n+    }\n+\n+    \/*\n+     * parseX methods are invoked directly from the generated benchmarks.\n+     * throwIfInvalidLiteral is invoked first to filter out things like trailing underscores etc.\n+     * that parse function just unconditionally trim.\n+     * We cannot ensure that the given `value` was checked via `StateObjectHandler.isParamValueConforming`\n+     * because of user-supplied or cmd-overridden arguments.\n+     *\/\n+\n+    public static byte parseByte(String value) {\n+        throwIfInvalidLiteral(value);\n+        return (byte) parseIntegral(value, Type.BYTE);\n+    }\n+\n+    public static short parseShort(String value) {\n+        throwIfInvalidLiteral(value);\n+        return (short) parseIntegral(value, Type.SHORT);\n+    }\n+\n+    public static int parseInt(String value) {\n+        throwIfInvalidLiteral(value);\n+        return (int) parseIntegral(value, Type.INT);\n+    }\n+\n+    public static long parseLong(String value) {\n+        throwIfInvalidLiteral(value);\n+        return parseIntegral(value, Type.LONG);\n+    }\n+\n+    public static float parseFloat(String value) {\n+        \/\/ TODO maybe just trim underscores?\n+        return Float.parseFloat(value);\n+    }\n+\n+    public static double parseDouble(String value) {\n+        \/\/ TODO maybe just trim underscores?\n+        return Double.parseDouble(value);\n+    }\n+\n+    private static void throwIfInvalidLiteral(String value) {\n+         if (!INTEGRAL_PATTERN.matcher(value).matches()) {\n+             \/\/ Mimic parse* exception. The exact type will be shown in the second frame\n+             throw new NumberFormatException(\"For input string: \\\"\" + value + \"\\\"\");\n+         }\n+    }\n+\n+    private static long parseIntegral(String value, Type type) {\n+        \/\/ Invariant: value matches INTEGRAL_PATTERN\n+        value = value.replace(\"_\", \"\");\n+        if (value.startsWith(\"0b\") || value.startsWith(\"0B\")) { \/\/ Binary\n+            String trimmed = value\n+                    .replaceFirst(\"0b\", \"\")\n+                    .replaceFirst(\"0B\", \"\");\n+            return type.parse(trimmed, 2);\n+        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) { \/\/ Hex\n+            String trimmed = value\n+                    .replaceFirst(\"0x\", \"\")\n+                    .replaceFirst(\"0X\", \"\");\n+            return type.parse(trimmed, 16);\n+        } else if (value.startsWith(\"0\") && value.length() > 1) { \/\/ Oct\n+            String trimmed = value\n+                    .replaceFirst(\"0\", \"\");\n+            return type.parse(trimmed, 8);\n+        } else { \/\/ Dec\n+            return type.parse(value, 10);\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the given value (received from arguments of `@Param()` annotation)\n+     * complies the given primitive type.\n+     *\/\n+    static boolean isValidLiteral(String value, Type type) {\n+        if (!INTEGRAL_PATTERN.matcher(value).matches()) {\n+            return false;\n+        }\n+\n+        try {\n+            \/\/ Can pass the regex, but still be e.g. too wide for the type\n+            parseIntegral(value, type);\n+            return true;\n+        } catch (NumberFormatException e) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ Package-private, available only for StateObjectHandler for static check\n+    enum Type {\n+\n+        BYTE {\n+            @Override\n+            public long parse(String value, int radix) {\n+                return Byte.parseByte(value, radix);\n+            }\n+        },\n+\n+        SHORT {\n+            @Override\n+            public long parse(String value, int radix) {\n+                return Short.parseShort(value, radix);\n+            }\n+        },\n+\n+        INT {\n+            @Override\n+            public long parse(String value, int radix) {\n+                return Integer.parseInt(value, radix);\n+            }\n+        },\n+\n+        LONG {\n+            @Override\n+            public long parse(String value, int radix) {\n+                return Long.parseLong(value, radix);\n+            }\n+        };\n+\n+        public abstract long parse(String value, int radix);\n+    }\n+}\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/generators\/core\/NumericLiteralsParser.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -116,1 +116,0 @@\n-\n@@ -124,1 +123,1 @@\n-            return \"Byte.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseByte(control.getParam(\\\"\" + name + \"\\\"))\";\n@@ -130,1 +129,1 @@\n-            return \"Short.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseShort(control.getParam(\\\"\" + name + \"\\\"))\";\n@@ -133,1 +132,1 @@\n-            return \"Integer.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseInt(control.getParam(\\\"\" + name + \"\\\"))\";\n@@ -136,1 +135,1 @@\n-            return \"Float.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseFloat(control.getParam(\\\"\" + name + \"\\\"))\";\n@@ -139,1 +138,1 @@\n-            return \"Long.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseLong(control.getParam(\\\"\" + name + \"\\\"))\";\n@@ -142,1 +141,1 @@\n-            return \"Double.valueOf(control.getParam(\\\"\" + name + \"\\\"))\";\n+            return \"NumericLiteralsParser.parseDouble(control.getParam(\\\"\" + name + \"\\\"))\";\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/generators\/core\/StateObject.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -476,6 +476,1 @@\n-            try {\n-                Byte.parseByte(val);\n-                return true;\n-            } catch (NumberFormatException nfe) {\n-                return false;\n-            }\n+            return NumericLiteralsParser.isValidLiteral(val, NumericLiteralsParser.Type.BYTE);\n@@ -487,6 +482,1 @@\n-            try {\n-                Short.parseShort(val);\n-                return true;\n-            } catch (NumberFormatException nfe) {\n-                return false;\n-            }\n+            return NumericLiteralsParser.isValidLiteral(val, NumericLiteralsParser.Type.SHORT);\n@@ -495,6 +485,1 @@\n-            try {\n-                Integer.parseInt(val);\n-                return true;\n-            } catch (NumberFormatException nfe) {\n-                return false;\n-            }\n+            return NumericLiteralsParser.isValidLiteral(val, NumericLiteralsParser.Type.INT);\n@@ -511,6 +496,1 @@\n-            try {\n-                Long.parseLong(val);\n-                return true;\n-            } catch (NumberFormatException nfe) {\n-                return false;\n-            }\n+            return NumericLiteralsParser.isValidLiteral(val, NumericLiteralsParser.Type.LONG);\n@@ -530,1 +510,1 @@\n-        \/\/ OK to have these annotation for @State objects\n+        \/\/ OK to have these annotations for @State objects\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/generators\/core\/StateObjectHandler.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.generators.core;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class NumericLiteralsParserTest {\n+    @Test\n+    public void testIntegerLiteral() {\n+        testValidIntegerLiteral(10, \"10\");\n+        testValidIntegerLiteral(1_0, \"10\");\n+        testValidIntegerLiteral(1__0__0, \"1__0__0\");\n+        testValidIntegerLiteral(0xFFF, \"0xFFF\");\n+        testValidIntegerLiteral(0xF__F_F, \"0xF__F_F\");\n+        testValidIntegerLiteral(0000, \"0000\");\n+        testValidIntegerLiteral(0_1234, \"0_1234\");\n+        testValidIntegerLiteral(0_12___3_4, \"0_12___3_4\");\n+        testValidIntegerLiteral(0b0_000, \"0b0_000\");\n+        testValidIntegerLiteral(0b0_1___00, \"0b0_1___00\");\n+\n+        testInvalidIntegerLiteral(\"_00\");\n+        testInvalidIntegerLiteral(\"00_\");\n+        testInvalidIntegerLiteral(\"123_\");\n+        testInvalidIntegerLiteral(\"0x_F\");\n+        testInvalidIntegerLiteral(\"0_xF\");\n+        testInvalidIntegerLiteral(\"0b1212\");\n+        testInvalidIntegerLiteral(\"09\");\n+        testInvalidIntegerLiteral(\"0_9\");\n+    }\n+\n+    private void testValidIntegerLiteral(int actualValue, String literal) {\n+        Assert.assertTrue(NumericLiteralsParser.isValidLiteral(literal, NumericLiteralsParser.Type.INT));\n+        assertEquals(actualValue, NumericLiteralsParser.parseInt(literal));\n+    }\n+\n+    private void testInvalidIntegerLiteral(String literal) {\n+        Assert.assertFalse(NumericLiteralsParser.isValidLiteral(literal, NumericLiteralsParser.Type.INT));\n+        try {\n+            NumericLiteralsParser.parseInt(literal);\n+            fail();\n+        } catch (NumberFormatException e) {\n+            \/\/ Nothing\n+        }\n+    }\n+}\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/generators\/core\/NumericLiteralsParserTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}