{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## jextract\n+## Jextract\n@@ -3,1 +3,1 @@\n-`jextract` is a tool that mechanically generates Java bindings from a native library headers. We would like to include this tool, originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)) in the set of tools that are part of the code-tools project.\n+`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated with a given native library, and the generated Java bindings build upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/419). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n@@ -5,1 +5,1 @@\n-The Java SE 18 API defines an [incubating API](https:\/\/openjdk.java.net\/jeps\/419) to:\n+### Getting started\n@@ -7,1 +7,1 @@\n-* manipulate foreign memory, that is memory which resides *outside* the Java heap; and\n+`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html) (a version >= 9 is required). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/419), so a suitable [jdk 18 distribution](https:\/\/jdk.java.net\/18\/) is also required.\n@@ -9,1 +9,1 @@\n-* invoke foreign functions, that is functions whose implementation is not defined in Java.\n+`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead):\n@@ -11,18 +11,2 @@\n-To allocate and access off-heap memory, clients can use the `MemorySegment` API. Memory segments can be associated with optional *layouts* (e.g `MemoryLayout`) which describe the contents of a given memory region and can be used to derive access expression e.g. into a struct field:\n-\n-```java\n-\/\/ struct Point2d {\n-\/\/     double x;\n-\/\/     double y;\n-\/\/ }\n-MemoryLayout POINT_2D = MemoryLayout.structLayout(\n-        ValueLayout.JAVA_DOUBLE.withName(\"x\"),\n-        ValueLayout.JAVA_DOUBLE.withName(\"y\"),\n-);\n-\n-VarHandle xHandle = POINT_2D.varHandle(PathElement.groupElement(\"x\")); \/\/ var handle to access Point2d::x\n-VarHandle yHandle = POINT_2D.varHandle(PathElement.groupElement(\"y\")); \/\/ var handle to access Point2d::x\n-\n-MemorySegment segment = MemorySegment.allocateNative(POINT_2D, ReosurceScope.newImplicitScope());\n-xHandle.set(segment, 3d);\n-yHandle.set(segment, 4d);\n+```sh\n+$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -Plibclang_home=<libclang_dir> clean verify\n@@ -31,1 +15,1 @@\n-Furthermore, clients can use the `CLinker` API to create a so called *downcall* method handle, that is, a method handle which targets a native function, directly:\n+After building, there should be a new `jextract` folder under `build` (the contents and the name of this folder might vary slightly depending on the platform):\n@@ -33,6 +17,11 @@\n-```java\n-\/\/ double distance(struct Point2d);\n-MethodHandle distance = CLinker.systemCLinker().downcallHandle(\n-                                    LibraryLookup.loaderLookup().lookup(\"distance\").get()\n-                                    FunctionDescriptor.of(ValueLayout.JAVA_DOUBLE, POINT_2D);\n-distance.invoke(segment);\n+```\n+build\/jextract\n+├── bin\n+└── lib\n+    ├── app\n+    └── runtime\n+        ├── bin\n+        ├── conf\n+        ├── include\n+        ├── legal\n+        └── lib\n@@ -41,7 +30,1 @@\n-While the new APIs allow clients to manipulate off-heap memory and call native functions using only Java code (unlike JNI), handwriting the above code can be tedious and error-prone, especially when working with big libraries. For instance, inferring the layout of a struct is not an easy task, given that different platforms might have different size and alignment requirements, resulting in different padding bits inserted in the struct layout.\n-\n-Indeed, when working with big libraries, it would be far more convenient to rely on some tool which:\n-\n-* is able to parse the contents of the header file of a given native library;\n-* identify the set of functions, structs and constant symbols that need to be generated;\n-* for each of the symbols identified in the previous step, emit a Java binding using the Java 18 API.\n+To run the `jextract` tool, simply run the `jextract` command in the `bin` folder (again, the exact location of the binary might vary slightly depending on the platform):\n@@ -49,1 +32,5 @@\n-In other word, to work with a given native library, a developer would have to point the tool to the header file(s) of said library; the tool will then generate a set of Java sources that the developer can check-in into the source code repository, and then update when required (e.g. when the native library is updated), by re-running the tool.\n+```sh\n+build\/jextract\/bin\/jextract \n+WARNING: Using incubator modules: jdk.incubator.foreign\n+Expected a header file\n+```\n@@ -51,1 +38,1 @@\n-### Description\n+The repository also contains a comprehensive set of tests, written using the [jtreg](https:\/\/openjdk.java.net\/jtreg\/) test framework, which can be run as follows (again, on Windows, `gradlew.bat` should be used instead):\n@@ -53,1 +40,3 @@\n-`jextract` is a tool that leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated to a given native library and generate the Java glue code that is required to interact with said library. More specifically, jextract generates the following code:\n+```sh\n+$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -Plibclang_home=<libclang_dir> jtreg\n+```\n@@ -55,8 +44,1 @@\n-* for each native function, a downcall method handle constant is created and a small static method which wraps the downcall method handle invocation (`invokeExact`) is also generated;\n-* for each global variable, some static accessor methods are generated, which can be used to get, set or retrieve the address of the global variable;\n-* for each struct\/union type, a `MemoryLayout` constant is generated, which describes the platform-specific layout of the struct\/union. Moreover, for each struct\/union, some static accessor methods for all fields in the struct\/union are also generated. These accessors can be used to get, set or retrieve the address of a field in a given struct.\n-* for each function pointer type mentioned in function signatures, global variables or struct\/union field types, a new functional interface is emitted, together with a static factory method, which allows clients to create a function pointer (of type `MemoryAddress`) using a simple Java lambda expression, or a method reference;\n-* for each constant defined using the  `#define`  directive, a numeric constant (of a suitable Java primitive type) or pointer constant (of type `MemoryAddress`) is generated;\n-* for each enum constant, a numeric constant (of a suitable Java primitive type) is generated;\n-* each `typedef` is visited recursively. If the entity being defined is a struct\/union, then the struct\/union is processed accordingly (see above). If the entity being defined is a function pointer, then the function pointer is processed accordingly (see above). If the `typedef` refers to a primitive type, an additional `MemoryLayout` constant is generated;\n-* finally, a starter set of `MemoryLayout` constants (for each basic C type) is also generated.\n+### Using jextract\n@@ -129,1 +111,3 @@\n-In other words, the `jextract` tool has generated all the required supporting code (`MemoryLayout`, `MethodHandle` and `FunctionDescriptor`) that is needed to call the underlying `distance` native function.\n+In other words, the `jextract` tool has generated all the required supporting code (`MemoryLayout`, `MethodHandle` and `FunctionDescriptor`) that is needed to call the underlying `distance` native function. For more examples on how to use the `jextract` tool with real-world libraries, please refer to the [samples folder](samples) (building\/running particular sample may require specific third-party software installation).\n+\n+#### Command line options\n@@ -131,1 +115,16 @@\n-The `jextract` tool includes several customization options. Users can select what in which package the generated code should be emitted, and what the name of the main extracted class should be. To allow for symbol filtering, jextract can generate a *dump* of all the symbols encountered in an header file; this dump can be manipulated, and then used as an argument file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate bindings only for a *subset* of symbols seen by `jextract`. For instance, if we run `jextract` with as follows:\n+The `jextract` tool includes several customization options. Users can select in which package the generated code should be emitted, and what the name of the main extracted class should be. A complete list of all the supported options is given below:\n+\n+| Option                                                       | Meaning                                                      |\n+| :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `--header-class-name <String>`                               | specify the name of the main header class                       |\n+| `-t, --target-package <String>`                              | specify target package for the generated bindings            |\n+| `-I <String>`                                                | specify include files path for the clang parser              |\n+| `-l <String>`                                                | specify a library that will be loaded by the generated bindings |\n+| `-d <String>`                                                | specify where to place generated files                       |\n+| `--source`                                                   | generate java sources instead of classfiles                  |\n+| `--dump-includes <String>`                                   | dump included symbols into specified file (see below)        |\n+| `--include-[function,macro,struct,union,typedef,var]<String>` | Include a symbol of the given name and kind in the generated bindings (see below). When one of these options is specified, any symbol that is not matched by any specified filters is omitted from the generated bindings. |\n+\n+#### Filtering symbols\n+\n+To allow for symbol filtering, `jextract` can generate a *dump* of all the symbols encountered in an header file; this dump can be manipulated, and then used as an argument file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate bindings only for a *subset* of symbols seen by `jextract`. For instance, if we run `jextract` with as follows:\n@@ -146,1 +145,1 @@\n-This file can be passed back to jextract, as follows:\n+This file can be passed back to `jextract`, as follows:\n@@ -154,39 +153,0 @@\n-For more examples on how to use the `jextract` tool with real-world libraries, please refer to this [document](https:\/\/github.com\/openjdk\/panama-foreign\/blob\/d8c0fe5918cb1c6c744eb26797ea4fa04142c237\/doc\/panama_jextract.md).\n-\n-\n-### Building jextract tool\n-\n-jextract depends on clang+LLVM binaries. Please download and install clang+LLVM binaries for your platform.\n-You can find the prebuilt binaries from [https:\/\/releases.llvm.org\/download.html](https:\/\/releases.llvm.org\/download.html). The path of the clang+LLVM installation is provided using the `libclang_home` variable.\n-\n-Gradle tool needs jdk 17 or below to run. JAVA_HOME should be set to\n-jdk 17 or below. Or PATH should contain java from jdk 17 or below. jdk18 build is\n-needed to build jextract which is passed from command with -Pjdk18_home option.\n-\n-You can download jdk18 early access build from [https:\/\/jdk.java.net\/18\/](https:\/\/jdk.java.net\/18\/)\n-\n-For Windows, please use gradlew.bat.\n-\n-```sh\n-\n-$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -Plibclang_home=<libclang_dir> clean verify\n-\n-```\n-\n-### Testing jextract tool\n-\n-jextract tests are written for jtreg test framework. Please download and install jtreg binaries.\n-The path of the jtreg installation is provided using the `jtreg_home` variable.\n-\n-For Windows, please use gradlew.bat.\n-\n-```sh\n-\n-$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -Plibclang_home=<libclang_dir> -Pjtreg_home=<jtreg_dir> clean jtreg\n-\n-```\n-\n-### jextract samples\n-\n-jextract samples can be found \"samples\" top-level directory. Building\/running particular sample may require\n-specific third-party software installation.\n","filename":"README.md","additions":50,"deletions":90,"binary":false,"changes":140,"status":"modified"}]}