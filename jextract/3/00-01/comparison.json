{"files":[{"patch":"@@ -3,1 +3,1 @@\n-`jextract` is a tool that mechanically generates Java bindings from a native library headers. We would like to include this tool, originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)) in the set of tools that are part of the code-tools project.\n+`jextract` is a tool which mechanically generates Java bindings from a native library headers. This tools leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated to a given native library, and the generated Java bindings builds upon the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/419). The `jextract` tool was originally developed in the context of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/) (and then made available in the Project Panama [Early Access binaries](https:\/\/jdk.java.net\/panama\/)).\n@@ -7,1 +7,1 @@\n-The jextract tool depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html). Both the jextract tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/419), so a suitable [jdk 18 distribution](https:\/\/jdk.java.net\/18\/) is also required.\n+`jextract` depends on the [C libclang API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html). To build the jextract sources, the easiest option is to download LLVM binaries for your platform, which can be found [here](https:\/\/releases.llvm.org\/download.html). Both the `jextract` tool and the bindings it generates depend heavily on the [Foreign Function & Memory API](https:\/\/openjdk.java.net\/jeps\/419), so a suitable [jdk 18 distribution](https:\/\/jdk.java.net\/18\/) is also required.\n@@ -9,1 +9,1 @@\n-The jextract tool can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead):\n+`jextract` can be built using `gradle`, as follows (on Windows, `gradlew.bat` should be used instead):\n@@ -25,6 +25,0 @@\n-        │   ├── jextract\n-        │   ├── sdp\n-        │   └── security\n-        │       └── policy\n-        │           ├── limited\n-        │           └── unlimited\n@@ -32,1 +26,0 @@\n-        │   └── linux\n@@ -34,6 +27,0 @@\n-        │   ├── java.base\n-        │   ├── java.compiler\n-        │   ├── java.prefs\n-        │   ├── java.xml\n-        │   ├── jdk.compiler\n-        │   └── jdk.incubator.foreign\n@@ -41,2 +28,0 @@\n-            ├── security\n-            └── server\n@@ -45,1 +30,1 @@\n-To run jextract, simply run the `jextract` command in the `bin` folder:\n+To run the `jextract` tool, simply run the `jextract` command in the `bin` folder:\n@@ -61,1 +46,1 @@\n-`jextract` is a tool that leverages the [clang C API](https:\/\/clang.llvm.org\/doxygen\/group__CINDEX.html) in order to parse the headers associated to a given native library and generate the Java glue code that is required to interact with said library. To understand how `jextract` works, consider the following C header file:\n+To understand how `jextract` works, consider the following C header file:\n@@ -130,1 +115,1 @@\n-The `jextract` tool includes several customization options. Users can select what in which package the generated code should be emitted, and what the name of the main extracted class should be. To allow for symbol filtering, jextract can generate a *dump* of all the symbols encountered in an header file; this dump can be manipulated, and then used as an argument file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate bindings only for a *subset* of symbols seen by `jextract`. For instance, if we run `jextract` with as follows:\n+The `jextract` tool includes several customization options. Users can select what in which package the generated code should be emitted, and what the name of the main extracted class should be. To allow for symbol filtering, `jextract` can generate a *dump* of all the symbols encountered in an header file; this dump can be manipulated, and then used as an argument file (using the `@argfile` syntax also available in other JDK tools) to e.g. generate bindings only for a *subset* of symbols seen by `jextract`. For instance, if we run `jextract` with as follows:\n@@ -145,1 +130,1 @@\n-This file can be passed back to jextract, as follows:\n+This file can be passed back to `jextract`, as follows:\n","filename":"README.md","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"}]}