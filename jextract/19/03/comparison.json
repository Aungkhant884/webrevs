{"files":[{"patch":"@@ -7,2 +7,0 @@\n-    \/\/ moditect for module-info.class injection\n-    id \"org.moditect.gradleplugin\" version \"1.0.0-rc3\"\n@@ -41,4 +39,0 @@\n-dependencies {\n-    implementation \"net.sf.jopt-simple:jopt-simple:5.0.4\"\n-}\n-\n@@ -54,1 +48,1 @@\n-    archiveBaseName = 'jextract'\n+    archiveBaseName = 'org.openjdk.jextract'\n@@ -58,44 +52,0 @@\n-moditect {\n-    \/\/ moditect uses java.home to find JDK tools\n-    System.setProperty(\"java.home\", \"$jdk18_home\")\n-\n-    \/\/ inject module-info.class for org.openjdk.jextract module\n-    addMainModuleInfo {\n-        dependsOn build\n-\n-        jvmVersion = '18'\n-        version = project.version\n-        module {\n-            moduleInfoSource = '''\n-                module org.openjdk.jextract {\n-                    requires transitive java.compiler;\n-                    requires transitive jdk.incubator.foreign;\n-                    requires jopt.simple;\n-                    requires java.prefs;\n-                    exports org.openjdk.jextract;\n-\n-                    provides java.util.spi.ToolProvider with\n-                       org.openjdk.jextract.JextractTool.JextractToolProvider;\n-                }\n-                '''\n-        }\n-    }\n-\n-    \/\/ inject module-info.class for jopt.simple module\n-    addDependenciesModuleInfo {\n-        jvmVersion = '18'\n-        outputDirectory = file(\"$buildDir\/modules\")\n-        modules {\n-            module {\n-                artifact 'net.sf.jopt-simple:jopt-simple:5.0.4'\n-                moduleInfoSource = '''\n-                    module jopt.simple {\n-                        exports joptsimple;\n-                        exports joptsimple.util;\n-                    }\n-                '''\n-            }\n-        }\n-    }\n-}\n-\n@@ -103,1 +53,1 @@\n-    dependsOn addMainModuleInfo, addDependenciesModuleInfo\n+    dependsOn build\n@@ -109,1 +59,1 @@\n-         \"--module-path=$buildDir\/modules\",\n+         \"--module-path=$buildDir\/libs\",\n@@ -155,1 +105,1 @@\n-         \"--module-path=$buildDir\/modules\" + File.pathSeparator + \"$jdk18_home\/jmods\",\n+         \"--module-path=$buildDir\/libs\" + File.pathSeparator + \"$jdk18_home\/jmods\",\n@@ -204,0 +154,6 @@\n+    doFirst {\n+        if (findProperty(\"jtreg_home\") == null) {\n+            throw new GradleException(\"jtreg_home is not defined\")\n+        }\n+    }\n+\n","filename":"build.gradle","additions":10,"deletions":54,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-jextract -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+jextract -C-DFORCE_OPENBLAS_COMPLEX_STRUCT \\\n","filename":"samples\/cblas\/compile.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+module org.openjdk.jextract {\n+    requires transitive java.compiler;\n+    requires transitive jdk.incubator.foreign;\n+    exports org.openjdk.jextract;\n+\n+    provides java.util.spi.ToolProvider with\n+        org.openjdk.jextract.JextractTool.JextractToolProvider;\n+}\n","filename":"src\/main\/java\/module-info.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -35,3 +35,0 @@\n-import joptsimple.OptionException;\n-import joptsimple.OptionParser;\n-import joptsimple.OptionSet;\n@@ -48,0 +45,1 @@\n+import java.util.ArrayList;\n@@ -49,0 +47,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -140,4 +140,2 @@\n-    private int printHelp(OptionParser parser, int exitCode) {\n-        try {\n-            parser.printHelpOn(err);\n-        } catch (IOException ignored) {}\n+    private int printHelp(int exitCode) {\n+        err.println(format(\"jextract.usage\"));\n@@ -157,1 +155,1 @@\n-        err.println(\"Usage: jextract <options> [--] <header file>\");\n+        err.println(\"Usage: jextract <options> <header file>\");\n@@ -176,0 +174,114 @@\n+\n+    \/\/ Option handling code\n+\n+    \/\/ specification for an option\n+    record OptionSpec(String name, List<String> aliases, String help, boolean argRequired) {\n+    }\n+\n+    private static class OptionException extends RuntimeException {\n+        private static final long serialVersionUID = -1L;\n+        OptionException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    \/\/ output of OptionParser.parse\n+    private static class OptionSet {\n+        private final Map<String, List<String>> options;\n+        \/\/ non-option arguments\n+        private final List<String> nonOptionArgs;\n+\n+        OptionSet(Map<String, List<String>> options,\n+                List<String> nonOptionArgs) {\n+            this.options = options;\n+            this.nonOptionArgs = nonOptionArgs;\n+        }\n+\n+        boolean has(String name) {\n+            return options.containsKey(name);\n+        }\n+\n+        List<String> valuesOf(String name) {\n+            return options.get(name);\n+        }\n+\n+        String valueOf(String name) {\n+            var values = valuesOf(name);\n+            return values == null? null : values.get(values.size() - 1);\n+        }\n+\n+        List<String> nonOptionArguments() {\n+            return nonOptionArgs;\n+        }\n+    }\n+\n+    private static final class OptionParser {\n+        \/\/ option name to corresponding OptionSpec mapping\n+        private Map<String, OptionSpec> optionSpecs = new HashMap<>();\n+\n+        void accepts(String name, String help, boolean argRequired) {\n+            accepts(name, List.of(), help, argRequired);\n+        }\n+\n+        void accepts(String name, List<String> aliases, String help, boolean argRequired) {\n+            var spec = new OptionSpec(name, aliases, help, argRequired);\n+            optionSpecs.put(name, spec);\n+            for (String alias : aliases) {\n+                optionSpecs.put(alias, spec);\n+            }\n+        }\n+\n+        OptionSet parse(String[] args) {\n+            Map<String, List<String>> options = new HashMap<>();\n+            List<String> nonOptionArgs = new ArrayList<>();\n+            for (int i = 0; i < args.length; i++) {\n+               String arg = args[i];\n+               \/\/ does this look like an option?\n+               if (arg.charAt(0) == '-') {\n+                   OptionSpec spec = optionSpecs.get(arg);\n+                   String argValue = null;\n+                   if (spec == null) {\n+                       \/\/ check for single char option specifier followed\n+                       \/\/ by option value without whitespace in between.\n+                       \/\/ Examples: -lclang, -C-xc++\n+                       spec = arg.length() > 2 ? optionSpecs.get(arg.substring(0, 2)) : null;\n+                       if (spec != null) {\n+                           argValue = arg.substring(2);\n+                       } else {\n+                           throw new OptionException(\"invalid option: \" + arg);\n+                       }\n+                   }\n+                   \/\/ handle argument associated with the current option, if any\n+                   List<String> values;\n+                   if (spec.argRequired()) {\n+                       if (argValue == null) {\n+                           if (i == args.length - 1 || args[i + 1].charAt(0) == '-') {\n+                               throw new OptionException(spec.help());\n+                           }\n+                           argValue = args[i + 1];\n+                           i++; \/\/ consume value from next command line arg\n+                       } \/\/ else -C-xc++ like case. Value already set\n+\n+                       values = options.getOrDefault(spec.name(), new ArrayList<String>());\n+                       values.add(argValue);\n+                   } else {\n+                       \/\/ no argument value associated with this option.\n+                       \/\/ using empty list to flag that.\n+                       values = List.of();\n+                   }\n+\n+                   \/\/ set value for the option as well as all its aliases\n+                   \/\/ so that option lookup, value lookup will work regardless\n+                   \/\/ which alias was used to check.\n+                   options.put(spec.name(), values);\n+                   for (String alias : spec.aliases()) {\n+                       options.put(spec.name(), values);\n+                   }\n+               } else {\n+                   nonOptionArgs.add(arg);\n+               }\n+            }\n+            return new OptionSet(options, nonOptionArgs);\n+        }\n+    }\n+\n@@ -187,5 +299,4 @@\n-        OptionParser parser = new OptionParser(false);\n-        parser.accepts(\"C\", format(\"help.C\")).withRequiredArg();\n-        parser.accepts(\"I\", format(\"help.I\")).withRequiredArg();\n-        parser.accepts(\"d\", format(\"help.d\")).withRequiredArg();\n-        parser.accepts(\"dump-includes\", format(\"help.dump-includes\")).withRequiredArg();\n+        OptionParser parser = new OptionParser();\n+        parser.accepts(\"-C\", format(\"help.C\"), true);\n+        parser.accepts(\"-d\", format(\"help.d\"), true);\n+        parser.accepts(\"--dump-includes\", format(\"help.dump-includes\"), true);\n@@ -193,1 +304,1 @@\n-            parser.accepts(includeKind.optionName(), format(\"help.\" + includeKind.optionName())).withRequiredArg();\n+            parser.accepts(\"--\" + includeKind.optionName(), format(\"help.\" + includeKind.optionName()), true);\n@@ -195,6 +306,6 @@\n-        parser.accepts(\"l\", format(\"help.l\")).withRequiredArg();\n-        parser.accepts(\"source\", format(\"help.source\"));\n-        parser.acceptsAll(List.of(\"t\", \"target-package\"), format(\"help.t\")).withRequiredArg();\n-        parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), format(\"help.h\")).forHelp();\n-        parser.accepts(\"header-class-name\", format(\"help.header-class-name\")).withRequiredArg();\n-        parser.nonOptions(format(\"help.non.option\"));\n+        parser.accepts(\"-h\", List.of(\"-?\", \"--help\"), format(\"help.h\"), false);\n+        parser.accepts(\"--header-class-name\", format(\"help.header-class-name\"), true);\n+        parser.accepts(\"-I\", format(\"help.I\"), true);\n+        parser.accepts(\"-l\", format(\"help.l\"), true);\n+        parser.accepts(\"--source\", format(\"help.source\"), false);\n+        parser.accepts(\"-t\", List.of(\"--target-package\"), format(\"help.t\"), true);\n@@ -210,2 +321,2 @@\n-        if (optionSet.has(\"h\")) {\n-            return printHelp(parser, SUCCESS);\n+        if (optionSet.has(\"-h\")) {\n+            return printHelp(SUCCESS);\n@@ -220,2 +331,2 @@\n-        if (optionSet.has(\"I\")) {\n-            optionSet.valuesOf(\"I\").forEach(p -> builder.addClangArg(\"-I\" + p));\n+        if (optionSet.has(\"-I\")) {\n+            optionSet.valuesOf(\"-I\").forEach(p -> builder.addClangArg(\"-I\" + p));\n@@ -236,6 +347,2 @@\n-        if (optionSet.has(\"C\")) {\n-            optionSet.valuesOf(\"C\").forEach(p -> builder.addClangArg((String) p));\n-        }\n-\n-        if (optionSet.has(\"filter\")) {\n-            optionSet.valuesOf(\"filter\").forEach(p -> builder.addFilter((String) p));\n+        if (optionSet.has(\"-C\")) {\n+            optionSet.valuesOf(\"-C\").forEach(p -> builder.addClangArg(p));\n@@ -245,2 +352,2 @@\n-            if (optionSet.has(includeKind.optionName())) {\n-                optionSet.valuesOf(includeKind.optionName()).forEach(p -> builder.addIncludeSymbol(includeKind, (String)p));\n+            if (optionSet.has(\"--\" + includeKind.optionName())) {\n+                optionSet.valuesOf(\"--\" + includeKind.optionName()).forEach(p -> builder.addIncludeSymbol(includeKind, p));\n@@ -250,2 +357,2 @@\n-        if (optionSet.has(\"dump-includes\")) {\n-            builder.setDumpIncludeFile(optionSet.valueOf(\"dump-includes\").toString());\n+        if (optionSet.has(\"--dump-includes\")) {\n+            builder.setDumpIncludeFile(optionSet.valueOf(\"--dump-includes\"));\n@@ -254,2 +361,2 @@\n-        if (optionSet.has(\"d\")) {\n-            builder.setOutputDir(optionSet.valueOf(\"d\").toString());\n+        if (optionSet.has(\"-d\")) {\n+            builder.setOutputDir(optionSet.valueOf(\"-d\"));\n@@ -258,1 +365,1 @@\n-        if (optionSet.has(\"source\")) {\n+        if (optionSet.has(\"--source\")) {\n@@ -261,1 +368,1 @@\n-        boolean librariesSpecified = optionSet.has(\"l\");\n+        boolean librariesSpecified = optionSet.has(\"-l\");\n@@ -263,2 +370,1 @@\n-            for (Object arg : optionSet.valuesOf(\"l\")) {\n-                String lib = (String)arg;\n+            for (String lib : optionSet.valuesOf(\"-l\")) {\n@@ -279,1 +385,1 @@\n-        String targetPackage = optionSet.has(\"t\") ? (String) optionSet.valueOf(\"t\") : \"\";\n+        String targetPackage = optionSet.has(\"-t\") ? optionSet.valueOf(\"-t\") : \"\";\n@@ -284,1 +390,1 @@\n-        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());\n+        Path header = Paths.get(optionSet.nonOptionArguments().get(0));\n@@ -302,2 +408,2 @@\n-            String headerName = optionSet.has(\"header-class-name\") ?\n-                (String) optionSet.valueOf(\"header-class-name\") :\n+            String headerName = optionSet.has(\"--header-class-name\") ?\n+                optionSet.valueOf(\"--header-class-name\") :\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":150,"deletions":44,"binary":false,"changes":194,"status":"modified"},{"patch":"","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/options\/CommandLine.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CommandLine.java","status":"renamed"},{"patch":"@@ -28,1 +28,1 @@\n-l.option.value.invalid=option value for -l option should be a name or an absolute path\n+l.option.value.invalid=option value for -l option should be a name or an absolute path: {0}\n@@ -47,0 +47,20 @@\n+jextract.usage=\\\n+Usage: jextract <options> <header file>                                  \\n\\\n+                                                                         \\n\\\n+Option                         Description                               \\n\\\n+------                         -----------                               \\n\\\n+-?, -h, --help                 print help                                \\n\\\n+-C <String>                    pass through argument for clang           \\n\\\n+-I <String>                    specify include files path                \\n\\\n+-d <String>                    specify where to place generated files    \\n\\\n+--dump-includes <String>       dump included symbols into specified file \\n\\\n+--header-class-name <String>   name of the header class                  \\n\\\n+--include-function <String>    name of function to include               \\n\\\n+--include-macro <String>       name of constant macro to include         \\n\\\n+--include-struct <String>      name of struct definition to include      \\n\\\n+--include-typedef <String>     name of type definition to include        \\n\\\n+--include-union <String>       name of union definition to include       \\n\\\n+--include-var <String>         name of global variable to include        \\n\\\n+-l <String>                    specify a library                         \\n\\\n+--source                       generate java sources                     \\n\\\n+-t, --target-package <String>  target package for specified header files \\n\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-            \"--\",\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/IncompleteArrayTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,1 +213,0 @@\n-            \"--\",\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}