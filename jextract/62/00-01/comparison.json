{"files":[{"patch":"@@ -258,1 +258,1 @@\n-        String layoutClassName = Utils.layoutClassNameInDeclaration(layout);\n+        String layoutClassName = Utils.layoutDeclarationType(layout).getSimpleName();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-            append(\" \" + Utils.layoutClassNameInDeclaration(primType.kind().layout().orElseThrow()));\n+            append(\" \" + Utils.layoutDeclarationType(primType.kind().layout().orElseThrow()).getSimpleName());\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,2 +322,12 @@\n-    static String layoutClassNameInDeclaration(MemoryLayout layout) {\n-        if (layout.getClass().getName().contains(\".internal\")) {\n+    \/**\n+     * Returns the type that should be used in declarations of various\n+     * memory layout implementations.\n+     * <p>\n+     * For example, the concrete layout implementation class {@code OfLongImpl} should be\n+     * declared as {@code OfLong} and not {@code OfLongImpl}.\n+     *\n+     * @param layout to generate a declaring type string for.\n+     * @return the unqualified type\n+     *\/\n+    static Class<?> layoutDeclarationType(MemoryLayout layout) {\n+        if (!layout.getClass().isInterface()) {\n@@ -328,1 +338,1 @@\n-            return ifs[0].getSimpleName();\n+            return ifs[0];\n@@ -330,1 +340,1 @@\n-        return layout.getClass().getSimpleName();\n+        return layout.getClass();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}