{"files":[{"patch":"@@ -3,1 +3,1 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_4\/include \\\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+final class CDeclarationPrinter implements Declaration.Visitor<Void, Void> {\n+    private static String SPACES = \" \".repeat(92);\n+    private int align = 0;\n+    private String prefix;\n+\n+    private void incr() {\n+        align += 4;\n+    }\n+\n+    private void decr() {\n+        align -= 4;\n+    }\n+\n+    private CDeclarationPrinter(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    private void indent() {\n+        builder.append(prefix);\n+        builder.append(SPACES.substring(0, align));\n+    }\n+\n+    private final StringBuilder builder = new StringBuilder();\n+\n+    private String print(Declaration decl) {\n+        decl.accept(this, null);\n+        return builder.toString();\n+    }\n+\n+    \/\/ Return C source style signature for the given declaration.\n+    \/\/ The prefix is emitted for every line. This can be used\n+    \/\/ to prefix per line comment character \"*\" in generated javadoc.\n+    static String declaration(Declaration decl, String prefix) {\n+        Objects.requireNonNull(decl);\n+        Objects.requireNonNull(prefix);\n+        return new CDeclarationPrinter(prefix).print(decl);\n+    }\n+\n+    static String declaration(Type.Function funcType, String name) {\n+        return nameAndType(funcType, \"*\" + name);\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Void ignored) {\n+        indent();\n+        var tag = typeTag(d);\n+        if (!tag.isEmpty()) {\n+            builder.append(tag);\n+            if (!d.name().isEmpty()) {\n+                builder.append(\" \" + d.name());\n+            }\n+            builder.append(\" {\");\n+            builder.append(\"\\n\");\n+            incr();\n+        }\n+        d.members().forEach(m -> m.accept(this, null));\n+        if (!tag.isEmpty()) {\n+            decr();\n+            indent();\n+            builder.append(\"};\\n\");\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Void ignored) {\n+        indent();\n+        var ftype = d.type();\n+        var rtype = ftype.returnType();\n+        builder.append(typeStr(rtype));\n+        builder.append(\" \");\n+        builder.append(d.name());\n+        builder.append(\"(\");\n+        builder.append(\n+            d.parameters().\n+                stream().\n+                map(p -> nameAndType(p.type(), p.name())).\n+                collect(Collectors.joining(\", \"))\n+        );\n+        if (d.type().varargs()) {\n+            builder.append(\",...\");\n+        }\n+        builder.append(\");\\n\");\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Void ignored) {\n+        indent();\n+        builder.append(nameAndType(d.type(), d.name()));\n+        builder.append(\";\\n\");\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Void ignored) {\n+        indent();\n+        Optional<String> enumName = EnumConstantLifter.enumName(d);\n+        if (enumName.isPresent()) {\n+            builder.append(\"enum \" + enumName.get() + \".\" + d.name());\n+            builder.append(\" = \");\n+            builder.append(d.value());\n+            builder.append(\";\\n\");\n+        } else {\n+            builder.append(\"#define \");\n+            builder.append(d.name());\n+            Object value = d.value();\n+            builder.append(\" \");\n+            if (value instanceof String str) {\n+                builder.append(\"\\\"\" + Utils.quote(str) + \"\\\"\");\n+            } else {\n+                builder.append(value);\n+            }\n+            builder.append(\"\\n\");\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef d, Void ignored) {\n+        indent();\n+        builder.append(\"typedef \");\n+        builder.append(nameAndType(d.type(), d.name()));\n+        builder.append(\";\\n\");\n+        return null;\n+    }\n+\n+    \/\/ In few cases, C type signature 'embeds' name.\n+    \/\/ Examples:\n+    \/\/     int a[3]; \/\/ 'a' in between int and []\n+    \/\/     int (*func)(int); \/\/ 'func' is inside paren after '*'\n+    \/\/ TypeVisitor accepts name and includes it in the appropriate\n+    \/\/ place as needed. If not included, boolean flag is set to false\n+    \/\/ in the result.\n+\n+    private static String nameAndType(Type type, String name) {\n+        var result = type.accept(typeVisitor, name);\n+        var typeStr = result.typeStr();\n+        return result.nameIncluded() || name.isEmpty() ?\n+            typeStr : (typeStr + \" \" + name);\n+    }\n+\n+    private static String typeStr(Type type) {\n+        var result = type.accept(typeVisitor, \"\");\n+        assert !result.nameIncluded();\n+        return result.typeStr();\n+    }\n+\n+    \/\/ result type for Type.Visitor\n+    private record TypeVisitorResult(boolean nameIncluded, String typeStr) {}\n+\n+    private static Type.Visitor<TypeVisitorResult, String> typeVisitor = new Type.Visitor<>() {\n+        \/\/ context argument in this visitor starts with a name. But it may pick up\n+        \/\/ \"*\" prefixes for pointer type.\n+\n+        @Override\n+        public TypeVisitorResult visitPrimitive(Type.Primitive t, String context) {\n+            return new TypeVisitorResult(false, t.kind().typeName());\n+        }\n+\n+        private TypeVisitorResult prefixedType(String prefix, Type.Delegated delegated) {\n+            return new TypeVisitorResult(false,\n+                    prefix + \" \" + delegated.type().accept(this, \"\").typeStr());\n+        }\n+\n+        @Override\n+        public TypeVisitorResult visitDelegated(Type.Delegated t, String context) {\n+            switch (t.kind()) {\n+                case POINTER: {\n+                    var result = t.type().accept(this, \"*\" + context);\n+                    if (result.nameIncluded()) {\n+                        return new TypeVisitorResult(true, result.typeStr());\n+                    } else {\n+                        return new TypeVisitorResult(false, result.typeStr() + \"*\");\n+                    }\n+                }\n+                case UNSIGNED:\n+                    return prefixedType(\"unsigned\", t);\n+                case SIGNED:\n+                    return prefixedType(\"signed\", t);\n+                case VOLATILE:\n+                    return prefixedType(\"volatile\", t);\n+                case COMPLEX:\n+                    return prefixedType(\"complex\", t);\n+                case default:\n+                    \/\/ defensive. If no name is present, we don't want to crash\n+                    return new TypeVisitorResult(false,\n+                        t.name().isPresent()? t.name().get() : t.toString());\n+            }\n+        }\n+\n+        @Override\n+        public TypeVisitorResult visitFunction(Type.Function t, String context) {\n+            String argsStr;\n+            \/\/ Function type may optionally have parameter names.\n+            \/\/ Include parameter names if available.\n+            var optParameterNames = t.parameterNames();\n+            if (optParameterNames.isPresent()) {\n+                List<Type> argTypes = t.argumentTypes();\n+                List<String> argNames = optParameterNames.get();\n+                int numArgs = argTypes.size();\n+                List<String> args = new ArrayList<>(numArgs);\n+                for (int i = 0; i < numArgs; i++) {\n+                    args.add(nameAndType(argTypes.get(i), argNames.get(i)));\n+                }\n+                argsStr = args.stream()\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            } else {\n+                argsStr = t.argumentTypes().stream()\n+                    .map(a -> a.accept(this, \"\").typeStr())\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            }\n+            String res = t.returnType().accept(this, \"\").typeStr();\n+            return new TypeVisitorResult(true, res + \" (\" + context + \")\" + argsStr);\n+        }\n+\n+        @Override\n+        public TypeVisitorResult visitDeclared(Type.Declared t, String context) {\n+            Declaration.Scoped scoped = t.tree();\n+            return new TypeVisitorResult(false, typeTag(scoped) + \" \" + scoped.name());\n+        }\n+\n+        @Override\n+        public TypeVisitorResult visitArray(Type.Array t, String context) {\n+            String brackets = String.format(\" %s[%s]\", context,\n+                t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n+            return new TypeVisitorResult(true, t.elementType().accept(this, \"\").typeStr() + brackets);\n+        }\n+\n+        @Override\n+        public TypeVisitorResult visitType(Type t, String context) {\n+            return new TypeVisitorResult(false, t.getClass().getName());\n+        }\n+    };\n+\n+    private static String typeTag(Declaration.Scoped scoped) {\n+        return switch (scoped.kind()) {\n+            case STRUCT -> \"struct\";\n+            case UNION -> \"union\";\n+            case ENUM -> \"enum\";\n+            default -> \"\";\n+        };\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CDeclarationPrinter.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -31,0 +31,2 @@\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n@@ -109,0 +111,1 @@\n+        classDeclBegin();\n@@ -122,0 +125,2 @@\n+    void classDeclBegin() {}\n+\n@@ -192,0 +197,29 @@\n+    void emitDocComment(Declaration decl) {\n+        emitDocComment(decl, \"\");\n+    }\n+\n+    void emitDocComment(Declaration decl, String header) {\n+        indent();\n+        append(\"\/**\\n\");\n+        if (!header.isEmpty()) {\n+            indent();\n+            append(\" * \");\n+            append(header);\n+            append(\"\\n\");\n+        }\n+        append(CDeclarationPrinter.declaration(decl, \" \".repeat(align*4) + \" * \"));\n+        indent();\n+        append(\" *\/\\n\");\n+    }\n+\n+    void emitDocComment(Type.Function funcType, String name) {\n+        indent();\n+        append(\"\/**\\n\");\n+        indent();\n+        append(\" * \");\n+        append(CDeclarationPrinter.declaration(funcType, name));\n+        append(\";\\n\");\n+        indent();\n+        append(\" *\/\\n\");\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -36,0 +37,2 @@\n+    private static final String ENUM_NAME = \"enum-name\";\n+\n@@ -40,0 +43,4 @@\n+    static Optional<String> enumName(Declaration.Constant constant) {\n+        return constant.getAttribute(ENUM_NAME).map(attrs -> attrs.get(0).toString());\n+    }\n+\n@@ -79,1 +86,4 @@\n-            scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+            \/\/ add the name of the enum as an attribute.\n+            scoped.members().forEach(fieldTree -> fieldTree\n+                .withAttribute(ENUM_NAME, scoped.name())\n+                .accept(this, null));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    private final Type.Function funcType;\n@@ -52,0 +53,1 @@\n+        this.funcType = funcType;\n@@ -58,0 +60,5 @@\n+    @Override\n+    void classDeclBegin() {\n+        emitDocComment(funcType, className());\n+    }\n+\n@@ -67,1 +74,0 @@\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,0 +66,7 @@\n+    @Override\n+    void emitDocComment(Declaration decl, String header) {\n+        incrAlign();\n+        super.emitDocComment(decl, header);\n+        decrAlign();\n+    }\n+\n@@ -73,0 +80,1 @@\n+                    emitDocComment(varTree);\n@@ -85,0 +93,1 @@\n+                emitDocComment(varTree, \"Getter for variable:\");\n@@ -86,0 +95,1 @@\n+                emitDocComment(varTree, \"Setter for variable:\");\n@@ -107,0 +117,1 @@\n+            emitDocComment(funcTree);\n@@ -114,0 +125,1 @@\n+        emitDocComment(constantTree);\n@@ -206,0 +218,4 @@\n+        emitPrimitiveTypedef(null, primType, name);\n+    }\n+\n+    void emitPrimitiveTypedef(Declaration.Typedef typedefTree, Type.Primitive primType, String name) {\n@@ -208,0 +224,3 @@\n+            if (typedefTree != null) {\n+                emitDocComment(typedefTree);\n+            }\n@@ -222,0 +241,7 @@\n+        emitPointerTypedef(null, name);\n+    }\n+\n+    void emitPointerTypedef(Declaration.Typedef typedefTree, String name) {\n+        if (typedefTree != null) {\n+            emitDocComment(typedefTree);\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    private final Declaration.Scoped structTree;\n@@ -55,1 +56,1 @@\n-    StructBuilder(JavaSourceBuilder enclosing, Declaration.Scoped tree,\n+    StructBuilder(JavaSourceBuilder enclosing, Declaration.Scoped structTree,\n@@ -58,0 +59,1 @@\n+        this.structTree = structTree;\n@@ -59,1 +61,1 @@\n-        this.structType = Type.declared(tree);\n+        this.structType = Type.declared(structTree);\n@@ -90,0 +92,7 @@\n+    @Override\n+    void classDeclBegin() {\n+        if (!inAnonymousNested()) {\n+            emitDocComment(structTree);\n+        }\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            nextHeader().emitPrimitiveTypedef(primitive, javaName);\n+            nextHeader().emitPrimitiveTypedef(typedefTree, primitive, javaName);\n@@ -121,1 +121,1 @@\n-            nextHeader().emitPointerTypedef(javaName);\n+            nextHeader().emitPointerTypedef(typedefTree, javaName);\n@@ -123,1 +123,1 @@\n-            TypedefBuilder builder = new TypedefBuilder(this, javaName, superClass);\n+            TypedefBuilder builder = new TypedefBuilder(this, typedefTree, javaName, superClass);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-public class TypedefBuilder extends ClassSourceBuilder {\n+import org.openjdk.jextract.Declaration;\n@@ -30,0 +30,2 @@\n+public class TypedefBuilder extends ClassSourceBuilder {\n+    private final Declaration.Typedef typedefTree;\n@@ -32,1 +34,2 @@\n-    public TypedefBuilder(JavaSourceBuilder enclosing, String name, String superClass) {\n+    public TypedefBuilder(JavaSourceBuilder enclosing,\n+        Declaration.Typedef typedefTree, String name, String superClass) {\n@@ -34,0 +37,1 @@\n+        this.typedefTree = typedefTree;\n@@ -42,0 +46,5 @@\n+    @Override\n+    void classDeclBegin() {\n+        emitDocComment(typedefTree);\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefBuilder.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider.Test7903257;\n+\n+import testlib.JextractToolRunner;\n+import testlib.TestUtils;\n+import org.testng.annotations.Test;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDocComments extends JextractToolRunner {\n+    \/\/ Regular expression for javadoc comment text\n+    \/\/\n+    \/\/   (?s)     dot matches all including newlines\n+    \/\/   \/\\*\\*    doc comment start\n+    \/\/   (.*?)    comment text as a group (reluctant match)\n+    \/\/   \\*\/      doc comment end\n+    private static final Pattern JAVADOC_COMMENT = Pattern.compile(\"(?s)\/\\\\*\\\\*(.*?)\\\\*\/\");\n+\n+    @Test\n+    public void testMacros() throws IOException {\n+        var comments = getDocComments(\"macros.h\", \"macros_h.java\");\n+        assertEquals(comments, List.of(\n+            \"#define FOO 42\", \"#define MSG \\\"Hello\\\"\"));\n+    }\n+\n+    @Test\n+    public void testEnumConstants() throws IOException {\n+        var comments = getDocComments(\"enums.h\", \"enums_h.java\");\n+        assertEquals(comments, List.of(\n+            \"enum Color.RED = 0;\",\n+            \"enum Color.GREEN = 1;\",\n+            \"enum Color.BLUE = 2;\",\n+            \"enum Suit.club = 1;\",\n+            \"enum Suit.diamonds = 2;\",\n+            \"enum Suit.hearts = 3;\",\n+            \"enum Suit.spades = 4;\"));\n+    }\n+\n+    @Test\n+    public void testTypedefs() throws IOException {\n+        var comments = getDocComments(\"typedefs.h\", \"typedefs_h.java\");\n+        assertEquals(comments, List.of(\n+            \"typedef unsigned long size_t;\",\n+            \"typedef int INT_32;\",\n+            \"typedef int* INT_PTR;\",\n+            \"typedef struct Foo* OPAQUE_PTR;\"));\n+    }\n+\n+    @Test\n+    public void testArrays() throws IOException {\n+        var comments = getDocComments(\"arrays.h\", \"arrays_h.java\");\n+        assertEquals(comments, List.of(\n+            \"int abc[10];\",\n+            \"float numbers[3];\",\n+            \"char* msg[5];\"));\n+    }\n+\n+    @Test\n+    public void testFunctions() throws IOException {\n+        var comments = getDocComments(\"functions.h\", \"functions_h.java\");\n+        assertEquals(comments, List.of(\n+            \"int func(int* fp);\",\n+            \"double distance(struct Point p);\",\n+            \"int printf(char* fmt,...);\"));\n+    }\n+\n+    @Test\n+    public void testFunctionPointer() throws IOException {\n+        var comments = getDocComments(\"funcptrs.h\", \"funcptr.java\");\n+        assertEquals(comments, List.of(\n+            \"void (*funcptr)(int*,int);\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testVariables() throws IOException {\n+        var comments = getDocComments(\"variables.h\", \"variables_h.java\");\n+        assertEquals(comments, List.of(\n+            \"Getter for variable: int abc;\",\n+            \"Setter for variable: int abc;\",\n+            \"Getter for variable: char* msg;\",\n+            \"Setter for variable: char* msg;\"\n+        ));\n+    }\n+\n+    @Test\n+    public void testStruct() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point.java\");\n+        assertEquals(comments, List.of(\n+            \"struct Point { int x; int y; };\"));\n+    }\n+\n+    @Test\n+    public void testStruct2() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point3D.java\");\n+        assertEquals(comments, List.of(\n+            \"struct Point3D { int x; int y; int z; };\"));\n+    }\n+\n+    @Test\n+    public void testStructTypdef() throws IOException {\n+        var comments = getDocComments(\"structs.h\", \"Point_t.java\");\n+        assertEquals(comments, List.of(\n+            \"typedef struct Point Point_t;\"));\n+    }\n+\n+    private List<String> getDocComments(String header, String outputFile)\n+            throws IOException {\n+        var output = getOutputFilePath(\"7903257-parse-\" + header);\n+        var outputH = getInputFilePath(header);\n+        run(\"--source\", \"--output\",\n+            output.toString(), outputH.toString()).checkSuccess();\n+        try {\n+            return findDocComments(Files.readString(output.resolve(outputFile)));\n+        } finally {\n+            TestUtils.deleteDir(output);\n+        }\n+    }\n+\n+    \/\/ get doc comments from the given the source content\n+    private static List<String> findDocComments(String content) {\n+        var matcher = JAVADOC_COMMENT.matcher(content);\n+        var strings = new ArrayList<String>();\n+        while (matcher.find()) {\n+            \/\/ doc comment text is matched in group 1\n+            String rawComment = matcher.group(1);\n+\n+            \/\/ sanitize raw comment for test asserts\n+            strings.add(rawComment\n+                \/\/ remove \\n followed by whitespaces and then *\n+                .replaceAll(\"\\n\\\\s+\\\\*\", \"\")\n+\n+                \/\/ replace one or more whitespaces as single whitespace\n+                .replaceAll(\"\\\\s+\", \" \")\n+\n+                \/\/ remove trailing and leading whitespaces\n+                .trim());\n+        }\n+        return strings;\n+    }\n+}\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/TestDocComments.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -24,3 +24,3 @@\n-struct Foo {\n-    int (*Foo)();\n-};\n+int abc[10];\n+float numbers[3];\n+char* msg[5];\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/arrays.h","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+enum Color { RED, GREEN, BLUE };\n+\n+\/* enum with init values *\/\n+enum Suit {\n+    club = 1,\n+    diamonds = 2,\n+    hearts = 3,\n+    spades = 4\n+};\n+\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/enums.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,3 +24,1 @@\n-struct Foo {\n-    int (*Foo)();\n-};\n+void (*funcptr)(int x[], int numelements);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/funcptrs.h","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -24,2 +24,3 @@\n-struct Foo {\n-    int (*Foo)();\n+int func(int* fp);\n+struct Point {\n+  int x; int y;\n@@ -27,0 +28,3 @@\n+\n+double distance(struct Point p);\n+int printf(char* fmt,...);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/functions.h","additions":6,"deletions":2,"binary":false,"changes":8,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -24,1 +24,2 @@\n-void included_func(int);\n+#define FOO 42\n+#define MSG \"Hello\"\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/macros.h","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/inc\/includer_impl.h","status":"copied"},{"patch":"@@ -24,2 +24,3 @@\n-struct Foo {\n-    int (*Foo)();\n+struct Point {\n+   int x;\n+   int y;\n@@ -27,0 +28,8 @@\n+\n+struct Point3D {\n+   int x;\n+   int y;\n+   int z;\n+};\n+\n+typedef struct Point Point_t;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/structs.h","additions":11,"deletions":2,"binary":false,"changes":13,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/test7903237.h","status":"copied"},{"patch":"@@ -24,2 +24,4 @@\n-typedef void func(int foo);\n-typedef void (*fptr)(int x, int y);\n+typedef unsigned long size_t;\n+typedef int INT_32;\n+typedef int* INT_PTR;\n+typedef struct Foo* OPAQUE_PTR;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/typedefs.h","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"test\/jtreg\/generator\/test8281764\/test8281764.h","status":"copied"},{"patch":"@@ -24,1 +24,2 @@\n-void included_func(int);\n+int abc;\n+char* msg;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test7903257\/variables.h","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/inc\/includer_impl.h","status":"copied"}]}