{"files":[{"patch":"@@ -3,1 +3,1 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_4\/include \\\n","filename":"samples\/libffmpeg\/compile.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/lib LibffmpegMain.java $*\n+   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_4\/lib LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import org.openjdk.jextract.impl.OutputFactory;\n+import org.openjdk.jextract.impl.CodeGenerator;\n@@ -121,1 +121,1 @@\n-        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n@@ -126,1 +126,1 @@\n-        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, includeHelper, libNames));\n+        return List.of(CodeGenerator.generate(decl, headerName, targetPkg, includeHelper, libNames));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -73,0 +74,21 @@\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) return true;\n+            if (obj instanceof Position pos) {\n+                return Objects.equals(path(), pos.path()) &&\n+                    Objects.equals(line(), pos.line()) &&\n+                    Objects.equals(col(), pos.col());\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"NO_POSITION\";\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Position.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        this.desc = ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(name));\n+        this.desc = ClassDesc.of(enclosing.packageName(), name);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import javax.tools.JavaFileObject;\n+\n+public final class CodeGenerator {\n+    private CodeGenerator() {}\n+\n+    public static JavaFileObject[] generate(Declaration.Scoped decl, String headerName,\n+                    String targetPkg, IncludeHelper includeHelper,\n+                    List<String> libNames) {\n+        var nameMangler = new NameMangler(headerName);\n+        var transformedDecl = Stream.of(decl).\n+            map(new IncludeFilter(includeHelper)::transform).\n+            map(new EnumConstantLifter()::transform).\n+            map(new DuplicateFilter()::transform).\n+            map(nameMangler::scan).\n+            findFirst().get();\n+        return OutputFactory.generateWrapped(transformedDecl, targetPkg, libNames, nameMangler);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CodeGenerator.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/*\n+ * This visitor filters duplicate top-level variables, constants and functions.\n+ *\/\n+final class DuplicateFilter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n+    \/\/ To detect duplicate Variable and Function declarations.\n+    private final Set<String> constants = new HashSet<>();\n+    private final Set<String> variables = new HashSet<>();\n+    private final Set<Declaration.Typedef> typedefs = new HashSet<>();\n+    private final Set<Declaration.Function> functions = new HashSet<>();\n+    private final List<Declaration> decls = new ArrayList<>();\n+\n+    \/\/ have we seen this Constant earlier?\n+    private boolean constantSeen(Declaration.Constant tree) {\n+        return !constants.add(tree.name());\n+    }\n+\n+    \/\/ have we seen this Variable earlier?\n+    private boolean variableSeen(Declaration.Variable tree) {\n+        return !variables.add(tree.name());\n+    }\n+\n+    \/\/ have we seen this Function earlier?\n+    private boolean functionSeen(Declaration.Function tree) {\n+        return !functions.add(tree);\n+    }\n+\n+    \/\/ have we seen this Function earlier?\n+    private boolean typedefSeen(Declaration.Typedef tree) {\n+        return !typedefs.add(tree);\n+    }\n+\n+    DuplicateFilter() {\n+    }\n+\n+    @Override\n+    public Declaration.Scoped transform(Declaration.Scoped header) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return createHeader(header, decls);\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Void ignored) {\n+        if (constantSeen(constant)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        decls.add(constant);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Void ignored) {\n+        if (functionSeen(funcTree)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        decls.add(funcTree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n+        if (typedefSeen(tree)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        decls.add(tree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Void ignored) {\n+        if (variableSeen(tree)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        decls.add(tree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Void ignored) {\n+        decls.add(decl);\n+        return null;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DuplicateFilter.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * This visitor lifts enum constants to the top level and removes enum Trees.\n+ *\/\n+final class EnumConstantLifter implements TreeTransformer, Declaration.Visitor<Void, Void> {\n+    private final List<Declaration> decls = new ArrayList<>();\n+    EnumConstantLifter() {\n+    }\n+\n+    @Override\n+    public Declaration.Scoped transform(Declaration.Scoped header) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return createHeader(header, decls);\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped scoped, Void ignored) {\n+        if (liftEnumConstants(scoped)) {\n+            return null;\n+        }\n+        decls.add(scoped);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Void ignored) {\n+        Type type = tree.type();\n+        if (type instanceof Type.Declared declared) {\n+            if (liftEnumConstants(declared.tree())) {\n+                return null;\n+            }\n+        }\n+        decls.add(tree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Void ignored) {\n+        decls.add(decl);\n+        return null;\n+    }\n+\n+    private boolean liftEnumConstants(Declaration.Scoped scoped) {\n+        boolean isEnum = scoped.kind() == Declaration.Scoped.Kind.ENUM;\n+        if (isEnum) {\n+            scoped.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        }\n+        return isEnum;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/EnumConstantLifter.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.jextract.Type;\n@@ -48,1 +49,1 @@\n-    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className,\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, Type.Function funcType, String className,\n@@ -72,1 +73,1 @@\n-        return name.isEmpty()? \"_x\" + i : Utils.javaSafeIdentifier(name);\n+        return name.isEmpty()? \"_x\" + i : name;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.jextract.Declaration;\n@@ -66,1 +67,3 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree, String javaName,\n+        MemoryLayout layout, Optional<String> fiName) {\n+        String nativeName = varTree.name();\n@@ -93,1 +96,5 @@\n-    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n+    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n+            String javaName, List<String> parameterNames) {\n+        String nativeName = funcTree.name();\n+        boolean isVarargs = funcTree.type().varargs();\n+\n@@ -105,2 +112,3 @@\n-    public void addConstant(String javaName, Class<?> type, Object value) {\n-        if (type.equals(MemorySegment.class)) {\n+    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n+        Object value = constantTree.value();\n+        if (javaType.equals(MemorySegment.class)) {\n@@ -108,1 +116,1 @@\n-                constantBuilder.addConstantDesc(javaName, type, value)\n+                constantBuilder.addConstantDesc(javaName, javaType, value)\n@@ -112,1 +120,1 @@\n-            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+            emitGetter(MEMBER_MODS, javaType, javaName, getConstantString(javaType, value));\n@@ -205,1 +213,1 @@\n-            append(\" \" + uniqueNestedClassName(name));\n+            append(\" \" + name);\n@@ -219,1 +227,1 @@\n-        append(uniqueNestedClassName(name));\n+        append(name);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/*\n+ * This visitor filters tree elements based on --include options specified.\n+ *\/\n+final class IncludeFilter implements TreeTransformer, Declaration.Visitor<Void, Declaration> {\n+    private List<Declaration> decls = new ArrayList<>();\n+    private final IncludeHelper includeHelper;\n+\n+    IncludeFilter(IncludeHelper includeHelper) {\n+        this.includeHelper = includeHelper;\n+    }\n+\n+    @Override\n+    public Declaration.Scoped transform(Declaration.Scoped header) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return createHeader(header, decls);\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {\n+        if (!includeHelper.isIncluded(constant)) {\n+            \/\/skip\n+            return null;\n+        }\n+        decls.add(constant);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {\n+        if (!includeHelper.isIncluded(funcTree)) {\n+            return null;\n+        }\n+\n+        decls.add(funcTree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {\n+        boolean isStructKind = Utils.isStructOrUnion(d);\n+        if (isStructKind) {\n+            String name = d.name();\n+            if (!name.isEmpty() && !includeHelper.isIncluded(d)) {\n+                return null;\n+            }\n+        }\n+\n+        List<Declaration> oldDecls = decls;\n+        this.decls = new ArrayList<>();\n+        try {\n+            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        } finally {\n+            var scoped = createScoped(d, decls);\n+            this.decls = oldDecls;\n+            decls.add(scoped);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {\n+        if (!includeHelper.isIncluded(tree)) {\n+            return null;\n+        }\n+        decls.add(tree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {\n+        if (parent == null && !includeHelper.isIncluded(tree)) {\n+            return null;\n+        }\n+        decls.add(tree);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Declaration parent) {\n+        decls.add(decl);\n+        return null;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeFilter.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -43,1 +43,2 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree, String javaName,\n+        MemoryLayout layout, Optional<String> fiName) {\n@@ -47,1 +48,2 @@\n-    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n+    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n+        String javaName, List<String> parameterNames) {\n@@ -51,1 +53,1 @@\n-    public void addConstant(String javaName, Class<?> type, Object value) {\n+    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n@@ -55,1 +57,6 @@\n-    public void addTypedef(String name, String superClass, Type type) {\n+    public void addTypedef(Declaration.Typedef typedefTree, String javaName, String superClass) {\n+        addTypedef(typedefTree, javaName, superClass, typedefTree.type());\n+    }\n+\n+    public void addTypedef(Declaration.Typedef typedefTree, String javaName,\n+        String superClass, Type type) {\n@@ -59,1 +66,2 @@\n-    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+    public StructBuilder addStruct(Declaration.Scoped structTree, boolean isNestedAnonStruct,\n+        String javaName, GroupLayout layout) {\n@@ -63,1 +71,2 @@\n-    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+    public void addFunctionalInterface(Type.Function funcType, String javaName,\n+        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n@@ -71,19 +80,0 @@\n-    Set<String> nestedClassNames = new HashSet<>();\n-    int nestedClassNameCount = 0;\n-\n-    \/*\n-     * We may have case-insensitive name collision! A C program may have\n-     * defined structs\/unions\/typedefs with the names FooS, fooS, FoOs, fOOs.\n-     * Because we map structs\/unions\/typedefs to nested classes of header classes,\n-     * such a case-insensitive name collision is problematic. This is because in\n-     * a case-insensitive file system javac will overwrite classes for\n-     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by\n-     * generating unique case-insensitive names for nested classes.\n-     *\/\n-    final String uniqueNestedClassName(String name) {\n-        name = Utils.javaSafeIdentifier(name);\n-        var notSeen = nestedClassNames.add(name.toLowerCase());\n-        var notEnclosed = !isEnclosedBySameName(name);\n-        return notSeen && notEnclosed? name : (name + \"$\" + nestedClassNameCount++);\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import javax.lang.model.SourceVersion;\n+\n+\/*\n+ * This visitor handles java safe names for identifiers, type names. This visitor\n+ * stores java safe names in maps. Subsequent code generation steps can check for\n+ * java safe names via lookup methods.\n+ *\n+ * NOTE: Unlike other transforming tree visitors, this visitor collects name\n+ * mappings as it visits tree nodes. Subsequent code generation steps can check\n+ * the collected names using getters.\n+ *\/\n+final class NameMangler implements Declaration.Visitor<Void, Declaration> {\n+    private final String headerName;\n+\n+    private static class Scope {\n+         private Scope parent;\n+         private String className;\n+         private Set<String> nestedClassNames = new HashSet<>();\n+         private int nestedClassNameCount = 0;\n+         private boolean isStruct;\n+\n+         \/\/ is the name enclosed enclosed by a class of the same name?\n+         private boolean isEnclosedBySameName(String name) {\n+            return className().equals(name) ||\n+                (isNested() && parent.isEnclosedBySameName(name));\n+         }\n+\n+         private boolean isNested() {\n+             return parent != null && parent.isStruct;\n+         }\n+\n+         private Scope(Scope parent, String name, boolean isStruct) {\n+             this.parent = parent;\n+             this.className = parent != null ?\n+                  parent.uniqueNestedClassName(name) :\n+                  javaSafeIdentifier(name);\n+             this.isStruct = isStruct;\n+         }\n+\n+         static Scope newStruct(Scope parent, String name) {\n+             return new Scope(parent, name, true);\n+         }\n+\n+         static Scope newHeader(String name) {\n+             return new Scope(null, name, false);\n+         }\n+\n+         String uniqueNestedClassName(String name) {\n+             name = javaSafeIdentifier(name);\n+             var notSeen = nestedClassNames.add(name.toLowerCase());\n+             var notEnclosed = !isEnclosedBySameName(name);\n+             return notSeen && notEnclosed? name : (name + \"$\" + nestedClassNameCount++);\n+         }\n+\n+         String className() {\n+             return className;\n+         }\n+    }\n+\n+    private Scope curScope;\n+\n+    private static record NameAndDecl(String name, Declaration decl) {}\n+    \/\/ key is either Declaration or NameAndDecl\n+    private final Map<Object, String> declJavaNames = new HashMap<>();\n+\n+    private static record DeclPair(Declaration parent, Declaration decl) {}\n+    \/\/ key is either Declaration or NameAndDecl or DeclPair\n+    private final Map<Object, String> declFiNames = new HashMap<>();\n+    private final Map<Type.Function, List<String>> parameterNames = new HashMap<>();\n+\n+    NameMangler(String headerName) {\n+        this.headerName = headerName;\n+    }\n+\n+    \/\/ package private name lookup API\n+    String getJavaName(Declaration parent, Declaration decl) {\n+        Objects.requireNonNull(decl);\n+        if (declJavaNames.containsKey(decl)) {\n+            return Objects.requireNonNull(declJavaNames.get(decl));\n+        } else {\n+            var name = decl.name().isEmpty()? parent.name() : decl.name();\n+            var nameAndDecl = new NameAndDecl(name, decl);\n+            return Objects.requireNonNull(declJavaNames.get(nameAndDecl));\n+        }\n+    }\n+\n+    Optional<List<String>> getParameterNames(Type.Function func) {\n+        return Optional.ofNullable(parameterNames.get(func));\n+    }\n+\n+    String getFiName(Declaration.Function func, int paramNum, Declaration.Variable param) {\n+        Objects.requireNonNull(func);\n+        Objects.requireNonNull(param);\n+        var nameAndDecl = new NameAndDecl(funcParamID(func, paramNum), param);\n+        return Objects.requireNonNull(declFiNames.get(nameAndDecl));\n+    }\n+\n+    String getFiName(Declaration parent, Declaration decl) {\n+        Objects.requireNonNull(decl);\n+        if (declFiNames.containsKey(decl)) {\n+            return Objects.requireNonNull(declFiNames.get(decl));\n+        } else {\n+            Objects.requireNonNull(parent);\n+            var declPair = new DeclPair(parent, decl);\n+            return Objects.requireNonNull(declFiNames.get(declPair));\n+        }\n+    }\n+\n+    \/\/ Internals below this point\n+\n+    private static String funcParamID(Declaration.Function func, int paramNum) {\n+        return func.name() + \"$\" + paramNum;\n+    }\n+\n+    private void putJavaName(Declaration decl, String javaName) {\n+        assert decl != null;\n+        assert javaName != null;\n+        declJavaNames.put(decl, javaName);\n+    }\n+\n+    private void putJavaName(String name, Declaration decl, String javaName) {\n+        assert name != null;\n+        assert decl != null;\n+        assert javaName != null;\n+        declJavaNames.put(new NameAndDecl(name, decl), javaName);\n+    }\n+\n+    private void putFiName(Declaration decl, String javaName) {\n+        assert decl != null;\n+        assert javaName != null;\n+        declFiNames.put(decl, javaName);\n+    }\n+\n+    private void putFiName(Declaration parent, Declaration.Variable variable, String javaName) {\n+        assert parent != null;\n+        assert variable != null;\n+        assert javaName != null;\n+        declFiNames.put(new DeclPair(parent, variable), javaName);\n+    }\n+\n+    private void putFiName(String name, Declaration decl, String javaName) {\n+        assert name != null;\n+        assert decl != null;\n+        assert javaName != null;\n+        declFiNames.put(new NameAndDecl(name, decl), javaName);\n+    }\n+\n+    \/\/ entry point for this visitor\n+    Declaration.Scoped scan(Declaration.Scoped header) {\n+        String javaName = javaSafeIdentifier(headerName.replace(\".h\", \"_h\"), true);\n+        curScope = Scope.newHeader(javaName);\n+        putJavaName(header, javaName);\n+        \/\/ Process all header declarations are collect java name mappings\n+        header.members().forEach(fieldTree -> fieldTree.accept(this, null));\n+        return header;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {\n+        putJavaName(constant, makeJavaName(constant));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function func, Declaration parent) {\n+        putJavaName(func, makeJavaName(func));\n+        int i = 0;\n+        for (Declaration.Variable param : func.parameters()) {\n+            Type.Function f = Utils.getAsFunctionPointer(param.type());\n+            if (f != null) {\n+                String declFiName = func.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                putFiName(funcParamID(func, i), param, declFiName);\n+                i++;\n+            }\n+            putJavaName(param, makeJavaName(param));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped scoped, Declaration parent) {\n+        String name = scoped.name().isEmpty()? parent.name() : scoped.name();\n+        if (declJavaNames.containsKey(new NameAndDecl(name, scoped))) {\n+            \/\/skip struct that's seen already\n+            return null;\n+        }\n+\n+        boolean isStruct = Utils.isStructOrUnion(scoped);\n+        if (!isStruct) {\n+            return null;\n+        }\n+\n+        Scope oldScope = curScope;\n+        boolean isNestedAnonStruct = scoped.name().isEmpty() &&\n+            (parent instanceof Declaration.Scoped);\n+        if (!isNestedAnonStruct) {\n+            this.curScope = Scope.newStruct(oldScope, name);\n+            putJavaName(name, scoped, curScope.className());\n+        }\n+        try {\n+            scoped.members().forEach(fieldTree -> fieldTree.accept(this, scoped));\n+        } finally {\n+            this.curScope = oldScope;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef typedef, Declaration parent) {\n+        if (declJavaNames.containsKey(typedef)) {\n+            \/\/skip typedef that's seen already\n+            return null;\n+        }\n+\n+        \/\/ handle if this typedef is of a struct\/union\/enum etc.\n+        if (typedef.type() instanceof Type.Declared declared) {\n+            declared.tree().accept(this, typedef);\n+        }\n+\n+        \/\/ We may potentially generate a class for a typedef. Make sure\n+        \/\/ class name is unique in the current nesting context.\n+        String javaName = curScope.uniqueNestedClassName(typedef.name());\n+        putJavaName(typedef, javaName);\n+        Type.Function func = Utils.getAsFunctionPointer(typedef.type());\n+        if (func != null) {\n+           var paramNamesOpt = func.parameterNames();\n+           if (paramNamesOpt.isPresent()) {\n+               parameterNames.put(func,\n+                   paramNamesOpt.\n+                      get().\n+                      stream().\n+                      map(NameMangler::javaSafeIdentifier).\n+                      toList()\n+               );\n+           }\n+           putFiName(typedef, javaName);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable variable, Declaration parent) {\n+        putJavaName(variable, makeJavaName(variable));\n+        var type = variable.type();\n+        if (type instanceof Type.Declared declared) {\n+            \/\/ declared type - visit declaration recursively\n+            declared.tree().accept(this, variable);\n+        }\n+        Type.Function func = Utils.getAsFunctionPointer(type);\n+        if (func != null) {\n+            String fiName = curScope.uniqueNestedClassName(variable.name());\n+            if (parent != null) {\n+                putFiName(parent, variable, fiName);\n+            } else {\n+                putFiName(variable, fiName);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration decl, Declaration parent) {\n+        return null;\n+    }\n+\n+    private List<String> javaSafeNameList(List<String> names) {\n+        return names.stream().\n+            map(n -> n.isEmpty()? n : javaSafeIdentifier(n)).\n+            toList();\n+    }\n+\n+    private String makeJavaName(Declaration decl) {\n+        return decl.name().isEmpty()? decl.name() : javaSafeIdentifier(decl.name());\n+    }\n+\n+    \/\/ Java identifier handling helpers\n+    private static String javaSafeIdentifier(String name) {\n+        return javaSafeIdentifier(name, false);\n+    }\n+\n+    private static String javaSafeIdentifier(String name, boolean checkAllChars) {\n+        if (checkAllChars) {\n+            StringBuilder buf = new StringBuilder();\n+            char[] chars = name.toCharArray();\n+            if (Character.isJavaIdentifierStart(chars[0])) {\n+                buf.append(chars[0]);\n+            } else {\n+                buf.append('_');\n+            }\n+            if (chars.length > 1) {\n+                for (int i = 1; i < chars.length; i++) {\n+                    char ch = chars[i];\n+                    if (Character.isJavaIdentifierPart(ch)) {\n+                        buf.append(ch);\n+                    } else {\n+                        buf.append('_');\n+                    }\n+                }\n+            }\n+            return buf.toString();\n+        } else {\n+            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n+            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n+            assert SourceVersion.isIdentifier(name);\n+\n+            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) || isJavaTypeName(name)? (name + \"_\") : name;\n+        }\n+    }\n+\n+    private static boolean isRestrictedTypeName(String name) {\n+        return switch (name) {\n+            case \"var\", \"yield\", \"record\",\n+                \"sealed\", \"permits\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private static boolean isJavaTypeName(String name) {\n+        \/\/ Java types that are used unqualified in the generated code\n+        return switch (name) {\n+            case \"String\", \"Struct\", \"MethodHandle\",\n+                \"VarHandle\", \"ByteOrder\",\n+                \"FunctionDescriptor\", \"LibraryLookup\",\n+                \"MemoryLayout\",\n+                \"Arena\", \"NativeArena\", \"MemorySegment\", \"ValueLayout\",\n+                \"RuntimeHelper\" -> true;\n+            default -> false;\n+        };\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/NameMangler.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -55,7 +55,0 @@\n-    \/\/ internal symbol used by clang for \"va_list\"\n-    private static final String VA_LIST_TAG = \"__va_list_tag\";\n-    private final Set<String> constants = new HashSet<>();\n-    \/\/ To detect duplicate Variable and Function declarations.\n-    private final Set<String> variables = new HashSet<>();\n-    private final Set<Declaration.Function> functions = new HashSet<>();\n-\n@@ -65,1 +58,1 @@\n-    private final Map<Declaration, String> structClassNames = new HashMap<>();\n+    private final Map<Declaration.Scoped, String> structClassNames = new HashMap<>();\n@@ -67,2 +60,2 @@\n-    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n-    private final IncludeHelper includeHelper;\n+    private final Map<Type.Delegated, String> functionTypeDefNames = new HashMap<>();\n+    private final NameMangler nameMangler;\n@@ -70,1 +63,1 @@\n-    private void addStructDefinition(Declaration decl, String name) {\n+    private void addStructDefinition(Declaration.Scoped decl, String name) {\n@@ -74,1 +67,1 @@\n-    private boolean structDefinitionSeen(Declaration decl) {\n+    private boolean structDefinitionSeen(Declaration.Scoped decl) {\n@@ -78,1 +71,1 @@\n-    private String structDefinitionName(Declaration decl) {\n+    private String structDefinitionName(Declaration.Scoped decl) {\n@@ -94,13 +87,3 @@\n-    \/\/ have we seen this Variable earlier?\n-    protected boolean variableSeen(Declaration.Variable tree) {\n-        return !variables.add(tree.name());\n-    }\n-\n-    \/\/ have we seen this Function earlier?\n-    protected boolean functionSeen(Declaration.Function tree) {\n-        return !functions.add(tree);\n-    }\n-\n-    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName,\n-                String pkgName, IncludeHelper includeHelper, List<String> libraryNames) {\n-        String clsName = Utils.javaSafeIdentifier(headerName.replace(\".h\", \"_h\"), true);\n+    static JavaFileObject[] generateWrapped(Declaration.Scoped decl,\n+                String pkgName, List<String> libraryNames, NameMangler nameMangler) {\n+        String clsName = nameMangler.getJavaName(null, decl);\n@@ -108,1 +91,2 @@\n-        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl, libraryNames.toArray(new String[0]));\n+        return new OutputFactory(pkgName, toplevelBuilder, nameMangler).\n+            generate(decl, libraryNames.toArray(new String[0]));\n@@ -111,1 +95,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, IncludeHelper includeHelper) {\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, NameMangler nameMangler) {\n@@ -115,1 +99,1 @@\n-        this.includeHelper = includeHelper;\n+        this.nameMangler = nameMangler;\n@@ -124,2 +108,1 @@\n-            toplevelBuilder.addTypedef(td.name(),\n-                    structDefinitionSeen(structDef) ? structDefinitionName(structDef) : null, td.type());\n+            toplevelBuilder.addTypedef(td, nameMangler.getJavaName(null, td), structDefinitionName(structDef));\n@@ -173,2 +156,6 @@\n-        if (!constants.add(constant.name()) || !includeHelper.isIncluded(constant)) {\n-            \/\/skip\n+        \/*\n+         * This method is called from visitVariable when it recursively visits type\n+         * When type is enum, enum constants are visited again! Checking parent to be\n+         * null to avoid duplicate generation of enum constant getter methods.\n+         *\/\n+        if (parent != null) {\n@@ -183,3 +170,1 @@\n-        toplevelBuilder.addConstant(Utils.javaSafeIdentifier(constant.name()),\n-                constant.value() instanceof String ? MemorySegment.class :\n-                clazz, constant.value());\n+        toplevelBuilder.addConstant(constant, nameMangler.getJavaName(parent, constant), clazz);\n@@ -195,4 +180,2 @@\n-        boolean isStructKind = switch (d.kind()) {\n-            case STRUCT, UNION -> true;\n-            default -> false;\n-        };\n+\n+        boolean isStructKind = Utils.isStructOrUnion(d);\n@@ -201,4 +184,0 @@\n-            String className = d.name();\n-            if (!className.isEmpty() && !includeHelper.isIncluded(d)) {\n-                return null;\n-            }\n@@ -206,1 +185,7 @@\n-            currentBuilder = structBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            boolean isNestedAnonStruct = d.name().isEmpty() &&\n+                (parent instanceof Declaration.Scoped);\n+            currentBuilder = structBuilder = currentBuilder.addStruct(\n+                d,\n+                isNestedAnonStruct,\n+                isNestedAnonStruct? null : nameMangler.getJavaName(parent, d),\n+                layout);\n@@ -208,1 +193,4 @@\n-            if (!className.isEmpty()) {\n+            if (!d.name().isEmpty()) {\n+                addStructDefinition(d, structBuilder.fullName());\n+            }\n+            if (parent instanceof Declaration.Typedef) {\n@@ -222,1 +210,1 @@\n-    private String generateFunctionalInterface(Type.Function func, String name) {\n+    private boolean generateFunctionalInterface(Type.Function func, String javaName) {\n@@ -225,1 +213,1 @@\n-            return null;\n+            return false;\n@@ -230,1 +218,1 @@\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+            warn(\"skipping \" + javaName + \" because of unsupported type usage: \" +\n@@ -232,1 +220,1 @@\n-            return null;\n+            return false;\n@@ -238,1 +226,1 @@\n-            return null;\n+            return false;\n@@ -241,1 +229,3 @@\n-        return currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), descriptor, func.parameterNames());\n+        currentBuilder.addFunctionalInterface(func, javaName, descriptor,\n+            nameMangler.getParameterNames(func));\n+        return true;\n@@ -246,13 +236,0 @@\n-        if (functionSeen(funcTree) ||\n-                !includeHelper.isIncluded(funcTree)) {\n-            return null;\n-        }\n-\n-        String mhName = Utils.javaSafeIdentifier(funcTree.name());\n-        \/\/generate static wrapper for function\n-        List<String> paramNames = funcTree.parameters()\n-                                          .stream()\n-                                          .map(Declaration.Variable::name)\n-                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)\n-                                          .collect(Collectors.toList());\n-\n@@ -264,0 +241,1 @@\n+        \/\/generate static wrapper for function\n@@ -273,1 +251,1 @@\n-            Type.Function f = getAsFunctionPointer(param.type());\n+            Type.Function f = Utils.getAsFunctionPointer(param.type());\n@@ -275,2 +253,2 @@\n-                String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                if (generateFunctionalInterface(f, name) == null) {\n+                String fiName = nameMangler.getFiName(funcTree, i, param);\n+                if (! generateFunctionalInterface(f, fiName)) {\n@@ -283,1 +261,6 @@\n-        toplevelBuilder.addFunction(mhName, funcTree.name(), descriptor, funcTree.type().varargs(), paramNames);\n+        toplevelBuilder.addFunction(funcTree, descriptor, nameMangler.getJavaName(parent, funcTree),\n+            funcTree.parameters().\n+                stream().\n+                map(param -> nameMangler.getJavaName(null, param)).\n+                toList());\n+\n@@ -297,28 +280,0 @@\n-    Type.Function getAsFunctionPointer(Type type) {\n-        if (type instanceof Type.Function function) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return function;\n-        } else if (Utils.isPointerType(type)) {\n-            return getAsFunctionPointer(((Type.Delegated)type).type());\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    Type.Primitive getAsSignedOrUnsigned(Type type) {\n-        if (type instanceof Type.Delegated delegated &&\n-            delegated.type() instanceof Type.Primitive primitive) {\n-            var kind = delegated.kind();\n-            if (kind == Type.Delegated.Kind.SIGNED ||\n-                kind == Type.Delegated.Kind.UNSIGNED) {\n-                return primitive;\n-            }\n-        }\n-        return null;\n-    }\n-\n@@ -327,3 +282,0 @@\n-        if (!includeHelper.isIncluded(tree)) {\n-            return null;\n-        }\n@@ -351,1 +303,2 @@\n-                                toplevelBuilder.addTypedef(tree.name(), structDefinitionName(s), tree.type());\n+                                String javaName = nameMangler.getJavaName(parent, tree);\n+                                toplevelBuilder.addTypedef(tree, javaName, structDefinitionName(s));\n@@ -365,1 +318,1 @@\n-            toplevelBuilder.addTypedef(tree.name(), null, type);\n+            toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n@@ -367,1 +320,1 @@\n-            Type.Function func = getAsFunctionPointer(type);\n+            Type.Function func = Utils.getAsFunctionPointer(type);\n@@ -369,3 +322,4 @@\n-                String funcIntfName = generateFunctionalInterface(func, tree.name());\n-                if (funcIntfName != null) {\n-                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), funcIntfName);\n+                String fiName = nameMangler.getFiName(parent, tree);\n+                boolean funcIntfGen = generateFunctionalInterface(func, fiName);\n+                if (funcIntfGen) {\n+                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), fiName);\n@@ -374,1 +328,1 @@\n-                toplevelBuilder.addTypedef(tree.name(), null, type);\n+                toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null);\n@@ -376,1 +330,1 @@\n-                Type.Primitive primitive = getAsSignedOrUnsigned(type);\n+                Type.Primitive primitive = Utils.getAsSignedOrUnsigned(type);\n@@ -378,1 +332,1 @@\n-                    toplevelBuilder.addTypedef(tree.name(), null, primitive);\n+                    toplevelBuilder.addTypedef(tree, nameMangler.getJavaName(parent, tree), null, primitive);\n@@ -387,10 +341,0 @@\n-        if (parent == null && (variableSeen(tree) || !includeHelper.isIncluded(tree))) {\n-            return null;\n-        }\n-\n-        String fieldName = tree.name();\n-        String symbol = tree.name();\n-        assert !symbol.isEmpty();\n-        assert !fieldName.isEmpty();\n-        fieldName = Utils.javaSafeIdentifier(fieldName);\n-\n@@ -403,0 +347,1 @@\n+\n@@ -409,0 +354,9 @@\n+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        final String fieldName = tree.name();\n+        assert !fieldName.isEmpty();\n+\n@@ -427,1 +381,1 @@\n-        Type.Function func = getAsFunctionPointer(type);\n+        Type.Function func = Utils.getAsFunctionPointer(type);\n@@ -430,1 +384,4 @@\n-            fiName = generateFunctionalInterface(func, fieldName);\n+            fiName = nameMangler.getFiName(parent, tree);\n+            if (! generateFunctionalInterface(func, fiName)) {\n+                fiName = null;\n+            }\n@@ -434,1 +391,1 @@\n-                fiName = Utils.javaSafeIdentifier(funcTypedef.get());\n+                fiName = funcTypedef.get();\n@@ -438,7 +395,1 @@\n-        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n-                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n-            \/\/skip\n-            return null;\n-        }\n-\n-        currentBuilder.addVar(fieldName, tree.name(), layout, Optional.ofNullable(fiName));\n+        currentBuilder.addVar(tree, nameMangler.getJavaName(parent, tree), layout, Optional.ofNullable(fiName));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":80,"deletions":129,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-    StructBuilder(JavaSourceBuilder enclosing, String name, GroupLayout structLayout, Type structType) {\n+    StructBuilder(JavaSourceBuilder enclosing, Declaration.Scoped tree,\n+        String name, GroupLayout structLayout) {\n@@ -58,1 +59,1 @@\n-        this.structType = structType;\n+        this.structType = Type.declared(tree);\n@@ -109,2 +110,3 @@\n-    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n-        if (name.isEmpty() && (parent instanceof Declaration.Scoped)) {\n+    public StructBuilder addStruct(Declaration.Scoped tree, boolean isNestedAnonStruct,\n+        String name, GroupLayout layout) {\n+        if (isNestedAnonStruct) {\n@@ -116,1 +118,1 @@\n-            return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n+            return new StructBuilder(this, tree, name, layout);\n@@ -121,2 +123,3 @@\n-    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, descriptor, parameterNames);\n+    public void addFunctionalInterface(Type.Function funcType, String javaName,\n+        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n@@ -125,1 +128,0 @@\n-        return builder.className();\n@@ -129,1 +131,3 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n+    public void addVar(Declaration.Variable varTree, String javaName,\n+        MemoryLayout layout, Optional<String> fiName) {\n+        String nativeName = varTree.name();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -97,2 +97,3 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n-        nextHeader().addVar(javaName, nativeName, layout, fiName);\n+    public void addVar(Declaration.Variable varTree, String javaName,\n+        MemoryLayout layout, Optional<String> fiName) {\n+        nextHeader().addVar(varTree, javaName, layout, fiName);\n@@ -102,2 +103,3 @@\n-    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n-        nextHeader().addFunction(javaName, nativeName, descriptor, isVarargs, parameterNames);\n+    public void addFunction(Declaration.Function funcTree, FunctionDescriptor descriptor,\n+            String javaName, List<String> parameterNames) {\n+        nextHeader().addFunction(funcTree, descriptor, javaName, parameterNames);\n@@ -107,2 +109,2 @@\n-    public void addConstant(String javaName, Class<?> type, Object value) {\n-        nextHeader().addConstant(javaName, type, value);\n+    public void addConstant(Declaration.Constant constantTree, String javaName, Class<?> javaType) {\n+        nextHeader().addConstant(constantTree, javaName, javaType);\n@@ -112,1 +114,2 @@\n-    public void addTypedef(String name, String superClass, Type type) {\n+    public void addTypedef(Declaration.Typedef typedefTree, String javaName,\n+        String superClass, Type type) {\n@@ -115,1 +118,1 @@\n-            nextHeader().emitPrimitiveTypedef(primitive, name);\n+            nextHeader().emitPrimitiveTypedef(primitive, javaName);\n@@ -118,1 +121,1 @@\n-            nextHeader().emitPointerTypedef(name);\n+            nextHeader().emitPointerTypedef(javaName);\n@@ -120,1 +123,1 @@\n-            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            TypedefBuilder builder = new TypedefBuilder(this, javaName, superClass);\n@@ -128,3 +131,3 @@\n-    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n-        String structName = name.isEmpty() ? parent.name() : name;\n-        StructBuilder structBuilder = new StructBuilder(this, structName, layout, type) {\n+    public StructBuilder addStruct(Declaration.Scoped tree, boolean isNestedAnonStruct,\n+        String javaName, GroupLayout layout) {\n+        StructBuilder structBuilder = new StructBuilder(this, tree, javaName, layout) {\n@@ -146,2 +149,3 @@\n-    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, descriptor, parameterNames);\n+    public void addFunctionalInterface(Type.Function funcType, String javaName,\n+        FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, funcType, javaName, descriptor, parameterNames);\n@@ -151,1 +155,0 @@\n-        return builder.className();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -160,0 +160,16 @@\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) return true;\n+            if (obj instanceof Position pos) {\n+                return Objects.equals(path, pos.path()) &&\n+                    Objects.equals(line, pos.line()) &&\n+                    Objects.equals(column, pos.col());\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(path, line, column);\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserveold.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import java.util.List;\n+import org.openjdk.jextract.Declaration;\n+\n+interface TreeTransformer {\n+    Declaration.Scoped transform(Declaration.Scoped header);\n+\n+    default Declaration.Scoped createHeader(Declaration.Scoped old, List<Declaration> members) {\n+        return Declaration.toplevel(old.pos(), members.toArray(new Declaration[0]));\n+    }\n+\n+    default Declaration.Scoped createScoped(Declaration.Scoped old, List<Declaration> members) {\n+        var declsArray = members.toArray(new Declaration[0]);\n+        return old.layout().isEmpty() ?\n+            Declaration.scoped(old.kind(), old.pos(), old.name(), declsArray) :\n+            Declaration.scoped(old.kind(), old.pos(), old.name(), old.layout().get(), declsArray);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeTransformer.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package org.openjdk.jextract.impl;\n-\n-import org.openjdk.jextract.Declaration;\n-import org.openjdk.jextract.clang.Cursor;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/**\n- * This visitor handles certain typedef declarations.\n- *\n- * 1. Remove redundant typedefs.\n- * 2. Rename typedef'ed anonymous type definitions like\n- *        typedef struct { int x; int y; } Point;\n- *\/\n-final class TypedefHandler implements Declaration.Visitor<Void, Void> {\n-\n-    TreeMaker maker;\n-\n-    public TypedefHandler(TreeMaker maker) {\n-        this.maker = maker;\n-    }\n-\n-    \/\/ Potential Tree instances that will go into transformed HeaderTree\n-    \/\/ are collected in this list.\n-    private List<Declaration> decls = new ArrayList<>();\n-\n-    \/\/ Tree instances that are to be replaced from \"decls\" list are\n-    \/\/ saved in the following Map. One or more Trees can replace a Tree.\n-    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();\n-\n-    public Declaration.Scoped transform(Declaration.Scoped ht) {\n-        \/\/ Process all header declarations are collect potential\n-        \/\/ declarations that will go into transformed HeaderTree\n-        \/\/ into the this.decls field.\n-        ht.accept(this, null);\n-\n-\/\/        \/\/ Replace trees from this.decls with Trees found in this.replacements.\n-\/\/        \/\/ We need this two step process so that named StructTree instances\n-\/\/        \/\/ will replace with original unnamed StructTree instances.\n-\/\/        List<Declaration> newDecls = decls.stream().flatMap(tx -> {\n-\/\/            if (replacements.containsKey(tx.cursor())) {\n-\/\/                return replacements.get(tx.cursor()).stream();\n-\/\/            } else {\n-\/\/                return Stream.of(tx);\n-\/\/            }\n-\/\/        }).collect(Collectors.toList());\n-\/\/\n-\/\/        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);\n-        return ht;\n-    }\n-\n-    @Override\n-    public Void visitDeclaration(Declaration d, Void aVoid) {\n-        decls.add(d);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped ht, Void v) {\n-        ht.members().forEach(decl -> decl.accept(this, null));\n-        return null;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefHandler.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -29,0 +29,2 @@\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n@@ -30,0 +32,1 @@\n+import org.openjdk.jextract.Type.Function;\n@@ -32,2 +35,0 @@\n-import org.openjdk.jextract.clang.SourceLocation;\n-import org.openjdk.jextract.clang.Type;\n@@ -35,1 +36,0 @@\n-import javax.lang.model.SourceVersion;\n@@ -38,1 +38,0 @@\n-import java.io.IOException;\n@@ -40,0 +39,1 @@\n+import java.io.IOException;\n@@ -41,7 +41,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n@@ -53,4 +46,0 @@\n-    public static String qualifiedClassName(String packageName, String simpleName) {\n-        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n-    }\n-\n@@ -71,144 +60,0 @@\n-    static String javaSafeIdentifier(String name) {\n-        return javaSafeIdentifier(name, false);\n-    }\n-\n-    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n-        if (checkAllChars) {\n-            StringBuilder buf = new StringBuilder();\n-            char[] chars = name.toCharArray();\n-            if (Character.isJavaIdentifierStart(chars[0])) {\n-                buf.append(chars[0]);\n-            } else {\n-                buf.append('_');\n-            }\n-            if (chars.length > 1) {\n-                for (int i = 1; i < chars.length; i++) {\n-                    char ch = chars[i];\n-                    if (Character.isJavaIdentifierPart(ch)) {\n-                        buf.append(ch);\n-                    } else {\n-                        buf.append('_');\n-                    }\n-                }\n-            }\n-            return buf.toString();\n-        } else {\n-            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n-            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n-            assert SourceVersion.isIdentifier(name);\n-\n-            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) || isJavaTypeName(name)? (name + \"_\") : name;\n-        }\n-    }\n-\n-    private static boolean isRestrictedTypeName(String name) {\n-        return switch (name) {\n-            case \"var\", \"yield\", \"record\",\n-                \"sealed\", \"permits\" -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    private static boolean isJavaTypeName(String name) {\n-        \/\/ Java types that are used unqualified in the generated code\n-        return switch (name) {\n-            case \"String\", \"MethodHandle\",\n-                \"VarHandle\", \"ByteOrder\",\n-                \"FunctionDescriptor\", \"LibraryLookup\",\n-                \"MemoryLayout\", \"MemorySegment\",\n-                \"ValueLayout\", \"RuntimeHelper\" -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    static void validSimpleIdentifier(String name) {\n-        int length = name.length();\n-        if (length == 0) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        int ch = name.codePointAt(0);\n-        if (length == 1 && ch == '_') {\n-            throw new IllegalArgumentException(\"'_' is no longer valid identifier.\");\n-        }\n-\n-        if (!Character.isJavaIdentifierStart(ch)) {\n-            throw new IllegalArgumentException(\"Invalid start character for an identifier: \" + ch);\n-        }\n-\n-        for (int i = 1; i < length; i++) {\n-            ch = name.codePointAt(i);\n-            if (!Character.isJavaIdentifierPart(ch)) {\n-                throw new IllegalArgumentException(\"Invalid character for an identifier: \" + ch);\n-            }\n-        }\n-    }\n-\n-    static void validPackageName(String name) {\n-        if (name.isEmpty()) {\n-            throw new IllegalArgumentException();\n-        }\n-        int idx = name.lastIndexOf('.');\n-        if (idx == -1) {\n-           validSimpleIdentifier(name);\n-        } else {\n-            validSimpleIdentifier(name.substring(idx + 1));\n-            validPackageName(name.substring(0, idx));\n-        }\n-    }\n-\n-    static String toJavaIdentifier(String str) {\n-        final int size = str.length();\n-        StringBuilder sb = new StringBuilder(size);\n-        if (! Character.isJavaIdentifierStart(str.charAt(0))) {\n-            sb.append('_');\n-        }\n-        for (int i = 0; i < size; i++) {\n-            char ch = str.charAt(i);\n-            if (Character.isJavaIdentifierPart(ch)) {\n-                sb.append(ch);\n-            } else {\n-                sb.append('_');\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    static String toSafeName(String name) {\n-        StringBuilder sb = new StringBuilder(name.length());\n-        name = toJavaIdentifier(name);\n-        sb.append(name);\n-        if (SourceVersion.isKeyword(name)) {\n-            sb.append(\"$\");\n-        }\n-        return sb.toString();\n-    }\n-\n-    static String toClassName(String cname) {\n-        return toSafeName(cname);\n-    }\n-\n-    static String toMacroName(String mname) {\n-        return toSafeName(mname);\n-    }\n-\n-    static String toInternalName(String pkg, String name, String... nested) {\n-        if ((pkg == null || pkg.isEmpty()) && nested == null) {\n-            return name;\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        if (pkg != null && ! pkg.isEmpty()) {\n-            sb.append(pkg.replace('.', '\/'));\n-            if (sb.charAt(sb.length() - 1) != '\/') {\n-                sb.append('\/');\n-            }\n-        }\n-        sb.append(name);\n-        for (String n: nested) {\n-            sb.append('$');\n-            sb.append(n);\n-        }\n-        return sb.toString();\n-    }\n-\n@@ -219,64 +64,0 @@\n-    \/\/ return builtin Record types accessible from the given Type\n-    static Stream<Cursor> getBuiltinRecordTypes(Type type) {\n-        List<Cursor> recordTypes = new ArrayList<>();\n-        fillBuiltinRecordTypes(type, recordTypes);\n-        return recordTypes.stream().distinct();\n-    }\n-\n-    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {\n-        Type canonicalType = type.canonicalType();\n-        switch (canonicalType.kind()) {\n-            case ConstantArray:\n-            case IncompleteArray:\n-                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);\n-                break;\n-\n-            case FunctionProto:\n-            case FunctionNoProto: {\n-                final int numArgs = canonicalType.numberOfArgs();\n-                for (int i = 0; i < numArgs; i++) {\n-                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);\n-                }\n-                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);\n-            }\n-            break;\n-\n-            case Record: {\n-                Cursor c = canonicalType.getDeclarationCursor();\n-                if (c.isDefinition()) {\n-                    SourceLocation sloc = c.getSourceLocation();\n-                    if (sloc != null && sloc.getFileLocation().path() == null) {\n-                        recordTypes.add(c);\n-                    }\n-                }\n-            }\n-            break;\n-\n-            case BlockPointer:\n-            case Pointer:\n-                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);\n-                break;\n-\n-            case Unexposed:\n-                if (! canonicalType.equalType(type)) {\n-                    fillBuiltinRecordTypes(canonicalType, recordTypes);\n-                }\n-                break;\n-\n-            case Elaborated:\n-            case Typedef:\n-                fillBuiltinRecordTypes(canonicalType, recordTypes);\n-                break;\n-\n-            default: \/\/ nothing to do\n-        }\n-    }\n-\n-    \/\/ return the absolute path of the library of given name by searching\n-    \/\/ in the given array of paths.\n-    static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n-        return Arrays.stream(paths).\n-                map(p -> p.resolve(System.mapLibraryName(libName))).\n-                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n-    }\n-\n@@ -343,1 +124,8 @@\n-    static boolean isPointerType(org.openjdk.jextract.Type type) {\n+    static boolean isStructOrUnion(Declaration.Scoped scoped) {\n+        return switch (scoped.kind()) {\n+            case STRUCT, UNION -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isPointerType(Type type) {\n@@ -351,0 +139,28 @@\n+    static Function getAsFunctionPointer(Type type) {\n+        if (type instanceof Function function) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return function;\n+        } else if (isPointerType(type)) {\n+            return getAsFunctionPointer(((Delegated)type).type());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static Type.Primitive getAsSignedOrUnsigned(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+            delegated.type() instanceof Type.Primitive primitive) {\n+            var kind = delegated.kind();\n+            if (kind == Type.Delegated.Kind.SIGNED ||\n+                kind == Type.Delegated.Kind.UNSIGNED) {\n+                return primitive;\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":40,"deletions":224,"binary":false,"changes":264,"status":"modified"}]}