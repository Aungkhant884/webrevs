{"files":[{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+\n+\/**\n+ * This class models a libclang entity that has an explicit lifecycle (e.g. TranslationUnit, Index).\n+ * This class starts a new confined session and an arena allocator; this arena allocator is used by all\n+ * the abstractions \"owned\" by this disposable. For instance, as a CXCursor's lifetime is the same as that of\n+ * the CXTranslationUnit's lifetime, cursors are allocated inside the translation unit's lifetime.\n+ *\/\n+public abstract class ClangDisposable implements SegmentAllocator, AutoCloseable {\n+    protected final MemorySegment ptr;\n+    protected final MemorySession session;\n+    protected final SegmentAllocator arena;\n+\n+    public ClangDisposable(MemoryAddress ptr, long size, Runnable cleanup) {\n+        this.session = MemorySession.openConfined();\n+        this.ptr = MemorySegment.ofAddress(ptr, size, session).asReadOnly();\n+        session.addCloseAction(cleanup);\n+        this.arena = SegmentAllocator.newNativeArena(session);\n+    }\n+\n+    public ClangDisposable(MemoryAddress ptr, Runnable cleanup) {\n+        this(ptr, 0, cleanup);\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return arena.allocate(bytesSize, bytesAlignment);\n+    }\n+\n+    \/**\n+     * A libclang entity owned by some libclang disposable entity. Entities modelled by this class\n+     * do not have their own session; instead, they piggyback on the session of their owner.\n+     *\/\n+    static class Owned {\n+        final MemorySegment segment;\n+        final ClangDisposable owner;\n+\n+        protected Owned(MemorySegment segment, ClangDisposable owner) {\n+            this.segment = segment;\n+            this.owner = owner;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/ClangDisposable.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -36,2 +35,1 @@\n-import java.util.ArrayList;\n-import java.util.stream.Stream;\n+import java.util.function.Consumer;\n@@ -39,1 +37,1 @@\n-import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+public final class Cursor extends ClangDisposable.Owned {\n@@ -41,3 +39,0 @@\n-public final class Cursor {\n-\n-    private final MemorySegment cursor;\n@@ -46,3 +41,3 @@\n-    Cursor(MemorySegment cursor) {\n-        this.cursor = cursor;\n-        kind = Index_h.clang_getCursorKind(cursor);\n+    Cursor(MemorySegment segment, ClangDisposable owner) {\n+        super(segment, owner);\n+        kind = Index_h.clang_getCursorKind(segment);\n@@ -64,1 +59,1 @@\n-        return Index_h.clang_isCursorDefinition(cursor) != 0;\n+        return Index_h.clang_isCursorDefinition(segment) != 0;\n@@ -70,1 +65,1 @@\n-        return Index_h.clang_Cursor_isAnonymousRecordDecl(cursor) != 0;\n+        return Index_h.clang_Cursor_isAnonymousRecordDecl(segment) != 0;\n@@ -74,1 +69,1 @@\n-        return Index_h.clang_Cursor_isMacroFunctionLike(cursor) != 0;\n+        return Index_h.clang_Cursor_isMacroFunctionLike(segment) != 0;\n@@ -78,2 +73,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-            Index_h.clang_getCursorSpelling(allocator, cursor));\n+        var spelling = Index_h.clang_getCursorSpelling(LibClang.STRING_ALLOCATOR, segment);\n+        return LibClang.CXStrToString(spelling);\n@@ -83,2 +78,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-                Index_h.clang_getCursorUSR(allocator, cursor));\n+        var USR = Index_h.clang_getCursorUSR(LibClang.STRING_ALLOCATOR, segment);\n+        return LibClang.CXStrToString(USR);\n@@ -88,2 +83,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-            Index_h.clang_getCursorPrettyPrinted(allocator, cursor, policy.ptr()));\n+        var prettyOutput = Index_h.clang_getCursorPrettyPrinted(LibClang.STRING_ALLOCATOR, segment, policy.ptr());\n+        return LibClang.CXStrToString(prettyOutput);\n@@ -99,2 +94,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-                Index_h.clang_getCursorDisplayName(allocator, cursor));\n+        var displayName = Index_h.clang_getCursorDisplayName(LibClang.STRING_ALLOCATOR, segment);\n+        return LibClang.CXStrToString(displayName);\n@@ -104,1 +99,1 @@\n-        return Index_h.clang_equalCursors(cursor, other.cursor) != 0;\n+        return Index_h.clang_equalCursors(segment, other.segment) != 0;\n@@ -108,1 +103,2 @@\n-        return new Type(Index_h.clang_getCursorType(IMPLICIT_ALLOCATOR, cursor));\n+        var cursorType = Index_h.clang_getCursorType(owner, segment);\n+        return new Type(cursorType, owner);\n@@ -112,1 +108,2 @@\n-        return new Type(Index_h.clang_getEnumDeclIntegerType(IMPLICIT_ALLOCATOR, cursor));\n+        var enumType = Index_h.clang_getEnumDeclIntegerType(owner, segment);\n+        return new Type(enumType, owner);\n@@ -116,1 +113,2 @@\n-        return new Cursor(Index_h.clang_getCursorDefinition(IMPLICIT_ALLOCATOR, cursor));\n+        var cursorDef = Index_h.clang_getCursorDefinition(owner, segment);\n+        return new Cursor(cursorDef, owner);\n@@ -120,1 +118,1 @@\n-        MemorySegment loc = Index_h.clang_getCursorLocation(IMPLICIT_ALLOCATOR, cursor);\n+        MemorySegment loc = Index_h.clang_getCursorLocation(owner, segment);\n@@ -126,1 +124,1 @@\n-        return new SourceLocation(loc);\n+        return new SourceLocation(loc, owner);\n@@ -130,1 +128,1 @@\n-        MemorySegment range = Index_h.clang_getCursorExtent(IMPLICIT_ALLOCATOR, cursor);\n+        MemorySegment range = Index_h.clang_getCursorExtent(owner, segment);\n@@ -134,1 +132,1 @@\n-        return new SourceRange(range);\n+        return new SourceRange(range, owner);\n@@ -138,1 +136,1 @@\n-        return Index_h.clang_Cursor_getNumArguments(cursor);\n+        return Index_h.clang_Cursor_getNumArguments(segment);\n@@ -142,1 +140,2 @@\n-        return new Cursor(Index_h.clang_Cursor_getArgument(IMPLICIT_ALLOCATOR, cursor, idx));\n+        var cursorArg = Index_h.clang_Cursor_getArgument(owner, segment, idx);\n+        return new Cursor(cursorArg, owner);\n@@ -147,1 +146,1 @@\n-        return Index_h.clang_getEnumConstantDeclValue(cursor);\n+        return Index_h.clang_getEnumConstantDeclValue(segment);\n@@ -152,1 +151,1 @@\n-        return Index_h.clang_getEnumConstantDeclUnsignedValue(cursor);\n+        return Index_h.clang_getEnumConstantDeclUnsignedValue(segment);\n@@ -156,1 +155,1 @@\n-        return Index_h.clang_Cursor_isBitField(cursor) != 0;\n+        return Index_h.clang_Cursor_isBitField(segment) != 0;\n@@ -160,1 +159,1 @@\n-        return Index_h.clang_getFieldDeclBitWidth(cursor);\n+        return Index_h.clang_getFieldDeclBitWidth(segment);\n@@ -168,1 +167,1 @@\n-        return CursorLanguage.valueOf(Index_h.clang_getCursorLanguage(cursor));\n+        return CursorLanguage.valueOf(Index_h.clang_getCursorLanguage(segment));\n@@ -176,1 +175,1 @@\n-     * For a cursor that is a reference, retrieve a cursor representing the entity that it references.\n+     * For a segment that is a reference, retrieve a segment representing the entity that it references.\n@@ -179,2 +178,6 @@\n-        return new Cursor(Index_h.clang_getCursorReferenced(\n-                IMPLICIT_ALLOCATOR, cursor));\n+        var referenced = Index_h.clang_getCursorReferenced(owner, segment);\n+        return new Cursor(referenced, owner);\n+    }\n+\n+    public void forEach(Consumer<Cursor> action) {\n+        CursorChildren.forEach(this, action);\n@@ -183,0 +186,7 @@\n+    \/**\n+     * We run the visitor action inside the upcall, so that we do not have to worry about\n+     * having to copy cursors into separate off-heap storage. To do this, we have to setup\n+     * some context for the upcall, so that the upcall code can call the \"correct\" user-defined visitor action.\n+     * Note: exceptions must be delayed until after the upcall has returned; this is necessary as upcalls\n+     * cannot throw (if they do, they cause a JVM crash).\n+     *\/\n@@ -184,1 +194,36 @@\n-        private static final ArrayList<Cursor> children = new ArrayList<>();\n+\n+        static class Context {\n+            private final Consumer<Cursor> action;\n+            private final ClangDisposable owner;\n+            private RuntimeException exception;\n+\n+            Context(Consumer<Cursor> action, ClangDisposable owner) {\n+                this.action = action;\n+                this.owner = owner;\n+            }\n+\n+            boolean visit(MemorySegment segment) {\n+                \/\/ Note: the session of this cursor is smaller than that of the translation unit\n+                \/\/ this is because the cursor will be destroyed when the upcall ends. This means\n+                \/\/ that the cursor passed by the visitor must NOT be leaked into a field and accessed\n+                \/\/ at a later time (or the liveness check will fail with IllegalStateException).\n+                try {\n+                    \/\/ run the visitor action\n+                    action.accept(new Cursor(segment, owner));\n+                    return true;\n+                } catch (RuntimeException ex) {\n+                    \/\/ if we fail, record the exception, and return false to stop the visit\n+                    exception = ex;\n+                    return false;\n+                }\n+            }\n+\n+            void handleExceptions() {\n+                if (exception != null) {\n+                    throw exception;\n+                }\n+            }\n+        }\n+\n+        static Context pendingContext = null;\n+\n@@ -186,5 +231,5 @@\n-            MemorySegment copy = MemorySegment.allocateNative(c.byteSize(), MemorySession.openImplicit());\n-            copy.copyFrom(c);\n-            Cursor cursor = new Cursor(copy);\n-            children.add(cursor);\n-            return Index_h.CXChildVisit_Continue();\n+            if (pendingContext.visit(c)) {\n+                return Index_h.CXChildVisit_Continue();\n+            } else {\n+                return Index_h.CXChildVisit_Break();\n+            }\n@@ -193,1 +238,3 @@\n-        synchronized static Stream<Cursor> get(Cursor c) {\n+        synchronized static void forEach(Cursor c, Consumer<Cursor> op) {\n+            \/\/ everything is confined, no need to synchronize\n+            Context prevContext = pendingContext;\n@@ -195,2 +242,3 @@\n-                Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);\n-                return new ArrayList<>(children).stream();\n+                pendingContext = new Context(op, c.owner);\n+                Index_h.clang_visitChildren(c.segment, callback, MemoryAddress.NULL);\n+                pendingContext.handleExceptions();\n@@ -198,1 +246,1 @@\n-                children.clear();\n+                pendingContext = prevContext;\n@@ -203,13 +251,0 @@\n-    public Stream<Cursor> children() {\n-        return CursorChildren.get(this);\n-    }\n-\n-    public Stream<Cursor> allChildren() {\n-        return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));\n-    }\n-\n-    public String getMangling() {\n-        return LibClang.CXStrToString(allocator ->\n-                Index_h.clang_Cursor_getMangling(allocator, cursor));\n-    }\n-\n@@ -217,1 +252,1 @@\n-        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(cursor));\n+        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(segment));\n@@ -221,1 +256,1 @@\n-        return Index_h.clang_Cursor_Evaluate(cursor);\n+        return Index_h.clang_Cursor_Evaluate(segment);\n@@ -230,1 +265,1 @@\n-        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(cursor));\n+        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(segment));\n@@ -239,1 +274,1 @@\n-                (Index_h.clang_equalCursors(cursor, otherCursor.cursor) != 0);\n+                (Index_h.clang_equalCursors(segment, otherCursor.segment) != 0);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":101,"deletions":66,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.SegmentAllocator;\n@@ -33,1 +31,1 @@\n-import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+import static org.openjdk.jextract.clang.LibClang.STRING_ALLOCATOR;\n@@ -35,2 +33,1 @@\n-public class Diagnostic {\n-    final MemoryAddress ptr;\n+public class Diagnostic extends ClangDisposable {\n@@ -71,1 +68,1 @@\n-        this.ptr = ptr;\n+        super(ptr, () -> Index_h.clang_disposeDiagnostic(ptr));\n@@ -79,1 +76,2 @@\n-        return new SourceLocation(Index_h.clang_getDiagnosticLocation(IMPLICIT_ALLOCATOR, ptr));\n+        var loc = Index_h.clang_getDiagnosticLocation(arena, ptr);\n+        return new SourceLocation(loc, this);\n@@ -83,5 +81,2 @@\n-       return LibClang.CXStrToString(allocator -> Index_h.clang_getDiagnosticSpelling(allocator, ptr));\n-    }\n-\n-    public void dispose() {\n-        Index_h.clang_disposeDiagnostic(ptr);\n+       var spelling = Index_h.clang_getDiagnosticSpelling(STRING_ALLOCATOR, ptr);\n+       return LibClang.CXStrToString(spelling);\n@@ -92,3 +87,3 @@\n-        return LibClang.CXStrToString(allocator ->\n-            Index_h.clang_formatDiagnostic(allocator, ptr,\n-                Index_h.clang_defaultDiagnosticDisplayOptions()));\n+        var diagString = Index_h.clang_formatDiagnostic(arena, ptr,\n+                Index_h.clang_defaultDiagnosticDisplayOptions());\n+        return LibClang.CXStrToString(diagString);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Diagnostic.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -37,2 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -40,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -44,5 +40,1 @@\n-public class Index implements AutoCloseable {\n-    \/\/ Pointer to CXIndex\n-    private MemoryAddress ptr;\n-    \/\/ Set of TranslationUnit\n-    public final List<TranslationUnit> translationUnits;\n+public class Index extends ClangDisposable {\n@@ -50,3 +42,2 @@\n-    Index(MemoryAddress ptr) {\n-        this.ptr = ptr;\n-        translationUnits = new ArrayList<>();\n+    Index(MemoryAddress addr) {\n+        super(addr, () -> Index_h.clang_disposeIndex(addr));\n@@ -109,1 +100,0 @@\n-            translationUnits.add(rv);\n@@ -133,15 +123,0 @@\n-    @Override\n-    public void close() {\n-        dispose();\n-    }\n-\n-    public void dispose() {\n-        for (TranslationUnit tu: translationUnits) {\n-            tu.dispose();\n-        }\n-        if (ptr != MemoryAddress.NULL) {\n-            Index_h.clang_disposeIndex(ptr);\n-        }\n-        ptr = MemoryAddress.NULL;\n-    }\n-\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Index.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-import java.lang.invoke.MethodType;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n@@ -52,3 +49,0 @@\n-    final static SegmentAllocator IMPLICIT_ALLOCATOR =\n-            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n-\n@@ -56,1 +50,2 @@\n-            IMPLICIT_ALLOCATOR.allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n+            SegmentAllocator.implicitAllocator()\n+                            .allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n@@ -82,2 +77,1 @@\n-    public static String CXStrToString(Function<SegmentAllocator, MemorySegment> segmentSupplier) {\n-        MemorySegment cxstr = segmentSupplier.apply(STRING_ALLOCATOR);\n+    public static String CXStrToString(MemorySegment cxstr) {\n@@ -96,1 +90,1 @@\n-    private final static SegmentAllocator STRING_ALLOCATOR = SegmentAllocator.prefixAllocator(\n+    public final static SegmentAllocator STRING_ALLOCATOR = SegmentAllocator.prefixAllocator(\n@@ -100,1 +94,2 @@\n-        return CXStrToString(Index_h::clang_getClangVersion);\n+        var clangVersion = Index_h.clang_getClangVersion(STRING_ALLOCATOR);\n+        return CXStrToString(clangVersion);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/LibClang.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -39,0 +38,1 @@\n+import static org.openjdk.jextract.clang.LibClang.STRING_ALLOCATOR;\n@@ -42,1 +42,1 @@\n-public class SourceLocation {\n+public class SourceLocation extends ClangDisposable.Owned {\n@@ -46,1 +46,2 @@\n-    SourceLocation(MemorySegment loc) {\n+    SourceLocation(MemorySegment loc, ClangDisposable owner) {\n+        super(loc, owner);\n@@ -74,2 +75,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-                Index_h.clang_getFileName(allocator, fname));\n+        var filename = Index_h.clang_getFileName(STRING_ALLOCATOR, fname);\n+        return LibClang.CXStrToString(filename);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SourceLocation.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -32,1 +31,1 @@\n-import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+public class SourceRange extends ClangDisposable.Owned {\n@@ -34,5 +33,2 @@\n-public class SourceRange {\n-    final MemorySegment range;\n-\n-    SourceRange(MemorySegment range) {\n-        this.range = range;\n+    SourceRange(MemorySegment range, ClangDisposable owner) {\n+        super(range, owner);\n@@ -42,2 +38,2 @@\n-        MemorySegment loc = Index_h.clang_getRangeStart(IMPLICIT_ALLOCATOR, range);\n-        return new SourceLocation(loc);\n+        var rangeStart = Index_h.clang_getRangeStart(owner, segment);\n+        return new SourceLocation(rangeStart, owner);\n@@ -47,2 +43,2 @@\n-        MemorySegment loc = Index_h.clang_getRangeEnd(IMPLICIT_ALLOCATOR, range);\n-        return new SourceLocation(loc);\n+        var rangeEnd = Index_h.clang_getRangeEnd(owner, segment);\n+        return new SourceLocation(rangeEnd, owner);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SourceRange.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static org.openjdk.jextract.clang.LibClang.STRING_ALLOCATOR;\n@@ -46,3 +47,1 @@\n-import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n-\n-public class TranslationUnit implements AutoCloseable {\n+public class TranslationUnit extends ClangDisposable {\n@@ -51,4 +50,2 @@\n-    private MemoryAddress tu;\n-\n-    TranslationUnit(MemoryAddress tu) {\n-        this.tu = tu;\n+    TranslationUnit(MemoryAddress addr) {\n+        super(addr, () -> Index_h.clang_disposeTranslationUnit(addr));\n@@ -58,12 +55,2 @@\n-        return new Cursor(Index_h.clang_getTranslationUnitCursor(IMPLICIT_ALLOCATOR, tu));\n-    }\n-\n-    public Diagnostic[] getDiagnostics() {\n-        int cntDiags = Index_h.clang_getNumDiagnostics(tu);\n-        Diagnostic[] rv = new Diagnostic[cntDiags];\n-        for (int i = 0; i < cntDiags; i++) {\n-            MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);\n-            rv[i] = new Diagnostic(diag);\n-        }\n-\n-        return rv;\n+        var cursor = Index_h.clang_getTranslationUnitCursor(arena, ptr);\n+        return new Cursor(cursor, this);\n@@ -76,1 +63,1 @@\n-            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr, 0));\n+            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(ptr, pathStr, 0));\n@@ -85,2 +72,4 @@\n-        for (Diagnostic diag : getDiagnostics()) {\n-            dh.accept(diag);\n+        int cntDiags = Index_h.clang_getNumDiagnostics(ptr);\n+        for (int i = 0; i < cntDiags; i++) {\n+            MemoryAddress diag = Index_h.clang_getDiagnostic(ptr, i);\n+            dh.accept(new Diagnostic(diag));\n@@ -110,1 +99,1 @@\n-                        tu,\n+                        ptr,\n@@ -113,1 +102,1 @@\n-                        Index_h.clang_defaultReparseOptions(tu)));\n+                        Index_h.clang_defaultReparseOptions(ptr)));\n@@ -128,4 +117,6 @@\n-        Tokens tokens = tokenize(range);\n-        String rv[] = new String[tokens.size()];\n-        for (int i = 0; i < rv.length; i++) {\n-            rv[i] = tokens.getToken(i).spelling();\n+        try (Tokens tokens = tokenize(range)) {\n+            String rv[] = new String[tokens.size()];\n+            for (int i = 0; i < rv.length; i++) {\n+                rv[i] = tokens.getToken(i).spelling();\n+            }\n+            return rv;\n@@ -133,1 +124,0 @@\n-        return rv;\n@@ -140,1 +130,1 @@\n-            Index_h.clang_tokenize(tu, range.range, p, pCnt);\n+            Index_h.clang_tokenize(ptr, range.segment, p, pCnt);\n@@ -146,14 +136,1 @@\n-    @Override\n-    public void close() {\n-        dispose();\n-    }\n-\n-    public void dispose() {\n-        if (tu != MemoryAddress.NULL) {\n-            Index_h.clang_disposeTranslationUnit(tu);\n-            tu = MemoryAddress.NULL;\n-        }\n-    }\n-\n-    public class Tokens {\n-        private final MemoryAddress ar;\n+    public class Tokens extends ClangDisposable {\n@@ -162,2 +139,3 @@\n-        Tokens(MemoryAddress ar, int size) {\n-            this.ar = ar;\n+        Tokens(MemoryAddress addr, int size) {\n+            super(addr, size * CXToken.$LAYOUT().byteSize(),\n+                    () -> Index_h.clang_disposeTokens(TranslationUnit.this.ptr, addr, size));\n@@ -167,4 +145,0 @@\n-        public void dispose() {\n-            Index_h.clang_disposeTokens(tu, ar, size);\n-        }\n-\n@@ -176,2 +150,1 @@\n-            MemoryAddress p = ar.addOffset(idx * CXToken.$LAYOUT().byteSize());\n-            return MemorySegment.ofAddress(p, CXToken.$LAYOUT().byteSize(), MemorySession.openConfined());\n+            return ptr.asSlice(idx * CXToken.$LAYOUT().byteSize());\n@@ -181,1 +154,1 @@\n-            return new Token(getTokenSegment(index));\n+            return new Token(getTokenSegment(index), this);\n@@ -191,3 +164,1 @@\n-                int pos = i;\n-                sb.append(LibClang.CXStrToString(allocator ->\n-                        Index_h.clang_getTokenSpelling(allocator, tu, getTokenSegment(pos))));\n+                sb.append(getToken(i).spelling());\n@@ -198,1 +169,0 @@\n-    }\n@@ -200,6 +170,4 @@\n-    public class Token {\n-        final MemorySegment token;\n-\n-        Token(MemorySegment token) {\n-            this.token = token;\n-        }\n+        public class Token extends ClangDisposable.Owned {\n+            Token(MemorySegment token, ClangDisposable owner) {\n+                super(token, owner);\n+            }\n@@ -207,3 +175,3 @@\n-        public int kind() {\n-            return Index_h.clang_getTokenKind(token);\n-        }\n+            public int kind() {\n+                return Index_h.clang_getTokenKind(segment);\n+            }\n@@ -211,4 +179,4 @@\n-        public String spelling() {\n-            return LibClang.CXStrToString(allocator ->\n-                    Index_h.clang_getTokenSpelling(allocator, tu, token));\n-        }\n+            public String spelling() {\n+                var spelling = Index_h.clang_getTokenSpelling(STRING_ALLOCATOR, TranslationUnit.this.ptr, segment);\n+                return LibClang.CXStrToString(spelling);\n+            }\n@@ -216,4 +184,4 @@\n-        public SourceLocation getLocation() {\n-            return new SourceLocation(Index_h.clang_getTokenLocation(\n-                IMPLICIT_ALLOCATOR, tu, token));\n-        }\n+            public SourceLocation getLocation() {\n+                var tokenLoc = Index_h.clang_getTokenLocation(owner, TranslationUnit.this.ptr, segment);\n+                return new SourceLocation(tokenLoc, owner);\n+            }\n@@ -221,3 +189,4 @@\n-        public SourceRange getExtent() {\n-            return new SourceRange(Index_h.clang_getTokenExtent(IMPLICIT_ALLOCATOR,\n-                    tu, token));\n+            public SourceRange getExtent() {\n+                var tokenExt = Index_h.clang_getTokenExtent(owner, TranslationUnit.this.ptr, segment);\n+                return new SourceRange(tokenExt, owner);\n+            }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TranslationUnit.java","additions":46,"deletions":77,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -35,1 +34,1 @@\n-import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+import static org.openjdk.jextract.clang.LibClang.STRING_ALLOCATOR;\n@@ -37,4 +36,4 @@\n-public final class Type {\n-    private final MemorySegment type;\n-    Type(MemorySegment type) {\n-        this.type = type;\n+public final class Type extends ClangDisposable.Owned {\n+\n+    Type(MemorySegment segment, ClangDisposable owner) {\n+        super(segment, owner);\n@@ -49,1 +48,1 @@\n-        return Index_h.clang_isFunctionTypeVariadic(type) != 0;\n+        return Index_h.clang_isFunctionTypeVariadic(segment) != 0;\n@@ -52,1 +51,2 @@\n-        return new Type(Index_h.clang_getResultType(IMPLICIT_ALLOCATOR, type));\n+        var resultType = Index_h.clang_getResultType(owner, segment);\n+        return new Type(resultType, owner);\n@@ -55,1 +55,1 @@\n-        return Index_h.clang_getNumArgTypes(type);\n+        return Index_h.clang_getNumArgTypes(segment);\n@@ -58,1 +58,2 @@\n-        return new Type(Index_h.clang_getArgType(IMPLICIT_ALLOCATOR, type, idx));\n+        var argType = Index_h.clang_getArgType(owner, segment, idx);\n+        return new Type(argType, owner);\n@@ -61,1 +62,1 @@\n-        return Index_h.clang_getFunctionTypeCallingConv(type);\n+        return Index_h.clang_getFunctionTypeCallingConv(segment);\n@@ -88,1 +89,1 @@\n-    \/\/ Pointer type\n+    \/\/ Pointer segment\n@@ -90,1 +91,2 @@\n-        return new Type(Index_h.clang_getPointeeType(IMPLICIT_ALLOCATOR, type));\n+        var pointee = Index_h.clang_getPointeeType(owner, segment);\n+        return new Type(pointee, owner);\n@@ -93,1 +95,1 @@\n-    \/\/ array\/vector type\n+    \/\/ array\/vector segment\n@@ -95,1 +97,2 @@\n-        return new Type(Index_h.clang_getElementType(IMPLICIT_ALLOCATOR, type));\n+        var elementType = Index_h.clang_getElementType(owner, segment);\n+        return new Type(elementType, owner);\n@@ -99,1 +102,1 @@\n-        return Index_h.clang_getNumElements(type);\n+        return Index_h.clang_getNumElements(segment);\n@@ -107,1 +110,1 @@\n-            return Index_h.clang_Type_getOffsetOf(type, cfname);\n+            return Index_h.clang_Type_getOffsetOf(segment, cfname);\n@@ -114,1 +117,1 @@\n-            throw new TypeLayoutError(res, String.format(\"type: %s, fieldName: %s\", this, fieldName));\n+            throw new TypeLayoutError(res, String.format(\"segment: %s, fieldName: %s\", this, fieldName));\n@@ -121,1 +124,1 @@\n-     * Return the canonical type for a Type.\n+     * Return the canonical segment for a Type.\n@@ -123,4 +126,4 @@\n-     * Clang's type system explicitly models typedefs and all the ways\n-     * a specific type can be represented.  The canonical type is the underlying\n-     * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n-     * for 'int', the canonical type for 'T' would be 'int'.\n+     * Clang's segment system explicitly models typedefs and all the ways\n+     * a specific segment can be represented.  The canonical segment is the underlying\n+     * segment with all the \"sugar\" removed.  For example, if 'T' is a typedef\n+     * for 'int', the canonical segment for 'T' would be 'int'.\n@@ -129,1 +132,2 @@\n-        return new Type(Index_h.clang_getCanonicalType(IMPLICIT_ALLOCATOR, type));\n+        var canonicalType = Index_h.clang_getCanonicalType(owner, segment);\n+        return new Type(canonicalType, owner);\n@@ -138,1 +142,1 @@\n-        return Index_h.clang_isConstQualifiedType(type) != 0;\n+        return Index_h.clang_isConstQualifiedType(segment) != 0;\n@@ -147,1 +151,1 @@\n-        return Index_h.clang_isVolatileQualifiedType(type) != 0;\n+        return Index_h.clang_isVolatileQualifiedType(segment) != 0;\n@@ -151,2 +155,2 @@\n-        return LibClang.CXStrToString(allocator ->\n-                Index_h.clang_getTypeSpelling(allocator, type));\n+        var spelling = Index_h.clang_getTypeSpelling(STRING_ALLOCATOR, segment);\n+        return LibClang.CXStrToString(spelling);\n@@ -156,1 +160,1 @@\n-        return CXType.kind$get(type);\n+        return CXType.kind$get(segment);\n@@ -160,1 +164,1 @@\n-        return Index_h.clang_Type_getSizeOf(type);\n+        return Index_h.clang_Type_getSizeOf(segment);\n@@ -166,1 +170,1 @@\n-            throw new TypeLayoutError(res, String.format(\"type: %s\", this));\n+            throw new TypeLayoutError(res, String.format(\"segment: %s\", this));\n@@ -174,1 +178,1 @@\n-        \/\/ TODO: Atomic type doesn't work\n+        \/\/ TODO: Atomic segment doesn't work\n@@ -179,1 +183,2 @@\n-        return new Cursor(Index_h.clang_getTypeDeclaration(IMPLICIT_ALLOCATOR, type));\n+        var cursorDecl = Index_h.clang_getTypeDeclaration(owner, segment);\n+        return new Cursor(cursorDecl, owner);\n@@ -183,1 +188,1 @@\n-        return Index_h.clang_equalTypes(type, other.type) != 0;\n+        return Index_h.clang_equalTypes(segment, other.segment) != 0;\n@@ -191,1 +196,1 @@\n-        return other instanceof Type type && equalType(type);\n+        return other instanceof Type segment && equalType(segment);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":40,"deletions":35,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-class MacroParserImpl {\n+class MacroParserImpl implements AutoCloseable {\n@@ -81,2 +81,2 @@\n-    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n-        if (!(pos instanceof TreeMaker.CursorPosition cursorPosition)) {\n+    Optional<Declaration.Constant> parseConstant(Cursor cursor, String name, String[] tokens) {\n+        if (cursor.isMacroFunctionLike()) {\n@@ -84,10 +84,5 @@\n-        } else {\n-            Cursor cursor = cursorPosition.cursor();\n-            if (cursor.isMacroFunctionLike()) {\n-                return Optional.empty();\n-            } else if (tokens.length == 2) {\n-                \/\/check for fast path\n-                Integer num = toNumber(tokens[1]);\n-                if (num != null) {\n-                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n-                }\n+        } else if (tokens.length == 2) {\n+            \/\/check for fast path\n+            Integer num = toNumber(tokens[1]);\n+            if (num != null) {\n+                return Optional.of(treeMaker.createMacro(TreeMaker.CursorPosition.of(cursor), name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n@@ -95,2 +90,0 @@\n-            macroTable.enterMacro(name, tokens, cursor);\n-            return Optional.empty();\n@@ -98,0 +91,2 @@\n+        macroTable.enterMacro(name, tokens, TreeMaker.CursorPosition.of(cursor));\n+        return Optional.empty();\n@@ -145,1 +140,1 @@\n-        public Stream<Cursor> reparse(String snippet) {\n+        public Cursor reparse(String snippet) {\n@@ -148,1 +143,1 @@\n-            return macroUnit.getCursor().children();\n+            return macroUnit.getCursor();\n@@ -177,1 +172,1 @@\n-            final Cursor cursor;\n+            final Position position;\n@@ -179,1 +174,1 @@\n-            Entry(String name, String[] tokens, Cursor cursor) {\n+            Entry(String name, String[] tokens, Position position) {\n@@ -182,1 +177,1 @@\n-                this.cursor = cursor;\n+                this.position = position;\n@@ -213,2 +208,2 @@\n-            Unparsed(String name, String[] tokens, Cursor cursor) {\n-                super(name, tokens, cursor);\n+            Unparsed(String name, String[] tokens, Position position) {\n+                super(name, tokens, position);\n@@ -219,1 +214,1 @@\n-                return new Success(name, tokens, cursor, type, value);\n+                return new Success(name, tokens, position, type, value);\n@@ -225,2 +220,2 @@\n-                        new RecoverableFailure(name, tokens, cursor, type) :\n-                        new UnparseableMacro(name, tokens, cursor);\n+                        new RecoverableFailure(name, tokens, type, position) :\n+                        new UnparseableMacro(name, tokens, position);\n@@ -244,2 +239,2 @@\n-            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n-                super(name, tokens, cursor);\n+            public RecoverableFailure(String name, String[] tokens, Type type, Position position) {\n+                super(name, tokens, position);\n@@ -251,1 +246,1 @@\n-                return new Success(name, tokens, cursor, this.type, value);\n+                return new Success(name, tokens, position, this.type, value);\n@@ -256,1 +251,1 @@\n-                return new UnparseableMacro(name, tokens, cursor);\n+                return new UnparseableMacro(name, tokens, position);\n@@ -266,2 +261,1 @@\n-            final Type type;\n-            final Object value;\n+            final Declaration.Constant constant;\n@@ -269,4 +263,3 @@\n-            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n-                super(name, tokens, cursor);\n-                this.type = type;\n-                this.value = value;\n+            public Success(String name, String[] tokens, Position position, Type type, Object value) {\n+                super(name, tokens, position);\n+                constant = treeMaker.createMacro(position, name, type, value);\n@@ -280,2 +273,2 @@\n-            public Object value() {\n-                return value;\n+            Declaration.Constant constant() {\n+                return constant;\n@@ -287,2 +280,2 @@\n-            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n-                super(name, tokens, cursor);\n+            UnparseableMacro(String name, String[] tokens, Position position) {\n+                super(name, tokens, position);\n@@ -297,2 +290,2 @@\n-        void enterMacro(String name, String[] tokens, Cursor cursor) {\n-            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n+        void enterMacro(String name, String[] tokens, Position position) {\n+            Unparsed unparsed = new Unparsed(name, tokens, position);\n@@ -314,1 +307,1 @@\n-                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n+                    .map(e -> ((Success) e).constant())\n@@ -349,4 +342,6 @@\n-                reparser.reparse(snippet)\n-                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n-                                c.spelling().contains(\"jextract$\"))\n-                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n+                reparser.reparse(snippet).forEach(c -> {\n+                    if (c.kind() == CursorKind.VarDecl &&\n+                            c.spelling().contains(\"jextract$\")) {\n+                        updateTable(treeMaker.typeMaker, c);\n+                    }\n+                });\n@@ -379,0 +374,6 @@\n+\n+    @Override\n+    public void close() {\n+        reparser.macroUnit.close();\n+        reparser.macroIndex.close();\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":47,"deletions":46,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -52,11 +52,9 @@\n-        final Index index = LibClang.createIndex(false);\n-\n-        TranslationUnit tu = index.parse(path.toString(),\n-            d -> {\n-                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n-                    throw new ClangException(d.toString());\n-                }\n-            },\n-            true, args.toArray(new String[0]));\n-\n-        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);\n+        try (Index index = LibClang.createIndex(false) ;\n+             TranslationUnit tu = index.parse(path.toString(),\n+                d -> {\n+                    if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n+                        throw new ClangException(d.toString());\n+                    }\n+                },\n+            true, args.toArray(new String[0])) ;\n+            MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args)) {\n@@ -64,4 +62,3 @@\n-        List<Declaration> decls = new ArrayList<>();\n-        Cursor tuCursor = tu.getCursor();\n-        tuCursor.children().\n-            forEach(c -> {\n+            List<Declaration> decls = new ArrayList<>();\n+            Cursor tuCursor = tu.getCursor();\n+            tuCursor.forEach(c -> {\n@@ -81,4 +78,7 @@\n-                        c.kind() == CursorKind.Namespace) {\n-                        c.children().map(treeMaker::createTree)\n-                                .filter(t -> t != null)\n-                                .forEach(decls::add);\n+                            c.kind() == CursorKind.Namespace) {\n+                        c.forEach(t -> {\n+                            Declaration declaration = treeMaker.createTree(t);\n+                            if (declaration != null) {\n+                                decls.add(declaration);\n+                            }\n+                        });\n@@ -94,1 +94,1 @@\n-                    Optional<Declaration.Constant> constant = macroParser.parseConstant(TreeMaker.CursorPosition.of(c), c.spelling(), tokens);\n+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(c, c.spelling(), tokens);\n@@ -101,5 +101,5 @@\n-        decls.addAll(macroParser.macroTable.reparseConstants());\n-        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n-        treeMaker.freeze();\n-        index.close();\n-        return rv;\n+            decls.addAll(macroParser.macroTable.reparseConstants());\n+            Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n+            treeMaker.freeze();\n+            return rv;\n+        }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -39,2 +38,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -91,15 +88,17 @@\n-        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);\n-        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n-            \/*\n-             * Ignore bitfields of zero width.\n-             *\n-             * struct Foo {\n-             *     int i:0;\n-             * }\n-             *\n-             * And bitfields without a name.\n-             * (padding is computed automatically)\n-             *\/\n-            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n-                startBitfield();\n-                continue;\n+        cursor.forEach(fc -> {\n+            if (Utils.isFlattenable(fc)) {\n+                \/*\n+                 * Ignore bitfields of zero width.\n+                 *\n+                 * struct Foo {\n+                 *     int i:0;\n+                 * }\n+                 *\n+                 * And bitfields without a name.\n+                 * (padding is computed automatically)\n+                 *\/\n+                if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n+                    startBitfield();\n+                } else {\n+                    processField(fc);\n+                }\n@@ -107,0 +106,1 @@\n+        });\n@@ -108,1 +108,4 @@\n-            processField(fc);\n+        Declaration.Scoped declaration = finishRecord(anonName);\n+        if (cursor.isAnonymousStruct()) {\n+            \/\/ record this with a declaration attribute, so we don't have to rely on the cursor again later\n+            declaration = (Declaration.Scoped)declaration.withAttribute(\"ANONYMOUS\", true);\n@@ -110,2 +113,1 @@\n-\n-        return finishRecord(anonName);\n+        return org.openjdk.jextract.Type.declared(declaration);\n@@ -116,1 +118,1 @@\n-    abstract org.openjdk.jextract.Type.Declared finishRecord(String anonName);\n+    abstract Declaration.Scoped finishRecord(String anonName);\n@@ -176,3 +178,7 @@\n-            return Utils.flattenableChildren(c)\n-                    .mapToLong(child -> offsetOf(parent, child))\n-                    .findFirst()\n+            List<Long> offsets = new ArrayList<>();\n+            c.forEach(child -> {\n+                if (Utils.isFlattenable(child)) {\n+                    offsets.add(offsetOf(parent, child));\n+                }\n+            });\n+            return offsets.stream().findFirst()\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    org.openjdk.jextract.Type.Declared finishRecord(String anonName) {\n+    Declaration.Scoped finishRecord(String anonName) {\n@@ -151,1 +151,2 @@\n-        return org.openjdk.jextract.Type.declared(Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n+        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new));\n+        return declaration;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.HashMap;\n@@ -55,5 +56,8 @@\n-        return c.children().filter(Cursor::isAttribute)\n-                .collect(Collectors.groupingBy(\n-                        attr -> attr.kind().name(),\n-                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n-                ));\n+        Map<String, List<Constable>> attributeMap = new HashMap<>();\n+        c.forEach(child -> {\n+            if (child.isAttribute()) {\n+                List<Constable> attrs = attributeMap.computeIfAbsent(child.kind().name(), _unused -> new ArrayList<>());\n+                attrs.add(child.spelling());\n+            }\n+        });\n+        return attributeMap;\n@@ -161,3 +165,2 @@\n-    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n-        checkCursorAny(c, CursorKind.MacroDefinition);\n-        return Declaration.constant(CursorPosition.of(c), name, value, type);\n+    public Declaration.Constant createMacro(Position pos, String name, Type type, Object value) {\n+        return Declaration.constant(pos, name, value, type);\n@@ -191,9 +194,7 @@\n-        List<Declaration> decls = filterNestedDeclarations(c.children()\n-                .filter(fc -> {\n-                    if (fc.isBitField()) {\n-                        \/\/ only non-empty and named bit fields are generated\n-                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n-                    }\n-                    return true;\n-                })\n-                .map(this::createTree).collect(Collectors.toList()));\n+        List<Declaration> allDecls = new ArrayList<>();\n+        c.forEach(child -> {\n+            if (!child.isBitField() || (child.getBitFieldWidth() != 0 && !child.spelling().isEmpty())) {\n+                allDecls.add(createTree(child));\n+            }\n+        });\n+        List<Declaration> decls = filterNestedDeclarations(allDecls);\n@@ -225,1 +226,1 @@\n-        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n+        return declaration.getAttribute(\"ANONYMOUS\").isPresent();\n@@ -262,6 +263,6 @@\n-            List<String> params = c.children().\n-                filter(ch -> ch.kind() == CursorKind.ParmDecl).\n-                map(this::createTree).\n-                map(Declaration.Variable.class::cast).\n-                map(Declaration::name).\n-                collect(Collectors.toList());\n+            List<String> params = new ArrayList<>();\n+            c.forEach(child -> {\n+                if (child.kind() == CursorKind.ParmDecl) {\n+                    params.add(createTree(child).name());\n+                }\n+            });\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    org.openjdk.jextract.Type.Declared finishRecord(String anonName) {\n+    Declaration.Scoped finishRecord(String anonName) {\n@@ -105,1 +105,1 @@\n-        return org.openjdk.jextract.Type.declared(Declaration.union(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n+        return Declaration.union(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -218,3 +215,2 @@\n-    static Stream<Cursor> flattenableChildren(Cursor c) {\n-        return c.children()\n-                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n+    static boolean isFlattenable(Cursor c) {\n+        return c.isAnonymousStruct() || c.kind() == CursorKind.FieldDecl;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}