{"files":[{"patch":"@@ -140,1 +140,3 @@\n-            LongDouble(\"long double\", UnsupportedLayouts.LONG_DOUBLE),\n+            LongDouble(\"long double\", TypeImpl.IS_WINDOWS ?\n+                    ValueLayout.JAVA_DOUBLE :\n+                    UnsupportedLayouts.LONG_DOUBLE),\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+    public boolean isAnonymous() {\n+        return Index_h.clang_Cursor_isAnonymous(segment) != 0;\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,5 +211,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n-        if (descriptor == null) {\n-            return false;\n-        }\n-\n@@ -223,0 +218,5 @@\n+        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n+        if (descriptor == null) {\n+            return false;\n+        }\n+\n@@ -225,1 +225,1 @@\n-            warn(\"varargs in callbacks is not supported: \" + func);\n+            warn(\"varargs in callbacks is not supported: \" + CDeclarationPrinter.declaration(func, javaName));\n@@ -236,5 +236,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n-            return null;\n-        }\n-\n@@ -249,0 +244,5 @@\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n+        if (descriptor == null) {\n+            return null;\n+        }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-        Declaration.Scoped declaration = finishRecord(anonName);\n+        String declName = recordName();\n+        Declaration.Scoped declaration = finishRecord(anonName != null ? anonName : declName, declName);\n@@ -123,1 +124,1 @@\n-    abstract Declaration.Scoped finishRecord(String anonName);\n+    abstract Declaration.Scoped finishRecord(String layoutName, String declName);\n@@ -202,0 +203,8 @@\n+    private String recordName() {\n+        if (cursor.isAnonymous()) {\n+            return \"\";\n+        } else {\n+            return cursor.spelling();\n+        }\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+        if (offset > expectedOffset) {\n+            \/\/ out-of-order field, skip\n+            System.err.println(\"WARNING: ignoring field: \" + c.spelling() + \" in struct \" + type.spelling());\n+            return;\n+        }\n@@ -118,1 +123,1 @@\n-    Declaration.Scoped finishRecord(String anonName) {\n+    Declaration.Scoped finishRecord(String layoutName, String declName) {\n@@ -138,6 +143,2 @@\n-        if (!cursor.spelling().isEmpty()) {\n-            g = g.withName(cursor.spelling());\n-        } else if (anonName != null) {\n-            g = g.withName(anonName);\n-        }\n-        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(),\n+        g = g.withName(layoutName);\n+        Declaration.Scoped declaration = Declaration.struct(TreeMaker.CursorPosition.of(cursor), declName,\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-        List<Declaration> decls = filterNestedDeclarations(t.tree().members());\n@@ -208,0 +207,2 @@\n+            Declaration.Scoped scoped = t.tree();\n+            List<Declaration> decls = filterNestedDeclarations(scoped.members());\n@@ -209,2 +210,2 @@\n-            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(),\n-                                      t.tree().layout().get(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scoped.kind(), scoped.pos(), scoped.name(),\n+                                      scoped.layout().get(), decls.toArray(new Declaration[0]));\n@@ -216,1 +217,1 @@\n-            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling());\n@@ -233,6 +234,1 @@\n-            \/\/just a declaration\n-            \/\/if there's a real definition somewhere else, skip this redundant declaration\n-            if (!c.getDefinition().isInvalid()) {\n-                return null;\n-            }\n-            return Declaration.enum_(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return null;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    Declaration.Scoped finishRecord(String anonName) {\n+    Declaration.Scoped finishRecord(String layoutName, String declName) {\n@@ -98,6 +98,2 @@\n-        if (!cursor.spelling().isEmpty()) {\n-            g = g.withName(cursor.spelling());\n-        } else if (anonName != null) {\n-            g = g.withName(anonName);\n-        }\n-        return Declaration.union(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new));\n+        g = g.withName(layoutName);\n+        return Declaration.union(TreeMaker.CursorPosition.of(cursor), declName, g, fieldDecls.stream().toArray(Declaration[]::new));\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.ValueLayout;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedLayouts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import org.testng.SkipException;\n@@ -54,0 +55,3 @@\n+\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -89,0 +93,3 @@\n+        if (IS_WINDOWS) {\n+            throw new SkipException(\"long double works on Windows\");\n+        }\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}