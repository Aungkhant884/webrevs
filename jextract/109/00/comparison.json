{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -84,1 +83,6 @@\n-    public Constant addMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+    public Constant addDowncallMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitDowncallMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n+    }\n+\n+    public Constant addLookupMethodHandle(String javaName, String className, String name, FunctionDescriptor descriptor) {\n@@ -86,1 +90,1 @@\n-                () -> emitMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n+                () -> emitUpcallMethodHandleField(javaName, className, name, descriptor));\n@@ -200,1 +204,1 @@\n-    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+    private Constant emitDowncallMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n@@ -227,0 +231,15 @@\n+    }\n+\n+    private Constant emitUpcallMethodHandleField(String javaName, String className, String methodName, FunctionDescriptor descriptor) {\n+        Constant functionDesc = addFunctionDesc(javaName, descriptor);\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.upcallHandle(\");\n+        append(className + \".class, \");\n+        append(\"\\\"\" + methodName + \"\\\", \");\n+        append(functionDesc.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+            Constant upcallHandle = constantBuilder.addLookupMethodHandle(className() + \"_UP\", className(), \"apply\", fiDesc);\n@@ -105,2 +106,2 @@\n-            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" +\n-                functionDesc.accessExpression() + \", scope);\\n\");\n+            append(\"return RuntimeHelper.upcallStub(\" +\n+                upcallHandle.accessExpression() + \", fi, \" + functionDesc.accessExpression() + \", scope);\\n\");\n@@ -116,1 +117,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(),\n+            Constant mhConstant = constantBuilder.addDowncallMethodHandle(className() + \"_DOWN\", className(),\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.Linker;\n@@ -112,1 +111,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n+            Constant mhConstant = constantBuilder.addDowncallMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    static <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, Arena scope) {\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n@@ -76,3 +76,10 @@\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", fdesc.toMethodType());\n-            handle = handle.bindTo(z);\n-            return LINKER.upcallStub(handle, fdesc, scope);\n+            return MH_LOOKUP.findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static <Z> MemorySegment upcallStub(MethodHandle fiHandle, Z z, FunctionDescriptor fdesc, Arena scope) {\n+        try {\n+            fiHandle = fiHandle.bindTo(z);\n+            return LINKER.upcallStub(fiHandle, fdesc, scope);\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"}]}