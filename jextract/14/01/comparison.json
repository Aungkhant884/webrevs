{"files":[{"patch":"@@ -33,2 +33,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -381,0 +379,12 @@\n+    \/**\n+     * Creates a new variable declaration with given kind, name and type.\n+     * @param kind the variable declaration kind.\n+     * @param pos the variable declaration position.\n+     * @param name the variable declaration name.\n+     * @param type the variable declaration type.\n+     * @return a new variable declaration with given kind, name and type.\n+     *\/\n+    static Declaration.Variable var(Variable.Kind kind, Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, kind, name, pos);\n+    }\n+\n@@ -388,1 +398,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -400,1 +410,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -412,1 +422,1 @@\n-        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(bitfields);\n@@ -424,1 +434,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -437,1 +447,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -449,1 +459,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -462,1 +472,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -474,1 +484,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -487,1 +497,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -499,1 +509,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -512,1 +522,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -516,0 +526,27 @@\n+    \/**\n+     * Creates a new scoped declaration with given kind, name and member declarations.\n+     * @param kind the kind of the scoped declaration.\n+     * @param pos the scoped declaration position.\n+     * @param name the scoped declaration name.\n+     * @param decls the scoped declaration member declarations.\n+     * @return a new scoped declaration with given kind, name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = List.of(decls);\n+        return new DeclarationImpl.ScopedImpl(kind, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new scoped declaration with given kind, name, layout and member declarations.\n+     * @param kind the kind of the scoped declaration.\n+     * @param pos the scoped declaration position.\n+     * @param name the scoped declaration name.\n+     * @param layout the scoped declaration layout.\n+     * @param decls the scoped declaration member declarations.\n+     * @return a new scoped declaration with given kind, name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = List.of(decls);\n+        return new DeclarationImpl.ScopedImpl(kind, layout, declList, name, pos);\n+    }\n+\n@@ -525,1 +562,1 @@\n-        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());\n+        List<Variable> paramList = List.of(params);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+    public Constant addFieldVarHandle(String javaName, String nativeName, ValueLayout valueLayout,\n@@ -70,1 +70,1 @@\n-        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n+        return addVarHandle(javaName, nativeName, valueLayout, rootJavaName, prefixElementNames);\n@@ -73,2 +73,2 @@\n-    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n-        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, ValueLayout valueLayout) {\n+        return addVarHandle(javaName, nativeName, valueLayout, null, List.of());\n@@ -77,1 +77,1 @@\n-    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+    private Constant addVarHandle(String javaName, String nativeName, ValueLayout valueLayout,\n@@ -80,1 +80,1 @@\n-                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n+                () -> emitVarHandleField(javaName, nativeName, valueLayout, rootLayoutName, prefixElementNames));\n@@ -83,1 +83,1 @@\n-    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n@@ -85,1 +85,1 @@\n-                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n+                () -> emitMethodHandleField(javaName, nativeName, descriptor, isVarargs, virtual));\n@@ -187,2 +187,2 @@\n-    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n-        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, descriptor);\n@@ -204,1 +204,1 @@\n-        append(functionInfo.isVarargs());\n+        append(isVarargs);\n@@ -213,1 +213,1 @@\n-    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n+    private Constant emitVarHandleField(String javaName, String nativeName, ValueLayout valueLayout,\n@@ -217,1 +217,1 @@\n-                addLayout(javaName, varInfo.layout()).accessExpression();\n+                addLayout(javaName, valueLayout).accessExpression();\n@@ -219,1 +219,0 @@\n-        String typeName = varInfo.carrier().getName();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-                               FunctionInfo functionInfo) {\n+                               FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n@@ -51,4 +51,4 @@\n-        this.fiType = functionInfo.methodType();\n-        this.downcallType = functionInfo.reverseMethodType();\n-        this.fiDesc = functionInfo.descriptor();\n-        this.parameterNames = functionInfo.parameterNames();\n+        this.fiType = CLinker.upcallType(descriptor);\n+        this.downcallType = CLinker.downcallType(descriptor);\n+        this.fiDesc = descriptor;\n+        this.parameterNames = parameterNames;\n@@ -110,1 +110,1 @@\n-                 FunctionInfo.ofFunctionPointer(downcallType, fiType, fiDesc, parameterNames), true);\n+                 fiDesc, false, true);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n@@ -28,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -31,0 +35,1 @@\n+import jdk.incubator.foreign.SequenceLayout;\n@@ -39,0 +44,1 @@\n+import java.util.Optional;\n@@ -62,2 +68,2 @@\n-    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n-        if (varInfo.carrier().equals(MemorySegment.class)) {\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n+        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n@@ -65,1 +71,1 @@\n-                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                constantBuilder.addSegment(javaName, nativeName, layout)\n@@ -68,1 +74,1 @@\n-        } else {\n+        } else if (layout instanceof ValueLayout valueLayout) {\n@@ -70,1 +76,1 @@\n-                constantBuilder.addLayout(javaName, varInfo.layout())\n+                constantBuilder.addLayout(javaName, valueLayout)\n@@ -72,1 +78,1 @@\n-                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, valueLayout)\n@@ -74,1 +80,1 @@\n-                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, valueLayout)\n@@ -76,4 +82,4 @@\n-                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n-                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n-                if (varInfo.fiName().isPresent()) {\n-                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, valueLayout.carrier());\n+                if (fiName.isPresent()) {\n+                    emitFunctionalInterfaceGetter(fiName.get(), javaName);\n@@ -86,1 +92,1 @@\n-    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n@@ -88,1 +94,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, descriptor, isVarargs, false)\n@@ -90,2 +96,3 @@\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n-            if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+            MethodType downcallType = CLinker.downcallType(descriptor);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, isVarargs, parameterNames);\n+            if (downcallType.returnType().equals(MemorySegment.class)) {\n@@ -93,1 +100,1 @@\n-                emitFunctionWrapperScopedOverload(javaName, functionInfo);\n+                emitFunctionWrapperScopedOverload(javaName, downcallType, isVarargs, parameterNames);\n@@ -112,1 +119,1 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType declType, boolean isVarargs, List<String> parameterNames) {\n@@ -116,3 +123,1 @@\n-        MethodType declType = functionInfo.methodType();\n-        List<String> paramNames = functionInfo.parameterNames().get();\n-        if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+        if (declType.returnType().equals(MemorySegment.class)) {\n@@ -121,2 +126,2 @@\n-            paramNames = new ArrayList<>(paramNames);\n-            paramNames.add(0, \"allocator\");\n+            parameterNames = new ArrayList<>(parameterNames);\n+            parameterNames.add(0, \"allocator\");\n@@ -124,1 +129,1 @@\n-        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, functionInfo.isVarargs(), paramNames);\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, isVarargs, parameterNames);\n@@ -137,2 +142,2 @@\n-        if (!functionInfo.methodType().returnType().equals(void.class)) {\n-            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        if (!declType.returnType().equals(void.class)) {\n+            append(\"return (\" + declType.returnType().getName() + \")\");\n@@ -156,1 +161,1 @@\n-    private void emitFunctionWrapperScopedOverload(String javaName, FunctionInfo functionInfo) {\n+    private void emitFunctionWrapperScopedOverload(String javaName, MethodType declType, boolean isVarargs, List<String> parameterNames) {\n@@ -160,1 +165,1 @@\n-        List<String> paramNames = new ArrayList<>(functionInfo.parameterNames().get());\n+        List<String> paramNames = new ArrayList<>(parameterNames);\n@@ -163,2 +168,2 @@\n-        functionInfo.methodType().insertParameterTypes(0, ResourceScope.class),\n-        functionInfo.isVarargs(),\n+                declType.insertParameterTypes(0, ResourceScope.class),\n+                isVarargs,\n@@ -171,1 +176,1 @@\n-        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+        if (!declType.returnType().equals(void.class)) {\n@@ -262,1 +267,1 @@\n-                buf.append(value.toString());\n+                buf.append(value);\n@@ -275,1 +280,1 @@\n-                buf.append(value.toString());\n+                buf.append(value);\n@@ -278,0 +283,3 @@\n+        } else if (type == boolean.class) {\n+            boolean booleanValue = ((Number)value).byteValue() != 0;\n+            buf.append(booleanValue);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n@@ -42,1 +40,0 @@\n-import java.util.stream.Collectors;\n@@ -46,34 +43,1 @@\n-    \/\/ public API (used by OutputFactory)\n-\n-    public static record FunctionInfo(\n-            MethodType methodType,\n-            MethodType reverseMethodType,\n-            FunctionDescriptor descriptor,\n-            boolean isVarargs,\n-            Optional<List<String>> parameterNames) {\n-\n-        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n-            return new FunctionInfo(methodType, null, functionDescriptor, isVarargs, Optional.of(parameterNames));\n-        }\n-\n-        static FunctionInfo ofFunctionPointer(MethodType upcallType, MethodType downcallType, FunctionDescriptor functionDescriptor,\n-                 Optional<List<String>> parameterNames) {\n-            return new FunctionInfo(upcallType, downcallType, functionDescriptor, false, parameterNames);\n-        }\n-   }\n-\n-    public static record VarInfo(\n-            Class<?> carrier,\n-            MemoryLayout layout,\n-            Optional<String> fiName) {\n-\n-        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n-            return new VarInfo(carrier, layout, Optional.empty());\n-        }\n-\n-        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n-            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n-        }\n-    }\n-\n-    public void addVar(String javaName, String nativeName, ClassSourceBuilder.VarInfo varInfo) {\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n@@ -83,1 +47,1 @@\n-    public void addFunction(String javaName, String nativeName, ClassSourceBuilder.FunctionInfo functionInfo) {\n+    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n@@ -99,1 +63,1 @@\n-    public String addFunctionalInterface(String name, ClassSourceBuilder.FunctionInfo fInfo) {\n+    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import org.openjdk.jextract.JextractTool;\n@@ -32,3 +31,0 @@\n-import org.openjdk.jextract.impl.JavaSourceBuilder.VarInfo;\n-import org.openjdk.jextract.impl.JavaSourceBuilder.FunctionInfo;\n-\n@@ -39,2 +35,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodType;\n@@ -53,1 +47,0 @@\n-import java.util.function.BiFunction;\n@@ -71,1 +64,0 @@\n-    protected final TypeTranslator typeTranslator = new TypeTranslator();\n@@ -193,1 +185,1 @@\n-                getJavaType(constant.type()), constant.value());\n+                clazz, constant.value());\n@@ -231,4 +223,19 @@\n-        return functionInfo(func, name, false,\n-                 (mtype, desc) -> FunctionInfo.ofFunctionPointer(mtype, getMethodType(func, true), desc, func.parameterNames()))\n-                 .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n-                 .orElse(null);\n+        FunctionDescriptor descriptor = Type.descriptorFor(func).orElse(null);\n+        if (descriptor == null) {\n+            return null;\n+        }\n+\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(func);\n+        if (unsupportedType != null) {\n+            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            return null;\n+        }\n+\n+        \/\/generate functional interface\n+        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + func);\n+            return null;\n+        }\n+\n+        return currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), descriptor, func.parameterNames());\n@@ -252,13 +259,19 @@\n-        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n-                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n-\n-        if (functionInfo.isPresent()) {\n-            int i = 0;\n-            for (Declaration.Variable param : funcTree.parameters()) {\n-                Type.Function f = getAsFunctionPointer(param.type());\n-                if (f != null) {\n-                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                    if (generateFunctionalInterface(f, name) == null) {\n-                        return null;\n-                    }\n-                    i++;\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n+        if (descriptor == null) {\n+            return null;\n+        }\n+\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcTree.type());\n+        if (unsupportedType != null) {\n+            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            return null;\n+        }\n+\n+        int i = 0;\n+        for (Declaration.Variable param : funcTree.parameters()) {\n+            Type.Function f = getAsFunctionPointer(param.type());\n+            if (f != null) {\n+                String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                if (generateFunctionalInterface(f, name) == null) {\n+                    return null;\n@@ -266,0 +279,1 @@\n+                i++;\n@@ -267,2 +281,0 @@\n-\n-            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n@@ -271,0 +283,1 @@\n+        toplevelBuilder.addFunction(mhName, funcTree.name(), descriptor, funcTree.type().varargs(), paramNames);\n@@ -397,1 +410,0 @@\n-        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n@@ -399,1 +411,1 @@\n-        String fiName;\n+        String fiName = null;\n@@ -402,3 +414,0 @@\n-            if (fiName != null) {\n-                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n-            }\n@@ -408,1 +417,1 @@\n-                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, Utils.javaSafeIdentifier(funcTypedef.get()));\n+                fiName = Utils.javaSafeIdentifier(funcTypedef.get());\n@@ -426,1 +435,1 @@\n-            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n+            currentBuilder.addVar(fieldName, tree.name(), layout, Optional.ofNullable(fiName));\n@@ -434,27 +443,0 @@\n-    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean downcall,\n-                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n-        if (descriptor == null) {\n-            \/\/abort\n-            return Optional.empty();\n-        }\n-\n-        \/\/generate functional interface\n-        if (!downcall && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n-            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n-            return Optional.empty();\n-        }\n-\n-        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcPtr);\n-        if (unsupportedType != null) {\n-            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n-                    unsupportedType);\n-            return Optional.empty();\n-        }\n-\n-        MethodType mtype = getMethodType(funcPtr, downcall);\n-        return mtype != null ?\n-                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n-                Optional.empty();\n-    }\n-\n@@ -477,19 +459,7 @@\n-        try {\n-            return typeTranslator.getJavaType(type, false);\n-        } catch (UnsupportedOperationException uoe) {\n-            warn(uoe.toString());\n-            if (JextractTool.DEBUG) {\n-                uoe.printStackTrace();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private MethodType getMethodType(Type.Function type, boolean downcall) {\n-        try {\n-            return typeTranslator.getMethodType(type, downcall);\n-        } catch (UnsupportedOperationException uoe) {\n-            warn(uoe.toString());\n-            if (JextractTool.DEBUG) {\n-                uoe.printStackTrace();\n-            }\n+        Optional<MemoryLayout> layout = Type.layoutFor(type);\n+        if (!layout.isPresent()) return null;\n+        if (layout.get() instanceof SequenceLayout || layout.get() instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else if (layout.get() instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":52,"deletions":82,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,0 +31,2 @@\n+import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import java.util.Optional;\n@@ -118,2 +122,2 @@\n-    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n+    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, descriptor, parameterNames);\n@@ -126,1 +130,1 @@\n-    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n@@ -134,4 +138,4 @@\n-        if (varInfo.carrier().equals(MemorySegment.class)) {\n-            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n-        } else {\n-            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n+        if (layout instanceof SequenceLayout || layout instanceof GroupLayout) {\n+            emitSegmentGetter(javaName, nativeName, layout);\n+        } else if (layout instanceof ValueLayout valueLayout) {\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, valueLayout, layoutField(), prefixNamesList())\n@@ -139,6 +143,6 @@\n-            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n-            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n-            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n-            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n-            if (varInfo.fiName().isPresent()) {\n-                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+            emitFieldGetter(vhConstant, javaName, valueLayout.carrier());\n+            emitFieldSetter(vhConstant, javaName, valueLayout.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, valueLayout.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, valueLayout.carrier());\n+            if (fiName.isPresent()) {\n+                emitFunctionalInterfaceGetter(fiName.get(), javaName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -97,2 +98,2 @@\n-    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n-        nextHeader().addVar(javaName, nativeName, varInfo);\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Optional<String> fiName) {\n+        nextHeader().addVar(javaName, nativeName, layout, fiName);\n@@ -102,2 +103,2 @@\n-    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n-        nextHeader().addFunction(javaName, nativeName, functionInfo);\n+    public void addFunction(String javaName, String nativeName, FunctionDescriptor descriptor, boolean isVarargs, List<String> parameterNames) {\n+        nextHeader().addFunction(javaName, nativeName, descriptor, isVarargs, parameterNames);\n@@ -136,2 +137,2 @@\n-    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n+    public String addFunctionalInterface(String name, FunctionDescriptor descriptor, Optional<List<String>> parameterNames) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, descriptor, parameterNames);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -55,12 +54,0 @@\n-    interface ScopedFactoryLayout {\n-        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n-    }\n-\n-    interface ScopedFactoryNoLayout {\n-        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n-    }\n-\n-    interface VarFactoryNoLayout {\n-        Declaration.Variable make(Position pos, String name, Type type);\n-    }\n-\n@@ -86,24 +73,14 @@\n-        switch (c.kind()) {\n-            case EnumDecl:\n-                return createEnum(c, Declaration::enum_, Declaration::enum_);\n-            case EnumConstantDecl:\n-                return createEnumConstant(c);\n-            case FieldDecl:\n-                return createVar(c.isBitField() ?\n-                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n-            case ParmDecl:\n-                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n-            case FunctionDecl:\n-                return createFunction(c);\n-            case StructDecl:\n-                return createRecord(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n-            case UnionDecl:\n-                return createRecord(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n-            case TypedefDecl: {\n-                return createTypedef(c);\n-            }\n-            case VarDecl:\n-                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n-            default:\n-                return null;\n-        }\n+        return switch (c.kind()) {\n+            case EnumDecl -> createEnum(c);\n+            case EnumConstantDecl -> createEnumConstant(c);\n+            case FieldDecl -> c.isBitField() ?\n+                        createBitfield(c) :\n+                        createVar(c, Declaration.Variable.Kind.FIELD);\n+            case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n+            case FunctionDecl -> createFunction(c);\n+            case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n+            case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n+            case TypedefDecl -> createTypedef(c);\n+            case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n+            default -> null; \/\/ skip\n+        };\n@@ -189,1 +166,1 @@\n-    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind) {\n@@ -194,1 +171,2 @@\n-            return factoryLayout.make(CursorPosition.of(c), c.spelling(), t.tree().layout().get(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(),\n+                                      t.tree().layout().get(), decls.toArray(new Declaration[0]));\n@@ -196,8 +174,3 @@\n-            \/\/just a declaration\n-            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n-                    scopeKind == Declaration.Scoped.Kind.UNION ||\n-                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n-                \/\/if there's a real definition somewhere else, skip this redundant declaration\n-                if (!c.getDefinition().isInvalid()) {\n-                    return null;\n-                }\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n+            if (!c.getDefinition().isInvalid()) {\n+                return null;\n@@ -205,1 +178,1 @@\n-            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n@@ -209,1 +182,1 @@\n-    public Declaration.Scoped createEnum(Cursor c, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+    public Declaration.Scoped createEnum(Cursor c) {\n@@ -222,1 +195,1 @@\n-            return factoryLayout.make(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n@@ -229,1 +202,1 @@\n-            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n@@ -306,1 +279,7 @@\n-    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+    private Declaration.Variable createBitfield(Cursor c) {\n+        checkCursorAny(c, CursorKind.FieldDecl);\n+        return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n+                MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n+    }\n+\n+    private Declaration.Variable createVar(Cursor c, Declaration.Variable.Kind kind) {\n@@ -308,13 +287,7 @@\n-        if (c.isBitField()) {\n-            return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n-                    MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n-        } else {\n-            Type type = null;\n-            try {\n-                type = toType(c);\n-            } catch (TypeMaker.TypeException ex) {\n-                System.err.println(ex);\n-                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n-                return null;\n-            }\n-            return varFactory.make(CursorPosition.of(c), c.spelling(), type);\n+        Type type;\n+        try {\n+            type = toType(c);\n+        } catch (TypeMaker.TypeException ex) {\n+            System.err.println(ex);\n+            System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+            return null;\n@@ -322,0 +295,1 @@\n+        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":40,"deletions":66,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.jextract.impl;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.openjdk.jextract.Type.Primitive;\n-import org.openjdk.jextract.Type;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import java.lang.invoke.MethodType;\n-\n-public class TypeTranslator implements Type.Visitor<Class<?>, Boolean> {\n-    @Override\n-    public Class<?> visitPrimitive(Type.Primitive t, Boolean isArg) {\n-        if (t.kind().layout().isEmpty()) {\n-            return void.class;\n-        } else {\n-            return layoutToClass(isFloatingPoint(t), t.kind().layout().orElseThrow(UnsupportedOperationException::new));\n-        }\n-    }\n-\n-    private boolean isFloatingPoint(Type.Primitive t) {\n-        switch (t.kind()) {\n-            case Float:\n-            case Float128:\n-            case HalfFloat:\n-            case Double:\n-            case LongDouble:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    static Class<?> layoutToClass(boolean fp, MemoryLayout layout) {\n-        switch ((int)layout.bitSize()) {\n-            case 8: return byte.class;\n-            case 16: return short.class;\n-            case 32: return !fp ? int.class : float.class;\n-            case 64:\n-            case 128: return !fp ? long.class : double.class;\n-            default:\n-                throw new UnsupportedOperationException(\"size: \" + (int)layout.bitSize());\n-        }\n-    }\n-\n-    @Override\n-    public Class<?> visitDelegated(Type.Delegated t, Boolean isArg) {\n-        return t.kind() == Type.Delegated.Kind.POINTER ?\n-                (isArg ? Addressable.class : MemoryAddress.class) :\n-                t.type().accept(this, isArg);\n-    }\n-\n-    @Override\n-    public Class<?> visitFunction(Type.Function t, Boolean isArg) {\n-        return isArg ? Addressable.class : MemoryAddress.class; \/\/ function pointer\n-    }\n-\n-    @Override\n-    public Class<?> visitDeclared(Type.Declared t, Boolean isArg) {\n-        return switch (t.tree().kind()) {\n-            case UNION, STRUCT -> MemorySegment.class;\n-            case ENUM -> layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n-            default -> throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n-        };\n-    }\n-\n-    @Override\n-    public Class<?> visitArray(Type.Array t, Boolean isArg) {\n-        if (t.kind() == Type.Array.Kind.VECTOR) {\n-            throw new UnsupportedOperationException(\"vector\");\n-        } else {\n-            return MemorySegment.class;\n-        }\n-    }\n-\n-    @Override\n-    public Class<?> visitType(Type t, Boolean isArg) {\n-        throw new UnsupportedOperationException(t.getClass().toString());\n-    }\n-\n-    Class<?> getJavaType(Type t, boolean isArg) {\n-        return t.accept(this, isArg);\n-    }\n-\n-    MethodType getMethodType(Type.Function type, boolean downcall) {\n-        MethodType mtype = MethodType.methodType(getJavaType(type.returnType(), !downcall));\n-        for (Type arg : type.argumentTypes()) {\n-            mtype = mtype.appendParameterTypes(getJavaType(arg, downcall));\n-        }\n-        if (downcall && type.varargs()) {\n-            mtype = mtype.appendParameterTypes(Object[].class);\n-        }\n-        return mtype;\n-    }\n-}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeTranslator.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -94,1 +94,1 @@\n-                { \"BOOL_VALUE\", byte.class, equalsTo((byte)1) },\n+                { \"BOOL_VALUE\", boolean.class, equalsTo(true) },\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/ConstantsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}