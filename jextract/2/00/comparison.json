{"files":[{"patch":"@@ -0,0 +1,2 @@\n+.gradle\n+**\/build\/\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+default: all\n+\n+.NOTPARALLEL:\n+\n+include make\/Common.gmk\n+\n+JEXTRACT_NATIVE_TEST_DIR ?= $(JEXTRACT_IMAGE_NATIVE_TEST_DIR)\n+JEXTRACT_TEST_JDK ?= $(JEXTRACT_IMAGE_TEST_JDK_DIR)\n+JEXTRACT_DIR ?= $(JEXTRACT_IMAGE_DIR)\n+\n+TEST ?= test\n+\n+all: bundles\n+\n+TARGETS += all\n+\n+\n+image images test-image bundles:\n+\t$(MAKE) -f make\/Build.gmk $@\n+\n+TARGETS += image images test-image bundles\n+\n+\n+verify: test test-integration\n+\n+TARGETS += verify\n+\n+\n+test-prebuilt:\n+\t@( \\\n+\t    $(MAKE) --no-print-directory -r -R -I make\/common\/ -f make\/RunTestsPrebuilt.gmk \\\n+\t        test-prebuilt $(MAKE_ARGS) \\\n+\t        JEXTRACT_TEST_JDK=\"$(JEXTRACT_TEST_JDK)\" \\\n+\t        JEXTRACT_NATIVE_TEST_DIR=\"$(JEXTRACT_NATIVE_TEST_DIR)\" \\\n+\t        JEXTRACT_DIR=\"$(JEXTRACT_DIR)\" \\\n+\t        TEST=\"$(TEST)\" \\\n+\t)\n+\n+TARGETS += test-prebuilt\n+\n+\n+test: image test-image test-prebuilt\n+\n+TARGETS += test\n+\n+clean:\n+\trm -rf $(BUILD_DIR)\n+\n+TARGETS += clean\n+\n+\n+.PHONY: default $(TARGETS)\n","filename":"Makefile","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-## Proposal: jextract\n+## jextract\n@@ -5,2 +5,0 @@\n-### Rationale\n-\n@@ -158,0 +156,37 @@\n+\n+#### Building jextract tool\n+\n+jextract depends on clang+LLVM binaries. Please download and install clang+LLVM binaries for your platform.\n+You can find the prebuilt binaries from [https:\/\/releases.llvm.org\/download.html](https:\/\/releases.llvm.org\/download.html). The path of the clang+LLVM installation is provided using the `LIBCLANG_HOME` variable.\n+\n+Gradle tool needs jdk 17 or below to run. JAVA_HOME should be set to\n+jdk 17 or below. Or PATH should contain java from jdk 17 or below. jdk18 build is\n+needed to build jextract which is passed from command with -Pjdk18_home option.\n+\n+You can download jdk18 early access build from [https:\/\/jdk.java.net\/18\/](https:\/\/jdk.java.net\/18\/)\n+\n+For Windows, please use gradlew.bat.\n+\n+```sh\n+\n+$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -PLIBCLANG_HOME=<libclang_dir> clean verify\n+\n+```\n+\n+### Testing jextract tool\n+\n+jextract tests are written for jtreg test framework. Please download and install jtreg binaries.\n+The path of the jtreg installation is provided using the `jtreg_home` variable.\n+\n+For Windows, please use gradlew.bat.\n+\n+```sh\n+\n+$ sh .\/gradlew -Pjdk18_home=<jdk18_home_dir> -PLIBCLANG_HOME=<libclang_dir> -Pjtreg_home=<jtreg_dir> clean jtreg\n+\n+```\n+\n+### jextract samples\n+\n+jextract samples can be found \"samples\" top-level directory. Building\/running particular sample may require\n+specific third-party software installation.\n","filename":"README.md","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+import org.apache.tools.ant.taskdefs.condition.Os\n+\n+plugins {\n+    id \"java\"\n+    \/\/ moditect for module-info.class injection and jlink\n+    id \"org.moditect.gradleplugin\" version \"1.0.0-rc3\"\n+    \/\/ jpackage plugin for packging jextract native app\n+    id \"org.panteleyev.jpackageplugin\" version \"1.3.1\"\n+}\n+\n+version = '1.0'\n+\n+def libclang_home = project.property(\"LIBCLANG_HOME\")\n+def clang_version = new File(\"${libclang_home}\/lib\/clang\/\").list()[0]\n+\n+def jextract_path\n+if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n+    jextract_path = \"$buildDir\/jextract\/jextract.exe\"\n+} else if (Os.isFamily(Os.FAMILY_MAC)) {\n+    jextract_path = \"$buildDir\/jextract.app\/Contents\/MacOS\/jextract\"\n+} else {\n+    jextract_path = \"$buildDir\/jextract\/bin\/jextract\"\n+}\n+\n+def clang_include_dir = \"${libclang_home}\/lib\/clang\/${clang_version}\/include\"\n+def os_lib_dir = Os.isFamily(Os.FAMILY_WINDOWS)? \"bin\" : \"lib\"\n+def libclang_dir = \"${libclang_home}\/${os_lib_dir}\"\n+\n+repositories {\n+    mavenCentral()\n+}\n+\n+dependencies {\n+    implementation \"net.sf.jopt-simple:jopt-simple:5.0.4\"\n+}\n+\n+compileJava {\n+    options.compilerArgs.addAll(['--release', '18'])\n+    options.compilerArgs << \"--add-modules=jdk.incubator.foreign\"\n+    options.compilerArgs << \"-Xlint:all\"\n+    options.fork = true\n+    options.forkOptions.executable = \"${jdk18_home}\/bin\/javac\"\n+}\n+\n+jar {\n+    archiveBaseName = 'jextract'\n+    archiveVersion = project.version\n+}\n+\n+moditect {\n+    \/\/ moditect uses java.home to find JDK tools\n+    System.setProperty(\"java.home\", \"$jdk18_home\")\n+\n+    \/\/ inject module-info.class for org.openjdk.jextract module\n+    addMainModuleInfo {\n+        dependsOn build\n+\n+        jvmVersion = '18'\n+        version = project.version\n+        module {\n+            moduleInfoSource = '''\n+                module org.openjdk.jextract {\n+                    requires transitive java.compiler;\n+                    requires transitive jdk.incubator.foreign;\n+                    requires jopt.simple;\n+                    requires java.prefs;\n+                    exports org.openjdk.jextract;\n+\n+                    provides java.util.spi.ToolProvider with\n+                       org.openjdk.jextract.JextractTool.JextractToolProvider;\n+                }\n+                '''\n+        }\n+    }\n+\n+    \/\/ inject module-info.class for jopt.simple module\n+    addDependenciesModuleInfo {\n+        jvmVersion = '18'\n+        outputDirectory = file(\"$buildDir\/modules\")\n+        modules {\n+            module {\n+                artifact 'net.sf.jopt-simple:jopt-simple:5.0.4'\n+                moduleInfoSource = '''\n+                    module jopt.simple {\n+                        exports joptsimple;\n+                        exports joptsimple.util;\n+                    }\n+                '''\n+            }\n+        }\n+    }\n+\n+    \/\/ jlink a JDK image with org.openjdk.jextract & dependent modules only\n+    createRuntimeImage {\n+        onlyIf { !new File(\"$buildDir\/jextract-jdk-image\").exists() }\n+        outputDirectory = file(\"$buildDir\/jextract-jdk-image\")\n+        modulePath = [file(\"$buildDir\/modules\")]\n+        modules = ['org.openjdk.jextract', 'jdk.compiler']\n+    }\n+}\n+\n+task copyLibClang(type: Copy) {\n+    dependsOn createRuntimeImage\n+\n+    into(\"$buildDir\")\n+\n+    from(\"${libclang_dir}\") {\n+        include(\"*clang.*\")\n+        include(\"libLLVM.*\")\n+        into(\"jextract-jdk-image\/${os_lib_dir}\")\n+    }\n+\n+    from(\"$clang_include_dir\") {\n+        include(\"*.h\")\n+        into(\"jextract-jdk-image\/conf\/jextract\")\n+    }\n+}\n+\n+\/\/ jpackage jextract jdk image as a platform dependent native app\n+jpackage {\n+    dependsOn copyLibClang\n+    onlyIf { !new File(jextract_path).exists() }\n+\n+    appName = \"jextract\"\n+    runtimeImage = \"$buildDir\/jextract-jdk-image\/\"\n+    module = \"org.openjdk.jextract\/org.openjdk.jextract.JextractTool\"\n+    type = \"APP_IMAGE\"\n+    appVersion = \"1.0\"\n+    destination =  \"$buildDir\"\n+    javaOptions = [\n+        \"--add-modules=jdk.incubator.foreign\",\n+        \"--enable-native-access=org.openjdk.jextract\"\n+    ]\n+    winConsole = true\n+}\n+\n+\/\/ very simple integration test for generated jpackage'd jextract\n+task verify(type: Exec) {\n+    dependsOn jpackage\n+\n+    executable = \"${jextract_path}\"\n+    args = [ \"test.h\", \"-d\", \"$buildDir\/integration_test\" ]\n+}\n+\n+\/\/ jlink a JDK image with org.openjdk.jextract for testing\n+task createRuntimeImageForTest(type: org.moditect.gradleplugin.image.CreateRuntimeImageTask) {\n+    dependsOn verify\n+\n+    onlyIf { !new File(\"$buildDir\/jextract-jdk-test-image\").exists() }\n+    outputDirectory = file(\"$buildDir\/jextract-jdk-test-image\")\n+    modulePath = [file(\"$buildDir\/modules\"),file(\"$jdk18_home\/jmods\")]\n+    modules = ['ALL-MODULE-PATH']\n+}\n+\n+task prepareTestJDK(type: Copy) {\n+    dependsOn createRuntimeImageForTest\n+\n+    into(\"$buildDir\")\n+\n+    from(\"${libclang_dir}\") {\n+        include(\"*clang.*\")\n+        include(\"libLLVM.*\")\n+        into(\"jextract-jdk-test-image\/${os_lib_dir}\")\n+    }\n+\n+    from(\"$clang_include_dir\") {\n+        include(\"*.h\")\n+        into(\"jextract-jdk-test-image\/conf\/jextract\")\n+    }\n+}\n+\n+task cmakeConfigure(type: Exec) {\n+    executable = \"cmake\"\n+    args = [\n+        \"-B\", \"$buildDir\/testlib-build\",\n+        \"-S\", \"$projectDir\/test\/test-support\",\n+        \"-DTEST_SOURCE_ROOT:FILEPATH=$projectDir\/test\",\n+        \"-DCMAKE_BUILD_TYPE:STRING=Release\",\n+        \"-DCMAKE_INSTALL_PREFIX:FILEPATH=$buildDir\/testlib-install\"\n+    ]\n+}\n+\n+task cmakeBuild(type: Exec) {\n+    dependsOn cmakeConfigure\n+\n+    executable = \"cmake\"\n+    args = [\n+        \"--build\", \"$buildDir\/testlib-build\",\n+        \"--config\", \"Release\",\n+        \"--target\", \"install\"\n+    ]\n+}\n+\n+\/\/ run jtreg tests. Note: needs jtreg_cmd variable set to point to the jtreg\n+task jtreg(type: JavaExec) {\n+    dependsOn prepareTestJDK,cmakeBuild\n+\n+    workingDir = \"$buildDir\"\n+\n+    classpath = files(findProperty(\"jtreg_home\") + \"\/lib\/jtreg.jar\")\n+\n+    args = [\n+            \"-jdk\", \"$buildDir\/jextract-jdk-test-image\",\n+            \"-nativepath:$buildDir\/testlib-install\/${os_lib_dir}\",\n+            \"-javaoption:--enable-native-access=org.openjdk.jextract,ALL-UNNAMED\",\n+            \"-avm\", \"-conc:auto\", \"-verbose:summary\",\n+            \"..\/test\"\n+    ]\n+}\n","filename":"build.gradle","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"filename":"gradle\/wrapper\/gradle-wrapper.jar","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+distributionBase=GRADLE_USER_HOME\n+distributionPath=wrapper\/dists\n+distributionUrl=https\\:\/\/services.gradle.org\/distributions\/gradle-7.3.3-bin.zip\n+zipStoreBase=GRADLE_USER_HOME\n+zipStorePath=wrapper\/dists\n","filename":"gradle\/wrapper\/gradle-wrapper.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+#!\/bin\/sh\n+\n+#\n+# Copyright © 2015-2021 the original authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#      https:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+##############################################################################\n+#\n+#   Gradle start up script for POSIX generated by Gradle.\n+#\n+#   Important for running:\n+#\n+#   (1) You need a POSIX-compliant shell to run this script. If your \/bin\/sh is\n+#       noncompliant, but you have some other compliant shell such as ksh or\n+#       bash, then to run this script, type that shell name before the whole\n+#       command line, like:\n+#\n+#           ksh Gradle\n+#\n+#       Busybox and similar reduced shells will NOT work, because this script\n+#       requires all of these POSIX shell features:\n+#         * functions;\n+#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,\n+#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;\n+#         * compound commands having a testable exit status, especially «case»;\n+#         * various built-in commands including «command», «set», and «ulimit».\n+#\n+#   Important for patching:\n+#\n+#   (2) This script targets any POSIX shell, so it avoids extensions provided\n+#       by Bash, Ksh, etc; in particular arrays are avoided.\n+#\n+#       The \"traditional\" practice of packing multiple parameters into a\n+#       space-separated string is a well documented source of bugs and security\n+#       problems, so this is (mostly) avoided, by progressively accumulating\n+#       options in \"$@\", and eventually passing that to Java.\n+#\n+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,\n+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;\n+#       see the in-line comments for details.\n+#\n+#       There are tweaks for specific operating systems such as AIX, CygWin,\n+#       Darwin, MinGW, and NonStop.\n+#\n+#   (3) This script is generated from the Groovy template\n+#       https:\/\/github.com\/gradle\/gradle\/blob\/master\/subprojects\/plugins\/src\/main\/resources\/org\/gradle\/api\/internal\/plugins\/unixStartScript.txt\n+#       within the Gradle project.\n+#\n+#       You can find Gradle at https:\/\/github.com\/gradle\/gradle\/.\n+#\n+##############################################################################\n+\n+# Attempt to set APP_HOME\n+\n+# Resolve links: $0 may be a link\n+app_path=$0\n+\n+# Need this for daisy-chained symlinks.\n+while\n+    APP_HOME=${app_path%\"${app_path##*\/}\"}  # leaves a trailing \/; empty if no leading path\n+    [ -h \"$app_path\" ]\n+do\n+    ls=$( ls -ld \"$app_path\" )\n+    link=${ls#*' -> '}\n+    case $link in             #(\n+      \/*)   app_path=$link ;; #(\n+      *)    app_path=$APP_HOME$link ;;\n+    esac\n+done\n+\n+APP_HOME=$( cd \"${APP_HOME:-.\/}\" && pwd -P ) || exit\n+\n+APP_NAME=\"Gradle\"\n+APP_BASE_NAME=${0##*\/}\n+\n+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\n+DEFAULT_JVM_OPTS='\"-Xmx64m\" \"-Xms64m\"'\n+\n+# Use the maximum available, or set MAX_FD != -1 to use that value.\n+MAX_FD=maximum\n+\n+warn () {\n+    echo \"$*\"\n+} >&2\n+\n+die () {\n+    echo\n+    echo \"$*\"\n+    echo\n+    exit 1\n+} >&2\n+\n+# OS specific support (must be 'true' or 'false').\n+cygwin=false\n+msys=false\n+darwin=false\n+nonstop=false\n+case \"$( uname )\" in                #(\n+  CYGWIN* )         cygwin=true  ;; #(\n+  Darwin* )         darwin=true  ;; #(\n+  MSYS* | MINGW* )  msys=true    ;; #(\n+  NONSTOP* )        nonstop=true ;;\n+esac\n+\n+CLASSPATH=$APP_HOME\/gradle\/wrapper\/gradle-wrapper.jar\n+\n+\n+# Determine the Java command to use to start the JVM.\n+if [ -n \"$JAVA_HOME\" ] ; then\n+    if [ -x \"$JAVA_HOME\/jre\/sh\/java\" ] ; then\n+        # IBM's JDK on AIX uses strange locations for the executables\n+        JAVACMD=$JAVA_HOME\/jre\/sh\/java\n+    else\n+        JAVACMD=$JAVA_HOME\/bin\/java\n+    fi\n+    if [ ! -x \"$JAVACMD\" ] ; then\n+        die \"ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation.\"\n+    fi\n+else\n+    JAVACMD=java\n+    which java >\/dev\/null 2>&1 || die \"ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n+\n+Please set the JAVA_HOME variable in your environment to match the\n+location of your Java installation.\"\n+fi\n+\n+# Increase the maximum file descriptors if we can.\n+if ! \"$cygwin\" && ! \"$darwin\" && ! \"$nonstop\" ; then\n+    case $MAX_FD in #(\n+      max*)\n+        MAX_FD=$( ulimit -H -n ) ||\n+            warn \"Could not query maximum file descriptor limit\"\n+    esac\n+    case $MAX_FD in  #(\n+      '' | soft) :;; #(\n+      *)\n+        ulimit -n \"$MAX_FD\" ||\n+            warn \"Could not set maximum file descriptor limit to $MAX_FD\"\n+    esac\n+fi\n+\n+# Collect all arguments for the java command, stacking in reverse order:\n+#   * args from the command line\n+#   * the main class name\n+#   * -classpath\n+#   * -D...appname settings\n+#   * --module-path (only if needed)\n+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.\n+\n+# For Cygwin or MSYS, switch paths to Windows format before running java\n+if \"$cygwin\" || \"$msys\" ; then\n+    APP_HOME=$( cygpath --path --mixed \"$APP_HOME\" )\n+    CLASSPATH=$( cygpath --path --mixed \"$CLASSPATH\" )\n+\n+    JAVACMD=$( cygpath --unix \"$JAVACMD\" )\n+\n+    # Now convert the arguments - kludge to limit ourselves to \/bin\/sh\n+    for arg do\n+        if\n+            case $arg in                                #(\n+              -*)   false ;;                            # don't mess with options #(\n+              \/?*)  t=${arg#\/} t=\/${t%%\/*}              # looks like a POSIX filepath\n+                    [ -e \"$t\" ] ;;                      #(\n+              *)    false ;;\n+            esac\n+        then\n+            arg=$( cygpath --path --ignore --mixed \"$arg\" )\n+        fi\n+        # Roll the args list around exactly as many times as the number of\n+        # args, so each arg winds up back in the position where it started, but\n+        # possibly modified.\n+        #\n+        # NB: a `for` loop captures its iteration list before it begins, so\n+        # changing the positional parameters here affects neither the number of\n+        # iterations, nor the values presented in `arg`.\n+        shift                   # remove old arg\n+        set -- \"$@\" \"$arg\"      # push replacement arg\n+    done\n+fi\n+\n+# Collect all arguments for the java command;\n+#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of\n+#     shell script including quotes and variable substitutions, so put them in\n+#     double quotes to make sure that they get re-expanded; and\n+#   * put everything else in single quotes, so that it's not re-expanded.\n+\n+set -- \\\n+        \"-Dorg.gradle.appname=$APP_BASE_NAME\" \\\n+        -classpath \"$CLASSPATH\" \\\n+        org.gradle.wrapper.GradleWrapperMain \\\n+        \"$@\"\n+\n+# Use \"xargs\" to parse quoted args.\n+#\n+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.\n+#\n+# In Bash we could simply go:\n+#\n+#   readarray ARGS < <( xargs -n1 <<<\"$var\" ) &&\n+#   set -- \"${ARGS[@]}\" \"$@\"\n+#\n+# but POSIX shell has neither arrays nor command substitution, so instead we\n+# post-process each arg (as a line of input to sed) to backslash-escape any\n+# character that might be a shell metacharacter, then use eval to reverse\n+# that process (while maintaining the separation between arguments), and wrap\n+# the whole thing up as a single \"set\" statement.\n+#\n+# This will of course break if any of these variables contains a newline or\n+# an unmatched quote.\n+#\n+\n+eval \"set -- $(\n+        printf '%s\\n' \"$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS\" |\n+        xargs -n1 |\n+        sed ' s~[^-[:alnum:]+,.\/:=@_]~\\\\&~g; ' |\n+        tr '\\n' ' '\n+    )\" '\"$@\"'\n+\n+exec \"$JAVACMD\" \"$@\"\n","filename":"gradlew","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+@rem\r\n+@rem Copyright 2015 the original author or authors.\r\n+@rem\r\n+@rem Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+@rem you may not use this file except in compliance with the License.\r\n+@rem You may obtain a copy of the License at\r\n+@rem\r\n+@rem      https:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n+@rem\r\n+@rem Unless required by applicable law or agreed to in writing, software\r\n+@rem distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+@rem See the License for the specific language governing permissions and\r\n+@rem limitations under the License.\r\n+@rem\r\n+\r\n+@if \"%DEBUG%\" == \"\" @echo off\r\n+@rem ##########################################################################\r\n+@rem\r\n+@rem  Gradle startup script for Windows\r\n+@rem\r\n+@rem ##########################################################################\r\n+\r\n+@rem Set local scope for the variables with windows NT shell\r\n+if \"%OS%\"==\"Windows_NT\" setlocal\r\n+\r\n+set DIRNAME=%~dp0\r\n+if \"%DIRNAME%\" == \"\" set DIRNAME=.\r\n+set APP_BASE_NAME=%~n0\r\n+set APP_HOME=%DIRNAME%\r\n+\r\n+@rem Resolve any \".\" and \"..\" in APP_HOME to make it shorter.\r\n+for %%i in (\"%APP_HOME%\") do set APP_HOME=%%~fi\r\n+\r\n+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r\n+set DEFAULT_JVM_OPTS=\"-Xmx64m\" \"-Xms64m\"\r\n+\r\n+@rem Find java.exe\r\n+if defined JAVA_HOME goto findJavaFromJavaHome\r\n+\r\n+set JAVA_EXE=java.exe\r\n+%JAVA_EXE% -version >NUL 2>&1\r\n+if \"%ERRORLEVEL%\" == \"0\" goto execute\r\n+\r\n+echo.\r\n+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r\n+echo.\r\n+echo Please set the JAVA_HOME variable in your environment to match the\r\n+echo location of your Java installation.\r\n+\r\n+goto fail\r\n+\r\n+:findJavaFromJavaHome\r\n+set JAVA_HOME=%JAVA_HOME:\"=%\r\n+set JAVA_EXE=%JAVA_HOME%\/bin\/java.exe\r\n+\r\n+if exist \"%JAVA_EXE%\" goto execute\r\n+\r\n+echo.\r\n+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r\n+echo.\r\n+echo Please set the JAVA_HOME variable in your environment to match the\r\n+echo location of your Java installation.\r\n+\r\n+goto fail\r\n+\r\n+:execute\r\n+@rem Setup the command line\r\n+\r\n+set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r\n+\r\n+\r\n+@rem Execute Gradle\r\n+\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %*\r\n+\r\n+:end\r\n+@rem End local scope for the variables with windows NT shell\r\n+if \"%ERRORLEVEL%\"==\"0\" goto mainEnd\r\n+\r\n+:fail\r\n+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r\n+rem the _cmd.exe \/c_ return code!\r\n+if  not \"\" == \"%GRADLE_EXIT_CONSOLE%\" exit 1\r\n+exit \/b 1\r\n+\r\n+:mainEnd\r\n+if \"%OS%\"==\"Windows_NT\" endlocal\r\n+\r\n+:omega\r\n","filename":"gradlew.bat","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+include make\/Common.gmk\n+\n+$(eval $(call SetupVariable,PANAMA_JAVA_HOME))\n+$(eval $(call SetupVariable,LIBCLANG_HOME))\n+$(eval $(call SetupVariable,LIBCLANG_VERSION,,NO_CHECK))\n+$(eval $(call SetupVariable,JOPT_SIMPLE_JAR))\n+\n+include make\/NativeCompilation.gmk\n+\n+ifeq ($(PLATFORM_OS), windows)\n+  JPACKAGE_ARGS := --win-console\n+else\n+  JPACKAGE_ARGS :=\n+endif\n+\n+ifeq ($(PLATFORM_OS), macosx)\n+  TAR_SUPPORTS_TRANSFORM := false\n+else\n+  TAR_SUPPORTS_TRANSFORM := true\n+endif\n+\n+LIBCLANG_LIB_DIR := $(LIBCLANG_HOME)\/$(OS_LIB_DIR)\n+LIBCLANG_INCLUDE_DIR := $(LIBCLANG_HOME)\/lib\/clang\/$(LIBCLANG_VERSION)\/include\n+\n+BUILD_CLASSES_DIR := $(BUILD_DIR)\/classes\n+BUILD_MODULES_DIR := $(BUILD_DIR)\/modules\n+BUILD_TEST_SUPPORT_DIR := $(BUILD_DIR)\/support\/test\n+\n+BUILD_JEXTRACT_INTERIM_JDK_NAME := interim-jdk\n+BUILD_JEXTRACT_INTERIM_JDK_DIR := $(BUILD_DIR)\/images\/$(BUILD_JEXTRACT_INTERIM_JDK_NAME)\n+\n+ifeq ($(PLATFORM_OS), macosx)\n+  BUNDLE_PLATFORM := macos-$(PLATFORM_CPU)\n+else\n+  BUNDLE_PLATFORM := $(PLATFORM)\n+endif\n+\n+JEXTRACT_BUNDLE_TOP_DIR := $(JEXTRACT_NAME_VERSION)\n+JEXTRACT_BUNDLE_PREFIX := $(JEXTRACT_NAME_VERSION)-internal+0_$(BUNDLE_PLATFORM)\n+JEXTRACT_BUNDLE := $(BUILD_DIR)\/bundles\/$(JEXTRACT_BUNDLE_PREFIX)_bin.tar.gz\n+JEXTRACT_BUNDLE_TMP_DIR := $(BUILD_DIR)\/bundles\/tmp\/$(JEXTRACT_BUNDLE_TOP_DIR)\n+JEXTRACT_TESTS_BUNDLE := $(BUILD_DIR)\/bundles\/$(JEXTRACT_BUNDLE_PREFIX)_bin-tests.tar.gz\n+JEXTRACT_TEST_JDK_BUNDLE := $(BUILD_DIR)\/bundles\/$(JEXTRACT_BUNDLE_PREFIX)_bin-testjdk.tar.gz\n+\n+NATIVE_TEST_SOURCES := $(shell find $(TOPDIR)\/test -name \"lib*.c\")\n+\n+$(foreach file,$(NATIVE_TEST_SOURCES),$(eval $(call BuildNativeLibrary,$(file),$(JEXTRACT_IMAGE_NATIVE_TEST_DIR),$(BUILD_TEST_SUPPORT_DIR),BUILD_NATIVE_TEST_LIBRARIES)))\n+\n+$(BUILD_CLASSES_DIR): $(JOPT_SIMPLE_JAR)\n+\t$(MKDIR) -p $(BUILD_CLASSES_DIR)\/org\/openjdk\/jextract\/impl\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/javac \\\n+\t    --release=18 \\\n+\t    --add-modules=jdk.incubator.foreign \\\n+\t    -cp \"$(JOPT_SIMPLE_JAR)\" \\\n+\t    -d \"$(BUILD_CLASSES_DIR)\" \\\n+\t    src\/main\/java\/org\/openjdk\/jextract\/*.java \\\n+\t    src\/main\/java\/org\/openjdk\/jextract\/impl\/*.java \\\n+\t    src\/main\/java\/org\/openjdk\/jextract\/clang\/*.java \\\n+\t    src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/*.java\n+\t$(CP) -r src\/main\/java\/META-INF $(BUILD_CLASSES_DIR)\n+\t$(CP) -r src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources $(BUILD_CLASSES_DIR)\/org\/openjdk\/jextract\/impl\n+\n+$(BUILD_MODULES_DIR): $(BUILD_CLASSES_DIR) $(JOPT_SIMPLE_JAR)\n+\t$(MKDIR) -p $(BUILD_MODULES_DIR)\/jopt.simple\n+\t$(MKDIR) -p $(BUILD_MODULES_DIR)\/org.openjdk.jextract\n+\n+        # Generate module-info.java for jopt.simple module\n+\t@$(PRINTF) \"module jopt.simple {\\n \\\n+\t    exports joptsimple;\\n \\\n+\t    exports joptsimple.util;\\n \\\n+\t}\" > $(BUILD_MODULES_DIR)\/jopt.simple\/module-info.java\n+\n+        # Generate module-info.java for org.openjdk.jextract module\n+\t@$(PRINTF) \"module org.openjdk.jextract {\\n \\\n+\t    requires transitive java.compiler;\\n \\\n+\t    requires transitive jdk.incubator.foreign;\\n \\\n+\t    requires jopt.simple;\\n \\\n+\t    requires java.prefs;\\n \\\n+\t    exports org.openjdk.jextract;\\n \\\n+\t    provides java.util.spi.ToolProvider with\\n \\\n+\t        org.openjdk.jextract.JextractTool.JextractToolProvider;\\n \\\n+\t}\" > $(BUILD_MODULES_DIR)\/org.openjdk.jextract\/module-info.java\n+\n+        # Copy org.openjdk.jextract classes to the right place\n+\t$(CP) -r $(BUILD_CLASSES_DIR)\/* $(BUILD_MODULES_DIR)\/org.openjdk.jextract\n+\n+        # Extract jopt-simple in the right place\n+\t($(CD) $(BUILD_MODULES_DIR)\/jopt.simple; $(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/jar xf \"$(JOPT_SIMPLE_JAR)\")\n+\n+        # Compile the generated module-info.java files\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/javac \\\n+\t    -d \"$(BUILD_MODULES_DIR)\/jopt.simple\" \\\n+\t    \"$(BUILD_MODULES_DIR)\/jopt.simple\/module-info.java\"\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/javac \\\n+\t    --module-path \"$(BUILD_MODULES_DIR)\" \\\n+\t    -d \"$(BUILD_MODULES_DIR)\/org.openjdk.jextract\" \\\n+\t    \"$(BUILD_MODULES_DIR)\/org.openjdk.jextract\/module-info.java\"\n+\n+$(BUILD_JEXTRACT_INTERIM_JDK_DIR): $(BUILD_MODULES_DIR)\n+        # jlink the modules to create a custom runtime image for jextract\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/jlink \\\n+\t    --output \"$(BUILD_JEXTRACT_INTERIM_JDK_DIR)\" \\\n+\t    --module-path \"$(BUILD_MODULES_DIR)\" \\\n+\t    --add-modules org.openjdk.jextract \\\n+\t    --add-modules jdk.compiler\n+\n+        # Copy libclang library and header files into the jlink'ed image\n+\t$(CP) \"$(LIBCLANG_LIB_DIR)\/\"*clang.* \"$(BUILD_JEXTRACT_INTERIM_JDK_DIR)\/$(OS_LIB_DIR)\"\n+\t$(MKDIR) -p $(BUILD_JEXTRACT_INTERIM_JDK_DIR)\/conf\/jextract\n+\t$(CP) \"$(LIBCLANG_INCLUDE_DIR)\/\"*.h \"$(BUILD_JEXTRACT_INTERIM_JDK_DIR)\/conf\/jextract\/\"\n+\n+$(JEXTRACT_IMAGE_DIR): $(BUILD_JEXTRACT_INTERIM_JDK_DIR)\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/jpackage \\\n+\t    --name jextract \\\n+\t    --runtime-image \"$(BUILD_JEXTRACT_INTERIM_JDK_DIR)\" \\\n+\t    --module org.openjdk.jextract\/org.openjdk.jextract.JextractTool \\\n+\t    --type app-image \\\n+\t    --app-version 1.0 \\\n+\t    --dest \"$(patsubst %\/,%,$(dir $@))\" \\\n+\t    --java-options --add-modules=jdk.incubator.foreign \\\n+\t    --java-options --add-modules=org.openjdk.jextract \\\n+\t    --java-options --enable-native-access=org.openjdk.jextract \\\n+\t    $(JPACKAGE_ARGS)\n+\n+$(JEXTRACT_IMAGE_TEST_JDK_DIR): $(JEXTRACT_IMAGE_DIR)\n+        # jlink the modules to create a custom runtime image for jextract testing\n+\t$(FIXPATH) $(PANAMA_JAVA_HOME)\/bin\/jlink \\\n+\t    -J-Djlink.debug=true \\\n+\t    --output \"$(JEXTRACT_IMAGE_TEST_JDK_DIR)\" \\\n+\t    --module-path \"$(BUILD_MODULES_DIR):$(PANAMA_JAVA_HOME)\/jmods\" \\\n+\t    --add-modules ALL-MODULE-PATH\n+\n+        # Copy libclang library and header files into the jlink'ed test image\n+\t$(CP) $(LIBCLANG_LIB_DIR)\/*clang.* $(JEXTRACT_IMAGE_TEST_JDK_DIR)\/$(OS_LIB_DIR)\n+\t$(MKDIR) -p $(JEXTRACT_IMAGE_TEST_JDK_DIR)\/conf\/jextract\n+\t$(CP) $(LIBCLANG_INCLUDE_DIR)\/*.h $(JEXTRACT_IMAGE_TEST_JDK_DIR)\/conf\/jextract\/\n+\n+\n+$(JEXTRACT_BUNDLE): $(JEXTRACT_IMAGE_DIR)\n+\t@$(MKDIR) -p $(@D)\n+ifeq ($(TAR_SUPPORTS_TRANSFORM),true)\n+\t$(TAR) zcf $@ --transform 's|^$(JEXTRACT_NAME)|^$(JEXTRACT_BUNDLE_TOP_DIR)|S' -C $(dir $(JEXTRACT_IMAGE_DIR)) $(notdir $(JEXTRACT_IMAGE_DIR))\n+else\n+\t$(RM) -r $(JEXTRACT_BUNDLE_TMP_DIR)\n+\t$(MKDIR) -p $(JEXTRACT_BUNDLE_TMP_DIR)\n+\t($(CD) $(JEXTRACT_IMAGE_DIR) && $(TAR) cf - .) | ($(CD) $(JEXTRACT_BUNDLE_TMP_DIR) && $(TAR) xf -)\n+\t$(TAR) zcf $@ -C $(dir $(JEXTRACT_BUNDLE_TMP_DIR)) $(notdir $(JEXTRACT_BUNDLE_TMP_DIR))\n+endif\n+\n+$(JEXTRACT_TESTS_BUNDLE): $(BUILD_NATIVE_TEST_LIBRARIES)\n+\t@$(MKDIR) -p $(@D)\n+\t$(TAR) zcf $@ -C $(dir $(JEXTRACT_IMAGE_NATIVE_TEST_DIR)) $(notdir $(JEXTRACT_IMAGE_NATIVE_TEST_DIR))\n+\n+$(JEXTRACT_TEST_JDK_BUNDLE): $(JEXTRACT_IMAGE_TEST_JDK_DIR)\n+\t@$(MKDIR) -p $(@D)\n+\t$(TAR) zcf $@ -C $(dir $(JEXTRACT_IMAGE_TEST_JDK_DIR)) $(notdir $(JEXTRACT_IMAGE_TEST_JDK_DIR))\n+\n+\n+compile-java: $(BUILD_CLASSES_DIR)\n+\n+image: $(JEXTRACT_IMAGE_DIR)\n+\n+test-image: $(BUILD_NATIVE_TEST_LIBRARIES) $(JEXTRACT_IMAGE_TEST_JDK_DIR)\n+\n+images: image test-image\n+\n+bundles: $(JEXTRACT_BUNDLE) $(JEXTRACT_TESTS_BUNDLE) $(JEXTRACT_TEST_JDK_BUNDLE)\n+\n+.PHONY: compile-java image test-image images bundles\n","filename":"make\/Build.gmk","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+################################################################################\n+# Initial bootstrapping\n+################################################################################\n+\n+# In Cygwin, the MAKE variable gets prepended with the current directory if the\n+# make executable is called using a Windows mixed path (c:\/cygwin\/bin\/make.exe).\n+ifneq ($(findstring :, $(MAKE)), )\n+  export MAKE := $(patsubst $(CURDIR)%, %, $(patsubst $(CURDIR)\/%, %, $(MAKE)))\n+endif\n+\n+# Locate this Makefile\n+ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))),)\n+  makefile_path := $(CURDIR)\/$(strip $(lastword $(MAKEFILE_LIST)))\n+else\n+  makefile_path := $(lastword $(MAKEFILE_LIST))\n+endif\n+TOPDIR := $(strip $(patsubst %\/make\/, %, $(dir $(makefile_path))))\n+\n+################################################################################\n+# Functions\n+################################################################################\n+\n+\n+# Setup a required or optional variable, and\/or check that it is properly\n+# given.\n+# Note: No spaces are allowed around the arguments.\n+#\n+# $1: The name of the variable\n+# $2: The default value, if any, or OPTIONAL (do not provide a default but\n+#     do not exit if it is missing)\n+# $3: If NO_CHECK, disable checking for target file\/directory existence\n+#     If MKDIR, create the default directory\n+define SetupVariable\n+  ifeq ($$($1), )\n+    ifeq ($2, )\n+      $$(info Error: Variable $1 is missing)\n+      $$(error Cannot continue.)\n+    else ifeq ($2, OPTIONAL)\n+      ifneq ($$(findstring $$(LOG), info debug trace), )\n+        $$(info Variable $1 is not provided)\n+      endif\n+    else\n+      ifneq ($$(findstring $$(LOG), info debug trace), )\n+        $$(info Variable $1=$2 (default value))\n+      endif\n+      $1:=$2\n+    endif\n+  else\n+    ifneq ($$(findstring $$(LOG), info debug trace), )\n+      $$(info Variable $1=$$($1))\n+    endif\n+  endif\n+  # If $1 has a value (is not optional), and $3 is not set (to NO_CHECK),\n+  # and if wildcard is empty, then complain that the file is missing.\n+  ifeq ($3, MKDIR)\n+    ifneq ($$(findstring $$(LOG), info debug trace), )\n+      $$(info Creating directory for $1)\n+    endif\n+    $$(shell mkdir -p $$($1))\n+  else ifneq ($3, NO_CHECK)\n+    ifeq ($$(strip $$(if $$($1), , OPTIONAL) $$(wildcard $$($1))), )\n+      $$(info Error: Variable $1 points to missing file\/directory:)\n+      $$(info '$$($1)')\n+      $$(error Cannot continue.)\n+    endif\n+  endif\n+endef\n+\n+X :=\n+SPACE:=$(X) $(X)\n+\n+UNAME_M := $(shell uname -m)\n+ifeq ($(UNAME_M),x86_64)\n+  DEVKIT_VS_CPU_VAR_NAME := x86_64\n+  PLATFORM_CPU := x64\n+else\n+  $(error \"Unknown CPU: $(UNAME_M)\")\n+endif\n+\n+ifeq ($(OS),Windows_NT)\n+  PLATFORM_OS := windows\n+  FIXPATH := bash $(TOPDIR)\/make\/scripts\/fixpath.sh exec\n+else\n+  FIXPATH :=\n+\n+  UNAME_S := $(shell uname -s)\n+  ifeq ($(UNAME_S), Darwin)\n+    PLATFORM_OS := macosx\n+  else\n+    ifeq ($(UNAME_S), Linux)\n+      PLATFORM_OS := linux\n+    else\n+      $(error \"Unknown OS: $(UNAME_S)\")\n+    endif\n+  endif\n+endif\n+\n+PLATFORM := $(PLATFORM_OS)-$(PLATFORM_CPU)\n+\n+ECHO := echo\n+TR := tr\n+RM := rm -f\n+MKDIR := mkdir\n+CP := cp\n+CD := cd\n+TAR := tar\n+PRINTF := printf\n+\n+BUILD_VERSION ?= internal\n+\n+JEXTRACT_NAME := jextract\n+JEXTRACT_NAME_VERSION := $(JEXTRACT_NAME)-$(BUILD_VERSION)\n+\n+CONF_NAME ?= $(PLATFORM)\n+\n+BUILD_DIR := $(TOPDIR)\/build\/$(CONF_NAME)\n+\n+JEXTRACT_IMAGE_NATIVE_TEST_DIR := $(BUILD_DIR)\/images\/test\n+ifeq ($(PLATFORM_OS), macosx)\n+  JEXTRACT_NAME_SUFFIX := .app\n+endif\n+JEXTRACT_IMAGE_DIR := $(BUILD_DIR)\/images\/$(JEXTRACT_NAME)$(JEXTRACT_NAME_SUFFIX)\n+JEXTRACT_IMAGE_TEST_JDK_DIR := $(BUILD_DIR)\/images\/test-jdk\n","filename":"make\/Common.gmk","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+ifeq ($(PLATFORM),)\n+  $(error \"Must include make\/Common.gmk first\"\n+endif\n+\n+#\n+# Extract a value from a devkit path variable\n+#\n+# $1: Path to devkit root\n+# $2: Variable to extract (e.g. DEVKIT_VS_LIB_x86_64)\n+#\n+define ExtractDevkitPath\n+$(shell bash -c 'export DEVKIT_ROOT=$1; . $$DEVKIT_ROOT\/devkit.info; echo $$$2')\n+endef\n+\n+#\n+# Look up a tool\n+#\n+# $1: tool to look up\n+# $2: PATH to use\n+#\n+define FindTool\n+$(shell bash -c 'export PATH=\"$2\"; type -p $1')\n+endef\n+\n+OBJ_SUFFIX := .o\n+\n+ifeq ($(PLATFORM_OS), windows)\n+  # Doesn't handle the non-devkit case, yet\n+  $(eval $(call SetupVariable,DEVKIT_HOME))\n+\n+  OS_LIB_DIR := bin\n+\n+  SHARED_LIB_PREFIX :=\n+  SHARED_LIB_SUFFIX := .dll\n+  SHARED_LIBRARY_FLAGS := -dll\n+  CC_OUT_OPTION := -Fo\n+  LD_OUT_OPTION := -out:\n+\n+  # The VS CPU specific directory names happen to match our platform names\n+  VS_CPU_DIR := $(PLATFORM_CPU)\n+  CC := $(DEVKIT_HOME)\/VC\/bin\/$(VS_CPU_DIR)\/cl.exe\n+  LINK := $(DEVKIT_HOME)\/VC\/bin\/$(VS_CPU_DIR)\/link.exe\n+\n+  DEVKIT_VS_INCLUDE := $(call ExtractDevkitPath,$(DEVKIT_HOME),DEVKIT_VS_INCLUDE_$(DEVKIT_VS_CPU_VAR_NAME))\n+  DEVKIT_VS_LIB := $(call ExtractDevkitPath,$(DEVKIT_HOME),DEVKIT_VS_LIB_$(DEVKIT_VS_CPU_VAR_NAME))\n+\n+  CFLAGS := $(patsubst %,-I%,$(subst ;, ,$(DEVKIT_VS_INCLUDE)))\n+  LDFLAGS := $(SHARED_LIBRARY_FLAGS) $(patsubst %,-libpath:%,$(subst ;, ,$(DEVKIT_VS_LIB))) \/EXPERIMENTAL:DETERMINISTIC -pathmap:$(TOPDIR)=s\n+else\n+  OS_LIB_DIR := lib\n+\n+  CC_OUT_OPTION := -o$(SPACE)\n+  LD_OUT_OPTION := -o$(SPACE)\n+  SHARED_LIBRARY_FLAGS := -shared -fPIC\n+  SHARED_LIB_PREFIX := lib\n+\n+  CFLAGS := -fPIC\n+  LDFLAGS := $(SHARED_LIBRARY_FLAGS)\n+\n+  ifeq ($(DEVKIT_HOME),)\n+    TOOL_SEARCH_PATH := $(PATH)\n+  else\n+    DEVKIT_TOOLCHAIN_PATH := $(call ExtractDevkitPath,$(DEVKIT_HOME),DEVKIT_TOOLCHAIN_PATH)\n+    TOOL_SEARCH_PATH := $(DEVKIT_TOOLCHAIN_PATH)\n+\n+    DEVKIT_SYSROOT := $(call ExtractDevkitPath,$(DEVKIT_HOME),DEVKIT_SYSROOT)\n+    SYSROOT := $(DEVKIT_SYSROOT)\n+  endif\n+\n+  ifeq ($(PLATFORM_OS), macosx)\n+    SHARED_LIB_SUFFIX := .dylib\n+\n+    CC_NAME := clang\n+    LINK_NAME := clang\n+    ifneq ($(SYSROOT),)\n+      CFLAGS += -isysroot $(SYSROOT)\n+    endif\n+  else\n+    ifeq ($(PLATFORM_OS), linux)\n+      SHARED_LIB_SUFFIX := .so\n+\n+      CC_NAME := gcc\n+      LINK_NAME := gcc\n+      ifneq ($(SYSROOT),)\n+        CFLAGS += --sysroot=$(SYSROOT)\n+      endif\n+    endif\n+  endif\n+\n+  CC := $(call FindTool,$(CC_NAME),$(TOOL_SEARCH_PATH))\n+  LINK := $(call FindTool,$(LINK_NAME),$(TOOL_SEARCH_PATH))\n+endif\n+\n+ifeq ($(CC),)\n+  $(error CC tool not found)\n+endif\n+ifeq ($(LINK),)\n+  $(error LINK tool not found)\n+endif\n+\n+# Helper macro for building a shared native library from a single C source file\n+#\n+# Note: assumes C source file name is on the form lib%.c\n+#\n+# $1: source file\n+# $2: target directory\n+# $3: object dir\n+# $4: variable to add target to\n+#\n+define BuildNativeLibrary\n+$1_NAME := $$(patsubst lib%,%,$$(basename $$(notdir $1)))\n+$1_SHARED_LIBRARY := $2\/$$(SHARED_LIB_PREFIX)$$($1_NAME)$$(SHARED_LIB_SUFFIX)\n+\n+$1_OBJ := $3\/$$($1_NAME)$$(OBJ_SUFFIX)\n+ifeq ($$(PLATFORM_OS), windows)\n+  $1_IMPLIB := $3\/$$($1_NAME).lib\n+  $1_EXTRA_LDFLAGS := -implib:$$($1_IMPLIB)\n+endif\n+\n+$$($1_OBJ): $1\n+\t@$$(MKDIR) -p $$(@D)\n+\t$$(FIXPATH) $$(CC) $$(CFLAGS) $$(CC_OUT_OPTION)$$@ $$< -c\n+\n+$$($1_SHARED_LIBRARY): $$($1_OBJ)\n+\t@$$(MKDIR) -p $$(@D)\n+\t$$(FIXPATH) $$(LINK) $$(LDFLAGS) $$($1_EXTRA_LDFLAGS) $$(LD_OUT_OPTION)$$@ $$<\n+\n+$4 += $$($1_SHARED_LIBRARY)\n+endef\n","filename":"make\/NativeCompilation.gmk","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+default: all\n+\n+# We will always run multiple tests serially\n+.NOTPARALLEL:\n+\n+include make\/Common.gmk\n+\n+################################################################################\n+# Check input and setup basic buildsystem support\n+################################################################################\n+\n+# Verify that user has given correct additional input.\n+\n+ifeq ($(TEST),)\n+  $(info No test selection given in TEST)\n+  $(error Cannot continue)\n+endif\n+\n+# These variables are absolutely necessary\n+$(eval $(call SetupVariable,OUTPUTDIR,$(BUILD_DIR),MKDIR))\n+$(eval $(call SetupVariable,JTREG_HOME))\n+$(eval $(call SetupVariable,JTREG_JAVA_HOME))\n+$(eval $(call SetupVariable,JEXTRACT_DIR))\n+$(eval $(call SetupVariable,JEXTRACT_TEST_JDK))\n+$(eval $(call SetupVariable,JEXTRACT_NATIVE_TEST_DIR))\n+\n+JTREG_CONCURRENCY ?= 4\n+\n+JAVA := $(JTREG_JAVA_HOME)\/bin\/java\n+\n+# CMH: Make platform dependent\n+JEXTRACT := $(JEXTRACT_DIR)\/bin\/jextract\n+\n+# For JextractToolRunner.java and JextractApiTestBase.java\n+TEST_SOURCE_ROOT := $(TOPDIR)\/open\/test\/java\n+\n+#\n+# $1: Test id (make friendly string)\n+# $2: Path to test(s) to run\n+#\n+define SetupRunJtregTest\n+  $1_TEST_RESULTS_DIR := $$(OUTPUTDIR)\/test-results\/$1\n+  $1_TEST_SUPPORT_DIR := $$(OUTPUTDIR)\/test-support\/$1\n+  $1_EXITCODE := $$($1_TEST_RESULTS_DIR)\/exitcode.txt\n+\n+  clean-workdir-$1:\n+\t$$(RM) -r $$($1_TEST_SUPPORT_DIR)\n+\n+  run-test-$1: clean-workdir-$1\n+\t$$(FIXPATH) $$(JAVA) \\\n+\t    -Dprogram=jtreg -jar $$(JTREG_HOME)\/lib\/jtreg.jar \\\n+\t    -testjdk:$$(JEXTRACT_TEST_JDK) \\\n+\t    -dir:$$(TOPDIR) \\\n+\t    -reportDir:$$($1_TEST_RESULTS_DIR) \\\n+\t    -workDir:$$($1_TEST_SUPPORT_DIR) \\\n+\t    -avm \\\n+\t    -conc:$$(JTREG_CONCURRENCY) \\\n+\t    -verbose:summary \\\n+\t    -nativepath:$$(JEXTRACT_NATIVE_TEST_DIR) \\\n+\t    -vmoption:--enable-native-access=ALL-UNNAMED,org.openjdk.jextract \\\n+\t    $2 \\\n+\t    && $$(ECHO) $$$$? > $$($1_EXITCODE) \\\n+            || $$(ECHO) $$$$? > $$($1_EXITCODE)\n+\n+  parse-test-$1: run-test-$1\n+\t@$$(ECHO) \"Would parse test results here\"\n+\n+  $1: run-test-$1 parse-test-$1 clean-workdir-$1\n+\n+  TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1\n+  TEST_TARGETS += parse-test-$1\n+\n+endef\n+\n+\n+TESTS_TO_RUN := $(strip $(TEST))\n+\n+$(foreach test, $(TESTS_TO_RUN), \\\n+  $(eval TEST_ID := $(shell $(ECHO) $(strip $(test)) | \\\n+      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+  $(eval $(call SetupRunJtregTest,$(TEST_ID),$(test))) \\\n+)\n+\n+run-all-tests: $(TEST_TARGETS)\n+\n+post-run-test: run-all-tests\n+\n+run-test-report: post-run-test\n+\n+# The main run-test target\n+run-test: run-test-report\n+\n+TARGETS += run-all-tests pre-run-test post-run-test run-test-report run-test\n+\n+test-prebuilt: run-test\n+\n+TARGETS += test-prebuilt\n+\n+test-integration: $(JEXTRACT_DIR)\n+\t$(MKDIR) -p $(BUILD_DIR)\/integration_test\n+\n+\t@printf \"#include <stdarg.h>\\n \\\n+\tint getpid();\\n\" > $(BUILD_DIR)\/integration_test\/test.h\n+\n+\t$(FIXPATH) $(JEXTRACT_PATH) \"$(BUILD_DIR)\/integration_test\/test.h\" -d \"$(BUILD_DIR)\/integration_test\"\n+\n+TARGETS += test-integration\n+\n+all: run-test\n+\n+.PHONY: default all $(TARGETS)\n","filename":"make\/RunTestsPrebuilt.gmk","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Setup the environment fixpath assumes. Read from command line options if\n+# available, or extract values automatically from the environment if missing.\n+# This is robust, but slower.\n+function setup() {\n+  while getopts \"e:p:r:t:c:qmi\" opt; do\n+    case \"$opt\" in\n+    e) PATHTOOL=\"$OPTARG\" ;;\n+    p) DRIVEPREFIX=\"$OPTARG\" ;;\n+    r) ENVROOT=\"$OPTARG\" ;;\n+    t) WINTEMP=\"$OPTARG\" ;;\n+    c) CMD=\"$OPTARG\" ;;\n+    q) QUIET=true ;;\n+    m) MIXEDMODE=true ;;\n+    i) IGNOREFAILURES=true ;;\n+    ?)\n+      # optargs found argument error\n+      exit 2\n+      ;;\n+    esac\n+  done\n+\n+  shift $((OPTIND-1))\n+  ACTION=\"$1\"\n+\n+  # Locate variables ourself if not giving from caller\n+  if [[ -z ${PATHTOOL+x} ]]; then\n+    PATHTOOL=\"$(type -p cygpath)\"\n+    if [[ $PATHTOOL == \"\" ]]; then\n+      PATHTOOL=\"$(type -p wslpath)\"\n+      if [[ $PATHTOOL == \"\" ]]; then\n+        if [[ $QUIET != true ]]; then\n+          echo fixpath: failure: Cannot locate cygpath or wslpath >&2\n+        fi\n+        exit 2\n+      fi\n+    fi\n+  fi\n+\n+  if [[ -z ${DRIVEPREFIX+x} ]]; then\n+    winroot=\"$($PATHTOOL -u c:\/)\"\n+    DRIVEPREFIX=\"${winroot%\/c\/}\"\n+  else\n+    if [[ $DRIVEPREFIX == \"NONE\" ]]; then\n+      DRIVEPREFIX=\"\"\n+    fi\n+  fi\n+\n+  if [[ -z ${ENVROOT+x} ]]; then\n+    unixroot=\"$($PATHTOOL -w \/ 2> \/dev\/null)\"\n+    # Remove trailing backslash\n+    ENVROOT=\"${unixroot%\\\\}\"\n+  elif [[ \"$ENVROOT\" == \"[unavailable]\" ]]; then\n+    ENVROOT=\"\"\n+  fi\n+\n+  if [[ -z ${CMD+x} ]]; then\n+    CMD=\"$DRIVEPREFIX\/c\/windows\/system32\/cmd.exe\"\n+  fi\n+\n+  if [[ -z ${WINTEMP+x} ]]; then\n+    wintemp_win=\"$($CMD \/q \/c echo %TEMP% 2>\/dev\/null | tr -d \\\\n\\\\r)\"\n+    WINTEMP=\"$($PATHTOOL -u \"$wintemp_win\")\"\n+  fi\n+\n+  # Make regexp tests case insensitive\n+  shopt -s nocasematch\n+  # Prohibit msys2 from meddling with paths\n+  export MSYS2_ARG_CONV_EXCL=\"*\"\n+  #  Make sure WSL gets a copy of the path\n+  export WSLENV=PATH\/l\n+}\n+\n+# Cleanup handling\n+TEMPDIRS=\"\"\n+trap \"cleanup\" EXIT\n+function cleanup() {\n+  if [[ \"$TEMPDIRS\" != \"\" ]]; then\n+    rm -rf $TEMPDIRS\n+  fi\n+}\n+\n+# Import a single path\n+# Result: imported path returned in $result\n+function import_path() {\n+  path=\"$1\"\n+  # Strip trailing and leading space\n+  path=\"${path#\"${path%%[![:space:]]*}\"}\"\n+  path=\"${path%\"${path##*[![:space:]]}\"}\"\n+\n+  if [[ $path =~ ^.:[\/\\\\].*$ ]] || [[ \"$path\" =~ ^\"$ENVROOT\"\\\\.*$ ]] ; then\n+    # We got a Windows path as input; use pathtool to convert to unix path\n+    path=\"$($PATHTOOL -u \"$path\")\"\n+    # Path will now be absolute\n+  else\n+    # Make path absolute, and resolve embedded '..' in path\n+    dirpart=\"$(dirname \"$path\")\"\n+    dirpart=\"$(cd \"$dirpart\" 2>&1 > \/dev\/null && pwd)\"\n+    if [[ $? -ne 0 ]]; then\n+      if [[ $QUIET != true ]]; then\n+        echo fixpath: failure: Directory containing path \"'\"$path\"'\" does not exist >&2\n+      fi\n+      if [[ $IGNOREFAILURES != true ]]; then\n+        exit 1\n+      else\n+        path=\"\"\n+      fi\n+    else\n+      basepart=\"$(basename \"$path\")\"\n+      if [[ $dirpart == \/ ]]; then\n+        # Avoid double leading \/\n+        dirpart=\"\"\n+      fi\n+      if [[ $basepart == \/ ]]; then\n+        # Avoid trailing \/\n+        basepart=\"\"\n+      fi\n+      path=\"$dirpart\/$basepart\"\n+    fi\n+  fi\n+\n+  if [[ \"$path\" != \"\" ]]; then\n+    # Store current unix path\n+    unixpath=\"$path\"\n+    # Now turn it into a windows path\n+    winpath=\"$($PATHTOOL -w \"$path\" 2>\/dev\/null)\"\n+    # If it fails, try again with an added .exe (needed on WSL)\n+    if [[ $? -ne 0 ]]; then\n+      unixpath=\"$unixpath.exe\"\n+      winpath=\"$($PATHTOOL -w \"$unixpath\" 2>\/dev\/null)\"\n+    fi\n+    if [[ $? -eq 0 ]]; then\n+      if [[ ! \"$winpath\" =~ ^\"$ENVROOT\"\\\\.*$ ]] ; then\n+        # If it is not in envroot, it's a generic windows path\n+        if [[ ! $winpath =~ ^[-_.:\\\\a-zA-Z0-9]*$ ]] ; then\n+          # Path has forbidden characters, rewrite as short name\n+          # This monster of a command uses the %~s support from cmd.exe to\n+          # reliably convert to short paths on all winenvs.\n+          shortpath=\"$($CMD \/q \/c for %I in \\( \"$winpath\" \\) do echo %~sI 2>\/dev\/null | tr -d \\\\n\\\\r)\"\n+          unixpath=\"$($PATHTOOL -u \"$shortpath\")\"\n+          # unixpath is based on short name\n+        fi\n+        # Make it lower case\n+        path=\"$(echo \"$unixpath\" | tr '[:upper:]' '[:lower:]')\"\n+      fi\n+    else\n+      # On WSL1, PATHTOOL will fail for files in envroot. If the unix path\n+      # exists, we assume that $path is a valid unix path.\n+\n+      if [[ ! -e $path ]]; then\n+        if [[ -e $path.exe ]]; then\n+          path=\"$path.exe\"\n+        else\n+          if [[ $QUIET != true ]]; then\n+            echo fixpath: warning: Path \"'\"$path\"'\" does not exist >&2\n+          fi\n+          # This is not a fatal error, maybe the path will be created later on\n+        fi\n+      fi\n+    fi\n+  fi\n+\n+  if [[ \"$path\" =~ \" \" ]]; then\n+    # Our conversion attempts failed. Perhaps the path did not exists, and thus\n+    # we could not convert it to short name.\n+    if [[ $QUIET != true ]]; then\n+      echo fixpath: failure: Path \"'\"$path\"'\" contains space >&2\n+    fi\n+    if [[ $IGNOREFAILURES != true ]]; then\n+      exit 1\n+    else\n+      path=\"\"\n+    fi\n+  fi\n+\n+  result=\"$path\"\n+}\n+\n+# Import a single path, or a pathlist in Windows style (i.e. ; separated)\n+# Incoming paths can be in Windows or unix style.\n+# Returns in $result a converted path or path list\n+function import_command_line() {\n+  imported=\"\"\n+\n+  old_ifs=\"$IFS\"\n+  IFS=\";\"\n+  for arg in $1; do\n+    if ! [[ $arg =~ ^\" \"+$ ]]; then\n+      import_path \"$arg\"\n+\n+      if [[ \"$result\" != \"\" && \"$imported\" = \"\" ]]; then\n+        imported=\"$result\"\n+      else\n+        imported=\"$imported:$result\"\n+      fi\n+    fi\n+  done\n+  IFS=\"$old_ifs\"\n+\n+  result=\"$imported\"\n+}\n+\n+# If argument seems to be colon separated path list, and all elements\n+# are possible to convert to paths, make a windows path list\n+# Return 0 if successful with converted path list in $result, or\n+# 1 if it was not a path list.\n+function convert_pathlist() {\n+  converted_list=\"\"\n+  pathlist_args=\"$1\"\n+\n+  IFS=':' read -r -a arg_array <<< \"$pathlist_args\"\n+  for arg in \"${arg_array[@]}\"; do\n+    winpath=\"\"\n+    # Start looking for drive prefix\n+    if [[ $arg =~ ^($DRIVEPREFIX\/)([a-z])(\/[^\/]+.*$) ]] ; then\n+      winpath=\"${BASH_REMATCH[2]}:${BASH_REMATCH[3]}\"\n+      # Change slash to backslash (or vice versa if mixed mode)\n+      if [[ $MIXEDMODE != true ]]; then\n+        winpath=\"${winpath\/\/'\/'\/'\\'}\"\n+      else\n+        winpath=\"${winpath\/\/'\\'\/'\/'}\"\n+      fi\n+    elif [[ $arg =~ ^(\/[-_.*a-zA-Z0-9]+(\/[-_.*a-zA-Z0-9]+)+.*$) ]] ; then\n+      # This looks like a unix path, like \/foo\/bar\n+      pathmatch=\"${BASH_REMATCH[1]}\"\n+      if [[ $ENVROOT == \"\" ]]; then\n+        if [[ $QUIET != true ]]; then\n+          echo fixpath: failure: Path \"'\"$pathmatch\"'\" cannot be converted to Windows path >&2\n+        fi\n+        exit 1\n+      fi\n+      winpath=\"$ENVROOT$pathmatch\"\n+      # Change slash to backslash (or vice versa if mixed mode)\n+      if [[ $MIXEDMODE != true ]]; then\n+        winpath=\"${winpath\/\/'\/'\/'\\'}\"\n+      else\n+        winpath=\"${winpath\/\/'\\'\/'\/'}\"\n+      fi\n+    else\n+      # This does not look like a path, so assume this is not a proper pathlist.\n+      # Flag this to caller.\n+      result=\"\"\n+      return 1\n+    fi\n+\n+    if [[ \"$converted_list\" = \"\" ]]; then\n+      converted_list=\"$winpath\"\n+    else\n+      converted_list=\"$converted_list;$winpath\"\n+    fi\n+  done\n+\n+  result=\"$converted_list\"\n+  return 0\n+}\n+\n+# The central conversion function. Convert a single argument, so that any\n+# contained paths are converted to Windows style paths. Result is returned\n+# in $result. If it is a path list, convert it as one.\n+function convert_path() {\n+  if [[ $1 =~ : ]]; then\n+    convert_pathlist \"$1\"\n+    if [[ $? -eq 0 ]]; then\n+      return 0\n+    fi\n+    # Not all elements was possible to convert to Windows paths, so we\n+    # presume it is not a pathlist. Continue using normal conversion.\n+  fi\n+\n+  arg=\"$1\"\n+  winpath=\"\"\n+  # Start looking for drive prefix. Also allow \/xxxx prefixes (typically options\n+  # for Visual Studio tools), and embedded file:\/\/ URIs.\n+  if [[ $arg =~ ^([^\/]*|-[^:=]*[:=]|.*file:\/\/|\/[a-zA-Z:]{1,3}:?)($DRIVEPREFIX\/)([a-z])(\/[^\/]+.*$) ]] ; then\n+    prefix=\"${BASH_REMATCH[1]}\"\n+    winpath=\"${BASH_REMATCH[3]}:${BASH_REMATCH[4]}\"\n+    # Change slash to backslash (or vice versa if mixed mode)\n+    if [[ $MIXEDMODE != true ]]; then\n+      winpath=\"${winpath\/\/'\/'\/'\\'}\"\n+    else\n+      winpath=\"${winpath\/\/'\\'\/'\/'}\"\n+    fi\n+  elif [[ $arg =~ ^([^\/]*|-[^:=]*[:=]|(.*file:\/\/))(\/([-_.+a-zA-Z0-9]+)(\/[-_.+a-zA-Z0-9]+)+)(.*)?$ ]] ; then\n+    # This looks like a unix path, like \/foo\/bar. Also embedded file:\/\/ URIs.\n+    prefix=\"${BASH_REMATCH[1]}\"\n+    pathmatch=\"${BASH_REMATCH[3]}\"\n+    firstdir=\"${BASH_REMATCH[4]}\"\n+    suffix=\"${BASH_REMATCH[6]}\"\n+\n+    # We only believe this is a path if the first part is an existing directory\n+    if [[ -d \"\/$firstdir\" ]];  then\n+      if [[ $ENVROOT == \"\" ]]; then\n+        if [[ $QUIET != true ]]; then\n+          echo fixpath: failure: Path \"'\"$pathmatch\"'\" cannot be converted to Windows path >&2\n+        fi\n+        exit 1\n+      fi\n+      winpath=\"$ENVROOT$pathmatch\"\n+      # Change slash to backslash (or vice versa if mixed mode)\n+      if [[ $MIXEDMODE != true ]]; then\n+        winpath=\"${winpath\/\/'\/'\/'\\'}\"\n+      else\n+        winpath=\"${winpath\/\/'\\'\/'\/'}\"\n+      fi\n+      winpath=\"$winpath$suffix\"\n+    fi\n+  fi\n+\n+  if [[ $winpath != \"\" ]]; then\n+    result=\"$prefix$winpath\"\n+  else\n+    # Return the arg unchanged\n+    result=\"$arg\"\n+  fi\n+}\n+\n+# Treat $1 as name of a file containg paths. Convert those paths to Windows style,\n+# in a new temporary file, and return a string \"@<temp file>\" pointing to that\n+# new file.\n+function convert_at_file() {\n+  infile=\"$1\"\n+  if [[ -e $infile ]] ; then\n+    tempdir=$(mktemp -dt fixpath.XXXXXX -p \"$WINTEMP\")\n+    TEMPDIRS=\"$TEMPDIRS $tempdir\"\n+\n+    while read line; do\n+      convert_path \"$line\"\n+      echo \"$result\" >> $tempdir\/atfile\n+    done < $infile\n+    convert_path \"$tempdir\/atfile\"\n+    result=\"@$result\"\n+  else\n+    result=\"@$infile\"\n+  fi\n+}\n+\n+# Convert an entire command line, replacing all unix paths with Windows paths,\n+# and all unix-style path lists (colon separated) with Windows-style (semicolon\n+# separated).\n+function print_command_line() {\n+  converted_args=\"\"\n+  for arg in \"$@\" ; do\n+    if [[ $arg =~ ^@(.*$) ]] ; then\n+      # This is an @-file with paths that need converting\n+      convert_at_file \"${BASH_REMATCH[1]}\"\n+    else\n+      convert_path \"$arg\"\n+    fi\n+    converted_args=\"$converted_args$result \"\n+  done\n+  result=\"${converted_args% }\"\n+}\n+\n+# Check if the winenv will allow us to start a Windows program when we are\n+# standing in the current directory\n+function verify_current_dir() {\n+  arg=\"$PWD\"\n+  if [[ $arg =~ ^($DRIVEPREFIX\/)([a-z])(\/[^\/]+.*$) ]] ; then\n+    return 0\n+  elif [[ $arg =~ ^(\/[^\/]+.*$) ]] ; then\n+    if [[ $ENVROOT == \"\" || $ENVROOT =~ ^\\\\\\\\.* ]]; then\n+      # This is a WSL1 or WSL2 environment\n+      return 1\n+    fi\n+    return 0\n+  fi\n+  # This should not happen\n+  return 1\n+}\n+\n+# The core functionality of fixpath. Take the given command line, and convert\n+# it and execute it, so that all paths are converted to Windows style.\n+# The return code is the return code of the executed command.\n+function exec_command_line() {\n+  # Check that Windows can handle our current directory (only an issue for WSL)\n+  verify_current_dir\n+\n+  if [[ $? -ne 0 ]]; then\n+    # WSL1 will just forcefully put us in C:\\Windows\\System32 if we execute this from\n+    # a unix directory. WSL2 will do the same, and print a warning. In both cases,\n+    # we prefer to take control.\n+    cd \"$WINTEMP\"\n+    if [[ $QUIET != true ]]; then\n+      echo fixpath: warning: Changing directory to $WINTEMP >&2\n+    fi\n+  fi\n+\n+  collected_args=()\n+  command=\"\"\n+  for arg in \"$@\" ; do\n+    if [[ $command == \"\" ]]; then\n+      # We have not yet located the command to run\n+      if [[ $arg =~ ^(.*)=(.*)$ ]]; then\n+        # It's a leading env variable assignment (FOO=bar)\n+        key=\"${BASH_REMATCH[1]}\"\n+        arg=\"${BASH_REMATCH[2]}\"\n+        convert_path \"$arg\"\n+        # Set the variable to the converted result\n+        export $key=\"$result\"\n+        # While this is only needed on WSL, it does not hurt to do everywhere\n+        export WSLENV=$WSLENV:$key\/w\n+      else\n+        # The actual command will be executed by bash, so don't convert it\n+        command=\"$arg\"\n+      fi\n+    else\n+      # Now we are collecting arguments; they all need converting\n+      if [[ $arg =~ ^@(.*$) ]] ; then\n+        # This is an @-file with paths that need converting\n+        convert_at_file \"${BASH_REMATCH[1]}\"\n+      else\n+        convert_path \"$arg\"\n+      fi\n+      collected_args=(\"${collected_args[@]}\" \"$result\")\n+    fi\n+  done\n+\n+  # Now execute it\n+  if [[ -v DEBUG_FIXPATH ]]; then\n+    echo fixpath: debug: input: \"$@\" >&2\n+    echo fixpath: debug: output: \"$command\" \"${collected_args[@]}\" >&2\n+  fi\n+\n+  if [[ ! -e \"$command\" ]]; then\n+    if [[ -e \"$command.exe\" ]]; then\n+      command=\"$command.exe\"\n+    fi\n+  fi\n+\n+  if [[ $ENVROOT != \"\" || ! -x \/bin\/grep ]]; then\n+    \"$command\" \"${collected_args[@]}\"\n+  else\n+    # For WSL1, automatically strip away warnings from WSLENV=PATH\/l\n+    \"$command\" \"${collected_args[@]}\" 2> >(\/bin\/grep -v \"ERROR: UtilTranslatePathList\" 1>&2)\n+  fi\n+}\n+\n+# Check that the input represents a path that is reachable from Windows\n+function verify_command_line() {\n+  arg=\"$1\"\n+  if [[ $arg =~ ^($DRIVEPREFIX\/)([a-z])(\/[^\/]+.*$) ]] ; then\n+    return 0\n+  elif [[ $arg =~ ^(\/[^\/]+\/[^\/]+.*$) ]] ; then\n+    if [[ $ENVROOT != \"\" ]]; then\n+      return 0\n+    fi\n+  fi\n+  return 1\n+}\n+\n+#### MAIN FUNCTION\n+\n+setup \"$@\"\n+# Shift away the options processed in setup\n+shift $((OPTIND))\n+\n+if [[ \"$ACTION\" == \"import\" ]] ; then\n+  import_command_line \"$@\"\n+  echo \"$result\"\n+elif [[ \"$ACTION\" == \"print\" ]] ; then\n+  print_command_line \"$@\"\n+  echo \"$result\"\n+elif [[ \"$ACTION\" == \"exec\" ]] ; then\n+  exec_command_line \"$@\"\n+  # Propagate exit code\n+  exit $?\n+elif [[ \"$ACTION\" == \"verify\" ]] ; then\n+  verify_command_line \"$@\"\n+  exit $?\n+else\n+  if [[ $QUIET != true ]]; then\n+    echo Unknown operation: \"$ACTION\" >&2\n+    echo Supported operations: import print exec verify >&2\n+  fi\n+  exit 2\n+fi\n","filename":"make\/scripts\/fixpath.sh","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+\n+Top level scripts:\n+\n+cleanall.sh\n+\n+- deletes all .java\/.class files generated by jextract\/javac\n+\n+compileall.sh\n+\n+- jextracts all samples\n+\n+compilesourceall.sh\n+\n+- jextracts all samples with --source to generate .java and then uses javac\n","filename":"samples\/README.md","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+import blas.*;\n+import static blas.cblas_h.*;\n+\n+public class TestBlas {\n+    public static void main(String[] args) {\n+        int Layout;\n+        int transa;\n+\n+        double alpha, beta;\n+        int m, n, lda, incx, incy, i;\n+\n+        Layout = CblasColMajor();\n+        transa = CblasNoTrans();\n+\n+        m = 4; \/* Size of Column ( the number of rows ) *\/\n+        n = 4; \/* Size of Row ( the number of columns ) *\/\n+        lda = 4; \/* Leading dimension of 5 * 4 matrix is 5 *\/\n+        incx = 1;\n+        incy = 1;\n+        alpha = 1;\n+        beta = 0;\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var a = allocator.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 3.0, 4.0,\n+                1.0, 1.0, 1.0, 1.0,\n+                3.0, 4.0, 5.0, 6.0,\n+                5.0, 6.0, 7.0, 8.0\n+            });\n+            var x = allocator.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 1.0, 1.0\n+            });\n+            var y = allocator.allocateArray(C_DOUBLE, n);\n+\n+            cblas_dgemv(Layout, transa, m, n, alpha, a, lda, x, incx, beta, y, incy);\n+            \/* Print y *\/\n+            for (i = 0; i < n; i++) {\n+                System.out.print(String.format(\" y%d = %f\\n\", i, y.getAtIndex(C_DOUBLE, i)));\n+            }\n+        }\n+    }\n+}\n","filename":"samples\/cblas\/TestBlas.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+jextract -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n","filename":"samples\/cblas\/compile.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lapack installation which include\/cblas.h and dependent headers\")]\r\n+  [string]$blasPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -t blas `\r\n+  -I \"$blasPath\\include\" `\r\n+  -l libcblas `\r\n+  -- `\r\n+  \"$blasPath\\include\\cblas.h\"\r\n","filename":"samples\/cblas\/compile_windows.ps1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract --source -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n+javac --add-modules jdk.incubator.foreign blas\/*.java\n","filename":"samples\/cblas\/compilesource.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+time java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/openblas\/lib \\\n+    TestBlas.java\n","filename":"samples\/cblas\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lib curl installation, which contains bin\/liblapacke.dll\")]\r\n+  [string]$blasPath,\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the mingw bin directory which contains libgcc_s_seh-1.dll and libquadmath-0.dll\")]\r\n+  [string]$mingwBinPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+$Env:path+=\"`;$blasPath\\bin\" # libblas.dll\r\n+$Env:path+=\"`;$mingwBinPath\" # mingw runtime dlls\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$blasPath\\bin\" `\r\n+  TestBlas.java `\r\n","filename":"samples\/cblas\/run_windows.ps1","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+cd cblas\n+rm -rf blas\n+cd ..\n+cd dlopen\n+rm -rf org\n+rm -rf libhello.dylib\n+cd ..\n+cd go\n+rm -rf org\n+rm -rf libhello.*\n+cd ..\n+cd helloworld\n+rm -rf org\n+rm -rf libhelloworld.dylib\n+cd ..\n+cd lapack\n+rm -rf lapack\n+cd ..\n+cd libclang\n+rm -rf org\n+cd ..\n+cd libcurl\n+rm -rf org\n+cd ..\n+cd libffmpeg\n+rm -rf libffmpeg\n+cd ..\n+cd libjimage\n+rm -rf build\n+cd ..\n+cd libgit2\n+rm -rf com\n+cd ..\n+cd libproc\n+rm -rf org\n+cd ..\n+cd opengl\n+rm -rf opengl\n+cd ..\n+cd python3\n+rm -rf org\n+cd ..\n+cd readline\n+rm -rf org\n+cd ..\n+cd sqlite\n+rm -rf org\n+rm -rf employee.db\n+cd ..\n+cd tcl\n+rm -rf org\n+cd ..\n+cd tensorflow\n+rm -rf org\n+cd ..\n+cd time\n+rm -rf org\n+cd ..\n","filename":"samples\/cleanall.sh","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+sh .\/cleanall.sh\n+echo \"compiling cblas\"\n+cd cblas\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling dlopen\"\n+cd dlopen\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling go\"\n+cd go\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling helloworld\"\n+cd helloworld\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling lapack\"\n+cd lapack\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libclang\"\n+cd libclang\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libcurl\"\n+cd libcurl\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libffmpeg\"\n+cd libffmpeg\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libjimage\"\n+cd libjimage\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libgit2\"\n+cd libgit2\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling libproc\"\n+cd libproc\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling opengl\"\n+cd opengl\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling python3\"\n+cd python3\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling readline\"\n+cd readline\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling sqlite\"\n+cd sqlite\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling tcl\"\n+cd tcl\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling tensorflow\"\n+cd tensorflow\n+sh .\/compile.sh\n+cd ..\n+echo \"compiling time\"\n+cd time\n+sh .\/compile.sh\n+cd ..\n","filename":"samples\/compileall.sh","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+sh .\/cleanall.sh\n+echo \"compiling cblas\"\n+cd cblas\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling dlopen\"\n+cd dlopen\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling go\"\n+cd go\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling helloworld\"\n+cd helloworld\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling lapack\"\n+cd lapack\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libclang\"\n+cd libclang\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libcurl\"\n+cd libcurl\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libffmpeg\"\n+cd libffmpeg\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libjimage\"\n+cd libjimage\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libgit2\"\n+cd libgit2\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling libproc\"\n+cd libproc\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling opengl\"\n+cd opengl\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling python3\"\n+cd python3\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling readline\"\n+cd readline\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling sqlite\"\n+cd sqlite\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling tcl\"\n+cd tcl\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling tensorflow\"\n+cd tensorflow\n+sh .\/compilesource.sh\n+cd ..\n+echo \"compiling time\"\n+cd time\n+sh .\/compilesource.sh\n+cd ..\n","filename":"samples\/compilesourceall.sh","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.util.Optional;\n+import jdk.incubator.foreign.*;\n+import org.unix.dlfcn_h.*;\n+import static org.unix.dlfcn_h.*;\n+\n+public class Dlopen {\n+    \/\/ implementation of SymbolLookup that loads a given shared object using dlopen\n+    \/\/ and looks up symbols using dlsym\n+    private static SymbolLookup lookup(String libraryName, ResourceScope scope) {\n+        try (ResourceScope openScope = ResourceScope.newConfinedScope()) {\n+            var openScopeAllocator = SegmentAllocator.nativeAllocator(openScope);\n+            var handle = dlopen(openScopeAllocator.allocateUtf8String(libraryName), RTLD_LOCAL());\n+            if (handle == MemoryAddress.NULL) {\n+                throw new IllegalArgumentException(\"Cannot find library: \" + libraryName);\n+            }\n+            scope.addCloseAction(() -> dlclose(handle));\n+            return name -> {\n+                var allocator = SegmentAllocator.nativeAllocator(scope);\n+                var addr = dlsym(handle, allocator.allocateUtf8String(name));\n+                return addr == MemoryAddress.NULL ?\n+                            Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, scope));\n+            };\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        var arg = args.length > 0? args[0] : \"Java\";\n+        var libName = \"libhello.dylib\";\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            var symLookup = lookup(libName, scope);\n+\n+            var linker = CLinker.systemCLinker();\n+            \/\/ get method handle for a function from helloLIb\n+            var greetingMH = linker.downcallHandle(\n+                symLookup.lookup(\"greeting\").get(),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+            \/\/ invoke a function from helloLib\n+            greetingMH.invoke(allocator.allocateUtf8String(arg));\n+        }\n+    }\n+}\n","filename":"samples\/dlopen\/Dlopen.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+cc --shared -o libhello.dylib hello.c\n+\n+jextract -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/dlfcn.h\n","filename":"samples\/dlopen\/compile.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+cc --shared -o libhello.dylib hello.c\n+\n+jextract --source -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/dlfcn.h\n+\n+javac --add-modules jdk.incubator.foreign org\/unix\/*.java\n","filename":"samples\/dlopen\/compilesource.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#include <stdio.h>\n+\n+void greeting(const char* name) {\n+    printf(\"Hello, %s\\n\", name);\n+}\n","filename":"samples\/dlopen\/hello.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   Dlopen.java $*\n","filename":"samples\/dlopen\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import static org.golang.libhello_h.*;\n+\n+class Main {\n+   public static void main(String[] a) {\n+       System.out.println(Add(2344L, 555L));\n+   }\n+}\n","filename":"samples\/go\/Main.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+go build -o libhello.dylib  -buildmode=c-shared\n+jextract -l hello -t org.golang libhello.h\n","filename":"samples\/go\/compile.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+go build -o libhello.dylib  -buildmode=c-shared\n+jextract --source -l hello -t org.golang libhello.h\n+javac --add-modules jdk.incubator.foreign org\/golang\/*.java\n+\n","filename":"samples\/go\/compilesource.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+module main\n+\n+go 1.17\n","filename":"samples\/go\/go.mod","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package main\n+\n+import \"fmt\"\n+import(\n+   \"runtime\/debug\"\n+)\n+\n+import \"C\"\n+\n+\/\/export Add\n+func Add(x, y int) int {\n+    var added = make(chan int)\n+    fmt.Printf(\"Go says: adding %v and %v\\n\", x, y)\n+\n+    go print(x, y, added)\n+\n+    return <- added \n+}\n+\n+func print(x, y int, c chan int) {\n+    fmt.Println(\"adding in another goroutine\")\n+    debug.PrintStack()\n+    c <- x+y\n+}\n+\n+func main() {\n+}\n+\n","filename":"samples\/go\/main.go","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+java --add-modules jdk.incubator.foreign --enable-native-access=ALL-UNNAMED Main.java\n","filename":"samples\/go\/run.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import static org.hello.helloworld_h.*;\n+\n+public class HelloWorld {\n+    public static void main(String[] args) {\n+        helloworld();\n+    }\n+}\n+\n","filename":"samples\/helloworld\/HelloWorld.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+cc -shared -o libhelloworld.dylib helloworld.c\n+jextract -t org.hello -lhelloworld helloworld.h\n","filename":"samples\/helloworld\/compile.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+cc -shared -o libhelloworld.dylib helloworld.c\n+jextract --source -t org.hello -lhelloworld helloworld.h\n+javac --add-modules jdk.incubator.foreign org\/hello\/*.java\n","filename":"samples\/helloworld\/compilesource.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#include \"helloworld.h\"\n+\n+void helloworld(void) {\n+    printf(\"Hello World!\\n\");\n+}\n+\n","filename":"samples\/helloworld\/helloworld.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#ifndef helloworld_h\n+#define helloworld_h\n+\n+extern void helloworld(void);\n+\n+#endif \/* helloworld_h *\/\n","filename":"samples\/helloworld\/helloworld.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign HelloWorld.java\n","filename":"samples\/helloworld\/run.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+import lapack.*;\n+import static lapack.lapacke_h.*;\n+\n+public class TestLapack {\n+    public static void main(String[] args) {\n+\n+        \/* Locals *\/\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var A = allocator.allocateArray(C_DOUBLE, new double[]{\n+                    1, 2, 3, 4, 5, 1, 3, 5, 2, 4, 1, 4, 2, 5, 3\n+            });\n+            var b = allocator.allocateArray(C_DOUBLE, new double[]{\n+                    -10, 12, 14, 16, 18, -3, 14, 12, 16, 16\n+            });\n+            int info, m, n, lda, ldb, nrhs;\n+\n+            \/* Initialization *\/\n+            m = 5;\n+            n = 3;\n+            nrhs = 2;\n+            lda = 5;\n+            ldb = 5;\n+\n+            \/* Print Entry Matrix *\/\n+            print_matrix_colmajor(\"Entry Matrix A\", m, n, A, lda );\n+            \/* Print Right Rand Side *\/\n+            print_matrix_colmajor(\"Right Hand Side b\", n, nrhs, b, ldb );\n+            System.out.println();\n+\n+            \/* Executable statements *\/\n+            \/\/            printf( \"LAPACKE_dgels (col-major, high-level) Example Program Results\\n\" );\n+            \/* Solve least squares problem*\/\n+            info = LAPACKE_dgels(LAPACK_COL_MAJOR(), (byte)'N', m, n, nrhs, A, lda, b, ldb);\n+\n+            \/* Print Solution *\/\n+            print_matrix_colmajor(\"Solution\", n, nrhs, b, ldb );\n+            System.out.println();\n+            System.exit(info);\n+        }\n+    }\n+\n+    static void print_matrix_colmajor(String msg, int m, int n, MemorySegment mat, int ldm) {\n+        int i, j;\n+        System.out.printf(\"\\n %s\\n\", msg);\n+\n+        for( i = 0; i < m; i++ ) {\n+            for( j = 0; j < n; j++ ) System.out.printf(\" %6.2f\", mat.getAtIndex(C_DOUBLE, i+j*ldm));\n+            System.out.printf( \"\\n\" );\n+        }\n+    }\n+}\n+\n","filename":"samples\/lapack\/TestLapack.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+jextract \\\n+   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   -l lapacke -t lapack \\\n+   \/usr\/local\/opt\/lapack\/include\/lapacke.h \n","filename":"samples\/lapack\/compile.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lapack installation which include\/lapacke.h and dependent headers\")]\r\n+  [string]$lapackPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -t lapack `\r\n+  -I \"$lapackPath\\include\" `\r\n+  -l liblapacke `\r\n+  -- `\r\n+  \"$lapackPath\\include\\lapacke.h\"\r\n","filename":"samples\/lapack\/compile_windows.ps1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract --source \\\n+   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   -l lapacke -t lapack \\\n+   \/usr\/local\/opt\/lapack\/include\/lapacke.h \n+\n+javac --add-modules jdk.incubator.foreign lapack\/*.java\n","filename":"samples\/lapack\/compilesource.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\\n+    TestLapack.java\n","filename":"samples\/lapack\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lib curl installation, which contains bin\/liblapacke.dll\")]\r\n+  [string]$lapackPath,\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the mingw bin directory which contains libgcc_s_seh-1.dll and libquadmath-0.dll\")]\r\n+  [string]$mingwBinPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+$Env:path+=\"`;$lapackPath\\bin\" # libblas.dll\r\n+$Env:path+=\"`;$mingwBinPath\" # mingw runtime dlls\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$lapackPath\\bin\" `\r\n+  TestLapack.java `\r\n","filename":"samples\/lapack\/run_windows.ps1","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.llvm.clang.Index_h.*;\n+import org.llvm.clang.*;\n+\n+public class ASTPrinter {\n+    private static String asJavaString(MemorySegment clangStr) {\n+        String str = clang_getCString(clangStr).getUtf8String(0);\n+        clang_disposeString(clangStr);\n+        return str;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"java ASTPrinter <C source or header>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            \/\/ parse the C header\/source passed from the command line\n+            var index = clang_createIndex(0, 0);\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var tu = clang_parseTranslationUnit(index, allocator.allocateUtf8String(args[0]),\n+                    NULL, 0, NULL, 0, CXTranslationUnit_None());\n+            \/\/ array trick to update within lambda\n+            var level = new int[1];\n+            var visitor = new NativeSymbol[1];\n+\n+            \/\/ clang Cursor visitor callback\n+            visitor[0] = CXCursorVisitor.allocate((cursor, parent, data) -> {\n+                var kind = clang_getCursorKind(cursor);\n+                var name = asJavaString(clang_getCursorSpelling(scope, cursor));\n+                var kindName = asJavaString(clang_getCursorKindSpelling(scope, kind));\n+                System.out.printf(\"%s %s %s\", \" \".repeat(level[0]), kindName, name);\n+                var type = clang_getCursorType(scope, cursor);\n+                if (CXType.kind$get(type) != CXType_Invalid()) {\n+                    var typeName = asJavaString(clang_getTypeSpelling(scope, type));\n+                    System.out.printf(\" <%s>\", typeName);\n+                }\n+                System.out.println();\n+\n+                \/\/ visit children\n+                level[0]++;\n+                clang_visitChildren(cursor, visitor[0], NULL);\n+                level[0]--;\n+\n+                return CXChildVisit_Continue();\n+            }, scope);\n+\n+            \/\/ get the AST root and visit it\n+            var root = clang_getTranslationUnitCursor(scope, tu);\n+            clang_visitChildren(root, visitor[0], NULL);\n+\n+            clang_disposeTranslationUnit(tu);\n+            clang_disposeIndex(index);\n+        }\n+    }\n+}\n","filename":"samples\/libclang\/ASTPrinter.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+You need to build llvm\/libclang (https:\/\/clang.llvm.org\/docs\/Tooling.html) or install libclang.\n+Set LIBCLANG_HOME env. var to be the directory where you've installed libclang.\n+\n+Command line to jextract clang's Index.h\n+\n+$ sh .\/compile.sh\n+\n+Command line to parse and print AST of a sample .c file\n+\n+$ sh .\/run.sh hello.c\n","filename":"samples\/libclang\/README","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract -t org.llvm.clang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n","filename":"samples\/libclang\/compile.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the llvm installation which include\/clang-c\")]\r\n+  [string]$clangPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -t org.llvm.clang `\r\n+  -I \"$clangPath\\include\" `\r\n+  -I \"$clangPath\\include\\clang-c\" `\r\n+  -l libclang `\r\n+  -- `\r\n+  \"$clangPath\\include\\clang-c\\Index.h\"\r\n","filename":"samples\/libclang\/compile_windows.ps1","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract --source -t org.llvm.clang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+javac --add-modules jdk.incubator.foreign org\/llvm\/clang\/*.java\n","filename":"samples\/libclang\/compilesource.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+typedef struct Point {\n+    double x, y;\n+} Point;\n+\n+double distance(Point p1, Point p2);\n+\n+extern int printf(const char* fmt, ...);\n+\n+void hello() {\n+    printf(\"hello\\n\");\n+}\n","filename":"samples\/libclang\/hello.c","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+java -Djava.library.path=${LIBCLANG_HOME}\/lib --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    ASTPrinter.java $*\n","filename":"samples\/libclang\/run.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the llvm installation which include bin\/libclang.dll\")]\r\n+  [string]$clangPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$clangPath\\bin\" `\r\n+  ASTPrinter.java hello.c\n\\ No newline at end of file\n","filename":"samples\/libclang\/run_windows.ps1","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.jextract.curl_h.*;\n+import org.jextract.*;\n+\n+public class CurlMain {\n+   public static void main(String[] args) {\n+       var urlStr = args[0];\n+       curl_global_init(CURL_GLOBAL_DEFAULT());\n+       var curl = curl_easy_init();\n+       if(!curl.equals(NULL)) {\n+           try (var scope = ResourceScope.newConfinedScope()) {\n+               var allocator = SegmentAllocator.nativeAllocator(scope);\n+               var url = allocator.allocateUtf8String(urlStr);\n+               curl_easy_setopt(curl, CURLOPT_URL(), url.address());\n+               int res = curl_easy_perform(curl);\n+               if (res != CURLE_OK()) {\n+                   String error = curl_easy_strerror(res).getUtf8String(0);\n+                   System.out.println(\"Curl error: \" + error);\n+                   curl_easy_cleanup(curl);\n+               }\n+           }\n+       }\n+       curl_global_cleanup();\n+   }\n+}\n+\n","filename":"samples\/libcurl\/CurlMain.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+jextract -t org.jextract -lcurl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n","filename":"samples\/libcurl\/compile.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lib curl installation\")]\r\n+  [string]$curlpath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -I \"$curlpath\\include\" `\r\n+  -I \"$curlpath\\include\\curl\" `\r\n+  --dump-includes 'includes_all.conf' `\r\n+  -- `\r\n+  \"$curlpath\\include\\curl\\curl.h\"\r\n+  \r\n+filter_file 'includes_all.conf' 'curl' 'includes_filtered.conf'\r\n+\r\n+& $jextract `\r\n+  -t org.jextract `\r\n+  -I \"$curlpath\\include\" `\r\n+  -I \"$curlpath\\include\\curl\" `\r\n+  -llibcurl `\r\n+  '@includes_filtered.conf' `\r\n+  -- `\r\n+  \"$curlpath\\include\\curl\\curl.h\"\r\n","filename":"samples\/libcurl\/compile_windows.ps1","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract --source -t org.jextract -lcurl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n+\n+javac --add-modules jdk.incubator.foreign org\/jextract\/*.java\n","filename":"samples\/libcurl\/compilesource.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib CurlMain.java $*\n","filename":"samples\/libcurl\/run.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the lib curl installation\")]\r\n+  [string]$curlpath,\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"URL to get\")]\r\n+  [string]$url\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$curlpath\\bin\" `\r\n+  CurlMain.java `\r\n+  $url\r\n","filename":"samples\/libcurl\/run_windows.ps1","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import jdk.incubator.foreign.*;\n+import libffmpeg.AVCodecContext;\n+import libffmpeg.AVFormatContext;\n+import libffmpeg.AVFrame;\n+import libffmpeg.AVPacket;\n+import libffmpeg.AVStream;\n+import static libffmpeg.Libffmpeg.*;\n+import static jdk.incubator.foreign.MemoryAddress.*;\n+\n+\/*\n+ * This sample is based on C sample from the ffmpeg tutorial at\n+ * http:\/\/dranger.com\/ffmpeg\/tutorial01.html\n+ *\n+ * This sample extracts first five frames of the video stream\n+ * from a given .mp4 file and stores those as .ppm image files.\n+*\/\n+public class LibffmpegMain {\n+    private static int NUM_FRAMES_TO_CAPTURE = 5;\n+\n+    static class ExitException extends RuntimeException {\n+        final int exitCode;\n+        ExitException(int exitCode, String msg) {\n+            super(msg);\n+            this.exitCode = exitCode;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length != 1) {\n+            System.err.println(\"please pass a .mp4 file\");\n+            System.exit(1);\n+        }\n+\n+        av_register_all();\n+\n+        int exitCode = 0;\n+        var pCodecCtxOrig = NULL;\n+        var pCodecCtx = NULL;\n+        var pFrame = NULL;\n+        var pFrameRGB = NULL;\n+        var buffer = NULL;\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            \/\/ AVFormatContext *ppFormatCtx;\n+            var ppFormatCtx = MemorySegment.allocateNative(C_POINTER, scope);\n+            \/\/ char* fileName;\n+            var fileName = allocator.allocateUtf8String(args[0]);\n+\n+            \/\/ open video file\n+            if (avformat_open_input(ppFormatCtx, fileName, NULL, NULL) != 0) {\n+                throw new ExitException(1, \"Cannot open \" + args[0]);\n+            }\n+            System.out.println(\"opened \" + args[0]);\n+            \/\/ AVFormatContext *pFormatCtx;\n+            var pFormatCtx = ppFormatCtx.get(C_POINTER, 0);\n+\n+            \/\/ Retrieve stream info\n+            if (avformat_find_stream_info(pFormatCtx, NULL) < 0) {\n+                throw new ExitException(1, \"Could not find stream information\");\n+            }\n+\n+            scope.addCloseAction(()-> {\n+                \/\/ Close the video file\n+                avformat_close_input(ppFormatCtx);\n+            });\n+\n+            \/\/ Dump AV format info on stderr\n+            av_dump_format(pFormatCtx, 0, fileName, 0);\n+\n+            \/\/ Find the first video stream\n+            int videoStream = -1;\n+            \/\/ AVFrameContext formatCtx;\n+            var formatCtx = MemorySegment.ofAddress(pFormatCtx, AVFormatContext.sizeof(), scope);\n+            \/\/ formatCtx.nb_streams\n+            int nb_streams = AVFormatContext.nb_streams$get(formatCtx);\n+            System.out.println(\"number of streams: \" + nb_streams);\n+            \/\/ formatCtx.streams\n+            var pStreams = AVFormatContext.streams$get(formatCtx);\n+            var streamsArray = MemorySegment.ofAddress(pStreams, nb_streams * C_POINTER.byteSize(), scope);\n+\n+            \/\/ AVCodecContext* pVideoCodecCtx;\n+            var pVideoCodecCtx = NULL;\n+            \/\/ AVCodec* pCodec;\n+            var pCodec = NULL;\n+            for (int i = 0; i < nb_streams; i++) {\n+                \/\/ AVStream* pStream;\n+                var pStream = streamsArray.getAtIndex(C_POINTER, i);\n+                \/\/ AVStream stream;\n+                var stream = MemorySegment.ofAddress(pStream, AVStream.sizeof(), scope);\n+                \/\/ AVCodecContext* pCodecCtx;\n+                pCodecCtx = AVStream.codec$get(stream);\n+                var avcodecCtx = MemorySegment.ofAddress(pCodecCtx, AVCodecContext.sizeof(), scope);\n+                if (AVCodecContext.codec_type$get(avcodecCtx) == AVMEDIA_TYPE_VIDEO()) {\n+                    videoStream = i;\n+                    pVideoCodecCtx = pCodecCtx;\n+                    \/\/ Find the decoder for the video stream\n+                    pCodec = avcodec_find_decoder(AVCodecContext.codec_id$get(avcodecCtx));\n+                    break;\n+                }\n+            }\n+\n+            if (videoStream == -1) {\n+                throw new ExitException(1, \"Didn't find a video stream\");\n+            } else {\n+                System.out.println(\"Found video stream (index: \" + videoStream + \")\");\n+            }\n+\n+            if (pCodec.equals(NULL)) {\n+                throw new ExitException(1, \"Unsupported codec\");\n+            }\n+\n+            \/\/ Copy context\n+            \/\/ AVCodecContext *pCodecCtxOrig;\n+            pCodecCtxOrig = pVideoCodecCtx;\n+            \/\/ AVCodecContext *pCodecCtx;\n+            pCodecCtx = avcodec_alloc_context3(pCodec);\n+            if (avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != 0) {\n+                throw new ExitException(1, \"Cannot copy context\");\n+            }\n+\n+            \/\/ Open codec\n+            if (avcodec_open2(pCodecCtx, pCodec, NULL) < 0) {\n+                throw new ExitException(1, \"Cannot open codec\");\n+            }\n+\n+            \/\/ Allocate video frame\n+            \/\/ AVFrame* pFrame;\n+            pFrame = av_frame_alloc();\n+            \/\/ Allocate an AVFrame structure\n+            \/\/ AVFrame* pFrameRGB;\n+            pFrameRGB = av_frame_alloc();\n+\n+            \/\/ Determine required buffer size and allocate buffer\n+            var codecCtx = MemorySegment.ofAddress(pCodecCtx, AVCodecContext.sizeof(), scope);\n+            int width = AVCodecContext.width$get(codecCtx);\n+            int height = AVCodecContext.height$get(codecCtx);\n+            int numBytes = avpicture_get_size(AV_PIX_FMT_RGB24(), width, height);\n+            buffer = av_malloc(numBytes * C_CHAR.byteSize());\n+\n+\n+            if (pFrame.equals(NULL)) {\n+                throw new ExitException(1, \"Cannot allocate frame\");\n+            }\n+            var frame = MemorySegment.ofAddress(pFrame, AVFrame.sizeof(), scope);\n+            if (pFrameRGB.equals(NULL)) {\n+                throw new ExitException(1, \"Cannot allocate RGB frame\");\n+            }\n+            var frameRGB = MemorySegment.ofAddress(pFrameRGB, AVFrame.sizeof(), scope);\n+            if (buffer.equals(NULL)) {\n+                throw new ExitException(1, \"cannot allocate buffer\");\n+            }\n+\n+            \/\/ Assign appropriate parts of buffer to image planes in pFrameRGB\n+            \/\/ Note that pFrameRGB is an AVFrame, but AVFrame is a superset\n+            \/\/ of AVPicture\n+            avpicture_fill(pFrameRGB, buffer, AV_PIX_FMT_RGB24(), width, height);\n+\n+            \/\/ initialize SWS context for software scaling\n+            int pix_fmt = AVCodecContext.pix_fmt$get(codecCtx);\n+            var sws_ctx = sws_getContext(width, height, pix_fmt, width, height,\n+                AV_PIX_FMT_RGB24(), SWS_BILINEAR(), NULL, NULL, NULL);\n+\n+            int i = 0;\n+            \/\/ ACPacket packet;\n+            var packet = AVPacket.allocate(scope);\n+            \/\/ int* pFrameFinished;\n+            var pFrameFinished = MemorySegment.allocateNative(C_INT, scope);\n+\n+            while (av_read_frame(pFormatCtx, packet) >= 0) {\n+                \/\/ Is this a packet from the video stream?\n+                \/\/ packet.stream_index == videoStream\n+                if (AVPacket.stream_index$get(packet) == videoStream) {\n+                    \/\/ Decode video frame\n+                    avcodec_decode_video2(pCodecCtx, pFrame, pFrameFinished, packet);\n+\n+                    int frameFinished = pFrameFinished.get(C_INT, 0);\n+                    \/\/ Did we get a video frame?\n+                    if (frameFinished != 0) {\n+                        \/\/ Convert the image from its native format to RGB\n+                        sws_scale(sws_ctx, AVFrame.data$slice(frame),\n+                            AVFrame.linesize$slice(frame), 0, height,\n+                            AVFrame.data$slice(frameRGB), AVFrame.linesize$slice(frameRGB));\n+\n+                        \/\/ Save the frame to disk\n+                        if (++i <= NUM_FRAMES_TO_CAPTURE) {\n+                            try {\n+                                saveFrame(frameRGB, scope, width, height, i);\n+                            } catch (Exception exp) {\n+                                exp.printStackTrace();\n+                                throw new ExitException(1, \"save frame failed for frame \" + i);\n+                            }\n+                        }\n+                     }\n+                 }\n+\n+                 \/\/ Free the packet that was allocated by av_read_frame\n+                 av_free_packet(packet);\n+            }\n+\n+            throw new ExitException(0, \"Goodbye!\");\n+        } catch (ExitException ee) {\n+            System.err.println(ee.getMessage());\n+            exitCode = ee.exitCode;\n+        } finally {\n+            \/\/ clean-up everything\n+\n+            \/\/ Free the RGB image\n+            if (!buffer.equals(NULL)) {\n+                av_free(buffer);\n+            }\n+\n+            if (!pFrameRGB.equals(NULL)) {\n+                av_free(pFrameRGB);\n+            }\n+\n+            \/\/ Free the YUV frame\n+            if (!pFrame.equals(NULL)) {\n+                av_free(pFrame);\n+            }\n+\n+            \/\/ Close the codecs\n+            if (!pCodecCtx.equals(NULL)) {\n+                avcodec_close(pCodecCtx);\n+            }\n+\n+            if (!pCodecCtxOrig.equals(NULL)) {\n+                avcodec_close(pCodecCtxOrig);\n+            }\n+        }\n+\n+        System.exit(exitCode);\n+    }\n+\n+    private static void saveFrame(MemorySegment frameRGB, ResourceScope scope,\n+            int width, int height, int iFrame)\n+            throws IOException {\n+        var header = String.format(\"P6\\n%d %d\\n255\\n\", width, height);\n+        var path = Paths.get(\"frame\" + iFrame + \".ppm\");\n+        try (var os = Files.newOutputStream(path)) {\n+            System.out.println(\"writing \" + path.toString());\n+            os.write(header.getBytes());\n+            var data = AVFrame.data$slice(frameRGB);\n+            \/\/ frameRGB.data[0]\n+            var pdata = data.get(C_POINTER, 0);\n+            \/\/ frameRGB.linespace[0]\n+            var linesize = AVFrame.linesize$slice(frameRGB).get(C_INT, 0);\n+            \/\/ Write pixel data\n+            for (int y = 0; y < height; y++) {\n+                \/\/ frameRGB.data[0] + y*frameRGB.linesize[0] is the pointer. And 3*width size of data\n+                var pixelArray = MemorySegment.ofAddress(pdata.addOffset(y*linesize), 3*width, scope);\n+                \/\/ dump the pixel byte buffer to file\n+                os.write(pixelArray.toArray(C_CHAR));\n+            }\n+        }\n+    }\n+}\n","filename":"samples\/libffmpeg\/LibffmpegMain.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+* Install libffmpeg on Mac using homebrew\n+\n+    brew install ffmpeg\n+\n+* run .\/compile.sh or .\/compilesource.sh to jextract libffmpeg headers\n+\n+* run\n+\n+    sh .\/run.sh <your .mp4 file>\n+\n+The last step will produce 5 .ppm image files (of the first 5 frames of video)\n+\n","filename":"samples\/libffmpeg\/README","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+jextract -t libffmpeg \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg\/4.4.1_3\/include \\\n+  -l avcodec \\\n+  -l avformat \\\n+  -l avutil \\\n+  -l swscale \\\n+  --header-class-name Libffmpeg \\\n+  libffmpeg.h\n+\n","filename":"samples\/libffmpeg\/compile.sh","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+jextract --source -t libffmpeg \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg\/4.4.1_3\/include \\\n+  -l avcodec \\\n+  -l avformat \\\n+  -l avutil \\\n+  -l swscale \\\n+  --header-class-name Libffmpeg \\\n+  libffmpeg.h\n+\n+javac --add-modules jdk.incubator.foreign libffmpeg\/*.java\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#include <libavcodec\/avcodec.h>\n+#include <libavformat\/avformat.h>\n+#include <libswscale\/swscale.h>\n","filename":"samples\/libffmpeg\/libffmpeg.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg\/4.4.1_3\/lib LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+import static com.github.git2_h.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import com.github.*;\n+\n+public class GitClone {\n+    public static void main(String[] args) {\n+          if (args.length != 2) {\n+              System.err.println(\"java GitClone <url> <path>\");\n+              System.exit(1);\n+          }\n+          git_libgit2_init();\n+          try (var scope = ResourceScope.newConfinedScope()) {\n+              var allocator = SegmentAllocator.newNativeArena(scope);\n+              var repo = allocator.allocate(C_POINTER);\n+              var url = allocator.allocateUtf8String(args[0]);\n+              var path = allocator.allocateUtf8String(args[1]);\n+              System.out.println(git_clone(repo, url, path, NULL));\n+          }\n+          git_libgit2_shutdown();\n+    }\n+}\n","filename":"samples\/libgit2\/GitClone.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+* get libgit2 source code from https:\/\/github.com\/libgit2\/libgit2\/releases and build.\n+* I assume ${LIBGIT2_HOME} is your directory where you expanded libgit2 release.\n+* Also ${LIBGIT2_HOME}\/build is the build directory where libgit2.dylib is built.\n","filename":"samples\/libgit2\/README","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract -t com.github -lgit2 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/git2 \\\n+  ${LIBGIT2_HOME}\/include\/git2.h\n","filename":"samples\/libgit2\/compile.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the libgit2 installation\")]\r\n+  [string]$libgit2path\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -t com.github `\r\n+  -I \"$libgit2path\\include\" `\r\n+  -l git2 `\r\n+  -- `\r\n+  \"$libgit2path\\include\\git2.h\"\r\n","filename":"samples\/libgit2\/compile_windows.ps1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+jextract --source -t com.github -lgit2 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/git2 \\\n+  ${LIBGIT2_HOME}\/include\/git2.h\n+\n+javac --add-modules jdk.incubator.foreign com\/github\/*.java\n","filename":"samples\/libgit2\/compilesource.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=${LIBGIT2_HOME}\/build\/ \\\n+    GitClone.java $*\n","filename":"samples\/libgit2\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the libgit2 installation\")]\r\n+  [string]$libgit2path,\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"URL to clone from\")]\r\n+  [string]$url,\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"Path to clone into\")]\r\n+  [string]$path\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$libgit2path\\bin\" `\r\n+  GitClone.java `\r\n+  $url $path\r\n","filename":"samples\/libgit2\/run_windows.ps1","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.openjdk.jimage_h.*;\n+\n+public class JImageFile {\n+    public static void main(String[] args) {\n+        String javaHome = System.getProperty(\"java.home\");\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var jintResPtr = allocator.allocate(jint);\n+            var moduleFilePath = allocator.allocateUtf8String(javaHome + \"\/lib\/modules\");\n+            var jimageFile = JIMAGE_Open(moduleFilePath, jintResPtr);\n+\n+            var mod = JIMAGE_PackageToModule(jimageFile,\n+                allocator.allocateUtf8String(\"java\/util\"));\n+            System.out.println(mod);\n+\n+            \/\/ const char* module_name, const char* version, const char* package,\n+            \/\/ const char* name, const char* extension, void* arg\n+\n+            var visitor = JImageResourceVisitor_t.allocate(\n+                (jimage, module_name, version, package_name, name, extension, arg) -> {\n+                   System.out.println(\"module \" + module_name.getUtf8String(0));\n+                   System.out.println(\"package \" + package_name.getUtf8String(0));\n+                   System.out.println(\"name \" + name.getUtf8String(0));\n+                   return 1;\n+                }, scope);\n+\n+            JIMAGE_ResourceIterator(jimageFile, visitor, NULL);\n+\n+            JIMAGE_Close(jimageFile);\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/JImageFile.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+This example demonstrates Java interface for libjimage C++ library\n+that parses Java modules file.\n+\n+** Note: libjimage is a private interface to Hotspot - not a public API. **\n+\n+libjimage.dylib\/libjimages.so\/jimage.dll is loaded by boot loader.\n+So an application cannot load this using System.loadLibrary\/.load. This\n+is because System.loadLibrary\/.load is classloader based. Two or more\n+classloaders cannot share a native library. While this is needed for type\n+safety of JNI (Java Native Interface) based native libraries, Panama libraries\n+need not have this restriction. This sample demonstrates using platform native\n+dlopen\/dlsym to load & use libjimage.dylib from a Java application.\n+\n+extract.sh script was used to jextract jimage.h and dlfcn.h. These two extracted\n+libraries are used together in this project to access libjimage.dylib functions\n+from a Java app.\n","filename":"samples\/libjimage\/README.md","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+javac -d build --add-modules jdk.incubator.foreign org\/unix\/*.java org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compile.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+jextract \\\n+  -I \/Library\/Developer\/CommandLineTools\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -t org.openjdk \\\n+  --source \\\n+  jimage.h\n+\n+jextract \\\n+  -I \/Library\/Developer\/CommandLineTools\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -t org.unix \\\n+  --source \\\n+  \/Library\/Developer\/CommandLineTools\/SDKs\/MacOSX.sdk\/usr\/include\/dlfcn.h \n","filename":"samples\/libjimage\/extract.sh","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+\/\/ This section is inlined from platform specific jni_md.h files\n+#ifdef _WIN64\n+    #define JNIEXPORT __declspec(dllexport)\n+#elif (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2))) || __has_attribute(visibility)\n+    #ifdef ARM\n+      #define JNIEXPORT     __attribute__((externally_visible,visibility(\"default\")))\n+    #else\n+      #define JNIEXPORT     __attribute__((visibility(\"default\")))\n+    #endif\n+#else\n+#define JNIEXPORT\n+#endif\n+\n+\/\/ just enough portable jni types for jimage interface\n+typedef long long jlong;\n+typedef int jint;\n+\n+\/\/ Opaque reference to a JImage file.\n+typedef struct JImageFile JImageFile;\n+\/\/ Opaque reference to an image file resource location.\n+typedef jlong JImageLocationRef;\n+\n+\/\/ Max path length limit independent of platform.  Windows max path is 1024,\n+\/\/ other platforms use 4096.\n+#define JIMAGE_MAX_PATH 4096\n+\n+\/\/ JImage Error Codes\n+\n+\/\/ Resource was not found\n+#define JIMAGE_NOT_FOUND (0)\n+\/\/ The image file is not prefixed with 0xCAFEDADA\n+#define JIMAGE_BAD_MAGIC (-1)\n+\/\/ The image file does not have a compatible (translatable) version\n+#define JIMAGE_BAD_VERSION (-2)\n+\/\/ The image file content is malformed\n+#define JIMAGE_CORRUPTED (-3)\n+\n+\/*\n+ * JImageOpen - Given the supplied full path file name, open an image file. This\n+ * function will also initialize tables and retrieve meta-data necessary to\n+ * satisfy other functions in the API. If the image file has been previously\n+ * open, a new open request will share memory and resources used by the previous\n+ * open. A call to JImageOpen should be balanced by a call to JImageClose, to\n+ * release memory and resources used. If the image file is not found or cannot\n+ * be open, then NULL is returned and error will contain a reason for the\n+ * failure; a positive value for a system error number, negative for a jimage\n+ * specific error (see JImage Error Codes.)\n+ *\n+ *  Ex.\n+ *   jint error;\n+ *   JImageFile* jimage = (*JImageOpen)(JAVA_HOME \"lib\/modules\", &error);\n+ *   if (image == NULL) {\n+ *     tty->print_cr(\"JImage failed to open: %d\", error);\n+ *     ...\n+ *   }\n+ *   ...\n+ *\/\n+\n+JNIEXPORT JImageFile*\n+JIMAGE_Open(const char *name, jint* error);\n+\n+typedef JImageFile* (*JImageOpen_t)(const char *name, jint* error);\n+\n+\/*\n+ * JImageClose - Given the supplied open image file (see JImageOpen), release\n+ * memory and resources used by the open file and close the file. If the image\n+ * file is shared by other uses, release and close is deferred until the last use\n+ * is also closed.\n+ *\n+ * Ex.\n+ *  (*JImageClose)(image);\n+ *\/\n+\n+JNIEXPORT void\n+JIMAGE_Close(JImageFile* jimage);\n+\n+typedef void (*JImageClose_t)(JImageFile* jimage);\n+\n+\n+\/*\n+ * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n+ * of a package, return the name of module where the package resides. If the\n+ * package does not exist in the image file, the function returns NULL.\n+ * The resulting string does\/should not have to be released. All strings are\n+ * utf-8, zero byte terminated.\n+ *\n+ * Ex.\n+ *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n+ *  tty->print_cr(package);\n+ *  -> java.base\n+ *\/\n+\n+JNIEXPORT const char *\n+JIMAGE_PackageToModule(JImageFile* jimage, const char* package_name);\n+\n+typedef const char* (*JImagePackageToModule_t)(JImageFile* jimage, const char* package_name);\n+\n+\n+\/*\n+ * JImageFindResource - Given an open image file (see JImageOpen), a module\n+ * name, a version string and the name of a class\/resource, return location\n+ * information describing the resource and its size. If no resource is found, the\n+ * function returns JIMAGE_NOT_FOUND and the value of size is undefined.\n+ * The version number should be \"9.0\" and is not used in locating the resource.\n+ * The resulting location does\/should not have to be released.\n+ * All strings are utf-8, zero byte terminated.\n+ *\n+ *  Ex.\n+ *   jlong size;\n+ *   JImageLocationRef location = (*JImageFindResource)(image,\n+ *                                \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *\/\n+JNIEXPORT JImageLocationRef JIMAGE_FindResource(JImageFile* jimage,\n+        const char* module_name, const char* version, const char* name,\n+        jlong* size);\n+\n+typedef JImageLocationRef(*JImageFindResource_t)(JImageFile* jimage,\n+        const char* module_name, const char* version, const char* name,\n+        jlong* size);\n+\n+\n+\/*\n+ * JImageGetResource - Given an open image file (see JImageOpen), a resource's\n+ * location information (see JImageFindResource), a buffer of appropriate\n+ * size and the size, retrieve the bytes associated with the\n+ * resource. If the size is less than the resource size then the read is truncated.\n+ * If the size is greater than the resource size then the remainder of the buffer\n+ * is zero filled.  The function will return the actual size of the resource.\n+ *\n+ * Ex.\n+ *  jlong size;\n+ *  JImageLocationRef location = (*JImageFindResource)(image,\n+ *                               \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *  char* buffer = new char[size];\n+ *  (*JImageGetResource)(image, location, buffer, size);\n+ *\/\n+JNIEXPORT jlong\n+JIMAGE_GetResource(JImageFile* jimage, JImageLocationRef location,\n+        char* buffer, jlong size);\n+\n+typedef jlong(*JImageGetResource_t)(JImageFile* jimage, JImageLocationRef location,\n+        char* buffer, jlong size);\n+\n+\n+\/*\n+ * JImageResourceIterator - Given an open image file (see JImageOpen), a visitor\n+ * function and a visitor argument, iterator through each of the image's resources.\n+ * The visitor function is called with the image file, the module name, the\n+ * package name, the base name, the extension and the visitor argument. The return\n+ * value of the visitor function should be true, unless an early iteration exit is\n+ * required. All strings are utf-8, zero byte terminated.file.\n+ *\n+ * Ex.\n+ *   int ctw_visitor(JImageFile* jimage, const char* module_name, const char* version,\n+ *                  const char* package, const char* name, const char* extension, void* arg) {\n+ *     if (strcmp(extension, \"class\") == 0) {\n+ *       char path[JIMAGE_MAX_PATH];\n+ *       Thread* THREAD = Thread::current();\n+ *       jio_snprintf(path, JIMAGE_MAX_PATH - 1, \"\/%s\/%s\", package, name);\n+ *       ClassLoader::compile_the_world_in(path, (Handle)arg, THREAD);\n+ *       return !HAS_PENDING_EXCEPTION;\n+ *     }\n+ *     return true;\n+ *   }\n+ *   (*JImageResourceIterator)(image, ctw_visitor, loader);\n+ *\/\n+\n+typedef int (*JImageResourceVisitor_t)(JImageFile* jimage,\n+        const char* module_name, const char* version, const char* package,\n+        const char* name, const char* extension, void* arg);\n+\n+JNIEXPORT void\n+JIMAGE_ResourceIterator(JImageFile* jimage,\n+        JImageResourceVisitor_t visitor, void *arg);\n+\n+typedef void (*JImageResourceIterator_t)(JImageFile* jimage,\n+        JImageResourceVisitor_t visitor, void* arg);\n","filename":"samples\/libjimage\/jimage.h","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageClose_t {\n+\n+    void apply(jdk.incubator.foreign.MemoryAddress x0);\n+    static NativeSymbol allocate(JImageClose_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageClose_t.class, fi, constants$0.JImageClose_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n+    }\n+    static JImageClose_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageClose_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0) -> {\n+            try {\n+                constants$0.JImageClose_t$MH.invokeExact(symbol, x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageClose_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageFindResource_t {\n+\n+    long apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4);\n+    static NativeSymbol allocate(JImageFindResource_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageFindResource_t.class, fi, constants$1.JImageFindResource_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)J\", scope);\n+    }\n+    static JImageFindResource_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageFindResource_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4) -> {\n+            try {\n+                return (long)constants$1.JImageFindResource_t$MH.invokeExact(symbol, x0, x1, x2, x3, x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageFindResource_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageGetResource_t {\n+\n+    long apply(jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2, long x3);\n+    static NativeSymbol allocate(JImageGetResource_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageGetResource_t.class, fi, constants$2.JImageGetResource_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;JLjdk\/incubator\/foreign\/MemoryAddress;J)J\", scope);\n+    }\n+    static JImageGetResource_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageGetResource_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2, long x3) -> {\n+            try {\n+                return (long)constants$2.JImageGetResource_t$MH.invokeExact(symbol, x0, x1, x2, x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageGetResource_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageOpen_t {\n+\n+    jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+    static NativeSymbol allocate(JImageOpen_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageOpen_t.class, fi, constants$0.JImageOpen_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n+    }\n+    static JImageOpen_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageOpen_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {\n+            try {\n+                return (jdk.incubator.foreign.MemoryAddress)constants$0.JImageOpen_t$MH.invokeExact(symbol, x0, x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageOpen_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImagePackageToModule_t {\n+\n+    jdk.incubator.foreign.MemoryAddress apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);\n+    static NativeSymbol allocate(JImagePackageToModule_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImagePackageToModule_t.class, fi, constants$1.JImagePackageToModule_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n+    }\n+    static JImagePackageToModule_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImagePackageToModule_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {\n+            try {\n+                return (jdk.incubator.foreign.MemoryAddress)constants$1.JImagePackageToModule_t$MH.invokeExact(symbol, x0, x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImagePackageToModule_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageResourceIterator_t {\n+\n+    void apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);\n+    static NativeSymbol allocate(JImageResourceIterator_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageResourceIterator_t.class, fi, constants$3.JImageResourceIterator_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n+    }\n+    static JImageResourceIterator_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageResourceIterator_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {\n+            try {\n+                constants$3.JImageResourceIterator_t$MH.invokeExact(symbol, x0, x1, x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceIterator_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface JImageResourceVisitor_t {\n+\n+    int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4, jdk.incubator.foreign.MemoryAddress x5, jdk.incubator.foreign.MemoryAddress x6);\n+    static NativeSymbol allocate(JImageResourceVisitor_t fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(JImageResourceVisitor_t.class, fi, constants$2.JImageResourceVisitor_t$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\", scope);\n+    }\n+    static JImageResourceVisitor_t ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"JImageResourceVisitor_t::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, jdk.incubator.foreign.MemoryAddress x4, jdk.incubator.foreign.MemoryAddress x5, jdk.incubator.foreign.MemoryAddress x6) -> {\n+            try {\n+                return (int)constants$2.JImageResourceVisitor_t$MH.invokeExact(symbol, x0, x1, x2, x3, x4, x5, x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceVisitor_t.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+package org.openjdk;\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.unix.dlfcn_h;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+\n+final class RuntimeHelper {\n+\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+    private final static SymbolLookup SYMBOL_LOOKUP;\n+\n+    final static SegmentAllocator CONSTANT_ALLOCATOR =\n+            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n+    \/\/ looks up symbols using dlsym - manual change\n+    private static SymbolLookup dlopenLookup(String libraryName) {\n+        System.out.println(\"loading \" + libraryName);\n+        var globalScope = ResourceScope.globalScope();\n+        try (ResourceScope openScope = ResourceScope.newConfinedScope()) {\n+            var openScopeAllocator = SegmentAllocator.newNativeArena(openScope);\n+            final MemoryAddress handle = dlfcn_h.dlopen(openScopeAllocator.allocateUtf8String(libraryName), dlfcn_h.RTLD_LOCAL());\n+            if (handle == MemoryAddress.NULL) {\n+                throw new IllegalArgumentException(\"Cannot find library: \" + libraryName);\n+            }\n+            globalScope.addCloseAction(() -> dlfcn_h.dlclose(handle));\n+            return name -> {\n+                var allocator = SegmentAllocator.newNativeArena(globalScope);\n+                MemoryAddress addr = dlfcn_h.dlsym(handle, allocator.allocateUtf8String(name));\n+                return addr == MemoryAddress.NULL ?\n+                            Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, globalScope));\n+            };\n+        }\n+    }\n+\n+    static {\n+        \/\/ manual change\n+        SymbolLookup dlopenLookup = dlopenLookup(System.getProperty(\"java.home\") + \"\/lib\/libjimage.dylib\");\n+        SYMBOL_LOOKUP = name -> dlopenLookup.lookup(name).or(() -> LINKER.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n+        return SYMBOL_LOOKUP.lookup(name).map(\n+                addr -> {\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        return LINKER.downcallHandle(fdesc);\n+    }\n+\n+    static final <Z> NativeSymbol upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final NativeSymbol symbol;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(NativeSymbol symbol, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(NativeSymbol symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return JAVA_LONG;\n+            } else if (c == double.class) {\n+                return JAVA_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return ADDRESS;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/openjdk\/RuntimeHelper.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$0 {\n+\n+    static final FunctionDescriptor JIMAGE_Open$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JIMAGE_Open$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_Open\",\n+        constants$0.JIMAGE_Open$FUNC, false\n+    );\n+    static final FunctionDescriptor JImageOpen_t$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JImageOpen_t$MH = RuntimeHelper.downcallHandle(\n+        constants$0.JImageOpen_t$FUNC, false\n+    );\n+    static final FunctionDescriptor JIMAGE_Close$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle JIMAGE_Close$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_Close\",\n+        constants$0.JIMAGE_Close$FUNC, false\n+    );\n+    static final FunctionDescriptor JImageClose_t$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle JImageClose_t$MH = RuntimeHelper.downcallHandle(\n+        constants$0.JImageClose_t$FUNC, false\n+    );\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/constants$0.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$1 {\n+\n+    static final FunctionDescriptor JIMAGE_PackageToModule$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JIMAGE_PackageToModule$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_PackageToModule\",\n+        constants$1.JIMAGE_PackageToModule$FUNC, false\n+    );\n+    static final FunctionDescriptor JImagePackageToModule_t$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JImagePackageToModule_t$MH = RuntimeHelper.downcallHandle(\n+        constants$1.JImagePackageToModule_t$FUNC, false\n+    );\n+    static final FunctionDescriptor JIMAGE_FindResource$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JIMAGE_FindResource$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_FindResource\",\n+        constants$1.JIMAGE_FindResource$FUNC, false\n+    );\n+    static final FunctionDescriptor JImageFindResource_t$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JImageFindResource_t$MH = RuntimeHelper.downcallHandle(\n+        constants$1.JImageFindResource_t$FUNC, false\n+    );\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/constants$1.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$2 {\n+\n+    static final FunctionDescriptor JIMAGE_GetResource$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS,\n+        JAVA_LONG,\n+        ADDRESS,\n+        JAVA_LONG\n+    );\n+    static final MethodHandle JIMAGE_GetResource$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_GetResource\",\n+        constants$2.JIMAGE_GetResource$FUNC, false\n+    );\n+    static final FunctionDescriptor JImageGetResource_t$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS,\n+        JAVA_LONG,\n+        ADDRESS,\n+        JAVA_LONG\n+    );\n+    static final MethodHandle JImageGetResource_t$MH = RuntimeHelper.downcallHandle(\n+        constants$2.JImageGetResource_t$FUNC, false\n+    );\n+    static final FunctionDescriptor JImageResourceVisitor_t$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JImageResourceVisitor_t$MH = RuntimeHelper.downcallHandle(\n+        constants$2.JImageResourceVisitor_t$FUNC, false\n+    );\n+    static final FunctionDescriptor JIMAGE_ResourceIterator$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JIMAGE_ResourceIterator$MH = RuntimeHelper.downcallHandle(\n+        \"JIMAGE_ResourceIterator\",\n+        constants$2.JIMAGE_ResourceIterator$FUNC, false\n+    );\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/constants$2.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$3 {\n+\n+    static final FunctionDescriptor JImageResourceIterator_t$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle JImageResourceIterator_t$MH = RuntimeHelper.downcallHandle(\n+        constants$3.JImageResourceIterator_t$FUNC, false\n+    );\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/constants$3.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/ Generated by jextract\n+\n+package org.openjdk;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class jimage_h  {\n+\n+    \/* package-private *\/ jimage_h() {}\n+    public static ValueLayout.OfByte C_CHAR = JAVA_BYTE;\n+    public static ValueLayout.OfShort C_SHORT = JAVA_SHORT;\n+    public static ValueLayout.OfInt C_INT = JAVA_INT;\n+    public static ValueLayout.OfLong C_LONG = JAVA_LONG;\n+    public static ValueLayout.OfLong C_LONG_LONG = JAVA_LONG;\n+    public static ValueLayout.OfFloat C_FLOAT = JAVA_FLOAT;\n+    public static ValueLayout.OfDouble C_DOUBLE = JAVA_DOUBLE;\n+    public static ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+    public static int JIMAGE_MAX_PATH() {\n+        return (int)4096L;\n+    }\n+    public static ValueLayout.OfLong jlong = JAVA_LONG;\n+    public static ValueLayout.OfInt jint = JAVA_INT;\n+    public static ValueLayout.OfLong JImageLocationRef = JAVA_LONG;\n+    public static MethodHandle JIMAGE_Open$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.JIMAGE_Open$MH,\"JIMAGE_Open\");\n+    }\n+    public static MemoryAddress JIMAGE_Open ( Addressable name,  Addressable error) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.JIMAGE_Open$MH, \"JIMAGE_Open\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(name, error);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle JIMAGE_Close$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.JIMAGE_Close$MH,\"JIMAGE_Close\");\n+    }\n+    public static void JIMAGE_Close ( Addressable jimage) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.JIMAGE_Close$MH, \"JIMAGE_Close\");\n+        try {\n+            mh$.invokeExact(jimage);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle JIMAGE_PackageToModule$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.JIMAGE_PackageToModule$MH,\"JIMAGE_PackageToModule\");\n+    }\n+    public static MemoryAddress JIMAGE_PackageToModule ( Addressable jimage,  Addressable package_name) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.JIMAGE_PackageToModule$MH, \"JIMAGE_PackageToModule\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(jimage, package_name);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle JIMAGE_FindResource$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.JIMAGE_FindResource$MH,\"JIMAGE_FindResource\");\n+    }\n+    public static long JIMAGE_FindResource ( Addressable jimage,  Addressable module_name,  Addressable version,  Addressable name,  Addressable size) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.JIMAGE_FindResource$MH, \"JIMAGE_FindResource\");\n+        try {\n+            return (long)mh$.invokeExact(jimage, module_name, version, name, size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle JIMAGE_GetResource$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.JIMAGE_GetResource$MH,\"JIMAGE_GetResource\");\n+    }\n+    public static long JIMAGE_GetResource ( Addressable jimage,  long location,  Addressable buffer,  long size) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.JIMAGE_GetResource$MH, \"JIMAGE_GetResource\");\n+        try {\n+            return (long)mh$.invokeExact(jimage, location, buffer, size);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle JIMAGE_ResourceIterator$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.JIMAGE_ResourceIterator$MH,\"JIMAGE_ResourceIterator\");\n+    }\n+    public static void JIMAGE_ResourceIterator ( Addressable jimage,  Addressable visitor,  Addressable arg) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.JIMAGE_ResourceIterator$MH, \"JIMAGE_ResourceIterator\");\n+        try {\n+            mh$.invokeExact(jimage, visitor, arg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int JIMAGE_NOT_FOUND() {\n+        return (int)0L;\n+    }\n+    public static int JIMAGE_BAD_MAGIC() {\n+        return (int)-1L;\n+    }\n+    public static int JIMAGE_BAD_VERSION() {\n+        return (int)-2L;\n+    }\n+    public static int JIMAGE_CORRUPTED() {\n+        return (int)-3L;\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/openjdk\/jimage_h.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class Dl_info$0 extends dl_info {\n+\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/Dl_info$0.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+package org.unix;\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+\n+final class RuntimeHelper {\n+\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+    private final static SymbolLookup SYMBOL_LOOKUP;\n+\n+    final static SegmentAllocator CONSTANT_ALLOCATOR =\n+            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n+    static {\n+\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n+        return SYMBOL_LOOKUP.lookup(name).map(\n+                addr -> {\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        return LINKER.downcallHandle(fdesc);\n+    }\n+\n+    static final <Z> NativeSymbol upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final NativeSymbol symbol;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(NativeSymbol symbol, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(NativeSymbol symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return JAVA_LONG;\n+            } else if (c == double.class) {\n+                return JAVA_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return ADDRESS;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"samples\/libjimage\/org\/unix\/RuntimeHelper.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$0 {\n+\n+    static final FunctionDescriptor dladdr$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle dladdr$MH = RuntimeHelper.downcallHandle(\n+        \"dladdr\",\n+        constants$0.dladdr$FUNC, false\n+    );\n+    static final FunctionDescriptor dlclose$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle dlclose$MH = RuntimeHelper.downcallHandle(\n+        \"dlclose\",\n+        constants$0.dlclose$FUNC, false\n+    );\n+    static final FunctionDescriptor dlerror$FUNC = FunctionDescriptor.of(ADDRESS);\n+    static final MethodHandle dlerror$MH = RuntimeHelper.downcallHandle(\n+        \"dlerror\",\n+        constants$0.dlerror$FUNC, false\n+    );\n+    static final FunctionDescriptor dlopen$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle dlopen$MH = RuntimeHelper.downcallHandle(\n+        \"dlopen\",\n+        constants$0.dlopen$FUNC, false\n+    );\n+    static final FunctionDescriptor dlsym$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle dlsym$MH = RuntimeHelper.downcallHandle(\n+        \"dlsym\",\n+        constants$0.dlsym$FUNC, false\n+    );\n+    static final FunctionDescriptor dlopen_preflight$FUNC = FunctionDescriptor.of(JAVA_BOOLEAN,\n+        ADDRESS\n+    );\n+    static final MethodHandle dlopen_preflight$MH = RuntimeHelper.downcallHandle(\n+        \"dlopen_preflight\",\n+        constants$0.dlopen_preflight$FUNC, false\n+    );\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/constants$0.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$1 {\n+\n+    static final MemorySegment __DARWIN_SUF_64_BIT_INO_T$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\"$INODE64\");\n+    static final MemorySegment __DARWIN_SUF_1050$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\"$1050\");\n+    static final MemorySegment __DARWIN_SUF_EXTSN$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\"$DARWIN_EXTSN\");\n+    static final MemoryAddress RTLD_NEXT$ADDR = MemoryAddress.ofLong(-1L);\n+    static final MemoryAddress RTLD_DEFAULT$ADDR = MemoryAddress.ofLong(-2L);\n+    static final MemoryAddress RTLD_SELF$ADDR = MemoryAddress.ofLong(-3L);\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/constants$1.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$2 {\n+\n+    static final MemoryAddress RTLD_MAIN_ONLY$ADDR = MemoryAddress.ofLong(-5L);\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/constants$2.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class dl_info {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        ADDRESS.withName(\"dli_fname\"),\n+        ADDRESS.withName(\"dli_fbase\"),\n+        ADDRESS.withName(\"dli_sname\"),\n+        ADDRESS.withName(\"dli_saddr\")\n+    ).withName(\"dl_info\");\n+    public static MemoryLayout $LAYOUT() {\n+        return dl_info.$struct$LAYOUT;\n+    }\n+    static final VarHandle dli_fname$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"dli_fname\"));\n+    public static VarHandle dli_fname$VH() {\n+        return dl_info.dli_fname$VH;\n+    }\n+    public static MemoryAddress dli_fname$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_fname$VH.get(seg);\n+    }\n+    public static void dli_fname$set( MemorySegment seg, MemoryAddress x) {\n+        dl_info.dli_fname$VH.set(seg, x);\n+    }\n+    public static MemoryAddress dli_fname$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_fname$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void dli_fname$set(MemorySegment seg, long index, MemoryAddress x) {\n+        dl_info.dli_fname$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle dli_fbase$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"dli_fbase\"));\n+    public static VarHandle dli_fbase$VH() {\n+        return dl_info.dli_fbase$VH;\n+    }\n+    public static MemoryAddress dli_fbase$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_fbase$VH.get(seg);\n+    }\n+    public static void dli_fbase$set( MemorySegment seg, MemoryAddress x) {\n+        dl_info.dli_fbase$VH.set(seg, x);\n+    }\n+    public static MemoryAddress dli_fbase$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_fbase$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void dli_fbase$set(MemorySegment seg, long index, MemoryAddress x) {\n+        dl_info.dli_fbase$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle dli_sname$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"dli_sname\"));\n+    public static VarHandle dli_sname$VH() {\n+        return dl_info.dli_sname$VH;\n+    }\n+    public static MemoryAddress dli_sname$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_sname$VH.get(seg);\n+    }\n+    public static void dli_sname$set( MemorySegment seg, MemoryAddress x) {\n+        dl_info.dli_sname$VH.set(seg, x);\n+    }\n+    public static MemoryAddress dli_sname$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_sname$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void dli_sname$set(MemorySegment seg, long index, MemoryAddress x) {\n+        dl_info.dli_sname$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle dli_saddr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"dli_saddr\"));\n+    public static VarHandle dli_saddr$VH() {\n+        return dl_info.dli_saddr$VH;\n+    }\n+    public static MemoryAddress dli_saddr$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_saddr$VH.get(seg);\n+    }\n+    public static void dli_saddr$set( MemorySegment seg, MemoryAddress x) {\n+        dl_info.dli_saddr$VH.set(seg, x);\n+    }\n+    public static MemoryAddress dli_saddr$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)dl_info.dli_saddr$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void dli_saddr$set(MemorySegment seg, long index, MemoryAddress x) {\n+        dl_info.dli_saddr$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/dl_info.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,701 @@\n+\/\/ Generated by jextract\n+\n+package org.unix;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class dlfcn_h  {\n+\n+    \/* package-private *\/ dlfcn_h() {}\n+    public static ValueLayout.OfByte C_CHAR = JAVA_BYTE;\n+    public static ValueLayout.OfShort C_SHORT = JAVA_SHORT;\n+    public static ValueLayout.OfInt C_INT = JAVA_INT;\n+    public static ValueLayout.OfLong C_LONG = JAVA_LONG;\n+    public static ValueLayout.OfLong C_LONG_LONG = JAVA_LONG;\n+    public static ValueLayout.OfFloat C_FLOAT = JAVA_FLOAT;\n+    public static ValueLayout.OfDouble C_DOUBLE = JAVA_DOUBLE;\n+    public static ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+    public static int __DARWIN_ONLY_64_BIT_INO_T() {\n+        return (int)0L;\n+    }\n+    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {\n+        return (int)1L;\n+    }\n+    public static int __DARWIN_ONLY_VERS_1050() {\n+        return (int)0L;\n+    }\n+    public static int __DARWIN_UNIX03() {\n+        return (int)1L;\n+    }\n+    public static int __DARWIN_64_BIT_INO_T() {\n+        return (int)1L;\n+    }\n+    public static int __DARWIN_VERS_1050() {\n+        return (int)1L;\n+    }\n+    public static int __DARWIN_NON_CANCELABLE() {\n+        return (int)0L;\n+    }\n+    public static int __STDC_WANT_LIB_EXT1__() {\n+        return (int)1L;\n+    }\n+    public static int __DARWIN_NO_LONG_LONG() {\n+        return (int)0L;\n+    }\n+    public static int _DARWIN_FEATURE_64_BIT_INODE() {\n+        return (int)1L;\n+    }\n+    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {\n+        return (int)1L;\n+    }\n+    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {\n+        return (int)3L;\n+    }\n+    public static int true_() {\n+        return (int)1L;\n+    }\n+    public static int false_() {\n+        return (int)0L;\n+    }\n+    public static int __bool_true_false_are_defined() {\n+        return (int)1L;\n+    }\n+    public static int __API_TO_BE_DEPRECATED() {\n+        return (int)100000L;\n+    }\n+    public static int __MAC_10_0() {\n+        return (int)1000L;\n+    }\n+    public static int __MAC_10_1() {\n+        return (int)1010L;\n+    }\n+    public static int __MAC_10_2() {\n+        return (int)1020L;\n+    }\n+    public static int __MAC_10_3() {\n+        return (int)1030L;\n+    }\n+    public static int __MAC_10_4() {\n+        return (int)1040L;\n+    }\n+    public static int __MAC_10_5() {\n+        return (int)1050L;\n+    }\n+    public static int __MAC_10_6() {\n+        return (int)1060L;\n+    }\n+    public static int __MAC_10_7() {\n+        return (int)1070L;\n+    }\n+    public static int __MAC_10_8() {\n+        return (int)1080L;\n+    }\n+    public static int __MAC_10_9() {\n+        return (int)1090L;\n+    }\n+    public static int __MAC_10_10() {\n+        return (int)101000L;\n+    }\n+    public static int __MAC_10_10_2() {\n+        return (int)101002L;\n+    }\n+    public static int __MAC_10_10_3() {\n+        return (int)101003L;\n+    }\n+    public static int __MAC_10_11() {\n+        return (int)101100L;\n+    }\n+    public static int __MAC_10_11_2() {\n+        return (int)101102L;\n+    }\n+    public static int __MAC_10_11_3() {\n+        return (int)101103L;\n+    }\n+    public static int __MAC_10_11_4() {\n+        return (int)101104L;\n+    }\n+    public static int __MAC_10_12() {\n+        return (int)101200L;\n+    }\n+    public static int __MAC_10_12_1() {\n+        return (int)101201L;\n+    }\n+    public static int __MAC_10_12_2() {\n+        return (int)101202L;\n+    }\n+    public static int __MAC_10_12_4() {\n+        return (int)101204L;\n+    }\n+    public static int __MAC_10_13() {\n+        return (int)101300L;\n+    }\n+    public static int __MAC_10_13_1() {\n+        return (int)101301L;\n+    }\n+    public static int __MAC_10_13_2() {\n+        return (int)101302L;\n+    }\n+    public static int __MAC_10_13_4() {\n+        return (int)101304L;\n+    }\n+    public static int __MAC_10_14() {\n+        return (int)101400L;\n+    }\n+    public static int __MAC_10_14_1() {\n+        return (int)101401L;\n+    }\n+    public static int __MAC_10_14_4() {\n+        return (int)101404L;\n+    }\n+    public static int __MAC_10_14_6() {\n+        return (int)101406L;\n+    }\n+    public static int __MAC_10_15() {\n+        return (int)101500L;\n+    }\n+    public static int __MAC_10_15_1() {\n+        return (int)101501L;\n+    }\n+    public static int __MAC_10_15_4() {\n+        return (int)101504L;\n+    }\n+    public static int __MAC_10_16() {\n+        return (int)101600L;\n+    }\n+    public static int __MAC_11_0() {\n+        return (int)110000L;\n+    }\n+    public static int __MAC_11_1() {\n+        return (int)110100L;\n+    }\n+    public static int __IPHONE_2_0() {\n+        return (int)20000L;\n+    }\n+    public static int __IPHONE_2_1() {\n+        return (int)20100L;\n+    }\n+    public static int __IPHONE_2_2() {\n+        return (int)20200L;\n+    }\n+    public static int __IPHONE_3_0() {\n+        return (int)30000L;\n+    }\n+    public static int __IPHONE_3_1() {\n+        return (int)30100L;\n+    }\n+    public static int __IPHONE_3_2() {\n+        return (int)30200L;\n+    }\n+    public static int __IPHONE_4_0() {\n+        return (int)40000L;\n+    }\n+    public static int __IPHONE_4_1() {\n+        return (int)40100L;\n+    }\n+    public static int __IPHONE_4_2() {\n+        return (int)40200L;\n+    }\n+    public static int __IPHONE_4_3() {\n+        return (int)40300L;\n+    }\n+    public static int __IPHONE_5_0() {\n+        return (int)50000L;\n+    }\n+    public static int __IPHONE_5_1() {\n+        return (int)50100L;\n+    }\n+    public static int __IPHONE_6_0() {\n+        return (int)60000L;\n+    }\n+    public static int __IPHONE_6_1() {\n+        return (int)60100L;\n+    }\n+    public static int __IPHONE_7_0() {\n+        return (int)70000L;\n+    }\n+    public static int __IPHONE_7_1() {\n+        return (int)70100L;\n+    }\n+    public static int __IPHONE_8_0() {\n+        return (int)80000L;\n+    }\n+    public static int __IPHONE_8_1() {\n+        return (int)80100L;\n+    }\n+    public static int __IPHONE_8_2() {\n+        return (int)80200L;\n+    }\n+    public static int __IPHONE_8_3() {\n+        return (int)80300L;\n+    }\n+    public static int __IPHONE_8_4() {\n+        return (int)80400L;\n+    }\n+    public static int __IPHONE_9_0() {\n+        return (int)90000L;\n+    }\n+    public static int __IPHONE_9_1() {\n+        return (int)90100L;\n+    }\n+    public static int __IPHONE_9_2() {\n+        return (int)90200L;\n+    }\n+    public static int __IPHONE_9_3() {\n+        return (int)90300L;\n+    }\n+    public static int __IPHONE_10_0() {\n+        return (int)100000L;\n+    }\n+    public static int __IPHONE_10_1() {\n+        return (int)100100L;\n+    }\n+    public static int __IPHONE_10_2() {\n+        return (int)100200L;\n+    }\n+    public static int __IPHONE_10_3() {\n+        return (int)100300L;\n+    }\n+    public static int __IPHONE_11_0() {\n+        return (int)110000L;\n+    }\n+    public static int __IPHONE_11_1() {\n+        return (int)110100L;\n+    }\n+    public static int __IPHONE_11_2() {\n+        return (int)110200L;\n+    }\n+    public static int __IPHONE_11_3() {\n+        return (int)110300L;\n+    }\n+    public static int __IPHONE_11_4() {\n+        return (int)110400L;\n+    }\n+    public static int __IPHONE_12_0() {\n+        return (int)120000L;\n+    }\n+    public static int __IPHONE_12_1() {\n+        return (int)120100L;\n+    }\n+    public static int __IPHONE_12_2() {\n+        return (int)120200L;\n+    }\n+    public static int __IPHONE_12_3() {\n+        return (int)120300L;\n+    }\n+    public static int __IPHONE_12_4() {\n+        return (int)120400L;\n+    }\n+    public static int __IPHONE_13_0() {\n+        return (int)130000L;\n+    }\n+    public static int __IPHONE_13_1() {\n+        return (int)130100L;\n+    }\n+    public static int __IPHONE_13_2() {\n+        return (int)130200L;\n+    }\n+    public static int __IPHONE_13_3() {\n+        return (int)130300L;\n+    }\n+    public static int __IPHONE_13_4() {\n+        return (int)130400L;\n+    }\n+    public static int __IPHONE_13_5() {\n+        return (int)130500L;\n+    }\n+    public static int __IPHONE_13_6() {\n+        return (int)130600L;\n+    }\n+    public static int __IPHONE_13_7() {\n+        return (int)130700L;\n+    }\n+    public static int __IPHONE_14_0() {\n+        return (int)140000L;\n+    }\n+    public static int __IPHONE_14_1() {\n+        return (int)140100L;\n+    }\n+    public static int __IPHONE_14_2() {\n+        return (int)140200L;\n+    }\n+    public static int __IPHONE_14_3() {\n+        return (int)140300L;\n+    }\n+    public static int __TVOS_9_0() {\n+        return (int)90000L;\n+    }\n+    public static int __TVOS_9_1() {\n+        return (int)90100L;\n+    }\n+    public static int __TVOS_9_2() {\n+        return (int)90200L;\n+    }\n+    public static int __TVOS_10_0() {\n+        return (int)100000L;\n+    }\n+    public static int __TVOS_10_0_1() {\n+        return (int)100001L;\n+    }\n+    public static int __TVOS_10_1() {\n+        return (int)100100L;\n+    }\n+    public static int __TVOS_10_2() {\n+        return (int)100200L;\n+    }\n+    public static int __TVOS_11_0() {\n+        return (int)110000L;\n+    }\n+    public static int __TVOS_11_1() {\n+        return (int)110100L;\n+    }\n+    public static int __TVOS_11_2() {\n+        return (int)110200L;\n+    }\n+    public static int __TVOS_11_3() {\n+        return (int)110300L;\n+    }\n+    public static int __TVOS_11_4() {\n+        return (int)110400L;\n+    }\n+    public static int __TVOS_12_0() {\n+        return (int)120000L;\n+    }\n+    public static int __TVOS_12_1() {\n+        return (int)120100L;\n+    }\n+    public static int __TVOS_12_2() {\n+        return (int)120200L;\n+    }\n+    public static int __TVOS_12_3() {\n+        return (int)120300L;\n+    }\n+    public static int __TVOS_12_4() {\n+        return (int)120400L;\n+    }\n+    public static int __TVOS_13_0() {\n+        return (int)130000L;\n+    }\n+    public static int __TVOS_13_2() {\n+        return (int)130200L;\n+    }\n+    public static int __TVOS_13_3() {\n+        return (int)130300L;\n+    }\n+    public static int __TVOS_13_4() {\n+        return (int)130400L;\n+    }\n+    public static int __TVOS_14_0() {\n+        return (int)140000L;\n+    }\n+    public static int __TVOS_14_1() {\n+        return (int)140100L;\n+    }\n+    public static int __TVOS_14_2() {\n+        return (int)140200L;\n+    }\n+    public static int __TVOS_14_3() {\n+        return (int)140300L;\n+    }\n+    public static int __WATCHOS_1_0() {\n+        return (int)10000L;\n+    }\n+    public static int __WATCHOS_2_0() {\n+        return (int)20000L;\n+    }\n+    public static int __WATCHOS_2_1() {\n+        return (int)20100L;\n+    }\n+    public static int __WATCHOS_2_2() {\n+        return (int)20200L;\n+    }\n+    public static int __WATCHOS_3_0() {\n+        return (int)30000L;\n+    }\n+    public static int __WATCHOS_3_1() {\n+        return (int)30100L;\n+    }\n+    public static int __WATCHOS_3_1_1() {\n+        return (int)30101L;\n+    }\n+    public static int __WATCHOS_3_2() {\n+        return (int)30200L;\n+    }\n+    public static int __WATCHOS_4_0() {\n+        return (int)40000L;\n+    }\n+    public static int __WATCHOS_4_1() {\n+        return (int)40100L;\n+    }\n+    public static int __WATCHOS_4_2() {\n+        return (int)40200L;\n+    }\n+    public static int __WATCHOS_4_3() {\n+        return (int)40300L;\n+    }\n+    public static int __WATCHOS_5_0() {\n+        return (int)50000L;\n+    }\n+    public static int __WATCHOS_5_1() {\n+        return (int)50100L;\n+    }\n+    public static int __WATCHOS_5_2() {\n+        return (int)50200L;\n+    }\n+    public static int __WATCHOS_5_3() {\n+        return (int)50300L;\n+    }\n+    public static int __WATCHOS_6_0() {\n+        return (int)60000L;\n+    }\n+    public static int __WATCHOS_6_1() {\n+        return (int)60100L;\n+    }\n+    public static int __WATCHOS_6_2() {\n+        return (int)60200L;\n+    }\n+    public static int __WATCHOS_7_0() {\n+        return (int)70000L;\n+    }\n+    public static int __WATCHOS_7_1() {\n+        return (int)70100L;\n+    }\n+    public static int __WATCHOS_7_2() {\n+        return (int)70200L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_0() {\n+        return (int)1000L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_1() {\n+        return (int)1010L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_2() {\n+        return (int)1020L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_3() {\n+        return (int)1030L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_4() {\n+        return (int)1040L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_5() {\n+        return (int)1050L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_6() {\n+        return (int)1060L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_7() {\n+        return (int)1070L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_8() {\n+        return (int)1080L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_9() {\n+        return (int)1090L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_10() {\n+        return (int)101000L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_10_2() {\n+        return (int)101002L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_10_3() {\n+        return (int)101003L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_11() {\n+        return (int)101100L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_11_2() {\n+        return (int)101102L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_11_3() {\n+        return (int)101103L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_11_4() {\n+        return (int)101104L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_12() {\n+        return (int)101200L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_12_1() {\n+        return (int)101201L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_12_2() {\n+        return (int)101202L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_12_4() {\n+        return (int)101204L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_13() {\n+        return (int)101300L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_13_1() {\n+        return (int)101301L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_13_2() {\n+        return (int)101302L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_13_4() {\n+        return (int)101304L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_14() {\n+        return (int)101400L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_14_1() {\n+        return (int)101401L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_14_4() {\n+        return (int)101404L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_14_6() {\n+        return (int)101406L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_15() {\n+        return (int)101500L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_15_1() {\n+        return (int)101501L;\n+    }\n+    public static int MAC_OS_X_VERSION_10_16() {\n+        return (int)101600L;\n+    }\n+    public static int MAC_OS_VERSION_11_0() {\n+        return (int)110000L;\n+    }\n+    public static int __DRIVERKIT_19_0() {\n+        return (int)190000L;\n+    }\n+    public static int __DRIVERKIT_20_0() {\n+        return (int)200000L;\n+    }\n+    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {\n+        return (int)1L;\n+    }\n+    public static int RTLD_LAZY() {\n+        return (int)1L;\n+    }\n+    public static int RTLD_NOW() {\n+        return (int)2L;\n+    }\n+    public static int RTLD_LOCAL() {\n+        return (int)4L;\n+    }\n+    public static int RTLD_GLOBAL() {\n+        return (int)8L;\n+    }\n+    public static int RTLD_NOLOAD() {\n+        return (int)16L;\n+    }\n+    public static int RTLD_NODELETE() {\n+        return (int)128L;\n+    }\n+    public static int RTLD_FIRST() {\n+        return (int)256L;\n+    }\n+    public static MethodHandle dladdr$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dladdr$MH,\"dladdr\");\n+    }\n+    public static int dladdr ( Addressable x0,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dladdr$MH, \"dladdr\");\n+        try {\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle dlclose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dlclose$MH,\"dlclose\");\n+    }\n+    public static int dlclose ( Addressable __handle) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dlclose$MH, \"dlclose\");\n+        try {\n+            return (int)mh$.invokeExact(__handle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle dlerror$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dlerror$MH,\"dlerror\");\n+    }\n+    public static MemoryAddress dlerror () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dlerror$MH, \"dlerror\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle dlopen$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dlopen$MH,\"dlopen\");\n+    }\n+    public static MemoryAddress dlopen ( Addressable __path,  int __mode) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dlopen$MH, \"dlopen\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(__path, __mode);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle dlsym$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dlsym$MH,\"dlsym\");\n+    }\n+    public static MemoryAddress dlsym ( Addressable __handle,  Addressable __symbol) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dlsym$MH, \"dlsym\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(__handle, __symbol);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle dlopen_preflight$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.dlopen_preflight$MH,\"dlopen_preflight\");\n+    }\n+    public static byte dlopen_preflight ( Addressable __path) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.dlopen_preflight$MH, \"dlopen_preflight\");\n+        try {\n+            return (byte)mh$.invokeExact(__path);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment __DARWIN_SUF_64_BIT_INO_T() {\n+        return constants$1.__DARWIN_SUF_64_BIT_INO_T$SEGMENT;\n+    }\n+    public static MemorySegment __DARWIN_SUF_1050() {\n+        return constants$1.__DARWIN_SUF_1050$SEGMENT;\n+    }\n+    public static MemorySegment __DARWIN_SUF_EXTSN() {\n+        return constants$1.__DARWIN_SUF_EXTSN$SEGMENT;\n+    }\n+    public static long __DARWIN_C_ANSI() {\n+        return 4096L;\n+    }\n+    public static long __DARWIN_C_FULL() {\n+        return 900000L;\n+    }\n+    public static long __DARWIN_C_LEVEL() {\n+        return 900000L;\n+    }\n+    public static int __MAC_OS_X_VERSION_MIN_REQUIRED() {\n+        return (int)101500L;\n+    }\n+    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {\n+        return (int)110100L;\n+    }\n+    public static MemoryAddress RTLD_NEXT() {\n+        return constants$1.RTLD_NEXT$ADDR;\n+    }\n+    public static MemoryAddress RTLD_DEFAULT() {\n+        return constants$1.RTLD_DEFAULT$ADDR;\n+    }\n+    public static MemoryAddress RTLD_SELF() {\n+        return constants$1.RTLD_SELF$ADDR;\n+    }\n+    public static MemoryAddress RTLD_MAIN_ONLY() {\n+        return constants$2.RTLD_MAIN_ONLY$ADDR;\n+    }\n+}\n+\n+\n","filename":"samples\/libjimage\/org\/unix\/dlfcn_h.java","additions":701,"deletions":0,"binary":false,"changes":701,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+java -cp build \\\n+   --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   JImageFile.java\n","filename":"samples\/libjimage\/run.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.unix.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.unix.libproc_h.*;\n+\n+public class LibprocMain {\n+    private static final int NAME_BUF_MAX = 256;\n+\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            \/\/ get the number of processes\n+            int numPids = proc_listallpids(NULL, 0);\n+            \/\/ allocate an array\n+            var pids = allocator.allocateArray(C_INT, numPids);\n+            \/\/ list all the pids into the native array\n+            proc_listallpids(pids, numPids);\n+            \/\/ convert native array to java array\n+            int[] jpids = pids.toArray(C_INT);\n+            \/\/ buffer for process name\n+            var nameBuf = allocator.allocateArray(C_CHAR, NAME_BUF_MAX);\n+            for (int i = 0; i < jpids.length; i++) {\n+                int pid = jpids[i];\n+                \/\/ get the process name\n+                proc_name(pid, nameBuf, NAME_BUF_MAX);\n+                String procName = nameBuf.getUtf8String(0);\n+                \/\/ print pid and process name\n+                System.out.printf(\"%d %s\\n\", pid, procName);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"samples\/libproc\/LibprocMain.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+jextract -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n","filename":"samples\/libproc\/compile.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract --source -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n+\n+javac --add-modules jdk.incubator.foreign org\/unix\/*.java\n","filename":"samples\/libproc\/compilesource.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   -Djava.library.path=\/usr\/lib LibprocMain.java\n","filename":"samples\/libproc\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+## Notes on Windows\n+\n+This sample requires freeglut as a dependency. On Windows the freeglut package that comes with MinGW is know not to work,\n+because clang (which jextract uses under the hood) doesn't seem to understand MinGW builtins found in the MinGW standard library header files.\n+\n+The sample has been tested against the freeglut MSVC package found here: https:\/\/www.transmissionzero.co.uk\/software\/freeglut-devel\/\n+\n+On top of that, the code in Teapot.java has to be changed to account for different parameter names in the Windows freeglut headers:\n+\n+```\n+diff --git a\/opengl\/Teapot.java b\/opengl\/Teapot.java\n+index 22d1f44..d5eb786 100644\n+--- a\/opengl\/Teapot.java\n++++ b\/opengl\/Teapot.java\n+@@ -79,8 +79,8 @@ public class Teapot {\n+             glutInitWindowSize(500, 500);\n+             glutCreateWindow(allocator.allocateUtf8String(\"Hello Panama!\"));\n+             var teapot = new Teapot(allocator);\n+-            var displayStub = glutDisplayFunc$func.allocate(teapot::display, scope);\n+-            var idleStub = glutIdleFunc$func.allocate(teapot::onIdle, scope);\n++            var displayStub = glutDisplayFunc$callback.allocate(teapot::display, scope);\n++            var idleStub = glutIdleFunc$callback.allocate(teapot::onIdle, scope);\n+             glutDisplayFunc(displayStub);\n+             glutIdleFunc(idleStub);\n+             glutMainLoop();\n+```\n","filename":"samples\/opengl\/README.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import opengl.*;\n+import static opengl.glut_h.*;\n+\n+public class Teapot {\n+    private float rot = 0;\n+\n+    Teapot(SegmentAllocator allocator) {\n+        \/\/ Reset Background\n+        glClearColor(0f, 0f, 0f, 0f);\n+        \/\/ Setup Lighting\n+        glShadeModel(GL_SMOOTH());\n+        var pos = allocator.allocateArray(C_FLOAT, new float[] {0.0f, 15.0f, -15.0f, 0});\n+        glLightfv(GL_LIGHT0(), GL_POSITION(), pos);\n+        var spec = allocator.allocateArray(C_FLOAT, new float[] {1, 1, 1, 0});\n+        glLightfv(GL_LIGHT0(), GL_AMBIENT(), spec);\n+        glLightfv(GL_LIGHT0(), GL_DIFFUSE(), spec);\n+        glLightfv(GL_LIGHT0(), GL_SPECULAR(), spec);\n+        var shini = allocator.allocate(C_FLOAT, 113);\n+        glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n+        glEnable(GL_LIGHTING());\n+        glEnable(GL_LIGHT0());\n+        glEnable(GL_DEPTH_TEST());\n+    }\n+\n+    void display() {\n+        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+        glPushMatrix();\n+        glRotatef(-20f, 1f, 1f, 0f);\n+        glRotatef(rot, 0f, 1f, 0f);\n+        glutSolidTeapot(0.5d);\n+        glPopMatrix();\n+        glutSwapBuffers();\n+    }\n+\n+    void onIdle() {\n+        rot += 0.1;\n+        glutPostRedisplay();\n+    }\n+\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var argc = allocator.allocate(C_INT, 0);\n+            glutInit(argc, argc);\n+            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n+            glutInitWindowSize(500, 500);\n+            glutCreateWindow(allocator.allocateUtf8String(\"Hello Panama!\"));\n+            var teapot = new Teapot(allocator);\n+            var displayStub = glutDisplayFunc$func.allocate(teapot::display, scope);\n+            var idleStub = glutIdleFunc$func.allocate(teapot::onIdle, scope);\n+            glutDisplayFunc(displayStub);\n+            glutIdleFunc(idleStub);\n+            glutMainLoop();\n+        }\n+    }\n+}\n","filename":"samples\/opengl\/Teapot.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+jextract -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n","filename":"samples\/opengl\/compile.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the freeglut installation\")]\r\n+  [string]$freeglutPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -I \"$freeglutPath\\include\" `\r\n+  \"-l\" opengl32 `\r\n+  \"-l\" glu32 `\r\n+  \"-l\" freeglut `\r\n+  \"-t\" \"opengl\" `\r\n+  \"--\" `\r\n+  \"$freeglutPath\\include\\GL\\glut.h\"\r\n","filename":"samples\/opengl\/compile_windows.ps1","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract --source -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n+\n+javac --add-modules jdk.incubator.foreign opengl\/*.java\n","filename":"samples\/opengl\/compilesource.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+java -XstartOnFirstThread --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=.:\/System\/Library\/Frameworks\/OpenGL.framework\/Versions\/Current\/Libraries\/ Teapot.java $*\n","filename":"samples\/opengl\/run.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the freeglut installation\")]\r\n+  [string]$freeglutPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=C:\\Windows\\System32`;$freeglutPath\\bin\\x64\" `\r\n+  Teapot.java\r\n","filename":"samples\/opengl\/run_windows.ps1","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+\/\/ import jextracted python 'header' class\n+import static org.python.Python_h.*;\n+import org.python.*;\n+\n+public class PythonMain {\n+    public static void main(String[] args) {\n+        String script = \"print(sum([33, 55, 66])); print('Hello from Python!')\\n\";\n+\n+        Py_Initialize();\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            var str = allocator.allocateUtf8String(script);\n+            PyRun_SimpleStringFlags(str, NULL);\n+            Py_Finalize();\n+        }\n+    }\n+}\n","filename":"samples\/python3\/PythonMain.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+I've installed anaconda3 under \/opt\/anaconda3\n+\n+You may have to fix shell scripts to your anaconda3 installation directory.\n+\n+Windows scripts under ..\/python handle 3.x versions (passed as parameter)\n","filename":"samples\/python3\/README","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+ANACONDA3_HOME=\/opt\/anaconda3\n+\n+jextract -l python3.8 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n+  -t org.python \\\n+  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n","filename":"samples\/python3\/compile.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+ANACONDA3_HOME=\/opt\/anaconda3\n+\n+jextract --source -l python3.8 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I ${ANACONDA3_HOME}\/include\/python3.8 \\\n+  -t org.python \\\n+  ${ANACONDA3_HOME}\/include\/python3.8\/Python.h\n+\n+javac --add-modules jdk.incubator.foreign org\/python\/*.java\n","filename":"samples\/python3\/compilesource.sh","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+ANACONDA3_HOME=\/opt\/anaconda3\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=${ANACONDA3_HOME}\/lib \\\n+    PythonMain.java\n","filename":"samples\/python3\/run.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static org.unix.readline_h.*;\n+import org.unix.*;\n+\n+public class Readline {\n+    public static void main(String[] args) {\n+       try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            var url = allocator.allocateUtf8String(\"name? \");\n+\n+            \/\/ call \"readline\" API\n+            var p = readline(url);\n+\n+            \/\/ print char* as is\n+            System.out.println(p);\n+            \/\/ convert char* ptr from readline as Java String & print it\n+            System.out.println(\"Hello, \" + p.getUtf8String(0));\n+\n+            \/\/ pointer returned by readline has to be 'free'd\n+            free(p);\n+        }\n+    }\n+}\n+\n","filename":"samples\/readline\/Readline.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract -l readline -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  --header-class-name readline_h \\\n+  --include-function readline \\\n+  --include-function free \\\n+  myreadline.h\n","filename":"samples\/readline\/compile.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+jextract --source -l readline -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  --header-class-name readline_h \\\n+  --include-function readline \\\n+  --include-function free \\\n+  myreadline.h\n+\n+javac --add-modules jdk.incubator.foreign org\/unix\/*.java\n","filename":"samples\/readline\/compilesource.sh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+#include <stdlib.h>\n+#include <readline\/readline.h>\n","filename":"samples\/readline\/myreadline.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n+\n","filename":"samples\/readline\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+$jdk = $Env:JAVA_HOME\r\n+\r\n+function find-tool($tool) {\r\n+  if (Test-Path \"$jdk\\bin\\$tool.exe\") {\r\n+    $func = {\r\n+      & \"$jdk\\bin\\$tool.exe\" $args;\r\n+      if ($LASTEXITCODE -ne 0) {\r\n+        Write-Host \"ERROR: $tool exited with non-zero exit code: $LASTEXITCODE\"\r\n+        exit\r\n+      }\r\n+    }.GetNewClosure()\r\n+    & $func.Module Set-Variable jdk $jdk\r\n+    return $func\r\n+  } else {\r\n+    Write-Host \"ERROR: Could not find $tool executable in %JAVA_HOME%\\bin.\"\r\n+    exit\r\n+  }\r\n+}\r\n+\r\n+function filter_file($includes_all, $pattern, $output_file) {  \r\n+  Select-String -Path $includes_all -Pattern $pattern | %{ $_.Line } | Out-File -FilePath $output_file -Encoding ascii\r\n+}\r\n","filename":"samples\/shared_windows.ps1","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.sqlite.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.sqlite.sqlite3_h.*;\n+\n+public class SqliteMain {\n+   public static void main(String[] args) throws Exception {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            \/\/ char** errMsgPtrPtr;\n+            var errMsgPtrPtr = allocator.allocate(C_POINTER);\n+\n+            \/\/ sqlite3** dbPtrPtr;\n+            var dbPtrPtr = allocator.allocate(C_POINTER);\n+\n+            int rc = sqlite3_open(allocator.allocateUtf8String(\"employee.db\"), dbPtrPtr);\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_open failed: \" + rc);\n+                return;\n+            } else {\n+                System.out.println(\"employee db opened\");\n+            }\n+\n+            \/\/ sqlite3* dbPtr;\n+            var dbPtr = dbPtrPtr.get(C_POINTER, 0);\n+\n+            \/\/ create a new table\n+            var sql = allocator.allocateUtf8String(\n+                \"CREATE TABLE EMPLOYEE (\"  +\n+                \"  ID INT PRIMARY KEY NOT NULL,\" +\n+                \"  NAME TEXT NOT NULL,\"    +\n+                \"  SALARY REAL NOT NULL )\");\n+\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + errMsgPtrPtr.get(C_POINTER, 0).getUtf8String(0));\n+                sqlite3_free(errMsgPtrPtr.get(C_POINTER, 0));\n+            } else {\n+                System.out.println(\"employee table created\");\n+            }\n+\n+            \/\/ insert two rows\n+            sql = allocator.allocateUtf8String(\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (134, 'Xyz', 200000.0); \" +\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (333, 'Abc', 100000.0);\"\n+            );\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + errMsgPtrPtr.get(C_POINTER, 0).getUtf8String(0));\n+                sqlite3_free(errMsgPtrPtr.get(C_POINTER, 0));\n+            } else {\n+                System.out.println(\"rows inserted\");\n+            }\n+\n+            int[] rowNum = new int[1];\n+            \/\/ callback to print rows from SELECT query\n+            var callback = sqlite3_exec$callback.allocate((a, argc, argv, columnNames) -> {\n+                System.out.println(\"Row num: \" + rowNum[0]++);\n+                System.out.println(\"numColumns = \" + argc);\n+                var argv_seg = MemorySegment.ofAddress(argv, C_POINTER.byteSize() * argc, scope);\n+                var columnNames_seg = MemorySegment.ofAddress(columnNames, C_POINTER.byteSize() * argc, scope);\n+                for (int i = 0; i < argc; i++) {\n+                     String name = columnNames_seg.getAtIndex(C_POINTER, i).getUtf8String(0);\n+                     String value = argv_seg.getAtIndex(C_POINTER, i).getUtf8String(0);\n+\n+                     System.out.printf(\"%s = %s\\n\", name, value);\n+                }\n+                return 0;\n+            }, scope);\n+\n+            \/\/ select query\n+            sql = allocator.allocateUtf8String(\"SELECT * FROM EMPLOYEE\");\n+            rc = sqlite3_exec(dbPtr, sql, callback, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + errMsgPtrPtr.get(C_POINTER, 0).getUtf8String(0));\n+                sqlite3_free(errMsgPtrPtr.get(C_POINTER, 0));\n+            } else {\n+                System.out.println(\"done\");\n+            }\n+\n+            sqlite3_close(dbPtr);\n+        }\n+    }\n+}\n+\n","filename":"samples\/sqlite\/SqliteMain.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+jextract \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n+  -t org.sqlite -lsqlite3 \n","filename":"samples\/sqlite\/compile.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract --source \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n+  -t org.sqlite -lsqlite3\n+\n+javac --add-modules jdk.incubator.foreign org\/sqlite\/*.java\n","filename":"samples\/sqlite\/compilesource.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+java --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   -Djava.library.path=\/usr\/lib SqliteMain.java\n+\n","filename":"samples\/sqlite\/run.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+\/\/ import jextracted tcl 'header' class\n+import static org.tcl.tcl_h.*;\n+import org.tcl.*;\n+\n+\/\/ Sample to demonstrate embedding Tcl\/Tk interpreter in Java code\n+\n+public class TCLMain {\n+    public static void main(String[] args) {\n+        var interp = Tcl_CreateInterp();\n+        if (interp.equals(NULL)) {\n+            System.err.println(\"cannot create Tcl interpreter\");\n+            System.exit(1);\n+        }\n+\n+        var script = \"\"\"\n+            puts \"Hello World!\"\n+            set name(first) \"Alan\"\n+            set name(last) \"Turing\"\n+            puts \"Full name: $name(first) $name(last)\"\n+        \"\"\";\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            var str = allocator.allocateUtf8String(script);\n+            Tcl_Eval(interp, str);\n+        }\n+\n+        Tcl_DeleteInterp(interp);\n+    }\n+}\n","filename":"samples\/tcl\/TCLMain.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+jextract -l tcl -t org.tcl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/tcl.h\n","filename":"samples\/tcl\/compile.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract --source -l tcl -t org.tcl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/tcl.h\n+\n+javac --add-modules jdk.incubator.foreign org\/tcl\/*.java\n","filename":"samples\/tcl\/compilesource.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib \\\n+    TCLMain.java\n","filename":"samples\/tcl\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+* Download tensorflow library from\n+\n+    https:\/\/www.tensorflow.org\/install\/lang_c\n+\n+* extract the downloaded tar in a directory called LIBTENSORFLOW_HOME\n+\n+* jextract using compile.sh\n+\n+    sh .\/compile.sh\n+\n+* create and save model using Python program mnist_model.py\n+\n+    python mnist_model.py\n+\n+* print saved model info using Panama program using \n+\n+    sh .\/loadsavedmodel.sh\n","filename":"samples\/tensorflow\/README","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.MemoryAddress.*;\n+import static org.tensorflow.c_api_h.*;\n+import org.tensorflow.*;\n+\n+\/\/ simple program that loads saved model and prints basic info on operations in it\n+\n+public class TensorflowLoadSavedModel {\n+    public static void main(String... args) throws Exception {\n+        System.out.println(\"TensorFlow C library version: \" + TF_Version().getUtf8String(0));\n+\n+        if (args.length == 0) {\n+            System.err.println(\"java TensorflowLoadSavedModel <saved model dir>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var graph = TF_NewGraph();\n+            var status = TF_NewStatus();\n+            var sessionOpts = TF_NewSessionOptions();\n+\n+            var savedModelDir = allocator.allocateUtf8String(args[0]);\n+            var tags = allocator.allocate(C_POINTER, allocator.allocateUtf8String(\"serve\"));\n+            var session = TF_LoadSessionFromSavedModel(sessionOpts, NULL, savedModelDir, tags, 1, graph, NULL, status);\n+\n+            if (TF_GetCode(status) != TF_OK()) {\n+                System.err.printf(\"cannot load session from saved model: %s\\n\",\n+                    TF_Message(status).getUtf8String(0));\n+            } else {\n+                System.err.println(\"load session from saved model works!\");\n+            }\n+\n+            \/\/ print operations\n+            var size = allocator.allocate(C_LONG_LONG);\n+            var operation = NULL;\n+            while (!(operation = TF_GraphNextOperation(graph, size)).equals(NULL)) {\n+                System.out.printf(\"%s : %s\\n\",\n+                    TF_OperationName(operation).getUtf8String(0),\n+                    TF_OperationOpType(operation).getUtf8String(0));\n+            }\n+\n+            TF_DeleteGraph(graph);\n+            TF_DeleteSession(session, status);\n+            TF_DeleteSessionOptions(sessionOpts);\n+            TF_DeleteStatus(status);\n+        }\n+    }\n+}\n","filename":"samples\/tensorflow\/TensorflowLoadSavedModel.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+jextract \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -t org.tensorflow \\\n+  -I ${LIBTENSORFLOW_HOME}\/include \\\n+  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  ${LIBTENSORFLOW_HOME}\/include\/tensorflow\/c\/c_api.h\n","filename":"samples\/tensorflow\/compile.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the tensorflow installation which include\/tensorflow\/c\")]\r\n+  [string]$tensorflowPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$jextract = find-tool(\"jextract\")\r\n+\r\n+& $jextract `\r\n+  -t org.tensorflow `\r\n+  -I \"$tensorflowPath\\include\" `\r\n+  -l tensorflow `\r\n+  -- `\r\n+  \"$tensorflowPath\\include\\tensorflow\\c\\c_api.h\"\r\n","filename":"samples\/tensorflow\/compile_windows.ps1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+jextract --source \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -t org.tensorflow \\\n+  -I ${LIBTENSORFLOW_HOME}\/include \\\n+  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  ${LIBTENSORFLOW_HOME}\/include\/tensorflow\/c\/c_api.h\n+\n+javac --add-modules jdk.incubator.foreign org\/tensorflow\/*.java\n","filename":"samples\/tensorflow\/compilesource.sh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+   TensorflowLoadSavedModel.java saved_mnist_model\n","filename":"samples\/tensorflow\/loadsavedmodel.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+import tensorflow as tf\n+from tensorflow.keras import models, layers\n+from tensorflow.keras.datasets import mnist\n+\n+model = tf.keras.models.Sequential([\n+  tf.keras.layers.Flatten(input_shape=(28, 28)),\n+  tf.keras.layers.Dense(128,activation='relu'),\n+  tf.keras.layers.Dense(10, activation='softmax')\n+])\n+\n+model.compile(\n+    loss='sparse_categorical_crossentropy',\n+    optimizer=tf.keras.optimizers.Adam(0.001),\n+    metrics=['accuracy'],\n+)\n+\n+print(model.summary())\n+\n+(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n+\n+train_images = train_images\/255.0\n+test_images = test_images\/255.0\n+\n+model.fit(train_images, train_labels,\n+    epochs=4, batch_size=128, verbose=1)\n+\n+test_loss, test_accuracy = model.evaluate(test_images, test_labels)\n+\n+print(test_loss, test_accuracy)\n+\n+model.save(\"saved_mnist_model\")\n+\n","filename":"samples\/tensorflow\/mnist_model.py","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+param(\r\n+  [Parameter(Mandatory=$true, HelpMessage=\"The path to the tensorflow installation, which contains lib\/tensorflow.dll\")]\r\n+  [string]$tensorflowPath\r\n+)\r\n+\r\n+. ..\/shared_windows.ps1\r\n+\r\n+$java = find-tool(\"java\")\r\n+\r\n+& $java `\r\n+  --enable-native-access=ALL-UNNAMED `\r\n+  --add-modules jdk.incubator.foreign `\r\n+  -D\"java.library.path=$tensorflowPath\\lib\" `\r\n+  TensorflowLoadSavedModel.java saved_mnist_model\n\\ No newline at end of file\n","filename":"samples\/tensorflow\/run_windows.ps1","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import static org.unix.time_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import jdk.incubator.foreign.*;\n+import org.unix.*;\n+\n+public class PanamaTime {\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            var now = allocator.allocate(C_LONG, System.currentTimeMillis() \/ 1000);\n+            MemorySegment time = tm.allocate(scope);\n+            localtime_r(now, time);\n+            System.err.printf(\"Time = %d:%d\\n\", tm.tm_hour$get(time), tm.tm_min$get(time));\n+        }\n+    }\n+}\n","filename":"samples\/time\/PanamaTime.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+jextract -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n","filename":"samples\/time\/compile.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+jextract --source -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n+\n+javac --add-modules jdk.incubator.foreign org\/unix\/*.java\n","filename":"samples\/time\/compilesource.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign PanamaTime.java\n+\n","filename":"samples\/time\/run.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+Manifest-Version: 1.0\r\n+Main-Class: org.openjdk.jextract.JextractTool\r\n+\r\n","filename":"src\/main\/java\/META-INF\/MANIFEST.MF","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,539 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract;\n+\n+import java.lang.constant.Constable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.impl.DeclarationImpl;\n+\n+\/**\n+ * Instances of this class are used to model declaration elements in the foreign language.\n+ * All declarations have a position (see {@link Position}) and a name. Instances of this class\n+ * support the <em>visitor<\/em> pattern (see {@link Declaration#accept(Visitor, Object)} and\n+ * {@link Visitor}).\n+ *\/\n+public interface Declaration {\n+\n+    \/**\n+     * The position associated with this declaration.\n+     * @return The position associated with this declaration.\n+     *\/\n+    Position pos();\n+\n+    \/**\n+     * The name associated with this declaration.\n+     * @return The name associated with this declaration.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Get a declaration with specified attribute.\n+     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute\n+     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become\n+     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.\n+     * @param name The attribute name\n+     * @param values More attribute values\n+     * @return the Declaration with attributes\n+     *\/\n+    Declaration withAttribute(String name, Constable... values);\n+\n+    \/**\n+     * Get a declaration without current attributes\n+     * @return the Declatation without any attributes\n+     *\/\n+    Declaration stripAttributes();\n+\n+    \/**\n+     * The values of the specified attribute.\n+     * @param name The attribute to retrieve\n+     * @return The list of values associate with this attribute\n+     *\/\n+    Optional<List<Constable>> getAttribute(String name);\n+\n+    \/**\n+     * The attributes associated with this declaration\n+     * @return The attributes associated with this declaration\n+     *\/\n+    Set<String> attributeNames();\n+\n+    \/**\n+     * Entry point for visiting declaration instances.\n+     * @param visitor the declaration visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this declaration through the specified declaration visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Declaration for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Declaration and both\n+     * the declarations are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Declaration\n+     * @return {@code true} if the specified object is equal to this Declaration\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Declaration.\n+     *\n+     * @return the hash code value for this Declaration.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A function declaration.\n+     *\/\n+    interface Function extends Declaration {\n+        \/**\n+         * The parameters associated with this function declaration.\n+         * @return The parameters associated with this function declaration.\n+         *\/\n+        List<Variable> parameters();\n+\n+        \/**\n+         * The foreign type associated with this function declaration.\n+         * @return The foreign type associated with this function declaration.\n+         *\/\n+        Type.Function type();\n+    }\n+\n+    \/**\n+     * A scoped declaration is a container for one or more nested declarations. This declaration can be used to model\n+     * several constructs in the foreign languages, such as (but not limited to) structs, unions and structs (see also\n+     * {@link Scoped.Kind}).\n+     *\/\n+    interface Scoped extends Declaration {\n+\n+        \/**\n+         * The scoped declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Namespace declaration.\n+             *\/\n+            NAMESPACE,\n+            \/**\n+             * Class declaration.\n+             *\/\n+            CLASS,\n+            \/**\n+             * Enum declaration.\n+             *\/\n+            ENUM,\n+            \/**\n+             * Struct declaration.\n+             *\/\n+            STRUCT,\n+            \/**\n+             * Union declaration.\n+             *\/\n+            UNION,\n+            \/**\n+             * Bitfields declaration.\n+             *\/\n+            BITFIELDS,\n+            \/**\n+             * Toplevel declaration.\n+             *\/\n+            TOPLEVEL;\n+        }\n+\n+        \/**\n+         * The member declarations associated with this scoped declaration.\n+         * @return The member declarations associated with this scoped declaration.\n+         *\/\n+        List<Declaration> members();\n+\n+        \/**\n+         * The (optional) layout associated with this scoped declaration.\n+         * @return The (optional) layout associated with this scoped declaration.\n+         *\n+         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},\n+         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and<\/em> if this declaration models an entity in the foreign\n+         * language that is associated with a <em>definition<\/em>.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The scoped declaration kind.\n+         * @return The scoped declaration kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A typedef declaration\n+     *\/\n+    interface Typedef extends Declaration {\n+        \/**\n+         * The canonical type associated with this typedef declaration.\n+         * @return The canonical type associated with this typedef declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * A variable declaration.\n+     *\/\n+    interface Variable extends Declaration {\n+        \/**\n+         * The variable declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Global variable declaration.\n+             *\/\n+            GLOBAL,\n+            \/**\n+             * Field declaration.\n+             *\/\n+            FIELD,\n+            \/**\n+             * Bitfield declaration.\n+             *\/\n+            BITFIELD,\n+            \/**\n+             * Function parameter declaration.\n+             *\/\n+            PARAMETER;\n+        }\n+\n+        \/**\n+         * The type associated with this variable declaration.\n+         * @return The type associated with this variable declaration.\n+         *\/\n+        Type type();\n+\n+        \/**\n+         * The optional layout associated with this variable declaration.\n+         * @return The optional layout associated with this variable declaration.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The kind associated with this variable declaration.\n+         * @return The kind associated with this variable declaration.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A constant value declaration.\n+     *\/\n+    interface Constant extends Declaration {\n+        \/**\n+         * The value associated with this constant declaration.\n+         * @return The value associated with this constant declaration.\n+         *\/\n+        Object value();\n+\n+        \/**\n+         * The type associated with this constant declaration.\n+         * @return The type associated with this constant declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Declaration visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a scoped declaration.\n+         * @param d the scoped declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given scoped declaration through this visitor object.\n+         *\/\n+        default R visitScoped(Scoped d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a function declaration.\n+         * @param d the function declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function declaration through this visitor object.\n+         *\/\n+        default R visitFunction(Function d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a variable declaration.\n+         * @param d the variable declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given variable declaration through this visitor object.\n+         *\/\n+        default R visitVariable(Variable d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a constant declaration.\n+         * @param d the constant declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given constant declaration through this visitor object.\n+         *\/\n+        default R visitConstant(Constant d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a typedef declaration.\n+         * @param d the typedef declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given typedef declaration through this visitor object.\n+         *\/\n+        default R visitTypedef(Typedef d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a declaration.\n+         * @param d the declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declaration through this visitor object.\n+         *\/\n+        default R visitDeclaration(Declaration d, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Creates a new constant declaration with given name and type.\n+     * @param pos the constant declaration position.\n+     * @param name the constant declaration name.\n+     * @param value the constant declaration value.\n+     * @param type the constant declaration type.\n+     * @return a new constant declaration with given name and type.\n+     *\/\n+    static Declaration.Constant constant(Position pos, String name, Object value, Type type) {\n+        return new DeclarationImpl.ConstantImpl(type, value, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new global variable declaration with given name and type.\n+     * @param pos the global variable declaration position.\n+     * @param name the global variable declaration name.\n+     * @param type the global variable declaration type.\n+     * @return a new global variable declaration with given name and type.\n+     *\/\n+    static Declaration.Variable globalVariable(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new field declaration with given name and type.\n+     * @param pos the field declaration position.\n+     * @param name the field declaration name.\n+     * @param type the field declaration type.\n+     * @return a new field declaration with given name and type.\n+     *\/\n+    static Declaration.Variable field(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfield declaration with given name, type and layout.\n+     * @param pos the bitfield declaration position.\n+     * @param name the bitfield declaration name.\n+     * @param type the bitfield declaration type.\n+     * @param layout the bitfield declaration layout.\n+     * @return a new bitfield declaration with given name, type and layout.\n+     *\/\n+    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {\n+        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new parameter declaration with given name and type.\n+     * @param pos the parameter declaration position.\n+     * @param name the parameter declaration name.\n+     * @param type the parameter declaration type.\n+     * @return a new parameter declaration with given name and type.\n+     *\/\n+    static Declaration.Variable parameter(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new toplevel declaration with given member declarations.\n+     * @param pos the toplevel declaration position.\n+     * @param decls the toplevel declaration member declarations.\n+     * @return a new toplevel declaration with given member declarations.\n+     *\/\n+    static Declaration.Scoped toplevel(Position pos, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.TOPLEVEL, declList, \"<toplevel>\", pos);\n+    }\n+\n+    \/**\n+     * Creates a new namespace declaration with given name and member declarations.\n+     * @param pos the namespace declaration position.\n+     * @param name the namespace declaration name.\n+     * @param decls the namespace declaration member declarations.\n+     * @return a new namespace declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfields group declaration with given name and layout.\n+     * @param pos the bitfields group declaration position.\n+     * @param layout the bitfields group declaration layout.\n+     * @param bitfields the bitfields group member declarations.\n+     * @return a new bitfields group declaration with given name and layout.\n+     *\/\n+    static Declaration.Scoped bitfields(Position pos, MemoryLayout layout, Declaration.Variable... bitfields) {\n+        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, \"\", pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name, layout and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param layout the struct declaration layout.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Scoped.Kind.UNION, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name, layout and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param layout the union declaration layout.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name, layout and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param layout the class declaration layout.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name, layout and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param layout the enum declaration layout.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new function declaration with given name, type and parameter declarations.\n+     * @param pos the function declaration position.\n+     * @param name the function declaration name.\n+     * @param type the function declaration type.\n+     * @param params the function declaration parameter declarations.\n+     * @return a new function declaration with given name, type and parameter declarations.\n+     *\/\n+    static Declaration.Function function(Position pos, String name, Type.Function type, Declaration.Variable... params) {\n+        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());\n+        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new typedef declaration with given name and declared type.\n+     * @param pos the typedef declaration position.\n+     * @param name the typedef declaration name.\n+     * @param type the typedef type\n+     * @return a new type declaration with given name and declared type.\n+     *\/\n+    static Declaration.Typedef typedef(Position pos, String name, Type type) {\n+        return new DeclarationImpl.TypedefImpl(type, name, pos, null);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":539,"deletions":0,"binary":false,"changes":539,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract;\n+\n+import org.openjdk.jextract.impl.ClangException;\n+import org.openjdk.jextract.impl.IncludeHelper;\n+import org.openjdk.jextract.impl.OutputFactory;\n+import org.openjdk.jextract.impl.Parser;\n+import org.openjdk.jextract.impl.Options;\n+import org.openjdk.jextract.impl.Writer;\n+import joptsimple.OptionException;\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,\n+ * where for each native function a static method is added which calls the underlying native method handles.\n+ * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated\n+ * on top of the underlying memory access var handles. For each struct, a static layout field is generated.\n+ *\/\n+public final class JextractTool {\n+    private static final String MESSAGES_RESOURCE = \"org.openjdk.jextract.impl.resources.Messages\";\n+\n+    private static final ResourceBundle MESSAGES_BUNDLE;\n+    static {\n+        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());\n+    }\n+\n+    public static final boolean DEBUG = Boolean.getBoolean(\"jextract.debug\");\n+\n+    \/\/ error codes\n+    private static final int SUCCESS       = 0;\n+    private static final int OPTION_ERROR  = 1;\n+    private static final int INPUT_ERROR   = 2;\n+    private static final int CLANG_ERROR   = 3;\n+    private static final int RUNTIME_ERROR = 4;\n+    private static final int OUTPUT_ERROR  = 5;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private static String format(String msgId, Object... args) {\n+        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);\n+    }\n+\n+    private JextractTool(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private static Path generateTmpSource(List<Path> headers) {\n+        assert headers.size() > 1;\n+        try {\n+            Path tmpFile = Files.createTempFile(\"jextract\", \".h\");\n+            tmpFile.toFile().deleteOnExit();\n+            Files.write(tmpFile, headers.stream().\n+                    map(src -> \"#include \\\"\" + src + \"\\\"\").\n+                    collect(Collectors.toList()));\n+            return tmpFile;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        }\n+    }\n+\n+    \/**\n+     * Parse input files into a toplevel declaration with given options.\n+     * @param parserOptions options to be passed to the parser.\n+     * @return a toplevel declaration.\n+     *\/\n+    public static Declaration.Scoped parse(List<Path> headers, String... parserOptions) {\n+        Path source = headers.size() > 1? generateTmpSource(headers) : headers.iterator().next();\n+        return new Parser().parse(source, Stream.of(parserOptions).collect(Collectors.toList()));\n+    }\n+\n+    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+    }\n+\n+    private static List<JavaFileObject> generateInternal(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, IncludeHelper includeHelper, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, includeHelper, libNames));\n+    }\n+\n+    \/**\n+     * Write resulting {@link JavaFileObject} instances into specified destination path.\n+     * @param dest the destination path.\n+     * @param compileSources whether to compile .java sources or not\n+     * @param files the {@link JavaFileObject} instances to be written.\n+     *\/\n+    public static void write(Path dest, boolean compileSources, List<JavaFileObject> files) throws UncheckedIOException {\n+        try {\n+            new Writer(dest, files).writeAll(compileSources);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private int printHelp(OptionParser parser, int exitCode) {\n+        try {\n+            parser.printHelpOn(err);\n+        } catch (IOException ignored) {}\n+        return exitCode;\n+    }\n+\n+\n+    private void printOptionError(Throwable throwable) {\n+        printOptionError(throwable.getMessage());\n+        if (DEBUG) {\n+            throwable.printStackTrace(err);\n+        }\n+    }\n+\n+    private void printOptionError(String message) {\n+        err.println(\"OPTION ERROR: \" + message);\n+        err.println(\"Usage: jextract <options> [--] <header file>\");\n+        err.println(\"Use --help for a list of possible options\");\n+    }\n+\n+    \/**\n+     * Main entry point to run the JextractTool\n+     *\n+     * @param args command line options passed\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a header file\");\n+            return;\n+        }\n+\n+        JextractTool m = new JextractTool(new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n+        System.exit(m.run(args));\n+    }\n+\n+    private int run(String[] args) {\n+        OptionParser parser = new OptionParser(false);\n+        parser.accepts(\"C\", format(\"help.C\")).withRequiredArg();\n+        parser.accepts(\"I\", format(\"help.I\")).withRequiredArg();\n+        parser.accepts(\"d\", format(\"help.d\")).withRequiredArg();\n+        parser.accepts(\"dump-includes\", format(\"help.dump-includes\")).withRequiredArg();\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            parser.accepts(includeKind.optionName(), format(\"help.\" + includeKind.optionName())).withRequiredArg();\n+        }\n+        parser.accepts(\"l\", format(\"help.l\")).withRequiredArg();\n+        parser.accepts(\"source\", format(\"help.source\"));\n+        parser.acceptsAll(List.of(\"t\", \"target-package\"), format(\"help.t\")).withRequiredArg();\n+        parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), format(\"help.h\")).forHelp();\n+        parser.accepts(\"header-class-name\", format(\"help.header-class-name\")).withRequiredArg();\n+        parser.nonOptions(format(\"help.non.option\"));\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(args);\n+        } catch (OptionException oe) {\n+            printOptionError(oe);\n+            return OPTION_ERROR;\n+        }\n+\n+        if (optionSet.has(\"h\")) {\n+            return printHelp(parser, SUCCESS);\n+        }\n+\n+        if (optionSet.nonOptionArguments().size() != 1) {\n+            printOptionError(\"Expected 1 header file, not \" + optionSet.nonOptionArguments().size());\n+            return OPTION_ERROR;\n+        }\n+\n+        Options.Builder builder = Options.builder();\n+        if (optionSet.has(\"I\")) {\n+            optionSet.valuesOf(\"I\").forEach(p -> builder.addClangArg(\"-I\" + p));\n+        }\n+\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        if (Files.isDirectory(builtinInc)) {\n+            builder.addClangArg(\"-I\" + builtinInc);\n+        }\n+        String jextractHeaderPath = System.getProperty(\"jextract.header.path\");\n+        if (jextractHeaderPath != null) {\n+            builtinInc = Paths.get(jextractHeaderPath);\n+            if (Files.isDirectory(builtinInc)) {\n+                builder.addClangArg(\"-I\" + builtinInc);\n+            }\n+        }\n+\n+        if (optionSet.has(\"C\")) {\n+            optionSet.valuesOf(\"C\").forEach(p -> builder.addClangArg((String) p));\n+        }\n+\n+        if (optionSet.has(\"filter\")) {\n+            optionSet.valuesOf(\"filter\").forEach(p -> builder.addFilter((String) p));\n+        }\n+\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            if (optionSet.has(includeKind.optionName())) {\n+                optionSet.valuesOf(includeKind.optionName()).forEach(p -> builder.addIncludeSymbol(includeKind, (String)p));\n+            }\n+        }\n+\n+        if (optionSet.has(\"dump-includes\")) {\n+            builder.setDumpIncludeFile(optionSet.valueOf(\"dump-includes\").toString());\n+        }\n+\n+        if (optionSet.has(\"d\")) {\n+            builder.setOutputDir(optionSet.valueOf(\"d\").toString());\n+        }\n+\n+        if (optionSet.has(\"source\")) {\n+            builder.setGenerateSource();\n+        }\n+        boolean librariesSpecified = optionSet.has(\"l\");\n+        if (librariesSpecified) {\n+            for (Object arg : optionSet.valuesOf(\"l\")) {\n+                String lib = (String)arg;\n+                if (lib.indexOf(File.separatorChar) == -1) {\n+                    builder.addLibraryName(lib);\n+                } else {\n+                    Path libPath = Paths.get(lib);\n+                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {\n+                        builder.addLibraryName(lib);\n+                    } else {\n+                        err.println(format(\"l.option.value.invalid\", lib));\n+                        return OPTION_ERROR;\n+                    }\n+                }\n+            }\n+        }\n+\n+        String targetPackage = optionSet.has(\"t\") ? (String) optionSet.valueOf(\"t\") : \"\";\n+        builder.setTargetPackage(targetPackage);\n+\n+        Options options = builder.build();\n+\n+        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());\n+        if (!Files.isReadable(header)) {\n+            err.println(format(\"cannot.read.header.file\", header));\n+            return INPUT_ERROR;\n+        }\n+        if (!(Files.isRegularFile(header))) {\n+            err.println(format(\"not.a.file\", header));\n+            return INPUT_ERROR;\n+        }\n+\n+        List<JavaFileObject> files = null;\n+        try {\n+            Declaration.Scoped toplevel = parse(List.of(header), options.clangArgs.toArray(new String[0]));\n+\n+            if (JextractTool.DEBUG) {\n+                System.out.println(toplevel);\n+            }\n+\n+            String headerName = optionSet.has(\"header-class-name\") ?\n+                (String) optionSet.valueOf(\"header-class-name\") :\n+                header.getFileName().toString();\n+\n+            files = generateInternal(\n+                toplevel, headerName,\n+                options.targetPackage, options.includeHelper, options.libraryNames);\n+        } catch (ClangException ce) {\n+            err.println(ce.getMessage());\n+            if (JextractTool.DEBUG) {\n+                ce.printStackTrace(err);\n+            }\n+            return CLANG_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        try {\n+            if (options.includeHelper.dumpIncludesFile != null) {\n+                options.includeHelper.dumpIncludes();\n+            } else {\n+                Path output = Path.of(options.outputDir);\n+                write(output, !options.source, files);\n+            }\n+        } catch (UncheckedIOException uioe) {\n+            err.println(uioe.getMessage());\n+            if (JextractTool.DEBUG) {\n+                uioe.printStackTrace(err);\n+            }\n+            return OUTPUT_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        return SUCCESS;\n+    }\n+\n+    \/**\n+     * ToolProvider implementation for jextract tool.\n+     *\/\n+    public static class JextractToolProvider implements ToolProvider {\n+        public JextractToolProvider() {}\n+\n+        @Override\n+        public String name() {\n+            return \"jextract\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            JextractTool instance = new JextractTool(out, err);\n+            return instance.run(args);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/JextractTool.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Instances of this class model are used to model source code positions.\n+ *\/\n+public interface Position {\n+\n+    \/**\n+     * The input file to which this position refers to.\n+     * @return The input file to which this position refers to.\n+     *\/\n+    Path path();\n+\n+    \/**\n+     * The line number associated with this position.\n+     * @return The line number associated with this position.\n+     *\/\n+    int line();\n+\n+    \/**\n+     * The column number associated with this position.\n+     * @return The column number associated with this position.\n+     *\/\n+    int col();\n+\n+    \/**\n+     * An empty position instance; this can be used to model <em>synthetic<\/em> program elements which are not\n+     * defined in any input file.\n+     *\/\n+    Position NO_POSITION = new Position() {\n+        @Override\n+        public Path path() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return 0;\n+        }\n+    };\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Position.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,529 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.impl.TypeImpl;\n+import org.openjdk.jextract.impl.UnsupportedLayouts;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Instances of this class are used to model types in the foreign language.\n+ * Instances of this class support the <em>visitor<\/em> pattern (see {@link Type#accept(Type.Visitor, Object)} and\n+ * {@link Type.Visitor}).\n+ *\/\n+public interface Type {\n+\n+    \/**\n+     * Is this type the erroneous type?\n+     * @return true, if this type is the erroneous type.\n+     *\/\n+    boolean isErroneous();\n+\n+    \/**\n+     * Entry point for visiting type instances.\n+     * @param visitor the type visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this type through the specified type visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Type for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Type and both\n+     * the Types are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Type\n+     * @return {@code true} if the specified object is equal to this Type\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Type.\n+     *\n+     * @return the hash code value for this Type.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A primitive type.\n+     *\/\n+    interface Primitive extends Type {\n+\n+        \/**\n+         * The primitive type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * {@code void} type.\n+             *\/\n+            Void(\"void\", null),\n+            \/**\n+             * {@code Bool} type.\n+             *\/\n+            Bool(\"_Bool\", ValueLayout.JAVA_BOOLEAN),\n+            \/**\n+             * {@code char} type.\n+             *\/\n+            Char(\"char\", ValueLayout.JAVA_BYTE),\n+            \/**\n+             * {@code char16} type.\n+             *\/\n+            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            \/**\n+             * {@code short} type.\n+             *\/\n+            Short(\"short\", ValueLayout.JAVA_SHORT.withBitAlignment(16)),\n+            \/**\n+             * {@code int} type.\n+             *\/\n+            Int(\"int\", ValueLayout.JAVA_INT.withBitAlignment(32)),\n+            \/**\n+             * {@code long} type.\n+             *\/\n+            Long(\"long\", TypeImpl.IS_WINDOWS ?\n+                ValueLayout.JAVA_INT.withBitAlignment(32) :\n+                ValueLayout.JAVA_LONG.withBitAlignment(64)),\n+            \/**\n+             * {@code long long} type.\n+             *\/\n+            LongLong(\"long long\", ValueLayout.JAVA_LONG.withBitAlignment(64)),\n+            \/**\n+             * {@code int128} type.\n+             *\/\n+            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            \/**\n+             * {@code float} type.\n+             *\/\n+            Float(\"float\", ValueLayout.JAVA_FLOAT.withBitAlignment(32)),\n+            \/**\n+             * {@code double} type.\n+             *\/\n+            Double(\"double\", ValueLayout.JAVA_DOUBLE.withBitAlignment(64)),\n+            \/**\n+              * {@code long double} type.\n+              *\/\n+            LongDouble(\"long double\", UnsupportedLayouts.LONG_DOUBLE),\n+            \/**\n+             * {@code float128} type.\n+             *\/\n+            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            \/**\n+             * {@code float16} type.\n+             *\/\n+            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            \/**\n+             * {@code wchar} type.\n+             *\/\n+            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+\n+            private final String typeName;\n+            private final MemoryLayout layout;\n+\n+            Kind(String typeName, MemoryLayout layout) {\n+                this.typeName = typeName;\n+                this.layout = layout;\n+            }\n+\n+            public String typeName() {\n+                return typeName;\n+            }\n+\n+            \/**\n+             * The primitive type (optional) layout.\n+             * @return The primitive type (optional) layout.\n+             *\/\n+            public Optional<MemoryLayout> layout() {\n+                return Optional.ofNullable(layout);\n+            }\n+        }\n+\n+        \/**\n+         * The primitive type kind.\n+         * @return The primitive type kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * Instances of this class are used to model types which are associated to a declaration in the foreign language\n+     * (see {@link Declaration}).\n+     *\/\n+    interface Declared extends Type {\n+        \/**\n+         * The declaration to this type refers to.\n+         * @return The declaration to this type refers to.\n+         *\/\n+        Declaration.Scoped tree();\n+    }\n+\n+    \/**\n+     * A function type.\n+     *\/\n+    interface Function extends Type {\n+        \/**\n+         * Is this function type a variable-arity?\n+         * @return true, if this function type is a variable-arity.\n+         *\/\n+        boolean varargs();\n+\n+        \/**\n+         * The function formal parameter types.\n+         * @return The function formal parameter types.\n+         *\/\n+        List<Type> argumentTypes();\n+\n+        \/**\n+         * The function return type.\n+         * @return The function return type.\n+         *\/\n+        Type returnType();\n+\n+        \/**\n+         * Names of function parameters (from typedef), if any\n+         * @return The optional list of function parameter names.\n+         *\/\n+        Optional<List<String>> parameterNames();\n+\n+        \/**\n+         * Returns a Function type that has the given parameter names.\n+         *\n+         * @param paramNames parameter names for this function type.\n+         * @return new Function type with the given parameter names.\n+         *\/\n+        Function withParameterNames(List<String> paramNames);\n+    }\n+\n+    \/**\n+     * An array type. Array types feature an element type and an optional size. As such they can also be used to\n+     * model array types.\n+     *\/\n+    interface Array extends Type {\n+\n+        \/**\n+         * The array type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Vector kind.\n+             *\/\n+            VECTOR,\n+            \/**\n+             * Array kind.\n+             *\/\n+            ARRAY,\n+            \/**\n+             * Incomplete array kind.\n+             *\/\n+            INCOMPLETE_ARRAY;\n+        }\n+\n+        \/**\n+         * The array type kind.\n+         * @return The array type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The (optional) array element count.\n+         * @return The (optional) array element count.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#VECTOR}, {@link Kind#ARRAY}.\n+         *\/\n+        OptionalLong elementCount();\n+\n+        \/**\n+         * The array type element type.\n+         * @return The array type element type.\n+         *\/\n+        Type elementType();\n+    }\n+\n+    \/**\n+     * A delegated type is used to model a type which contains an indirection to some other underlying type. For instance,\n+     * a delegated type can be used to model foreign pointers, where the indirection is used to model the pointee type.\n+     *\/\n+    interface Delegated extends Type {\n+\n+        \/**\n+         * The delegated type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Type-defined type.\n+             *\/\n+            TYPEDEF,\n+            \/**\n+             * Pointer type.\n+             *\/\n+            POINTER,\n+            \/**\n+             * Signed type.\n+             *\/\n+            SIGNED,\n+            \/**\n+             * Unsigned type.\n+             *\/\n+            UNSIGNED,\n+            \/**\n+             * Atomic type.\n+             *\/\n+            ATOMIC,\n+            \/**\n+             * Volatile type.\n+             *\/\n+            VOLATILE,\n+            \/**\n+             * Complex type.\n+             *\/\n+            COMPLEX;\n+        }\n+\n+        \/**\n+         * The delegated type kind.\n+         * @return The delegated type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The delegated type (optional) name.\n+         * @return The delegated type (optional) name.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#TYPEDEF}.\n+         *\/\n+        Optional<String> name();\n+\n+        \/**\n+         * The delegated type underlying type.\n+         * @return The delegated type underlying type.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Type visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a primitive type.\n+         * @param t the primitive type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given primitive type through this visitor object.\n+         *\/\n+        default R visitPrimitive(Primitive t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a function type.\n+         * @param t the function type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function type through this visitor object.\n+         *\/\n+        default R visitFunction(Function t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a declared type.\n+         * @param t the declared type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declared type through this visitor object.\n+         *\/\n+        default R visitDeclared(Declared t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a delegated type.\n+         * @param t the delegated type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given delegated type through this visitor object.\n+         *\/\n+        default R visitDelegated(Delegated t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit an array type.\n+         * @param t the array type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given array type through this visitor object.\n+         *\/\n+        default R visitArray(Array t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a type.\n+         * @param t the type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given type through this visitor object.\n+         *\/\n+        default R visitType(Type t, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Compute the layout for a given type.\n+     * @param t the type.\n+     * @return the layout for given type.\n+     *\/\n+    static Optional<MemoryLayout> layoutFor(Type t) {\n+        return TypeImpl.getLayout(t);\n+    }\n+\n+    \/**\n+     * Compute the function descriptor for a given function type.\n+     * @param function the function type.\n+     * @return the function descriptor for given function type.\n+     *\/\n+    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n+        return TypeImpl.getDescriptor(function);\n+    }\n+\n+    \/**\n+     * Create the {@code void} type.\n+     * @return the {@code void} type.\n+     *\/\n+    static Type.Primitive void_() {\n+        return new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void);\n+    }\n+\n+    \/**\n+     * Creates a new primitive type given kind.\n+     * @param kind the primitive type kind.\n+     * @return a new primitive type with given kind.\n+     *\/\n+    static Type.Primitive primitive(Type.Primitive.Kind kind) {\n+        return new TypeImpl.PrimitiveImpl(kind);\n+    }\n+\n+    \/**\n+     * Creates a new qualified type given kind and underlying type.\n+     * @param kind the qualified type kind.\n+     * @param type the qualified type underlying type.\n+     * @return a new qualified type with given name and underlying type.\n+     *\/\n+    static Type.Delegated qualified(Type.Delegated.Kind kind, Type type) {\n+        return new TypeImpl.QualifiedImpl(kind, type);\n+    }\n+\n+    \/**\n+     * Creates a new typedef type given name and underlying type.\n+     * @param name the typedef type name.\n+     * @param aliased the typeef type underlying type.\n+     * @return a new typedef type with given name and underlying type.\n+     *\/\n+    static Type.Delegated typedef(String name, Type aliased) {\n+        return new TypeImpl.QualifiedImpl(Delegated.Kind.TYPEDEF, name, aliased);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with no associated pointee information.\n+     * @return a new pointer type with no associated pointee information.\n+     *\/\n+    static Type.Delegated pointer() {\n+        return new TypeImpl.PointerImpl(() -> new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void));\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee the pointee type.\n+     * @return a new pointer type with given pointee type.\n+     *\/\n+    static Type.Delegated pointer(Type pointee) {\n+        return new TypeImpl.PointerImpl(() -> pointee);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee factory to (lazily) build the pointee type.\n+     * @return a new pointer type with given pointee type (lazily built from factory).\n+     *\/\n+    static Type.Delegated pointer(Supplier<Type> pointee) {\n+        return new TypeImpl.PointerImpl(pointee);\n+    }\n+\n+    \/**\n+     * Creates a new function type with given parameter types and return type.\n+     * @param varargs is this function type variable-arity?\n+     * @param returnType the function type return type.\n+     * @param arguments the function type formal parameter types.\n+     * @return a new function type with given parameter types and return type.\n+     *\/\n+    static Type.Function function(boolean varargs, Type returnType, Type... arguments) {\n+        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType, null);\n+    }\n+\n+    \/**\n+     * Creates a new declared type with given foreign declaration.\n+     * @param tree the foreign declaration the type refers to.\n+     * @return  a new declared type with given foreign declaration.\n+     *\/\n+    static Type.Declared declared(Declaration.Scoped tree) {\n+        return new TypeImpl.DeclaredImpl(tree);\n+    }\n+\n+    \/**\n+     * Creates a new vector type with given element count and element type.\n+     * @param elementCount the vector type element count.\n+     * @param elementType the vector type element type.\n+     * @return a new vector type with given element count and element type.\n+     *\/\n+    static Type.Array vector(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.VECTOR, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element count and element type.\n+     * @param elementCount the array type element count.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element count and element type.\n+     *\/\n+    static Type.Array array(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.ARRAY, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element type.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element type.\n+     *\/\n+    static Type.Array array(Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.INCOMPLETE_ARRAY, elementType);\n+    }\n+\n+    \/**\n+     * Creates an erroneous type.\n+     * @return an erroneous type.\n+     *\/\n+    static Type error() {\n+        return TypeImpl.ERROR;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Type.java","additions":529,"deletions":0,"binary":false,"changes":529,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum CallingConvention {\n+\n+    Default(CXCallingConv_Default()),\n+    C(CXCallingConv_C()),\n+    X86StdCall(CXCallingConv_X86StdCall()),\n+    X86FastCall(CXCallingConv_X86FastCall()),\n+    X86ThisCall(CXCallingConv_X86ThisCall()),\n+    X86Pascal(CXCallingConv_X86Pascal()),\n+    AAPCS(CXCallingConv_AAPCS()),\n+    AAPCS_VFP(CXCallingConv_AAPCS_VFP()),\n+    PnaclCall(CXCallingConv_X86RegCall()),\n+    IntelOclBicc(CXCallingConv_IntelOclBicc()),\n+    X86_64Win64(CXCallingConv_X86_64Win64()),\n+    X86_64SysV(CXCallingConv_X86_64SysV()),\n+    Invalid(CXCallingConv_Invalid()),\n+    Unexposed(CXCallingConv_Unexposed());\n+\n+    private final int value;\n+\n+    CallingConvention(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CallingConvention> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CallingConvention e: CallingConvention.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CallingConvention valueOf(int value) {\n+        CallingConvention x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException();\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/CallingConvention.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.CXCursorVisitor;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+\n+public final class Cursor {\n+\n+    private final MemorySegment cursor;\n+    private final int kind;\n+\n+    Cursor(MemorySegment cursor) {\n+        this.cursor = cursor;\n+        kind = Index_h.clang_getCursorKind(cursor);\n+    }\n+\n+    public boolean isDeclaration() {\n+        return Index_h.clang_isDeclaration(kind) != 0;\n+    }\n+\n+    public boolean isPreprocessing() {\n+        return Index_h.clang_isPreprocessing(kind) != 0;\n+    }\n+\n+    public boolean isInvalid() {\n+        return Index_h.clang_isInvalid(kind) != 0;\n+    }\n+\n+    public boolean isDefinition() {\n+        return Index_h.clang_isCursorDefinition(cursor) != 0;\n+    }\n+\n+    public boolean isAttribute() { return Index_h.clang_isAttribute(kind) != 0; }\n+\n+    public boolean isAnonymousStruct() {\n+        return Index_h.clang_Cursor_isAnonymousRecordDecl(cursor) != 0;\n+    }\n+\n+    public boolean isMacroFunctionLike() {\n+        return Index_h.clang_Cursor_isMacroFunctionLike(cursor) != 0;\n+    }\n+\n+    public String spelling() {\n+        return LibClang.CXStrToString(allocator ->\n+            Index_h.clang_getCursorSpelling(allocator, cursor));\n+    }\n+\n+    public String USR() {\n+        return LibClang.CXStrToString(allocator ->\n+                Index_h.clang_getCursorUSR(allocator, cursor));\n+    }\n+\n+    public String prettyPrinted(PrintingPolicy policy) {\n+        return LibClang.CXStrToString(allocator ->\n+            Index_h.clang_getCursorPrettyPrinted(allocator, cursor, policy.ptr()));\n+    }\n+\n+    public String prettyPrinted() {\n+        try (PrintingPolicy policy = getPrintingPolicy()) {\n+            return prettyPrinted(policy);\n+        }\n+    }\n+\n+    public String displayName() {\n+        return LibClang.CXStrToString(allocator ->\n+                Index_h.clang_getCursorDisplayName(allocator, cursor));\n+    }\n+\n+    public boolean equalCursor(Cursor other) {\n+        return Index_h.clang_equalCursors(cursor, other.cursor) != 0;\n+    }\n+\n+    public Type type() {\n+        return new Type(Index_h.clang_getCursorType(IMPLICIT_ALLOCATOR, cursor));\n+    }\n+\n+    public Type getEnumDeclIntegerType() {\n+        return new Type(Index_h.clang_getEnumDeclIntegerType(IMPLICIT_ALLOCATOR, cursor));\n+    }\n+\n+    public Cursor getDefinition() {\n+        return new Cursor(Index_h.clang_getCursorDefinition(IMPLICIT_ALLOCATOR, cursor));\n+    }\n+\n+    public SourceLocation getSourceLocation() {\n+        MemorySegment loc = Index_h.clang_getCursorLocation(IMPLICIT_ALLOCATOR, cursor);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            if (Index_h.clang_equalLocations(loc, Index_h.clang_getNullLocation(\n+                    SegmentAllocator.nativeAllocator(scope))) != 0) {\n+                return null;\n+            }\n+        }\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceRange getExtent() {\n+        MemorySegment range = Index_h.clang_getCursorExtent(IMPLICIT_ALLOCATOR, cursor);\n+        if (Index_h.clang_Range_isNull(range) != 0) {\n+            return null;\n+        }\n+        return new SourceRange(range);\n+    }\n+\n+    public int numberOfArgs() {\n+        return Index_h.clang_Cursor_getNumArguments(cursor);\n+    }\n+\n+    public Cursor getArgument(int idx) {\n+        return new Cursor(Index_h.clang_Cursor_getArgument(IMPLICIT_ALLOCATOR, cursor, idx));\n+    }\n+\n+    \/\/ C long long, 64-bit\n+    public long getEnumConstantValue() {\n+        return Index_h.clang_getEnumConstantDeclValue(cursor);\n+    }\n+\n+    \/\/ C unsigned long long, 64-bit\n+    public long getEnumConstantUnsignedValue() {\n+        return Index_h.clang_getEnumConstantDeclUnsignedValue(cursor);\n+    }\n+\n+    public boolean isBitField() {\n+        return Index_h.clang_Cursor_isBitField(cursor) != 0;\n+    }\n+\n+    public int getBitFieldWidth() {\n+        return Index_h.clang_getFieldDeclBitWidth(cursor);\n+    }\n+\n+    public CursorKind kind() {\n+        return CursorKind.valueOf(kind);\n+    }\n+\n+    public CursorLanguage language() {\n+        return CursorLanguage.valueOf(Index_h.clang_getCursorLanguage(cursor));\n+    }\n+\n+    public int kind0() {\n+        return kind;\n+    }\n+\n+    \/**\n+     * For a cursor that is a reference, retrieve a cursor representing the entity that it references.\n+     *\/\n+    public Cursor getCursorReferenced() {\n+        return new Cursor(Index_h.clang_getCursorReferenced(\n+                IMPLICIT_ALLOCATOR, cursor));\n+    }\n+\n+    private static class CursorChildren {\n+        private static final ArrayList<Cursor> children = new ArrayList<>();\n+        private static final NativeSymbol callback = CXCursorVisitor.allocate((c, p, d) -> {\n+            MemorySegment copy = MemorySegment.allocateNative(c.byteSize(), ResourceScope.newImplicitScope());\n+            copy.copyFrom(c);\n+            Cursor cursor = new Cursor(copy);\n+            children.add(cursor);\n+            return Index_h.CXChildVisit_Continue();\n+        }, ResourceScope.newImplicitScope());\n+\n+        synchronized static Stream<Cursor> get(Cursor c) {\n+            try {\n+                Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);\n+                return new ArrayList<>(children).stream();\n+            } finally {\n+                children.clear();\n+            }\n+        }\n+    }\n+\n+    public Stream<Cursor> children() {\n+        return CursorChildren.get(this);\n+    }\n+\n+    public Stream<Cursor> allChildren() {\n+        return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));\n+    }\n+\n+    public String getMangling() {\n+        return LibClang.CXStrToString(allocator ->\n+                Index_h.clang_Cursor_getMangling(allocator, cursor));\n+    }\n+\n+    public TranslationUnit getTranslationUnit() {\n+        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(cursor));\n+    }\n+\n+    private MemoryAddress eval0() {\n+        return Index_h.clang_Cursor_Evaluate(cursor);\n+    }\n+\n+    public EvalResult eval() {\n+        MemoryAddress ptr = eval0();\n+        return ptr == MemoryAddress.NULL ? EvalResult.erroneous : new EvalResult(ptr);\n+    }\n+\n+    public PrintingPolicy getPrintingPolicy() {\n+        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(cursor));\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Cursor)) {\n+            return false;\n+        }\n+        return (Index_h.clang_equalCursors(cursor, ((Cursor)other).cursor) != 0);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum CursorKind {\n+\n+    UnexposedDecl(CXCursor_UnexposedDecl()),\n+    StructDecl(CXCursor_StructDecl()),\n+    UnionDecl(CXCursor_UnionDecl()),\n+    ClassDecl(CXCursor_ClassDecl()),\n+    EnumDecl(CXCursor_EnumDecl()),\n+    FieldDecl(CXCursor_FieldDecl()),\n+    EnumConstantDecl(CXCursor_EnumConstantDecl()),\n+    FunctionDecl(CXCursor_FunctionDecl()),\n+    VarDecl(CXCursor_VarDecl()),\n+    ParmDecl(CXCursor_ParmDecl()),\n+    TypedefDecl(CXCursor_TypedefDecl()),\n+    Namespace(CXCursor_Namespace()),\n+    TypeRef(CXCursor_TypeRef()),\n+    IntegerLiteral(CXCursor_IntegerLiteral()),\n+    FloatingLiteral(CXCursor_FloatingLiteral()),\n+    ImaginaryLiteral(CXCursor_ImaginaryLiteral()),\n+    StringLiteral(CXCursor_StringLiteral()),\n+    CharacterLiteral(CXCursor_CharacterLiteral()),\n+    UnexposedAttr(CXCursor_UnexposedAttr()),\n+    IBActionAttr(CXCursor_IBActionAttr()),\n+    IBOutletAttr(CXCursor_IBOutletAttr()),\n+    IBOutletCollectionAttr(CXCursor_IBOutletCollectionAttr()),\n+    CXXFinalAttr(CXCursor_CXXFinalAttr()),\n+    CXXOverrideAttr(CXCursor_CXXOverrideAttr()),\n+    AnnotateAttr(CXCursor_AnnotateAttr()),\n+    AsmLabelAttr(CXCursor_AsmLabelAttr()),\n+    PackedAttr(CXCursor_PackedAttr()),\n+    PureAttr(CXCursor_PureAttr()),\n+    ConstAttr(CXCursor_ConstAttr()),\n+    NoDuplicateAttr(CXCursor_NoDuplicateAttr()),\n+    CUDAConstantAttr(CXCursor_CUDAConstantAttr()),\n+    CUDADeviceAttr(CXCursor_CUDADeviceAttr()),\n+    CUDAGlobalAttr(CXCursor_CUDAGlobalAttr()),\n+    CUDAHostAttr(CXCursor_CUDAHostAttr()),\n+    CUDASharedAttr(CXCursor_CUDASharedAttr()),\n+    VisibilityAttr(CXCursor_VisibilityAttr()),\n+    DLLExport(CXCursor_DLLExport()),\n+    DLLImport(CXCursor_DLLImport()),\n+    NSReturnsRetained(CXCursor_NSReturnsRetained()),\n+    NSReturnsNotRetained(CXCursor_NSReturnsNotRetained()),\n+    NSReturnsAutoreleased(CXCursor_NSReturnsAutoreleased()),\n+    NSConsumesSelf(CXCursor_NSConsumesSelf()),\n+    NSConsumed(CXCursor_NSConsumed()),\n+    ObjCException(CXCursor_ObjCException()),\n+    ObjCNSObject(CXCursor_ObjCNSObject()),\n+    ObjCIndependentClass(CXCursor_ObjCIndependentClass()),\n+    ObjCPreciseLifetime(CXCursor_ObjCPreciseLifetime()),\n+    ObjCReturnsInnerPointer(CXCursor_ObjCReturnsInnerPointer()),\n+    ObjCRequiresSuper(CXCursor_ObjCRequiresSuper()),\n+    ObjCRootClass(CXCursor_ObjCRootClass()),\n+    ObjCSubclassingRestricted(CXCursor_ObjCSubclassingRestricted()),\n+    ObjCExplicitProtocolImpl(CXCursor_ObjCExplicitProtocolImpl()),\n+    ObjCDesignatedInitializer(CXCursor_ObjCDesignatedInitializer()),\n+    ObjCRuntimeVisible(CXCursor_ObjCRuntimeVisible()),\n+    ObjCBoxable(CXCursor_ObjCBoxable()),\n+    FlagEnum(CXCursor_FlagEnum()),\n+    ConvergentAttr(CXCursor_ConvergentAttr()),\n+    WarnUnusedAttr(CXCursor_WarnUnusedAttr()),\n+    WarnUnusedResultAttr(CXCursor_WarnUnusedResultAttr()),\n+    AlignedAttr(CXCursor_AlignedAttr()),\n+    MacroDefinition(CXCursor_MacroDefinition()),\n+    MacroExpansion(CXCursor_MacroExpansion()),\n+    MacroInstantiation(CXCursor_MacroInstantiation()),\n+    InclusionDirective(CXCursor_InclusionDirective());\n+\n+    private final int value;\n+\n+    CursorKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CursorKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CursorKind e: CursorKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CursorKind valueOf(int value) {\n+        CursorKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid Cursor kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/CursorKind.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum CursorLanguage {\n+    Invalid(CXLanguage_Invalid(), \"Invalid\"),\n+    C(CXLanguage_C(), \"C\"),\n+    ObjC(CXLanguage_ObjC(), \"Objective C\"),\n+    CPlusPlus(CXLanguage_CPlusPlus(), \"C++\");\n+\n+    private final int code;\n+    private final String name;\n+\n+    CursorLanguage(int code, String name) {\n+        this.code = code;\n+        this.name = name;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    private static final Map<Integer, CursorLanguage> lookup = Arrays.stream(values())\n+            .collect(toMap(CursorLanguage::code, Function.identity()));\n+\n+    public static CursorLanguage valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No CursorLanguage with code: \" + k); });\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/CursorLanguage.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+\n+public class Diagnostic {\n+    final MemoryAddress ptr;\n+\n+    \/\/ Various Diagnostic severity levels - from Clang enum CXDiagnosticSeverity\n+\n+    \/**\n+     * A diagnostic that has been suppressed, e.g., by a command-line\n+     * option.\n+     *\/\n+    public static final int CXDiagnostic_Ignored = Index_h.CXDiagnostic_Ignored();\n+\n+    \/**\n+     * This diagnostic is a note that should be attached to the\n+     * previous (non-note) diagnostic.\n+     *\/\n+    public static final int CXDiagnostic_Note    = Index_h.CXDiagnostic_Note();\n+\n+    \/**\n+     * This diagnostic indicates suspicious code that may not be\n+     * wrong.\n+     *\/\n+    public static final int CXDiagnostic_Warning = Index_h.CXDiagnostic_Warning();\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed.\n+     *\/\n+    public static final int CXDiagnostic_Error   = Index_h.CXDiagnostic_Error();\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed such\n+     * that future parser recovery is unlikely to produce useful\n+     * results.\n+     *\/\n+    public static final int CXDiagnostic_Fatal   = Index_h.CXDiagnostic_Fatal();\n+\n+    Diagnostic(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public int severity() {\n+        return Index_h.clang_getDiagnosticSeverity(ptr);\n+    }\n+\n+    public SourceLocation location() {\n+        return new SourceLocation(Index_h.clang_getDiagnosticLocation(IMPLICIT_ALLOCATOR, ptr));\n+    }\n+\n+    public String spelling() {\n+       return LibClang.CXStrToString(allocator -> Index_h.clang_getDiagnosticSpelling(allocator, ptr));\n+    }\n+\n+    public void dispose() {\n+        Index_h.clang_disposeDiagnostic(ptr);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return LibClang.CXStrToString(allocator ->\n+            Index_h.clang_formatDiagnostic(allocator, ptr,\n+                Index_h.clang_defaultDiagnosticDisplayOptions()));\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Diagnostic.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum ErrorCode {\n+    Success(CXError_Success()),\n+    Failure(CXError_Failure()),\n+    Crashed(CXError_Crashed()),\n+    InvalidArguments(CXError_InvalidArguments()),\n+    ASTReadError(CXError_ASTReadError());\n+\n+    private final int code;\n+\n+    ErrorCode(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())\n+            .collect(toMap(ErrorCode::code, Function.identity()));\n+\n+    public static ErrorCode valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No ErrorCode with code: \" + k); });\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/ErrorCode.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+public class EvalResult implements AutoCloseable {\n+    private MemoryAddress ptr;\n+\n+    public EvalResult(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public enum Kind {\n+        Integral,\n+        FloatingPoint,\n+        StrLiteral,\n+        Erroneous,\n+        Unknown\n+    }\n+\n+    private int getKind0() {\n+        return Index_h.clang_EvalResult_getKind(ptr);\n+    }\n+\n+    public Kind getKind() {\n+        int code = getKind0();\n+        switch (code) {\n+            case 1: return Kind.Integral;\n+            case 2: return Kind.FloatingPoint;\n+            case 3: case 4: case 5:\n+                return Kind.StrLiteral;\n+            default:\n+                return Kind.Unknown;\n+        }\n+    }\n+\n+    private long getAsInt0() {\n+        return Index_h.clang_EvalResult_getAsLongLong(ptr);\n+    }\n+\n+    public long getAsInt() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case Integral:\n+                return getAsInt0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private double getAsFloat0() {\n+        return Index_h.clang_EvalResult_getAsDouble(ptr);\n+    }\n+\n+    public double getAsFloat() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case FloatingPoint:\n+                return getAsFloat0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private String getAsString0() {\n+        MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);\n+        return value.getUtf8String(0);\n+    }\n+\n+    public String getAsString() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case StrLiteral:\n+                return getAsString0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_EvalResult_dispose(ptr);\n+            ptr = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    final static EvalResult erroneous = new EvalResult(MemoryAddress.NULL) {\n+        @Override\n+        public Kind getKind() {\n+            return Kind.Erroneous;\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/do nothing\n+        }\n+    };\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/EvalResult.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_POINTER;\n+\n+public class Index implements AutoCloseable {\n+    \/\/ Pointer to CXIndex\n+    private MemoryAddress ptr;\n+    \/\/ Set of TranslationUnit\n+    public final List<TranslationUnit> translationUnits;\n+\n+    Index(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+        translationUnits = new ArrayList<>();\n+    }\n+\n+    public static class UnsavedFile {\n+        final String file;\n+        final String contents;\n+\n+        private UnsavedFile(Path path, String contents) {\n+            this.file = path.toAbsolutePath().toString();\n+            this.contents = contents;\n+        }\n+\n+        public static UnsavedFile of(Path path, String contents) {\n+            return new UnsavedFile(path, contents);\n+        }\n+    }\n+\n+    public static class ParsingFailedException extends RuntimeException {\n+        private static final long serialVersionUID = -1L;\n+        private final String srcFile;\n+        private final ErrorCode code;\n+\n+        public ParsingFailedException(Path srcFile, ErrorCode code) {\n+            super(\"Failed to parse \" + srcFile.toAbsolutePath().toString() + \": \" + code);\n+            this.srcFile = srcFile.toAbsolutePath().toString();\n+            this.code = code;\n+        }\n+    }\n+\n+    public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)\n+            throws ParsingFailedException {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MemorySegment src = allocator.allocateUtf8String(file);\n+            MemorySegment cargs = args.length == 0 ? null : allocator.allocateArray(C_POINTER, args.length);\n+            for (int i = 0 ; i < args.length ; i++) {\n+                cargs.set(C_POINTER, i * C_POINTER.byteSize(), allocator.allocateUtf8String(args[i]));\n+            }\n+            MemorySegment outAddress = allocator.allocate(C_POINTER);\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(\n+                    ptr,\n+                    src,\n+                    cargs == null ? MemoryAddress.NULL : cargs,\n+                    args.length, MemoryAddress.NULL,\n+                    0,\n+                    options,\n+                    outAddress));\n+\n+            MemoryAddress tu = outAddress.get(C_POINTER, 0);\n+            TranslationUnit rv = new TranslationUnit(tu);\n+            \/\/ even if we failed to parse, we might still have diagnostics\n+            rv.processDiagnostics(dh);\n+\n+            if (code != ErrorCode.Success) {\n+                throw new ParsingFailedException(Path.of(file).toAbsolutePath(), code);\n+            }\n+\n+            translationUnits.add(rv);\n+            return rv;\n+        }\n+    }\n+\n+    private int defaultOptions(boolean detailedPreprocessorRecord) {\n+        int rv = Index_h.CXTranslationUnit_ForSerialization();\n+        rv |= Index_h.CXTranslationUnit_SkipFunctionBodies();\n+        if (detailedPreprocessorRecord) {\n+            rv |= Index_h.CXTranslationUnit_DetailedPreprocessingRecord();\n+        }\n+        return rv;\n+    }\n+\n+    public TranslationUnit parse(String file, Consumer<Diagnostic> dh, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parseTU(file, dh, defaultOptions(detailedPreprocessorRecord), args);\n+    }\n+\n+    public TranslationUnit parse(String file, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parse(file, dh -> {}, detailedPreprocessorRecord, args);\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        for (TranslationUnit tu: translationUnits) {\n+            tu.dispose();\n+        }\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_disposeIndex(ptr);\n+        }\n+        ptr = MemoryAddress.NULL;\n+    }\n+\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Index.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.CXString;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_INT;\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_POINTER;\n+\n+public class LibClang {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"libclang.debug\");\n+    private static final boolean CRASH_RECOVERY = Boolean.getBoolean(\"libclang.crash_recovery\");\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    final static SegmentAllocator IMPLICIT_ALLOCATOR =\n+            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n+    private final static MemorySegment disableCrashRecovery =\n+            IMPLICIT_ALLOCATOR.allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n+\n+    static {\n+        if (!CRASH_RECOVERY) {\n+            \/\/this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the\n+            \/\/first call to createIndex.\n+            try {\n+                CLinker linker = CLinker.systemCLinker();\n+                String putenv = IS_WINDOWS ? \"_putenv\" : \"putenv\";\n+                MethodHandle PUT_ENV = linker.downcallHandle(linker.lookup(putenv).get(),\n+                                FunctionDescriptor.of(C_INT, C_POINTER));\n+                int res = (int) PUT_ENV.invokeExact((Addressable)disableCrashRecovery);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+    }\n+\n+    public static Index createIndex(boolean local) {\n+        Index index = new Index(Index_h.clang_createIndex(local ? 1 : 0, 0));\n+        if (DEBUG) {\n+            System.err.println(\"LibClang crash recovery \" + (CRASH_RECOVERY ? \"enabled\" : \"disabled\"));\n+        }\n+        return index;\n+    }\n+\n+    public static String CXStrToString(Function<SegmentAllocator, MemorySegment> segmentSupplier) {\n+        MemorySegment cxstr = segmentSupplier.apply(STRING_ALLOCATOR);\n+        MemoryAddress buf = Index_h.clang_getCString(cxstr);\n+        String str = buf.getUtf8String(0);\n+        Index_h.clang_disposeString(cxstr);\n+        return str;\n+    }\n+\n+    \/**\n+     * This is an allocator for temporary CXString structs. CXStrToString needs to save the CXString somewhere,\n+     * so that we can extract a Java string out of it. Once that's done, we can dispose the CXString, and the\n+     * associated segment. Since jextract is single-threaded, we can use a prefix allocator, to speed up string\n+     * conversion. The size of the prefix segment is set to 256, which should be enough to hold a CXString.\n+     *\/\n+    private final static SegmentAllocator STRING_ALLOCATOR = SegmentAllocator.prefixAllocator(\n+            MemorySegment.allocateNative(CXString.sizeof(), 8, ResourceScope.newImplicitScope()));\n+\n+    public static String version() {\n+        return CXStrToString(Index_h::clang_getClangVersion);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/LibClang.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+public final class PrintingPolicy implements AutoCloseable {\n+    private MemoryAddress policy;\n+\n+    PrintingPolicy(MemoryAddress policy) {\n+        this.policy = policy;\n+    }\n+\n+    MemoryAddress ptr() {\n+        return policy;\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (policy != MemoryAddress.NULL) {\n+            Index_h.clang_PrintingPolicy_dispose(policy);\n+            policy = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public boolean getProperty(PrintingPolicyProperty prop) {\n+        return Index_h.clang_PrintingPolicy_getProperty(policy, prop.value()) != 0;\n+    }\n+\n+    public void setProperty(PrintingPolicyProperty prop, boolean value) {\n+        Index_h.clang_PrintingPolicy_setProperty(policy, prop.value(), value? 1 : 0);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/PrintingPolicy.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum PrintingPolicyProperty {\n+    Indentation(CXPrintingPolicy_Indentation()),\n+    SuppressSpecifiers(CXPrintingPolicy_SuppressSpecifiers()),\n+    SuppressTagKeyword(CXPrintingPolicy_SuppressTagKeyword()),\n+    IncludeTagDefinition(CXPrintingPolicy_IncludeTagDefinition()),\n+    SuppressScope(CXPrintingPolicy_SuppressScope()),\n+    SuppressUnwrittenScope(CXPrintingPolicy_SuppressUnwrittenScope()),\n+    SuppressInitializers(CXPrintingPolicy_SuppressInitializers()),\n+    ConstantArraySizeAsWritten(CXPrintingPolicy_ConstantArraySizeAsWritten()),\n+    AnonymousTagLocations(CXPrintingPolicy_AnonymousTagLocations()),\n+    SuppressStrongLifetime(CXPrintingPolicy_SuppressStrongLifetime()),\n+    SuppressLifetimeQualifiers(CXPrintingPolicy_SuppressLifetimeQualifiers()),\n+    SuppressTemplateArgsInCXXConstructors(CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors()),\n+    Bool(CXPrintingPolicy_Bool()),\n+    Restrict(CXPrintingPolicy_Restrict()),\n+    Alignof(CXPrintingPolicy_Alignof()),\n+    UnderscoreAlignof(CXPrintingPolicy_UnderscoreAlignof()),\n+    UseVoidForZeroParams(CXPrintingPolicy_UseVoidForZeroParams()),\n+    TerseOutput(CXPrintingPolicy_TerseOutput()),\n+    PolishForDeclaration(CXPrintingPolicy_PolishForDeclaration()),\n+    Half(CXPrintingPolicy_Half()),\n+    MSWChar(CXPrintingPolicy_MSWChar()),\n+    IncludeNewlines(CXPrintingPolicy_IncludeNewlines()),\n+    MSVCFormatting(CXPrintingPolicy_MSVCFormatting()),\n+    ConstantsAsWritten(CXPrintingPolicy_ConstantsAsWritten()),\n+    SuppressImplicitBase(CXPrintingPolicy_SuppressImplicitBase()),\n+    FullyQualifiedName(CXPrintingPolicy_FullyQualifiedName()),\n+    LastProperty(CXPrintingPolicy_LastProperty());\n+\n+    private final int value;\n+\n+    PrintingPolicyProperty(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, PrintingPolicyProperty> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (PrintingPolicyProperty e: PrintingPolicyProperty.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static PrintingPolicyProperty valueOf(int value) {\n+        PrintingPolicyProperty x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid PrintingPolicyProperty value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/PrintingPolicyProperty.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum SaveError {\n+    None(CXSaveError_None()),\n+    Unknown(CXSaveError_Unknown()),\n+    TranslationErrors(CXSaveError_TranslationErrors()),\n+    InvalidTU(CXSaveError_InvalidTU());\n+\n+    private final int code;\n+\n+    SaveError(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())\n+            .collect(toMap(SaveError::code, Function.identity()));\n+\n+    public static SaveError valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No SaveError with code: \" + k); });\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SaveError.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_INT;\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_POINTER;\n+\n+public class SourceLocation {\n+\n+    private final MemorySegment loc;\n+\n+    SourceLocation(MemorySegment loc) {\n+        this.loc = loc;\n+    }\n+\n+    @FunctionalInterface\n+    private interface LocationFactory {\n+        void get(MemorySegment loc, Addressable file,\n+                 Addressable line, Addressable column, Addressable offset);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Location getLocation(LocationFactory fn) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+             MemorySegment file = MemorySegment.allocateNative(C_POINTER, scope);\n+             MemorySegment line = MemorySegment.allocateNative(C_INT, scope);\n+             MemorySegment col = MemorySegment.allocateNative(C_INT, scope);\n+             MemorySegment offset = MemorySegment.allocateNative(C_INT, scope);\n+\n+            fn.get(loc, file, line, col, offset);\n+            MemoryAddress fname = file.get(C_POINTER, 0);\n+            String str = fname == MemoryAddress.NULL ?  null : getFileName(fname);\n+\n+            return new Location(str, line.get(C_INT, 0),\n+                col.get(C_INT, 0), offset.get(C_INT, 0));\n+        }\n+    }\n+\n+    private static String getFileName(MemoryAddress fname) {\n+        return LibClang.CXStrToString(allocator ->\n+                Index_h.clang_getFileName(allocator, fname));\n+    }\n+\n+    public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }\n+    public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }\n+    public Location getSpellingLocation() { return getLocation(Index_h::clang_getSpellingLocation); }\n+    public boolean isInSystemHeader() {\n+        return Index_h.clang_Location_isInSystemHeader(loc) != 0;\n+    }\n+\n+    public boolean isFromMainFile() {\n+        return Index_h.clang_Location_isFromMainFile(loc) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof SourceLocation)) {\n+            return false;\n+        }\n+        SourceLocation sloc = (SourceLocation)other;\n+        return Objects.equals(getFileLocation(), sloc.getFileLocation());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return getFileLocation().hashCode();\n+    }\n+\n+    public final static class Location {\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+        private final int offset;\n+\n+        private Location(String filename, int line, int column, int offset) {\n+            if (filename == null || filename.isEmpty()) {\n+                this.path = null;\n+            } else {\n+                this.path = Paths.get(filename);\n+            }\n+\n+            this.line = line;\n+            this.column = column;\n+            this.offset = offset;\n+        }\n+\n+        public Path path() {\n+            return path;\n+        }\n+\n+        public int line() {\n+            return line;\n+        }\n+\n+        public int column() {\n+            return column;\n+        }\n+\n+        public int offset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!(other instanceof Location)) {\n+                return false;\n+            }\n+            Location loc = (Location)other;\n+            return Objects.equals(path, loc.path) &&\n+                line == loc.line && column == loc.column &&\n+                offset == loc.offset;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(path) ^ line ^ column ^ offset;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Objects.toString(path) + \":\" + line + \":\" + column + \":\" + offset;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SourceLocation.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+\n+public class SourceRange {\n+    final MemorySegment range;\n+\n+    SourceRange(MemorySegment range) {\n+        this.range = range;\n+    }\n+\n+    public SourceLocation getBegin() {\n+        MemorySegment loc = Index_h.clang_getRangeStart(IMPLICIT_ALLOCATOR, range);\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceLocation getEnd() {\n+        MemorySegment loc = Index_h.clang_getRangeEnd(IMPLICIT_ALLOCATOR, range);\n+        return new SourceLocation(loc);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SourceRange.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.CXToken;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+import org.openjdk.jextract.clang.libclang.CXUnsavedFile;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_INT;\n+import static org.openjdk.jextract.clang.libclang.Index_h.C_POINTER;\n+\n+import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+\n+public class TranslationUnit implements AutoCloseable {\n+\n+    private MemoryAddress tu;\n+\n+    TranslationUnit(MemoryAddress tu) {\n+        this.tu = tu;\n+    }\n+\n+    public Cursor getCursor() {\n+        return new Cursor(Index_h.clang_getTranslationUnitCursor(IMPLICIT_ALLOCATOR, tu));\n+    }\n+\n+    public Diagnostic[] getDiagnostics() {\n+        int cntDiags = Index_h.clang_getNumDiagnostics(tu);\n+        Diagnostic[] rv = new Diagnostic[cntDiags];\n+        for (int i = 0; i < cntDiags; i++) {\n+            MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);\n+            rv[i] = new Diagnostic(diag);\n+        }\n+\n+        return rv;\n+    }\n+\n+    public final void save(Path path) throws TranslationUnitSaveException {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment pathStr = allocator.allocateUtf8String(path.toAbsolutePath().toString());\n+            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr, 0));\n+            if (res != SaveError.None) {\n+                throw new TranslationUnitSaveException(path, res);\n+            }\n+        }\n+    }\n+\n+    void processDiagnostics(Consumer<Diagnostic> dh) {\n+        Objects.requireNonNull(dh);\n+        for (Diagnostic diag : getDiagnostics()) {\n+            dh.accept(diag);\n+        }\n+    }\n+\n+    static long FILENAME_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Filename\"));\n+    static long CONTENTS_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Contents\"));\n+    static long LENGTH_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Length\"));\n+\n+    public void reparse(Index.UnsavedFile... inMemoryFiles) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            MemorySegment files = inMemoryFiles.length == 0 ?\n+                    null :\n+                    allocator.allocateArray(CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n+            for (int i = 0; i < inMemoryFiles.length; i++) {\n+                MemorySegment start = files.asSlice(i * CXUnsavedFile.$LAYOUT().byteSize());\n+                start.set(C_POINTER, FILENAME_OFFSET, allocator.allocateUtf8String(inMemoryFiles[i].file));\n+                start.set(C_POINTER, CONTENTS_OFFSET, allocator.allocateUtf8String(inMemoryFiles[i].contents));\n+                start.set(C_INT, LENGTH_OFFSET, inMemoryFiles[i].contents.length());\n+            }\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(\n+                        tu,\n+                        inMemoryFiles.length,\n+                        files == null ? MemoryAddress.NULL : files,\n+                        Index_h.clang_defaultReparseOptions(tu)));\n+\n+            if (code != ErrorCode.Success) {\n+                throw new IllegalStateException(\"Re-parsing failed: \" + code);\n+            }\n+        }\n+    }\n+\n+    public void reparse(Consumer<Diagnostic> dh, Index.UnsavedFile... inMemoryFiles) {\n+        reparse(inMemoryFiles);\n+        processDiagnostics(dh);\n+    }\n+\n+    public String[] tokens(SourceRange range) {\n+        Tokens tokens = tokenize(range);\n+        String rv[] = new String[tokens.size()];\n+        for (int i = 0; i < rv.length; i++) {\n+            rv[i] = tokens.getToken(i).spelling();\n+        }\n+        return rv;\n+    }\n+\n+    public Tokens tokenize(SourceRange range) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment p = MemorySegment.allocateNative(C_POINTER, scope);\n+            MemorySegment pCnt = MemorySegment.allocateNative(C_INT, scope);\n+            Index_h.clang_tokenize(tu, range.range, p, pCnt);\n+            Tokens rv = new Tokens(p.get(C_POINTER, 0), pCnt.get(C_INT, 0));\n+            return rv;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (tu != MemoryAddress.NULL) {\n+            Index_h.clang_disposeTranslationUnit(tu);\n+            tu = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public class Tokens {\n+        private final MemoryAddress ar;\n+        private final int size;\n+\n+        Tokens(MemoryAddress ar, int size) {\n+            this.ar = ar;\n+            this.size = size;\n+        }\n+\n+        public void dispose() {\n+            Index_h.clang_disposeTokens(tu, ar, size);\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public MemorySegment getTokenSegment(int idx) {\n+            MemoryAddress p = ar.addOffset(idx * CXToken.$LAYOUT().byteSize());\n+            return MemorySegment.ofAddress(p, CXToken.$LAYOUT().byteSize(), ResourceScope.newConfinedScope());\n+        }\n+\n+        public Token getToken(int index) {\n+            return new Token(getTokenSegment(index));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < size; i++) {\n+                sb.append(\"Token[\");\n+                sb.append(i);\n+                sb.append(\"]=\");\n+                int pos = i;\n+                sb.append(LibClang.CXStrToString(allocator ->\n+                        Index_h.clang_getTokenSpelling(allocator, tu, getTokenSegment(pos))));\n+                sb.append(\"\\n\");\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    public class Token {\n+        final MemorySegment token;\n+\n+        Token(MemorySegment token) {\n+            this.token = token;\n+        }\n+\n+        public int kind() {\n+            return Index_h.clang_getTokenKind(token);\n+        }\n+\n+        public String spelling() {\n+            return LibClang.CXStrToString(allocator ->\n+                    Index_h.clang_getTokenSpelling(allocator, tu, token));\n+        }\n+\n+        public SourceLocation getLocation() {\n+            return new SourceLocation(Index_h.clang_getTokenLocation(\n+                IMPLICIT_ALLOCATOR, tu, token));\n+        }\n+\n+        public SourceRange getExtent() {\n+            return new SourceRange(Index_h.clang_getTokenExtent(IMPLICIT_ALLOCATOR,\n+                    tu, token));\n+        }\n+    }\n+\n+    public static class TranslationUnitSaveException extends IOException {\n+\n+        static final long serialVersionUID = 1L;\n+\n+        private final SaveError error;\n+\n+        TranslationUnitSaveException(Path path, SaveError error) {\n+            super(\"Cannot save translation unit to: \" + path.toAbsolutePath() + \". Error: \" + error);\n+            this.error = error;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TranslationUnit.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jextract.clang.libclang.CXType;\n+import org.openjdk.jextract.clang.libclang.Index_h;\n+\n+import static org.openjdk.jextract.clang.LibClang.IMPLICIT_ALLOCATOR;\n+\n+public final class Type {\n+    private final MemorySegment type;\n+    Type(MemorySegment type) {\n+        this.type = type;\n+    }\n+\n+    public boolean isInvalid() {\n+        return kind() == TypeKind.Invalid;\n+    }\n+\n+    \/\/ Function Types\n+    public boolean isVariadic() {\n+        return Index_h.clang_isFunctionTypeVariadic(type) != 0;\n+    }\n+    public Type resultType() {\n+        return new Type(Index_h.clang_getResultType(IMPLICIT_ALLOCATOR, type));\n+    }\n+    public int numberOfArgs() {\n+        return Index_h.clang_getNumArgTypes(type);\n+    }\n+    public Type argType(int idx) {\n+        return new Type(Index_h.clang_getArgType(IMPLICIT_ALLOCATOR, type, idx));\n+    }\n+    private int getCallingConvention0() {\n+        return Index_h.clang_getFunctionTypeCallingConv(type);\n+    }\n+\n+    public CallingConvention getCallingConvention() {\n+        int v = getCallingConvention0();\n+        return CallingConvention.valueOf(v);\n+    }\n+\n+    public boolean isPointer() {\n+        var kind = kind();\n+        return kind == TypeKind.Pointer ||\n+            kind == TypeKind.BlockPointer || kind == TypeKind.MemberPointer;\n+    }\n+\n+    public boolean isReference() {\n+        var kind = kind();\n+        return kind == TypeKind.LValueReference || kind == TypeKind.RValueReference;\n+    }\n+\n+    public boolean isArray() {\n+        var kind = kind();\n+        return kind == TypeKind.ConstantArray ||\n+           kind == TypeKind.IncompleteArray ||\n+           kind == TypeKind.VariableArray ||\n+           kind == TypeKind.DependentSizedArray;\n+    }\n+\n+    \/\/ Pointer type\n+    public Type getPointeeType() {\n+        return new Type(Index_h.clang_getPointeeType(IMPLICIT_ALLOCATOR, type));\n+    }\n+\n+    \/\/ array\/vector type\n+    public Type getElementType() {\n+        return new Type(Index_h.clang_getElementType(IMPLICIT_ALLOCATOR, type));\n+    }\n+\n+    public long getNumberOfElements() {\n+        return Index_h.clang_getNumElements(type);\n+    }\n+\n+    \/\/ Struct\/RecordType\n+    private long getOffsetOf0(String fieldName) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment cfname = allocator.allocateUtf8String(fieldName);\n+            return Index_h.clang_Type_getOffsetOf(type, cfname);\n+        }\n+    }\n+\n+    public long getOffsetOf(String fieldName) {\n+        long res = getOffsetOf0(fieldName);\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s, fieldName: %s\", this, fieldName));\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Typedef\n+    \/**\n+     * Return the canonical type for a Type.\n+     *\n+     * Clang's type system explicitly models typedefs and all the ways\n+     * a specific type can be represented.  The canonical type is the underlying\n+     * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n+     * for 'int', the canonical type for 'T' would be 'int'.\n+     *\/\n+    public Type canonicalType() {\n+        return new Type(Index_h.clang_getCanonicalType(IMPLICIT_ALLOCATOR, type));\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"const\" qualifier set,\n+     * without looking through typedefs that may have added \"const\" at a\n+     * different level.\n+     *\/\n+    public boolean isConstQualifierdType() {\n+        return Index_h.clang_isConstQualifiedType(type) != 0;\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"volatile\" qualifier set,\n+     * without looking through typedefs that may have added \"volatile\" at\n+     * a different level.\n+     *\/\n+    public boolean isVolatileQualified() {\n+        return Index_h.clang_isVolatileQualifiedType(type) != 0;\n+    }\n+\n+    public String spelling() {\n+        return LibClang.CXStrToString(allocator ->\n+                Index_h.clang_getTypeSpelling(allocator, type));\n+    }\n+\n+    public int kind0() {\n+        return CXType.kind$get(type);\n+    }\n+\n+    private long size0() {\n+        return Index_h.clang_Type_getSizeOf(type);\n+    }\n+\n+    public long size() {\n+        long res = size0();\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s\", this));\n+        }\n+        return res;\n+    }\n+\n+    public TypeKind kind() {\n+        int v = kind0();\n+        TypeKind rv = TypeKind.valueOf(v);\n+        \/\/ TODO: Atomic type doesn't work\n+        return rv;\n+    }\n+\n+    public Cursor getDeclarationCursor() {\n+        return new Cursor(Index_h.clang_getTypeDeclaration(IMPLICIT_ALLOCATOR, type));\n+    }\n+\n+    public boolean equalType(Type other) {\n+        return Index_h.clang_equalTypes(type, other.type) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Type)) {\n+            return false;\n+        }\n+        return equalType((Type) other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static org.openjdk.jextract.clang.libclang.Index_h.*;\n+\n+public enum TypeKind {\n+\n+    Invalid(CXType_Invalid()),\n+    Unexposed(CXType_Unexposed()),\n+    Void(CXType_Void()),\n+    Bool(CXType_Bool()),\n+    Char_U(CXType_Char_U()),\n+    UChar(CXType_UChar()),\n+    Char16(CXType_Char16()),\n+    Char32(CXType_Char32()),\n+    UShort(CXType_UShort()),\n+    UInt(CXType_UInt()),\n+    ULong(CXType_ULong()),\n+    ULongLong(CXType_ULongLong()),\n+    UInt128(CXType_UInt128()),\n+    Char_S(CXType_Char_S()),\n+    SChar(CXType_SChar()),\n+    WChar(CXType_WChar()),\n+    Short(CXType_Short()),\n+    Int(CXType_Int()),\n+    Long(CXType_Long()),\n+    LongLong(CXType_LongLong()),\n+    Int128(CXType_Int128()),\n+    Float(CXType_Float()),\n+    Double(CXType_Double()),\n+    LongDouble(CXType_LongDouble()),\n+    NullPtr(CXType_NullPtr()),\n+    Overload(CXType_Overload()),\n+    Dependent(CXType_Dependent()),\n+    ObjCId(CXType_ObjCId()),\n+    ObjCClass(CXType_ObjCClass()),\n+    ObjCSel(CXType_ObjCSel()),\n+    Float128(CXType_Float128()),\n+    Half(CXType_Half()),\n+    Float16(CXType_Float16()),\n+    ShortAccum(CXType_ShortAccum()),\n+    Accum(CXType_Accum()),\n+    LongAccum(CXType_LongAccum()),\n+    UShortAccum(CXType_UShortAccum()),\n+    UAccum(CXType_UAccum()),\n+    ULongAccum(CXType_ULongAccum()),\n+    Complex(CXType_Complex()),\n+    Pointer(CXType_Pointer()),\n+    BlockPointer(CXType_BlockPointer()),\n+    LValueReference(CXType_LValueReference()),\n+    RValueReference(CXType_RValueReference()),\n+    Record(CXType_Record()),\n+    Enum(CXType_Enum()),\n+    Typedef(CXType_Typedef()),\n+    ObjCInterface(CXType_ObjCInterface()),\n+    ObjCObjectPointer(CXType_ObjCObjectPointer()),\n+    FunctionNoProto(CXType_FunctionNoProto()),\n+    FunctionProto(CXType_FunctionProto()),\n+    ConstantArray(CXType_ConstantArray()),\n+    Vector(CXType_Vector()),\n+    IncompleteArray(CXType_IncompleteArray()),\n+    VariableArray(CXType_VariableArray()),\n+    DependentSizedArray(CXType_DependentSizedArray()),\n+    MemberPointer(CXType_MemberPointer()),\n+    Auto(CXType_Auto()),\n+    Elaborated(CXType_Elaborated()),\n+    Pipe(CXType_Pipe()),\n+    OCLImage1dRO(CXType_OCLImage1dRO()),\n+    OCLImage1dArrayRO(CXType_OCLImage1dArrayRO()),\n+    OCLImage1dBufferRO(CXType_OCLImage1dBufferRO()),\n+    OCLImage2dRO(CXType_OCLImage2dRO()),\n+    OCLImage2dArrayRO(CXType_OCLImage2dArrayRO()),\n+    OCLImage2dDepthRO(CXType_OCLImage2dDepthRO()),\n+    OCLImage2dArrayDepthRO(CXType_OCLImage2dArrayDepthRO()),\n+    OCLImage2dMSAARO(CXType_OCLImage2dMSAARO()),\n+    OCLImage2dArrayMSAARO(CXType_OCLImage2dArrayMSAARO()),\n+    OCLImage2dMSAADepthRO(CXType_OCLImage2dMSAADepthRO()),\n+    OCLImage2dArrayMSAADepthRO(CXType_OCLImage2dArrayMSAADepthRO()),\n+    OCLImage3dRO(CXType_OCLImage3dRO()),\n+    OCLImage1dWO(CXType_OCLImage1dWO()),\n+    OCLImage1dArrayWO(CXType_OCLImage1dArrayWO()),\n+    OCLImage1dBufferWO(CXType_OCLImage1dBufferWO()),\n+    OCLImage2dWO(CXType_OCLImage2dWO()),\n+    OCLImage2dArrayWO(CXType_OCLImage2dArrayWO()),\n+    OCLImage2dDepthWO(CXType_OCLImage2dDepthWO()),\n+    OCLImage2dArrayDepthWO(CXType_OCLImage2dArrayDepthWO()),\n+    OCLImage2dMSAAWO(CXType_OCLImage2dMSAAWO()),\n+    OCLImage2dArrayMSAAWO(CXType_OCLImage2dArrayMSAAWO()),\n+    OCLImage2dMSAADepthWO(CXType_OCLImage2dMSAADepthWO()),\n+    OCLImage2dArrayMSAADepthWO(CXType_OCLImage2dArrayMSAADepthWO()),\n+    OCLImage3dWO(CXType_OCLImage3dWO()),\n+    OCLImage1dRW(CXType_OCLImage1dRW()),\n+    OCLImage1dArrayRW(CXType_OCLImage1dArrayRW()),\n+    OCLImage1dBufferRW(CXType_OCLImage1dBufferRW()),\n+    OCLImage2dRW(CXType_OCLImage2dRW()),\n+    OCLImage2dArrayRW(CXType_OCLImage2dArrayRW()),\n+    OCLImage2dDepthRW(CXType_OCLImage2dDepthRW()),\n+    OCLImage2dArrayDepthRW(CXType_OCLImage2dArrayDepthRW()),\n+    OCLImage2dMSAARW(CXType_OCLImage2dMSAARW()),\n+    OCLImage2dArrayMSAARW(CXType_OCLImage2dArrayMSAARW()),\n+    OCLImage2dMSAADepthRW(CXType_OCLImage2dMSAADepthRW()),\n+    OCLImage2dArrayMSAADepthRW(CXType_OCLImage2dArrayMSAADepthRW()),\n+    OCLImage3dRW(CXType_OCLImage3dRW()),\n+    OCLSampler(CXType_OCLSampler()),\n+    OCLEvent(CXType_OCLEvent()),\n+    OCLQueue(CXType_OCLQueue()),\n+    OCLReserveID(CXType_OCLReserveID()),\n+    ObjCObject(CXType_ObjCObject()),\n+    ObjCTypeParam(CXType_ObjCTypeParam()),\n+    Attributed(CXType_Attributed()),\n+    OCLIntelSubgroupAVCMcePayload(CXType_OCLIntelSubgroupAVCMcePayload()),\n+    OCLIntelSubgroupAVCImePayload(CXType_OCLIntelSubgroupAVCImePayload()),\n+    OCLIntelSubgroupAVCRefPayload(CXType_OCLIntelSubgroupAVCRefPayload()),\n+    OCLIntelSubgroupAVCSicPayload(CXType_OCLIntelSubgroupAVCSicPayload()),\n+    OCLIntelSubgroupAVCMceResult(CXType_OCLIntelSubgroupAVCMceResult()),\n+    OCLIntelSubgroupAVCImeResult(CXType_OCLIntelSubgroupAVCImeResult()),\n+    OCLIntelSubgroupAVCRefResult(CXType_OCLIntelSubgroupAVCRefResult()),\n+    OCLIntelSubgroupAVCSicResult(CXType_OCLIntelSubgroupAVCSicResult()),\n+    OCLIntelSubgroupAVCImeResultSingleRefStreamout(CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout()),\n+    OCLIntelSubgroupAVCImeResultDualRefStreamout(CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout()),\n+    OCLIntelSubgroupAVCImeSingleRefStreamin(CXType_OCLIntelSubgroupAVCImeSingleRefStreamin()),\n+    OCLIntelSubgroupAVCImeDualRefStreamin(CXType_OCLIntelSubgroupAVCImeDualRefStreamin()),\n+    ExtVector(CXType_ExtVector()),\n+    Atomic(177);  \/\/ This is missing in auto-generated code\n+\n+    private final int value;\n+\n+    TypeKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, TypeKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (TypeKind e: TypeKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static TypeKind valueOf(int value) {\n+        TypeKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"kind = \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TypeKind.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class TypeLayoutError extends IllegalStateException {\n+\n+    private static final long serialVersionUID = 0L;\n+\n+    private final Kind kind;\n+\n+    public TypeLayoutError(long value, String message) {\n+        super(Kind.valueOf(value) + \". \" + message);\n+        this.kind = Kind.valueOf(value);\n+    }\n+\n+    public Kind kind() {\n+        return kind;\n+    }\n+\n+    public static boolean isError(long value) {\n+        return Kind.isError(value);\n+    }\n+\n+    public enum Kind {\n+        Invalid(-1),\n+        Incomplete(-2),\n+        Dependent(-3),\n+        NotConstantSize(-4),\n+        InvalidFieldName(-5);\n+\n+        private final long value;\n+\n+        Kind(long value) {\n+            this.value = value;\n+        }\n+\n+        private final static Map<Long, Kind> lookup;\n+\n+        static {\n+            lookup = new HashMap<>();\n+            for (Kind e: Kind.values()) {\n+                lookup.put(e.value, e);\n+            }\n+        }\n+\n+        public final static Kind valueOf(long value) {\n+            Kind x = lookup.get(value);\n+            if (null == x) {\n+                throw new NoSuchElementException(\"TypeLayoutError = \" + value);\n+            }\n+            return x;\n+        }\n+\n+        public static boolean isError(long value) {\n+            return lookup.containsKey(value);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TypeLayoutError.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public interface CXCursorVisitor {\n+\n+    int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemoryAddress x2);\n+    static NativeSymbol allocate(CXCursorVisitor fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$13.CXCursorVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\", scope);\n+    }\n+    static CXCursorVisitor ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        NativeSymbol symbol = NativeSymbol.ofAddress(\"CXCursorVisitor::\" + Long.toHexString(addr.toRawLongValue()), addr, scope);return (jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemoryAddress x2) -> {\n+            try {\n+                return (int)constants$13.CXCursorVisitor$MH.invokeExact(symbol, x0, x1, x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursorVisitor.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class CXString {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    );\n+    public static MemoryLayout $LAYOUT() {\n+        return CXString.$struct$LAYOUT;\n+    }\n+    static final VarHandle data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"data\"));\n+    public static VarHandle data$VH() {\n+        return CXString.data$VH;\n+    }\n+    public static MemoryAddress data$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXString.data$VH.get(seg);\n+    }\n+    public static void data$set( MemorySegment seg, MemoryAddress x) {\n+        CXString.data$VH.set(seg, x);\n+    }\n+    public static MemoryAddress data$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void data$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXString.data$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle private_flags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"private_flags\"));\n+    public static VarHandle private_flags$VH() {\n+        return CXString.private_flags$VH;\n+    }\n+    public static int private_flags$get(MemorySegment seg) {\n+        return (int)CXString.private_flags$VH.get(seg);\n+    }\n+    public static void private_flags$set( MemorySegment seg, int x) {\n+        CXString.private_flags$VH.set(seg, x);\n+    }\n+    public static int private_flags$get(MemorySegment seg, long index) {\n+        return (int)CXString.private_flags$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void private_flags$set(MemorySegment seg, long index, int x) {\n+        CXString.private_flags$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXString.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class CXToken {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"int_data\"),\n+        ADDRESS.withName(\"ptr_data\")\n+    );\n+    public static MemoryLayout $LAYOUT() {\n+        return CXToken.$struct$LAYOUT;\n+    }\n+    public static MemorySegment int_data$slice(MemorySegment seg) {\n+        return seg.asSlice(0, 16);\n+    }\n+    static final VarHandle ptr_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"ptr_data\"));\n+    public static VarHandle ptr_data$VH() {\n+        return CXToken.ptr_data$VH;\n+    }\n+    public static MemoryAddress ptr_data$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg);\n+    }\n+    public static void ptr_data$set( MemorySegment seg, MemoryAddress x) {\n+        CXToken.ptr_data$VH.set(seg, x);\n+    }\n+    public static MemoryAddress ptr_data$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void ptr_data$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXToken.ptr_data$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXToken.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class CXType {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    );\n+    public static MemoryLayout $LAYOUT() {\n+        return CXType.$struct$LAYOUT;\n+    }\n+    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"kind\"));\n+    public static VarHandle kind$VH() {\n+        return CXType.kind$VH;\n+    }\n+    public static int kind$get(MemorySegment seg) {\n+        return (int)CXType.kind$VH.get(seg);\n+    }\n+    public static void kind$set( MemorySegment seg, int x) {\n+        CXType.kind$VH.set(seg, x);\n+    }\n+    public static int kind$get(MemorySegment seg, long index) {\n+        return (int)CXType.kind$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void kind$set(MemorySegment seg, long index, int x) {\n+        CXType.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static MemorySegment data$slice(MemorySegment seg) {\n+        return seg.asSlice(8, 16);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class CXUnsavedFile {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        ADDRESS.withName(\"Filename\"),\n+        ADDRESS.withName(\"Contents\"),\n+        JAVA_LONG.withName(\"Length\")\n+    ).withName(\"CXUnsavedFile\");\n+    public static MemoryLayout $LAYOUT() {\n+        return CXUnsavedFile.$struct$LAYOUT;\n+    }\n+    static final VarHandle Filename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Filename\"));\n+    public static VarHandle Filename$VH() {\n+        return CXUnsavedFile.Filename$VH;\n+    }\n+    public static MemoryAddress Filename$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg);\n+    }\n+    public static void Filename$set( MemorySegment seg, MemoryAddress x) {\n+        CXUnsavedFile.Filename$VH.set(seg, x);\n+    }\n+    public static MemoryAddress Filename$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Filename$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXUnsavedFile.Filename$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle Contents$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Contents\"));\n+    public static VarHandle Contents$VH() {\n+        return CXUnsavedFile.Contents$VH;\n+    }\n+    public static MemoryAddress Contents$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg);\n+    }\n+    public static void Contents$set( MemorySegment seg, MemoryAddress x) {\n+        CXUnsavedFile.Contents$VH.set(seg, x);\n+    }\n+    public static MemoryAddress Contents$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Contents$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXUnsavedFile.Contents$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"Length\"));\n+    public static VarHandle Length$VH() {\n+        return CXUnsavedFile.Length$VH;\n+    }\n+    public static long Length$get(MemorySegment seg) {\n+        return (long)CXUnsavedFile.Length$VH.get(seg);\n+    }\n+    public static void Length$set( MemorySegment seg, long x) {\n+        CXUnsavedFile.Length$VH.set(seg, x);\n+    }\n+    public static long Length$get(MemorySegment seg, long index) {\n+        return (long)CXUnsavedFile.Length$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Length$set(MemorySegment seg, long index, long x) {\n+        CXUnsavedFile.Length$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXUnsavedFile.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,2874 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+public class Index_h  {\n+\n+    \/* package-private *\/ Index_h() {}\n+    public static ValueLayout.OfByte C_CHAR = JAVA_BYTE;\n+    public static ValueLayout.OfShort C_SHORT = JAVA_SHORT;\n+    public static ValueLayout.OfInt C_INT = JAVA_INT;\n+    public static ValueLayout.OfLong C_LONG = JAVA_LONG;\n+    public static ValueLayout.OfLong C_LONG_LONG = JAVA_LONG;\n+    public static ValueLayout.OfFloat C_FLOAT = JAVA_FLOAT;\n+    public static ValueLayout.OfDouble C_DOUBLE = JAVA_DOUBLE;\n+    public static ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+    public static int CXError_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXError_Failure() {\n+        return (int)1L;\n+    }\n+    public static int CXError_Crashed() {\n+        return (int)2L;\n+    }\n+    public static int CXError_InvalidArguments() {\n+        return (int)3L;\n+    }\n+    public static int CXError_ASTReadError() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getCString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH,\"clang_getCString\");\n+    }\n+    public static MemoryAddress clang_getCString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH, \"clang_getCString\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH,\"clang_disposeString\");\n+    }\n+    public static void clang_disposeString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH, \"clang_disposeString\");\n+        try {\n+            mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static ValueLayout.OfAddress CXIndex = ValueLayout.ADDRESS;\n+    public static ValueLayout.OfAddress CXTranslationUnit = ValueLayout.ADDRESS;\n+    public static int CXCursor_ExceptionSpecificationKind_None() {\n+        return (int)0L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_DynamicNone() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Dynamic() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_MSAny() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_BasicNoexcept() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_ComputedNoexcept() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unevaluated() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Uninstantiated() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unparsed() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_NoThrow() {\n+        return (int)9L;\n+    }\n+    public static MethodHandle clang_createIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH,\"clang_createIndex\");\n+    }\n+    public static MemoryAddress clang_createIndex ( int excludeDeclarationsFromPCH,  int displayDiagnostics) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH, \"clang_createIndex\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH,\"clang_disposeIndex\");\n+    }\n+    public static void clang_disposeIndex ( Addressable index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH, \"clang_disposeIndex\");\n+        try {\n+            mh$.invokeExact(index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH,\"clang_getFileName\");\n+    }\n+    public static MemorySegment clang_getFileName ( SegmentAllocator allocator,  Addressable SFile) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH, \"clang_getFileName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, SFile);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getFileName ( ResourceScope scope,  Addressable SFile) {\n+        return clang_getFileName(SegmentAllocator.nativeAllocator(scope), SFile);\n+    }\n+    public static MethodHandle clang_getNullLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH,\"clang_getNullLocation\");\n+    }\n+    public static MemorySegment clang_getNullLocation ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH, \"clang_getNullLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getNullLocation ( ResourceScope scope) {\n+        return clang_getNullLocation(SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MethodHandle clang_equalLocations$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH,\"clang_equalLocations\");\n+    }\n+    public static int clang_equalLocations ( MemorySegment loc1,  MemorySegment loc2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH, \"clang_equalLocations\");\n+        try {\n+            return (int)mh$.invokeExact(loc1, loc2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH,\"clang_getLocation\");\n+    }\n+    public static MemorySegment clang_getLocation ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int line,  int column) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH, \"clang_getLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, line, column);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getLocation ( ResourceScope scope,  Addressable tu,  Addressable file,  int line,  int column) {\n+        return clang_getLocation(SegmentAllocator.nativeAllocator(scope), tu, file, line, column);\n+    }\n+    public static MethodHandle clang_getLocationForOffset$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH,\"clang_getLocationForOffset\");\n+    }\n+    public static MemorySegment clang_getLocationForOffset ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH, \"clang_getLocationForOffset\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu, file, offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getLocationForOffset ( ResourceScope scope,  Addressable tu,  Addressable file,  int offset) {\n+        return clang_getLocationForOffset(SegmentAllocator.nativeAllocator(scope), tu, file, offset);\n+    }\n+    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH,\"clang_Location_isInSystemHeader\");\n+    }\n+    public static int clang_Location_isInSystemHeader ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH, \"clang_Location_isInSystemHeader\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Location_isFromMainFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH,\"clang_Location_isFromMainFile\");\n+    }\n+    public static int clang_Location_isFromMainFile ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH, \"clang_Location_isFromMainFile\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Range_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH,\"clang_Range_isNull\");\n+    }\n+    public static int clang_Range_isNull ( MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH, \"clang_Range_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getExpansionLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH,\"clang_getExpansionLocation\");\n+    }\n+    public static void clang_getExpansionLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH, \"clang_getExpansionLocation\");\n+        try {\n+            mh$.invokeExact(location, file, line, column, offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getSpellingLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH,\"clang_getSpellingLocation\");\n+    }\n+    public static void clang_getSpellingLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH, \"clang_getSpellingLocation\");\n+        try {\n+            mh$.invokeExact(location, file, line, column, offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH,\"clang_getFileLocation\");\n+    }\n+    public static void clang_getFileLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH, \"clang_getFileLocation\");\n+        try {\n+            mh$.invokeExact(location, file, line, column, offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRangeStart$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH,\"clang_getRangeStart\");\n+    }\n+    public static MemorySegment clang_getRangeStart ( SegmentAllocator allocator,  MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH, \"clang_getRangeStart\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getRangeStart ( ResourceScope scope,  MemorySegment range) {\n+        return clang_getRangeStart(SegmentAllocator.nativeAllocator(scope), range);\n+    }\n+    public static MethodHandle clang_getRangeEnd$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH,\"clang_getRangeEnd\");\n+    }\n+    public static MemorySegment clang_getRangeEnd ( SegmentAllocator allocator,  MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH, \"clang_getRangeEnd\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getRangeEnd ( ResourceScope scope,  MemorySegment range) {\n+        return clang_getRangeEnd(SegmentAllocator.nativeAllocator(scope), range);\n+    }\n+    public static int CXDiagnostic_Ignored() {\n+        return (int)0L;\n+    }\n+    public static int CXDiagnostic_Note() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_Warning() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_Error() {\n+        return (int)3L;\n+    }\n+    public static int CXDiagnostic_Fatal() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getChildDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH,\"clang_getChildDiagnostics\");\n+    }\n+    public static MemoryAddress clang_getChildDiagnostics ( Addressable D) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH, \"clang_getChildDiagnostics\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(D);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH,\"clang_getNumDiagnostics\");\n+    }\n+    public static int clang_getNumDiagnostics ( Addressable Unit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH, \"clang_getNumDiagnostics\");\n+        try {\n+            return (int)mh$.invokeExact(Unit);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH,\"clang_getDiagnostic\");\n+    }\n+    public static MemoryAddress clang_getDiagnostic ( Addressable Unit,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH, \"clang_getDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit, Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH,\"clang_disposeDiagnostic\");\n+    }\n+    public static void clang_disposeDiagnostic ( Addressable Diagnostic) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH, \"clang_disposeDiagnostic\");\n+        try {\n+            mh$.invokeExact(Diagnostic);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXDiagnostic_DisplaySourceLocation() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_DisplayColumn() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_DisplaySourceRanges() {\n+        return (int)4L;\n+    }\n+    public static int CXDiagnostic_DisplayOption() {\n+        return (int)8L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryId() {\n+        return (int)16L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryName() {\n+        return (int)32L;\n+    }\n+    public static MethodHandle clang_formatDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH,\"clang_formatDiagnostic\");\n+    }\n+    public static MemorySegment clang_formatDiagnostic ( SegmentAllocator allocator,  Addressable Diagnostic,  int Options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH, \"clang_formatDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic, Options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_formatDiagnostic ( ResourceScope scope,  Addressable Diagnostic,  int Options) {\n+        return clang_formatDiagnostic(SegmentAllocator.nativeAllocator(scope), Diagnostic, Options);\n+    }\n+    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH,\"clang_defaultDiagnosticDisplayOptions\");\n+    }\n+    public static int clang_defaultDiagnosticDisplayOptions () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH, \"clang_defaultDiagnosticDisplayOptions\");\n+        try {\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH,\"clang_getDiagnosticSeverity\");\n+    }\n+    public static int clang_getDiagnosticSeverity ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH, \"clang_getDiagnosticSeverity\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH,\"clang_getDiagnosticLocation\");\n+    }\n+    public static MemorySegment clang_getDiagnosticLocation ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH, \"clang_getDiagnosticLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getDiagnosticLocation ( ResourceScope scope,  Addressable x1) {\n+        return clang_getDiagnosticLocation(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH,\"clang_getDiagnosticSpelling\");\n+    }\n+    public static MemorySegment clang_getDiagnosticSpelling ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH, \"clang_getDiagnosticSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getDiagnosticSpelling ( ResourceScope scope,  Addressable x1) {\n+        return clang_getDiagnosticSpelling(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static int CXTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static int CXTranslationUnit_DetailedPreprocessingRecord() {\n+        return (int)1L;\n+    }\n+    public static int CXTranslationUnit_Incomplete() {\n+        return (int)2L;\n+    }\n+    public static int CXTranslationUnit_PrecompiledPreamble() {\n+        return (int)4L;\n+    }\n+    public static int CXTranslationUnit_CacheCompletionResults() {\n+        return (int)8L;\n+    }\n+    public static int CXTranslationUnit_ForSerialization() {\n+        return (int)16L;\n+    }\n+    public static int CXTranslationUnit_CXXChainedPCH() {\n+        return (int)32L;\n+    }\n+    public static int CXTranslationUnit_SkipFunctionBodies() {\n+        return (int)64L;\n+    }\n+    public static int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion() {\n+        return (int)128L;\n+    }\n+    public static int CXTranslationUnit_CreatePreambleOnFirstParse() {\n+        return (int)256L;\n+    }\n+    public static int CXTranslationUnit_KeepGoing() {\n+        return (int)512L;\n+    }\n+    public static int CXTranslationUnit_SingleFileParse() {\n+        return (int)1024L;\n+    }\n+    public static int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble() {\n+        return (int)2048L;\n+    }\n+    public static int CXTranslationUnit_IncludeAttributedTypes() {\n+        return (int)4096L;\n+    }\n+    public static int CXTranslationUnit_VisitImplicitAttributes() {\n+        return (int)8192L;\n+    }\n+    public static int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles() {\n+        return (int)16384L;\n+    }\n+    public static int CXTranslationUnit_RetainExcludedConditionalBlocks() {\n+        return (int)32768L;\n+    }\n+    public static MethodHandle clang_parseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH,\"clang_parseTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_parseTranslationUnit ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH, \"clang_parseTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_parseTranslationUnit2$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH,\"clang_parseTranslationUnit2\");\n+    }\n+    public static int clang_parseTranslationUnit2 ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options,  Addressable out_TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH, \"clang_parseTranslationUnit2\");\n+        try {\n+            return (int)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXSaveTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSaveError_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSaveError_Unknown() {\n+        return (int)1L;\n+    }\n+    public static int CXSaveError_TranslationErrors() {\n+        return (int)2L;\n+    }\n+    public static int CXSaveError_InvalidTU() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_saveTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH,\"clang_saveTranslationUnit\");\n+    }\n+    public static int clang_saveTranslationUnit ( Addressable TU,  Addressable FileName,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH, \"clang_saveTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU, FileName, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH,\"clang_disposeTranslationUnit\");\n+    }\n+    public static void clang_disposeTranslationUnit ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH, \"clang_disposeTranslationUnit\");\n+        try {\n+            mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXReparse_None() {\n+        return (int)0L;\n+    }\n+    public static MethodHandle clang_defaultReparseOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH,\"clang_defaultReparseOptions\");\n+    }\n+    public static int clang_defaultReparseOptions ( Addressable TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH, \"clang_defaultReparseOptions\");\n+        try {\n+            return (int)mh$.invokeExact(TU);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_reparseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH,\"clang_reparseTranslationUnit\");\n+    }\n+    public static int clang_reparseTranslationUnit ( Addressable TU,  int num_unsaved_files,  Addressable unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH, \"clang_reparseTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU, num_unsaved_files, unsaved_files, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXCursor_UnexposedDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_StructDecl() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_UnionDecl() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ClassDecl() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_EnumDecl() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_FieldDecl() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_EnumConstantDecl() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_FunctionDecl() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_VarDecl() {\n+        return (int)9L;\n+    }\n+    public static int CXCursor_ParmDecl() {\n+        return (int)10L;\n+    }\n+    public static int CXCursor_ObjCInterfaceDecl() {\n+        return (int)11L;\n+    }\n+    public static int CXCursor_ObjCCategoryDecl() {\n+        return (int)12L;\n+    }\n+    public static int CXCursor_ObjCProtocolDecl() {\n+        return (int)13L;\n+    }\n+    public static int CXCursor_ObjCPropertyDecl() {\n+        return (int)14L;\n+    }\n+    public static int CXCursor_ObjCIvarDecl() {\n+        return (int)15L;\n+    }\n+    public static int CXCursor_ObjCInstanceMethodDecl() {\n+        return (int)16L;\n+    }\n+    public static int CXCursor_ObjCClassMethodDecl() {\n+        return (int)17L;\n+    }\n+    public static int CXCursor_ObjCImplementationDecl() {\n+        return (int)18L;\n+    }\n+    public static int CXCursor_ObjCCategoryImplDecl() {\n+        return (int)19L;\n+    }\n+    public static int CXCursor_TypedefDecl() {\n+        return (int)20L;\n+    }\n+    public static int CXCursor_CXXMethod() {\n+        return (int)21L;\n+    }\n+    public static int CXCursor_Namespace() {\n+        return (int)22L;\n+    }\n+    public static int CXCursor_LinkageSpec() {\n+        return (int)23L;\n+    }\n+    public static int CXCursor_Constructor() {\n+        return (int)24L;\n+    }\n+    public static int CXCursor_Destructor() {\n+        return (int)25L;\n+    }\n+    public static int CXCursor_ConversionFunction() {\n+        return (int)26L;\n+    }\n+    public static int CXCursor_TemplateTypeParameter() {\n+        return (int)27L;\n+    }\n+    public static int CXCursor_NonTypeTemplateParameter() {\n+        return (int)28L;\n+    }\n+    public static int CXCursor_TemplateTemplateParameter() {\n+        return (int)29L;\n+    }\n+    public static int CXCursor_FunctionTemplate() {\n+        return (int)30L;\n+    }\n+    public static int CXCursor_ClassTemplate() {\n+        return (int)31L;\n+    }\n+    public static int CXCursor_ClassTemplatePartialSpecialization() {\n+        return (int)32L;\n+    }\n+    public static int CXCursor_NamespaceAlias() {\n+        return (int)33L;\n+    }\n+    public static int CXCursor_UsingDirective() {\n+        return (int)34L;\n+    }\n+    public static int CXCursor_UsingDeclaration() {\n+        return (int)35L;\n+    }\n+    public static int CXCursor_TypeAliasDecl() {\n+        return (int)36L;\n+    }\n+    public static int CXCursor_ObjCSynthesizeDecl() {\n+        return (int)37L;\n+    }\n+    public static int CXCursor_ObjCDynamicDecl() {\n+        return (int)38L;\n+    }\n+    public static int CXCursor_CXXAccessSpecifier() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_LastDecl() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCSuperClassRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCProtocolRef() {\n+        return (int)41L;\n+    }\n+    public static int CXCursor_ObjCClassRef() {\n+        return (int)42L;\n+    }\n+    public static int CXCursor_TypeRef() {\n+        return (int)43L;\n+    }\n+    public static int CXCursor_CXXBaseSpecifier() {\n+        return (int)44L;\n+    }\n+    public static int CXCursor_TemplateRef() {\n+        return (int)45L;\n+    }\n+    public static int CXCursor_NamespaceRef() {\n+        return (int)46L;\n+    }\n+    public static int CXCursor_MemberRef() {\n+        return (int)47L;\n+    }\n+    public static int CXCursor_LabelRef() {\n+        return (int)48L;\n+    }\n+    public static int CXCursor_OverloadedDeclRef() {\n+        return (int)49L;\n+    }\n+    public static int CXCursor_VariableRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_LastRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_FirstInvalid() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_InvalidFile() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_NoDeclFound() {\n+        return (int)71L;\n+    }\n+    public static int CXCursor_NotImplemented() {\n+        return (int)72L;\n+    }\n+    public static int CXCursor_InvalidCode() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_LastInvalid() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_FirstExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_UnexposedExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_DeclRefExpr() {\n+        return (int)101L;\n+    }\n+    public static int CXCursor_MemberRefExpr() {\n+        return (int)102L;\n+    }\n+    public static int CXCursor_CallExpr() {\n+        return (int)103L;\n+    }\n+    public static int CXCursor_ObjCMessageExpr() {\n+        return (int)104L;\n+    }\n+    public static int CXCursor_BlockExpr() {\n+        return (int)105L;\n+    }\n+    public static int CXCursor_IntegerLiteral() {\n+        return (int)106L;\n+    }\n+    public static int CXCursor_FloatingLiteral() {\n+        return (int)107L;\n+    }\n+    public static int CXCursor_ImaginaryLiteral() {\n+        return (int)108L;\n+    }\n+    public static int CXCursor_StringLiteral() {\n+        return (int)109L;\n+    }\n+    public static int CXCursor_CharacterLiteral() {\n+        return (int)110L;\n+    }\n+    public static int CXCursor_ParenExpr() {\n+        return (int)111L;\n+    }\n+    public static int CXCursor_UnaryOperator() {\n+        return (int)112L;\n+    }\n+    public static int CXCursor_ArraySubscriptExpr() {\n+        return (int)113L;\n+    }\n+    public static int CXCursor_BinaryOperator() {\n+        return (int)114L;\n+    }\n+    public static int CXCursor_CompoundAssignOperator() {\n+        return (int)115L;\n+    }\n+    public static int CXCursor_ConditionalOperator() {\n+        return (int)116L;\n+    }\n+    public static int CXCursor_CStyleCastExpr() {\n+        return (int)117L;\n+    }\n+    public static int CXCursor_CompoundLiteralExpr() {\n+        return (int)118L;\n+    }\n+    public static int CXCursor_InitListExpr() {\n+        return (int)119L;\n+    }\n+    public static int CXCursor_AddrLabelExpr() {\n+        return (int)120L;\n+    }\n+    public static int CXCursor_StmtExpr() {\n+        return (int)121L;\n+    }\n+    public static int CXCursor_GenericSelectionExpr() {\n+        return (int)122L;\n+    }\n+    public static int CXCursor_GNUNullExpr() {\n+        return (int)123L;\n+    }\n+    public static int CXCursor_CXXStaticCastExpr() {\n+        return (int)124L;\n+    }\n+    public static int CXCursor_CXXDynamicCastExpr() {\n+        return (int)125L;\n+    }\n+    public static int CXCursor_CXXReinterpretCastExpr() {\n+        return (int)126L;\n+    }\n+    public static int CXCursor_CXXConstCastExpr() {\n+        return (int)127L;\n+    }\n+    public static int CXCursor_CXXFunctionalCastExpr() {\n+        return (int)128L;\n+    }\n+    public static int CXCursor_CXXTypeidExpr() {\n+        return (int)129L;\n+    }\n+    public static int CXCursor_CXXBoolLiteralExpr() {\n+        return (int)130L;\n+    }\n+    public static int CXCursor_CXXNullPtrLiteralExpr() {\n+        return (int)131L;\n+    }\n+    public static int CXCursor_CXXThisExpr() {\n+        return (int)132L;\n+    }\n+    public static int CXCursor_CXXThrowExpr() {\n+        return (int)133L;\n+    }\n+    public static int CXCursor_CXXNewExpr() {\n+        return (int)134L;\n+    }\n+    public static int CXCursor_CXXDeleteExpr() {\n+        return (int)135L;\n+    }\n+    public static int CXCursor_UnaryExpr() {\n+        return (int)136L;\n+    }\n+    public static int CXCursor_ObjCStringLiteral() {\n+        return (int)137L;\n+    }\n+    public static int CXCursor_ObjCEncodeExpr() {\n+        return (int)138L;\n+    }\n+    public static int CXCursor_ObjCSelectorExpr() {\n+        return (int)139L;\n+    }\n+    public static int CXCursor_ObjCProtocolExpr() {\n+        return (int)140L;\n+    }\n+    public static int CXCursor_ObjCBridgedCastExpr() {\n+        return (int)141L;\n+    }\n+    public static int CXCursor_PackExpansionExpr() {\n+        return (int)142L;\n+    }\n+    public static int CXCursor_SizeOfPackExpr() {\n+        return (int)143L;\n+    }\n+    public static int CXCursor_LambdaExpr() {\n+        return (int)144L;\n+    }\n+    public static int CXCursor_ObjCBoolLiteralExpr() {\n+        return (int)145L;\n+    }\n+    public static int CXCursor_ObjCSelfExpr() {\n+        return (int)146L;\n+    }\n+    public static int CXCursor_OMPArraySectionExpr() {\n+        return (int)147L;\n+    }\n+    public static int CXCursor_ObjCAvailabilityCheckExpr() {\n+        return (int)148L;\n+    }\n+    public static int CXCursor_FixedPointLiteral() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_LastExpr() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_FirstStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_UnexposedStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_LabelStmt() {\n+        return (int)201L;\n+    }\n+    public static int CXCursor_CompoundStmt() {\n+        return (int)202L;\n+    }\n+    public static int CXCursor_CaseStmt() {\n+        return (int)203L;\n+    }\n+    public static int CXCursor_DefaultStmt() {\n+        return (int)204L;\n+    }\n+    public static int CXCursor_IfStmt() {\n+        return (int)205L;\n+    }\n+    public static int CXCursor_SwitchStmt() {\n+        return (int)206L;\n+    }\n+    public static int CXCursor_WhileStmt() {\n+        return (int)207L;\n+    }\n+    public static int CXCursor_DoStmt() {\n+        return (int)208L;\n+    }\n+    public static int CXCursor_ForStmt() {\n+        return (int)209L;\n+    }\n+    public static int CXCursor_GotoStmt() {\n+        return (int)210L;\n+    }\n+    public static int CXCursor_IndirectGotoStmt() {\n+        return (int)211L;\n+    }\n+    public static int CXCursor_ContinueStmt() {\n+        return (int)212L;\n+    }\n+    public static int CXCursor_BreakStmt() {\n+        return (int)213L;\n+    }\n+    public static int CXCursor_ReturnStmt() {\n+        return (int)214L;\n+    }\n+    public static int CXCursor_GCCAsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_AsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_ObjCAtTryStmt() {\n+        return (int)216L;\n+    }\n+    public static int CXCursor_ObjCAtCatchStmt() {\n+        return (int)217L;\n+    }\n+    public static int CXCursor_ObjCAtFinallyStmt() {\n+        return (int)218L;\n+    }\n+    public static int CXCursor_ObjCAtThrowStmt() {\n+        return (int)219L;\n+    }\n+    public static int CXCursor_ObjCAtSynchronizedStmt() {\n+        return (int)220L;\n+    }\n+    public static int CXCursor_ObjCAutoreleasePoolStmt() {\n+        return (int)221L;\n+    }\n+    public static int CXCursor_ObjCForCollectionStmt() {\n+        return (int)222L;\n+    }\n+    public static int CXCursor_CXXCatchStmt() {\n+        return (int)223L;\n+    }\n+    public static int CXCursor_CXXTryStmt() {\n+        return (int)224L;\n+    }\n+    public static int CXCursor_CXXForRangeStmt() {\n+        return (int)225L;\n+    }\n+    public static int CXCursor_SEHTryStmt() {\n+        return (int)226L;\n+    }\n+    public static int CXCursor_SEHExceptStmt() {\n+        return (int)227L;\n+    }\n+    public static int CXCursor_SEHFinallyStmt() {\n+        return (int)228L;\n+    }\n+    public static int CXCursor_MSAsmStmt() {\n+        return (int)229L;\n+    }\n+    public static int CXCursor_NullStmt() {\n+        return (int)230L;\n+    }\n+    public static int CXCursor_DeclStmt() {\n+        return (int)231L;\n+    }\n+    public static int CXCursor_OMPParallelDirective() {\n+        return (int)232L;\n+    }\n+    public static int CXCursor_OMPSimdDirective() {\n+        return (int)233L;\n+    }\n+    public static int CXCursor_OMPForDirective() {\n+        return (int)234L;\n+    }\n+    public static int CXCursor_OMPSectionsDirective() {\n+        return (int)235L;\n+    }\n+    public static int CXCursor_OMPSectionDirective() {\n+        return (int)236L;\n+    }\n+    public static int CXCursor_OMPSingleDirective() {\n+        return (int)237L;\n+    }\n+    public static int CXCursor_OMPParallelForDirective() {\n+        return (int)238L;\n+    }\n+    public static int CXCursor_OMPParallelSectionsDirective() {\n+        return (int)239L;\n+    }\n+    public static int CXCursor_OMPTaskDirective() {\n+        return (int)240L;\n+    }\n+    public static int CXCursor_OMPMasterDirective() {\n+        return (int)241L;\n+    }\n+    public static int CXCursor_OMPCriticalDirective() {\n+        return (int)242L;\n+    }\n+    public static int CXCursor_OMPTaskyieldDirective() {\n+        return (int)243L;\n+    }\n+    public static int CXCursor_OMPBarrierDirective() {\n+        return (int)244L;\n+    }\n+    public static int CXCursor_OMPTaskwaitDirective() {\n+        return (int)245L;\n+    }\n+    public static int CXCursor_OMPFlushDirective() {\n+        return (int)246L;\n+    }\n+    public static int CXCursor_SEHLeaveStmt() {\n+        return (int)247L;\n+    }\n+    public static int CXCursor_OMPOrderedDirective() {\n+        return (int)248L;\n+    }\n+    public static int CXCursor_OMPAtomicDirective() {\n+        return (int)249L;\n+    }\n+    public static int CXCursor_OMPForSimdDirective() {\n+        return (int)250L;\n+    }\n+    public static int CXCursor_OMPParallelForSimdDirective() {\n+        return (int)251L;\n+    }\n+    public static int CXCursor_OMPTargetDirective() {\n+        return (int)252L;\n+    }\n+    public static int CXCursor_OMPTeamsDirective() {\n+        return (int)253L;\n+    }\n+    public static int CXCursor_OMPTaskgroupDirective() {\n+        return (int)254L;\n+    }\n+    public static int CXCursor_OMPCancellationPointDirective() {\n+        return (int)255L;\n+    }\n+    public static int CXCursor_OMPCancelDirective() {\n+        return (int)256L;\n+    }\n+    public static int CXCursor_OMPTargetDataDirective() {\n+        return (int)257L;\n+    }\n+    public static int CXCursor_OMPTaskLoopDirective() {\n+        return (int)258L;\n+    }\n+    public static int CXCursor_OMPTaskLoopSimdDirective() {\n+        return (int)259L;\n+    }\n+    public static int CXCursor_OMPDistributeDirective() {\n+        return (int)260L;\n+    }\n+    public static int CXCursor_OMPTargetEnterDataDirective() {\n+        return (int)261L;\n+    }\n+    public static int CXCursor_OMPTargetExitDataDirective() {\n+        return (int)262L;\n+    }\n+    public static int CXCursor_OMPTargetParallelDirective() {\n+        return (int)263L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForDirective() {\n+        return (int)264L;\n+    }\n+    public static int CXCursor_OMPTargetUpdateDirective() {\n+        return (int)265L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForDirective() {\n+        return (int)266L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForSimdDirective() {\n+        return (int)267L;\n+    }\n+    public static int CXCursor_OMPDistributeSimdDirective() {\n+        return (int)268L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForSimdDirective() {\n+        return (int)269L;\n+    }\n+    public static int CXCursor_OMPTargetSimdDirective() {\n+        return (int)270L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeDirective() {\n+        return (int)271L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeSimdDirective() {\n+        return (int)272L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForSimdDirective() {\n+        return (int)273L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForDirective() {\n+        return (int)274L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDirective() {\n+        return (int)275L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeDirective() {\n+        return (int)276L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForDirective() {\n+        return (int)277L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective() {\n+        return (int)278L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeSimdDirective() {\n+        return (int)279L;\n+    }\n+    public static int CXCursor_BuiltinBitCastExpr() {\n+        return (int)280L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopDirective() {\n+        return (int)281L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopDirective() {\n+        return (int)282L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopSimdDirective() {\n+        return (int)283L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopSimdDirective() {\n+        return (int)284L;\n+    }\n+    public static int CXCursor_LastStmt() {\n+        return (int)285L;\n+    }\n+    public static int CXCursor_TranslationUnit() {\n+        return (int)300L;\n+    }\n+    public static int CXCursor_FirstAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_UnexposedAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_IBActionAttr() {\n+        return (int)401L;\n+    }\n+    public static int CXCursor_IBOutletAttr() {\n+        return (int)402L;\n+    }\n+    public static int CXCursor_IBOutletCollectionAttr() {\n+        return (int)403L;\n+    }\n+    public static int CXCursor_CXXFinalAttr() {\n+        return (int)404L;\n+    }\n+    public static int CXCursor_CXXOverrideAttr() {\n+        return (int)405L;\n+    }\n+    public static int CXCursor_AnnotateAttr() {\n+        return (int)406L;\n+    }\n+    public static int CXCursor_AsmLabelAttr() {\n+        return (int)407L;\n+    }\n+    public static int CXCursor_PackedAttr() {\n+        return (int)408L;\n+    }\n+    public static int CXCursor_PureAttr() {\n+        return (int)409L;\n+    }\n+    public static int CXCursor_ConstAttr() {\n+        return (int)410L;\n+    }\n+    public static int CXCursor_NoDuplicateAttr() {\n+        return (int)411L;\n+    }\n+    public static int CXCursor_CUDAConstantAttr() {\n+        return (int)412L;\n+    }\n+    public static int CXCursor_CUDADeviceAttr() {\n+        return (int)413L;\n+    }\n+    public static int CXCursor_CUDAGlobalAttr() {\n+        return (int)414L;\n+    }\n+    public static int CXCursor_CUDAHostAttr() {\n+        return (int)415L;\n+    }\n+    public static int CXCursor_CUDASharedAttr() {\n+        return (int)416L;\n+    }\n+    public static int CXCursor_VisibilityAttr() {\n+        return (int)417L;\n+    }\n+    public static int CXCursor_DLLExport() {\n+        return (int)418L;\n+    }\n+    public static int CXCursor_DLLImport() {\n+        return (int)419L;\n+    }\n+    public static int CXCursor_NSReturnsRetained() {\n+        return (int)420L;\n+    }\n+    public static int CXCursor_NSReturnsNotRetained() {\n+        return (int)421L;\n+    }\n+    public static int CXCursor_NSReturnsAutoreleased() {\n+        return (int)422L;\n+    }\n+    public static int CXCursor_NSConsumesSelf() {\n+        return (int)423L;\n+    }\n+    public static int CXCursor_NSConsumed() {\n+        return (int)424L;\n+    }\n+    public static int CXCursor_ObjCException() {\n+        return (int)425L;\n+    }\n+    public static int CXCursor_ObjCNSObject() {\n+        return (int)426L;\n+    }\n+    public static int CXCursor_ObjCIndependentClass() {\n+        return (int)427L;\n+    }\n+    public static int CXCursor_ObjCPreciseLifetime() {\n+        return (int)428L;\n+    }\n+    public static int CXCursor_ObjCReturnsInnerPointer() {\n+        return (int)429L;\n+    }\n+    public static int CXCursor_ObjCRequiresSuper() {\n+        return (int)430L;\n+    }\n+    public static int CXCursor_ObjCRootClass() {\n+        return (int)431L;\n+    }\n+    public static int CXCursor_ObjCSubclassingRestricted() {\n+        return (int)432L;\n+    }\n+    public static int CXCursor_ObjCExplicitProtocolImpl() {\n+        return (int)433L;\n+    }\n+    public static int CXCursor_ObjCDesignatedInitializer() {\n+        return (int)434L;\n+    }\n+    public static int CXCursor_ObjCRuntimeVisible() {\n+        return (int)435L;\n+    }\n+    public static int CXCursor_ObjCBoxable() {\n+        return (int)436L;\n+    }\n+    public static int CXCursor_FlagEnum() {\n+        return (int)437L;\n+    }\n+    public static int CXCursor_ConvergentAttr() {\n+        return (int)438L;\n+    }\n+    public static int CXCursor_WarnUnusedAttr() {\n+        return (int)439L;\n+    }\n+    public static int CXCursor_WarnUnusedResultAttr() {\n+        return (int)440L;\n+    }\n+    public static int CXCursor_AlignedAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_LastAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_PreprocessingDirective() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_MacroDefinition() {\n+        return (int)501L;\n+    }\n+    public static int CXCursor_MacroExpansion() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_MacroInstantiation() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_InclusionDirective() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_FirstPreprocessing() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_LastPreprocessing() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_ModuleImportDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_TypeAliasTemplateDecl() {\n+        return (int)601L;\n+    }\n+    public static int CXCursor_StaticAssert() {\n+        return (int)602L;\n+    }\n+    public static int CXCursor_FriendDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_FirstExtraDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_LastExtraDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_OverloadCandidate() {\n+        return (int)700L;\n+    }\n+    public static MethodHandle clang_getNullCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH,\"clang_getNullCursor\");\n+    }\n+    public static MemorySegment clang_getNullCursor ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH, \"clang_getNullCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getNullCursor ( ResourceScope scope) {\n+        return clang_getNullCursor(SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH,\"clang_getTranslationUnitCursor\");\n+    }\n+    public static MemorySegment clang_getTranslationUnitCursor ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH, \"clang_getTranslationUnitCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTranslationUnitCursor ( ResourceScope scope,  Addressable x1) {\n+        return clang_getTranslationUnitCursor(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_equalCursors$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH,\"clang_equalCursors\");\n+    }\n+    public static int clang_equalCursors ( MemorySegment x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH, \"clang_equalCursors\");\n+        try {\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH,\"clang_Cursor_isNull\");\n+    }\n+    public static int clang_Cursor_isNull ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH, \"clang_Cursor_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH,\"clang_getCursorKind\");\n+    }\n+    public static int clang_getCursorKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH, \"clang_getCursorKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH,\"clang_isDeclaration\");\n+    }\n+    public static int clang_isDeclaration ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH, \"clang_isDeclaration\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isAttribute$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH,\"clang_isAttribute\");\n+    }\n+    public static int clang_isAttribute ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH, \"clang_isAttribute\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isInvalid$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH,\"clang_isInvalid\");\n+    }\n+    public static int clang_isInvalid ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH, \"clang_isInvalid\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isPreprocessing$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH,\"clang_isPreprocessing\");\n+    }\n+    public static int clang_isPreprocessing ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH, \"clang_isPreprocessing\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXLanguage_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXLanguage_C() {\n+        return (int)1L;\n+    }\n+    public static int CXLanguage_ObjC() {\n+        return (int)2L;\n+    }\n+    public static int CXLanguage_CPlusPlus() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_getCursorLanguage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorLanguage$MH,\"clang_getCursorLanguage\");\n+    }\n+    public static int clang_getCursorLanguage ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getCursorLanguage$MH, \"clang_getCursorLanguage\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH,\"clang_Cursor_getTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_Cursor_getTranslationUnit ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH, \"clang_Cursor_getTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH,\"clang_getCursorLocation\");\n+    }\n+    public static MemorySegment clang_getCursorLocation ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH, \"clang_getCursorLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorLocation ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorLocation(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH,\"clang_getCursorExtent\");\n+    }\n+    public static MemorySegment clang_getCursorExtent ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH, \"clang_getCursorExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorExtent ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorExtent(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static int CXType_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXType_Unexposed() {\n+        return (int)1L;\n+    }\n+    public static int CXType_Void() {\n+        return (int)2L;\n+    }\n+    public static int CXType_Bool() {\n+        return (int)3L;\n+    }\n+    public static int CXType_Char_U() {\n+        return (int)4L;\n+    }\n+    public static int CXType_UChar() {\n+        return (int)5L;\n+    }\n+    public static int CXType_Char16() {\n+        return (int)6L;\n+    }\n+    public static int CXType_Char32() {\n+        return (int)7L;\n+    }\n+    public static int CXType_UShort() {\n+        return (int)8L;\n+    }\n+    public static int CXType_UInt() {\n+        return (int)9L;\n+    }\n+    public static int CXType_ULong() {\n+        return (int)10L;\n+    }\n+    public static int CXType_ULongLong() {\n+        return (int)11L;\n+    }\n+    public static int CXType_UInt128() {\n+        return (int)12L;\n+    }\n+    public static int CXType_Char_S() {\n+        return (int)13L;\n+    }\n+    public static int CXType_SChar() {\n+        return (int)14L;\n+    }\n+    public static int CXType_WChar() {\n+        return (int)15L;\n+    }\n+    public static int CXType_Short() {\n+        return (int)16L;\n+    }\n+    public static int CXType_Int() {\n+        return (int)17L;\n+    }\n+    public static int CXType_Long() {\n+        return (int)18L;\n+    }\n+    public static int CXType_LongLong() {\n+        return (int)19L;\n+    }\n+    public static int CXType_Int128() {\n+        return (int)20L;\n+    }\n+    public static int CXType_Float() {\n+        return (int)21L;\n+    }\n+    public static int CXType_Double() {\n+        return (int)22L;\n+    }\n+    public static int CXType_LongDouble() {\n+        return (int)23L;\n+    }\n+    public static int CXType_NullPtr() {\n+        return (int)24L;\n+    }\n+    public static int CXType_Overload() {\n+        return (int)25L;\n+    }\n+    public static int CXType_Dependent() {\n+        return (int)26L;\n+    }\n+    public static int CXType_ObjCId() {\n+        return (int)27L;\n+    }\n+    public static int CXType_ObjCClass() {\n+        return (int)28L;\n+    }\n+    public static int CXType_ObjCSel() {\n+        return (int)29L;\n+    }\n+    public static int CXType_Float128() {\n+        return (int)30L;\n+    }\n+    public static int CXType_Half() {\n+        return (int)31L;\n+    }\n+    public static int CXType_Float16() {\n+        return (int)32L;\n+    }\n+    public static int CXType_ShortAccum() {\n+        return (int)33L;\n+    }\n+    public static int CXType_Accum() {\n+        return (int)34L;\n+    }\n+    public static int CXType_LongAccum() {\n+        return (int)35L;\n+    }\n+    public static int CXType_UShortAccum() {\n+        return (int)36L;\n+    }\n+    public static int CXType_UAccum() {\n+        return (int)37L;\n+    }\n+    public static int CXType_ULongAccum() {\n+        return (int)38L;\n+    }\n+    public static int CXType_FirstBuiltin() {\n+        return (int)2L;\n+    }\n+    public static int CXType_LastBuiltin() {\n+        return (int)38L;\n+    }\n+    public static int CXType_Complex() {\n+        return (int)100L;\n+    }\n+    public static int CXType_Pointer() {\n+        return (int)101L;\n+    }\n+    public static int CXType_BlockPointer() {\n+        return (int)102L;\n+    }\n+    public static int CXType_LValueReference() {\n+        return (int)103L;\n+    }\n+    public static int CXType_RValueReference() {\n+        return (int)104L;\n+    }\n+    public static int CXType_Record() {\n+        return (int)105L;\n+    }\n+    public static int CXType_Enum() {\n+        return (int)106L;\n+    }\n+    public static int CXType_Typedef() {\n+        return (int)107L;\n+    }\n+    public static int CXType_ObjCInterface() {\n+        return (int)108L;\n+    }\n+    public static int CXType_ObjCObjectPointer() {\n+        return (int)109L;\n+    }\n+    public static int CXType_FunctionNoProto() {\n+        return (int)110L;\n+    }\n+    public static int CXType_FunctionProto() {\n+        return (int)111L;\n+    }\n+    public static int CXType_ConstantArray() {\n+        return (int)112L;\n+    }\n+    public static int CXType_Vector() {\n+        return (int)113L;\n+    }\n+    public static int CXType_IncompleteArray() {\n+        return (int)114L;\n+    }\n+    public static int CXType_VariableArray() {\n+        return (int)115L;\n+    }\n+    public static int CXType_DependentSizedArray() {\n+        return (int)116L;\n+    }\n+    public static int CXType_MemberPointer() {\n+        return (int)117L;\n+    }\n+    public static int CXType_Auto() {\n+        return (int)118L;\n+    }\n+    public static int CXType_Elaborated() {\n+        return (int)119L;\n+    }\n+    public static int CXType_Pipe() {\n+        return (int)120L;\n+    }\n+    public static int CXType_OCLImage1dRO() {\n+        return (int)121L;\n+    }\n+    public static int CXType_OCLImage1dArrayRO() {\n+        return (int)122L;\n+    }\n+    public static int CXType_OCLImage1dBufferRO() {\n+        return (int)123L;\n+    }\n+    public static int CXType_OCLImage2dRO() {\n+        return (int)124L;\n+    }\n+    public static int CXType_OCLImage2dArrayRO() {\n+        return (int)125L;\n+    }\n+    public static int CXType_OCLImage2dDepthRO() {\n+        return (int)126L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRO() {\n+        return (int)127L;\n+    }\n+    public static int CXType_OCLImage2dMSAARO() {\n+        return (int)128L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARO() {\n+        return (int)129L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRO() {\n+        return (int)130L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRO() {\n+        return (int)131L;\n+    }\n+    public static int CXType_OCLImage3dRO() {\n+        return (int)132L;\n+    }\n+    public static int CXType_OCLImage1dWO() {\n+        return (int)133L;\n+    }\n+    public static int CXType_OCLImage1dArrayWO() {\n+        return (int)134L;\n+    }\n+    public static int CXType_OCLImage1dBufferWO() {\n+        return (int)135L;\n+    }\n+    public static int CXType_OCLImage2dWO() {\n+        return (int)136L;\n+    }\n+    public static int CXType_OCLImage2dArrayWO() {\n+        return (int)137L;\n+    }\n+    public static int CXType_OCLImage2dDepthWO() {\n+        return (int)138L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthWO() {\n+        return (int)139L;\n+    }\n+    public static int CXType_OCLImage2dMSAAWO() {\n+        return (int)140L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAAWO() {\n+        return (int)141L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthWO() {\n+        return (int)142L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthWO() {\n+        return (int)143L;\n+    }\n+    public static int CXType_OCLImage3dWO() {\n+        return (int)144L;\n+    }\n+    public static int CXType_OCLImage1dRW() {\n+        return (int)145L;\n+    }\n+    public static int CXType_OCLImage1dArrayRW() {\n+        return (int)146L;\n+    }\n+    public static int CXType_OCLImage1dBufferRW() {\n+        return (int)147L;\n+    }\n+    public static int CXType_OCLImage2dRW() {\n+        return (int)148L;\n+    }\n+    public static int CXType_OCLImage2dArrayRW() {\n+        return (int)149L;\n+    }\n+    public static int CXType_OCLImage2dDepthRW() {\n+        return (int)150L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRW() {\n+        return (int)151L;\n+    }\n+    public static int CXType_OCLImage2dMSAARW() {\n+        return (int)152L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARW() {\n+        return (int)153L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRW() {\n+        return (int)154L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRW() {\n+        return (int)155L;\n+    }\n+    public static int CXType_OCLImage3dRW() {\n+        return (int)156L;\n+    }\n+    public static int CXType_OCLSampler() {\n+        return (int)157L;\n+    }\n+    public static int CXType_OCLEvent() {\n+        return (int)158L;\n+    }\n+    public static int CXType_OCLQueue() {\n+        return (int)159L;\n+    }\n+    public static int CXType_OCLReserveID() {\n+        return (int)160L;\n+    }\n+    public static int CXType_ObjCObject() {\n+        return (int)161L;\n+    }\n+    public static int CXType_ObjCTypeParam() {\n+        return (int)162L;\n+    }\n+    public static int CXType_Attributed() {\n+        return (int)163L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMcePayload() {\n+        return (int)164L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImePayload() {\n+        return (int)165L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefPayload() {\n+        return (int)166L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicPayload() {\n+        return (int)167L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMceResult() {\n+        return (int)168L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResult() {\n+        return (int)169L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefResult() {\n+        return (int)170L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicResult() {\n+        return (int)171L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout() {\n+        return (int)172L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout() {\n+        return (int)173L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin() {\n+        return (int)174L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeDualRefStreamin() {\n+        return (int)175L;\n+    }\n+    public static int CXType_ExtVector() {\n+        return (int)176L;\n+    }\n+    public static int CXCallingConv_Default() {\n+        return (int)0L;\n+    }\n+    public static int CXCallingConv_C() {\n+        return (int)1L;\n+    }\n+    public static int CXCallingConv_X86StdCall() {\n+        return (int)2L;\n+    }\n+    public static int CXCallingConv_X86FastCall() {\n+        return (int)3L;\n+    }\n+    public static int CXCallingConv_X86ThisCall() {\n+        return (int)4L;\n+    }\n+    public static int CXCallingConv_X86Pascal() {\n+        return (int)5L;\n+    }\n+    public static int CXCallingConv_AAPCS() {\n+        return (int)6L;\n+    }\n+    public static int CXCallingConv_AAPCS_VFP() {\n+        return (int)7L;\n+    }\n+    public static int CXCallingConv_X86RegCall() {\n+        return (int)8L;\n+    }\n+    public static int CXCallingConv_IntelOclBicc() {\n+        return (int)9L;\n+    }\n+    public static int CXCallingConv_Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64SysV() {\n+        return (int)11L;\n+    }\n+    public static int CXCallingConv_X86VectorCall() {\n+        return (int)12L;\n+    }\n+    public static int CXCallingConv_Swift() {\n+        return (int)13L;\n+    }\n+    public static int CXCallingConv_PreserveMost() {\n+        return (int)14L;\n+    }\n+    public static int CXCallingConv_PreserveAll() {\n+        return (int)15L;\n+    }\n+    public static int CXCallingConv_AArch64VectorCall() {\n+        return (int)16L;\n+    }\n+    public static int CXCallingConv_Invalid() {\n+        return (int)100L;\n+    }\n+    public static int CXCallingConv_Unexposed() {\n+        return (int)200L;\n+    }\n+    public static MethodHandle clang_getCursorType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH,\"clang_getCursorType\");\n+    }\n+    public static MemorySegment clang_getCursorType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH, \"clang_getCursorType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getCursorType(SegmentAllocator.nativeAllocator(scope), C);\n+    }\n+    public static MethodHandle clang_getTypeSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH,\"clang_getTypeSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeSpelling ( SegmentAllocator allocator,  MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH, \"clang_getTypeSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeSpelling ( ResourceScope scope,  MemorySegment CT) {\n+        return clang_getTypeSpelling(SegmentAllocator.nativeAllocator(scope), CT);\n+    }\n+    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getTypedefDeclUnderlyingType$MH,\"clang_getTypedefDeclUnderlyingType\");\n+    }\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getTypedefDeclUnderlyingType$MH, \"clang_getTypedefDeclUnderlyingType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getTypedefDeclUnderlyingType(SegmentAllocator.nativeAllocator(scope), C);\n+    }\n+    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH,\"clang_getEnumDeclIntegerType\");\n+    }\n+    public static MemorySegment clang_getEnumDeclIntegerType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH, \"clang_getEnumDeclIntegerType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getEnumDeclIntegerType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getEnumDeclIntegerType(SegmentAllocator.nativeAllocator(scope), C);\n+    }\n+    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH,\"clang_getEnumConstantDeclValue\");\n+    }\n+    public static long clang_getEnumConstantDeclValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH, \"clang_getEnumConstantDeclValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH,\"clang_getEnumConstantDeclUnsignedValue\");\n+    }\n+    public static long clang_getEnumConstantDeclUnsignedValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH, \"clang_getEnumConstantDeclUnsignedValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH,\"clang_getFieldDeclBitWidth\");\n+    }\n+    public static int clang_getFieldDeclBitWidth ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH, \"clang_getFieldDeclBitWidth\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH,\"clang_Cursor_getNumArguments\");\n+    }\n+    public static int clang_Cursor_getNumArguments ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH, \"clang_Cursor_getNumArguments\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getArgument$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getArgument$MH,\"clang_Cursor_getArgument\");\n+    }\n+    public static MemorySegment clang_Cursor_getArgument ( SegmentAllocator allocator,  MemorySegment C,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getArgument$MH, \"clang_Cursor_getArgument\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_Cursor_getArgument ( ResourceScope scope,  MemorySegment C,  int i) {\n+        return clang_Cursor_getArgument(SegmentAllocator.nativeAllocator(scope), C, i);\n+    }\n+    public static MethodHandle clang_equalTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH,\"clang_equalTypes\");\n+    }\n+    public static int clang_equalTypes ( MemorySegment A,  MemorySegment B) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH, \"clang_equalTypes\");\n+        try {\n+            return (int)mh$.invokeExact(A, B);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCanonicalType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH,\"clang_getCanonicalType\");\n+    }\n+    public static MemorySegment clang_getCanonicalType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH, \"clang_getCanonicalType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCanonicalType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getCanonicalType(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_isConstQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH,\"clang_isConstQualifiedType\");\n+    }\n+    public static int clang_isConstQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH, \"clang_isConstQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH,\"clang_Cursor_isMacroFunctionLike\");\n+    }\n+    public static int clang_Cursor_isMacroFunctionLike ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH, \"clang_Cursor_isMacroFunctionLike\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_isVolatileQualifiedType$MH,\"clang_isVolatileQualifiedType\");\n+    }\n+    public static int clang_isVolatileQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_isVolatileQualifiedType$MH, \"clang_isVolatileQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypedefName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getTypedefName$MH,\"clang_getTypedefName\");\n+    }\n+    public static MemorySegment clang_getTypedefName ( SegmentAllocator allocator,  MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getTypedefName$MH, \"clang_getTypedefName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypedefName ( ResourceScope scope,  MemorySegment CT) {\n+        return clang_getTypedefName(SegmentAllocator.nativeAllocator(scope), CT);\n+    }\n+    public static MethodHandle clang_getPointeeType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH,\"clang_getPointeeType\");\n+    }\n+    public static MemorySegment clang_getPointeeType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH, \"clang_getPointeeType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getPointeeType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getPointeeType(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_getTypeDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH,\"clang_getTypeDeclaration\");\n+    }\n+    public static MemorySegment clang_getTypeDeclaration ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH, \"clang_getTypeDeclaration\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeDeclaration ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getTypeDeclaration(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_getTypeKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH,\"clang_getTypeKindSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeKindSpelling ( SegmentAllocator allocator,  int K) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH, \"clang_getTypeKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, K);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeKindSpelling ( ResourceScope scope,  int K) {\n+        return clang_getTypeKindSpelling(SegmentAllocator.nativeAllocator(scope), K);\n+    }\n+    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH,\"clang_getFunctionTypeCallingConv\");\n+    }\n+    public static int clang_getFunctionTypeCallingConv ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH, \"clang_getFunctionTypeCallingConv\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getResultType$MH,\"clang_getResultType\");\n+    }\n+    public static MemorySegment clang_getResultType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getResultType$MH, \"clang_getResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getResultType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getResultType(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_getNumArgTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getNumArgTypes$MH,\"clang_getNumArgTypes\");\n+    }\n+    public static int clang_getNumArgTypes ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getNumArgTypes$MH, \"clang_getNumArgTypes\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getArgType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH,\"clang_getArgType\");\n+    }\n+    public static MemorySegment clang_getArgType ( SegmentAllocator allocator,  MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH, \"clang_getArgType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getArgType ( ResourceScope scope,  MemorySegment T,  int i) {\n+        return clang_getArgType(SegmentAllocator.nativeAllocator(scope), T, i);\n+    }\n+    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH,\"clang_isFunctionTypeVariadic\");\n+    }\n+    public static int clang_isFunctionTypeVariadic ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH, \"clang_isFunctionTypeVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH,\"clang_getCursorResultType\");\n+    }\n+    public static MemorySegment clang_getCursorResultType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH, \"clang_getCursorResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorResultType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getCursorResultType(SegmentAllocator.nativeAllocator(scope), C);\n+    }\n+    public static MethodHandle clang_getElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH,\"clang_getElementType\");\n+    }\n+    public static MemorySegment clang_getElementType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH, \"clang_getElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getElementType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getElementType(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_getNumElements$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getNumElements$MH,\"clang_getNumElements\");\n+    }\n+    public static long clang_getNumElements ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getNumElements$MH, \"clang_getNumElements\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getArrayElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getArrayElementType$MH,\"clang_getArrayElementType\");\n+    }\n+    public static MemorySegment clang_getArrayElementType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getArrayElementType$MH, \"clang_getArrayElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getArrayElementType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getArrayElementType(SegmentAllocator.nativeAllocator(scope), T);\n+    }\n+    public static MethodHandle clang_getArraySize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH,\"clang_getArraySize\");\n+    }\n+    public static long clang_getArraySize ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH, \"clang_getArraySize\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTypeNullability_NonNull() {\n+        return (int)0L;\n+    }\n+    public static int CXTypeNullability_Nullable() {\n+        return (int)1L;\n+    }\n+    public static int CXTypeNullability_Unspecified() {\n+        return (int)2L;\n+    }\n+    public static int CXTypeNullability_Invalid() {\n+        return (int)3L;\n+    }\n+    public static int CXTypeLayoutError_Invalid() {\n+        return (int)-1L;\n+    }\n+    public static int CXTypeLayoutError_Incomplete() {\n+        return (int)-2L;\n+    }\n+    public static int CXTypeLayoutError_Dependent() {\n+        return (int)-3L;\n+    }\n+    public static int CXTypeLayoutError_NotConstantSize() {\n+        return (int)-4L;\n+    }\n+    public static int CXTypeLayoutError_InvalidFieldName() {\n+        return (int)-5L;\n+    }\n+    public static int CXTypeLayoutError_Undeduced() {\n+        return (int)-6L;\n+    }\n+    public static MethodHandle clang_Type_getSizeOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH,\"clang_Type_getSizeOf\");\n+    }\n+    public static long clang_Type_getSizeOf ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH, \"clang_Type_getSizeOf\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getOffsetOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH,\"clang_Type_getOffsetOf\");\n+    }\n+    public static long clang_Type_getOffsetOf ( MemorySegment T,  Addressable S) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH, \"clang_Type_getOffsetOf\");\n+        try {\n+            return (long)mh$.invokeExact(T, S);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH,\"clang_Cursor_isAnonymous\");\n+    }\n+    public static int clang_Cursor_isAnonymous ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH, \"clang_Cursor_isAnonymous\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymousRecordDecl$MH,\"clang_Cursor_isAnonymousRecordDecl\");\n+    }\n+    public static int clang_Cursor_isAnonymousRecordDecl ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymousRecordDecl$MH, \"clang_Cursor_isAnonymousRecordDecl\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isBitField$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isBitField$MH,\"clang_Cursor_isBitField\");\n+    }\n+    public static int clang_Cursor_isBitField ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isBitField$MH, \"clang_Cursor_isBitField\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXChildVisit_Break() {\n+        return (int)0L;\n+    }\n+    public static int CXChildVisit_Continue() {\n+        return (int)1L;\n+    }\n+    public static int CXChildVisit_Recurse() {\n+        return (int)2L;\n+    }\n+    public static MethodHandle clang_visitChildren$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH,\"clang_visitChildren\");\n+    }\n+    public static int clang_visitChildren ( MemorySegment parent,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH, \"clang_visitChildren\");\n+        try {\n+            return (int)mh$.invokeExact(parent, visitor, client_data);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorUSR$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH,\"clang_getCursorUSR\");\n+    }\n+    public static MemorySegment clang_getCursorUSR ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH, \"clang_getCursorUSR\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorUSR ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorUSR(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorSpelling$MH,\"clang_getCursorSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorSpelling ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getCursorSpelling$MH, \"clang_getCursorSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorSpelling ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorSpelling(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static int CXPrintingPolicy_Indentation() {\n+        return (int)0L;\n+    }\n+    public static int CXPrintingPolicy_SuppressSpecifiers() {\n+        return (int)1L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTagKeyword() {\n+        return (int)2L;\n+    }\n+    public static int CXPrintingPolicy_IncludeTagDefinition() {\n+        return (int)3L;\n+    }\n+    public static int CXPrintingPolicy_SuppressScope() {\n+        return (int)4L;\n+    }\n+    public static int CXPrintingPolicy_SuppressUnwrittenScope() {\n+        return (int)5L;\n+    }\n+    public static int CXPrintingPolicy_SuppressInitializers() {\n+        return (int)6L;\n+    }\n+    public static int CXPrintingPolicy_ConstantArraySizeAsWritten() {\n+        return (int)7L;\n+    }\n+    public static int CXPrintingPolicy_AnonymousTagLocations() {\n+        return (int)8L;\n+    }\n+    public static int CXPrintingPolicy_SuppressStrongLifetime() {\n+        return (int)9L;\n+    }\n+    public static int CXPrintingPolicy_SuppressLifetimeQualifiers() {\n+        return (int)10L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors() {\n+        return (int)11L;\n+    }\n+    public static int CXPrintingPolicy_Bool() {\n+        return (int)12L;\n+    }\n+    public static int CXPrintingPolicy_Restrict() {\n+        return (int)13L;\n+    }\n+    public static int CXPrintingPolicy_Alignof() {\n+        return (int)14L;\n+    }\n+    public static int CXPrintingPolicy_UnderscoreAlignof() {\n+        return (int)15L;\n+    }\n+    public static int CXPrintingPolicy_UseVoidForZeroParams() {\n+        return (int)16L;\n+    }\n+    public static int CXPrintingPolicy_TerseOutput() {\n+        return (int)17L;\n+    }\n+    public static int CXPrintingPolicy_PolishForDeclaration() {\n+        return (int)18L;\n+    }\n+    public static int CXPrintingPolicy_Half() {\n+        return (int)19L;\n+    }\n+    public static int CXPrintingPolicy_MSWChar() {\n+        return (int)20L;\n+    }\n+    public static int CXPrintingPolicy_IncludeNewlines() {\n+        return (int)21L;\n+    }\n+    public static int CXPrintingPolicy_MSVCFormatting() {\n+        return (int)22L;\n+    }\n+    public static int CXPrintingPolicy_ConstantsAsWritten() {\n+        return (int)23L;\n+    }\n+    public static int CXPrintingPolicy_SuppressImplicitBase() {\n+        return (int)24L;\n+    }\n+    public static int CXPrintingPolicy_FullyQualifiedName() {\n+        return (int)25L;\n+    }\n+    public static int CXPrintingPolicy_LastProperty() {\n+        return (int)25L;\n+    }\n+    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_PrintingPolicy_getProperty$MH,\"clang_PrintingPolicy_getProperty\");\n+    }\n+    public static int clang_PrintingPolicy_getProperty ( Addressable Policy,  int Property) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_PrintingPolicy_getProperty$MH, \"clang_PrintingPolicy_getProperty\");\n+        try {\n+            return (int)mh$.invokeExact(Policy, Property);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH,\"clang_PrintingPolicy_setProperty\");\n+    }\n+    public static void clang_PrintingPolicy_setProperty ( Addressable Policy,  int Property,  int Value) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH, \"clang_PrintingPolicy_setProperty\");\n+        try {\n+            mh$.invokeExact(Policy, Property, Value);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH,\"clang_getCursorPrintingPolicy\");\n+    }\n+    public static MemoryAddress clang_getCursorPrintingPolicy ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH, \"clang_getCursorPrintingPolicy\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH,\"clang_PrintingPolicy_dispose\");\n+    }\n+    public static void clang_PrintingPolicy_dispose ( Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH, \"clang_PrintingPolicy_dispose\");\n+        try {\n+            mh$.invokeExact(Policy);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH,\"clang_getCursorPrettyPrinted\");\n+    }\n+    public static MemorySegment clang_getCursorPrettyPrinted ( SegmentAllocator allocator,  MemorySegment Cursor,  Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH, \"clang_getCursorPrettyPrinted\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorPrettyPrinted ( ResourceScope scope,  MemorySegment Cursor,  Addressable Policy) {\n+        return clang_getCursorPrettyPrinted(SegmentAllocator.nativeAllocator(scope), Cursor, Policy);\n+    }\n+    public static MethodHandle clang_getCursorDisplayName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorDisplayName$MH,\"clang_getCursorDisplayName\");\n+    }\n+    public static MemorySegment clang_getCursorDisplayName ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorDisplayName$MH, \"clang_getCursorDisplayName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorDisplayName ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorDisplayName(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorReferenced$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorReferenced$MH,\"clang_getCursorReferenced\");\n+    }\n+    public static MemorySegment clang_getCursorReferenced ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorReferenced$MH, \"clang_getCursorReferenced\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorReferenced ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorReferenced(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH,\"clang_getCursorDefinition\");\n+    }\n+    public static MemorySegment clang_getCursorDefinition ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH, \"clang_getCursorDefinition\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorDefinition ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorDefinition(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static MethodHandle clang_isCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH,\"clang_isCursorDefinition\");\n+    }\n+    public static int clang_isCursorDefinition ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH, \"clang_isCursorDefinition\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH,\"clang_Cursor_isVariadic\");\n+    }\n+    public static int clang_Cursor_isVariadic ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH, \"clang_Cursor_isVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getMangling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH,\"clang_Cursor_getMangling\");\n+    }\n+    public static MemorySegment clang_Cursor_getMangling ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH, \"clang_Cursor_getMangling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_Cursor_getMangling ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_Cursor_getMangling(SegmentAllocator.nativeAllocator(scope), x1);\n+    }\n+    public static int CXToken_Punctuation() {\n+        return (int)0L;\n+    }\n+    public static int CXToken_Keyword() {\n+        return (int)1L;\n+    }\n+    public static int CXToken_Identifier() {\n+        return (int)2L;\n+    }\n+    public static int CXToken_Literal() {\n+        return (int)3L;\n+    }\n+    public static int CXToken_Comment() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getTokenKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getTokenKind$MH,\"clang_getTokenKind\");\n+    }\n+    public static int clang_getTokenKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getTokenKind$MH, \"clang_getTokenKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTokenSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getTokenSpelling$MH,\"clang_getTokenSpelling\");\n+    }\n+    public static MemorySegment clang_getTokenSpelling ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getTokenSpelling$MH, \"clang_getTokenSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenSpelling ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenSpelling(SegmentAllocator.nativeAllocator(scope), x1, x2);\n+    }\n+    public static MethodHandle clang_getTokenLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH,\"clang_getTokenLocation\");\n+    }\n+    public static MemorySegment clang_getTokenLocation ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH, \"clang_getTokenLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenLocation ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenLocation(SegmentAllocator.nativeAllocator(scope), x1, x2);\n+    }\n+    public static MethodHandle clang_getTokenExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH,\"clang_getTokenExtent\");\n+    }\n+    public static MemorySegment clang_getTokenExtent ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH, \"clang_getTokenExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1, x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenExtent ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenExtent(SegmentAllocator.nativeAllocator(scope), x1, x2);\n+    }\n+    public static MethodHandle clang_tokenize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH,\"clang_tokenize\");\n+    }\n+    public static void clang_tokenize ( Addressable TU,  MemorySegment Range,  Addressable Tokens,  Addressable NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH, \"clang_tokenize\");\n+        try {\n+            mh$.invokeExact(TU, Range, Tokens, NumTokens);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTokens$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH,\"clang_disposeTokens\");\n+    }\n+    public static void clang_disposeTokens ( Addressable TU,  Addressable Tokens,  int NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH, \"clang_disposeTokens\");\n+        try {\n+            mh$.invokeExact(TU, Tokens, NumTokens);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorKindSpelling$MH,\"clang_getCursorKindSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorKindSpelling ( SegmentAllocator allocator,  int Kind) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorKindSpelling$MH, \"clang_getCursorKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Kind);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorKindSpelling ( ResourceScope scope,  int Kind) {\n+        return clang_getCursorKindSpelling(SegmentAllocator.nativeAllocator(scope), Kind);\n+    }\n+    public static MethodHandle clang_getClangVersion$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getClangVersion$MH,\"clang_getClangVersion\");\n+    }\n+    public static MemorySegment clang_getClangVersion ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getClangVersion$MH, \"clang_getClangVersion\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getClangVersion ( ResourceScope scope) {\n+        return clang_getClangVersion(SegmentAllocator.nativeAllocator(scope));\n+    }\n+    public static MethodHandle clang_toggleCrashRecovery$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH,\"clang_toggleCrashRecovery\");\n+    }\n+    public static void clang_toggleCrashRecovery ( int isEnabled) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH, \"clang_toggleCrashRecovery\");\n+        try {\n+            mh$.invokeExact(isEnabled);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_Evaluate$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH,\"clang_Cursor_Evaluate\");\n+    }\n+    public static MemoryAddress clang_Cursor_Evaluate ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH, \"clang_Cursor_Evaluate\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH,\"clang_EvalResult_getKind\");\n+    }\n+    public static int clang_EvalResult_getKind ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH, \"clang_EvalResult_getKind\");\n+        try {\n+            return (int)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH,\"clang_EvalResult_getAsInt\");\n+    }\n+    public static int clang_EvalResult_getAsInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH, \"clang_EvalResult_getAsInt\");\n+        try {\n+            return (int)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsLongLong$MH,\"clang_EvalResult_getAsLongLong\");\n+    }\n+    public static long clang_EvalResult_getAsLongLong ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsLongLong$MH, \"clang_EvalResult_getAsLongLong\");\n+        try {\n+            return (long)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_isUnsignedInt$MH,\"clang_EvalResult_isUnsignedInt\");\n+    }\n+    public static int clang_EvalResult_isUnsignedInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_isUnsignedInt$MH, \"clang_EvalResult_isUnsignedInt\");\n+        try {\n+            return (int)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH,\"clang_EvalResult_getAsUnsigned\");\n+    }\n+    public static long clang_EvalResult_getAsUnsigned ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH, \"clang_EvalResult_getAsUnsigned\");\n+        try {\n+            return (long)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH,\"clang_EvalResult_getAsDouble\");\n+    }\n+    public static double clang_EvalResult_getAsDouble ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH, \"clang_EvalResult_getAsDouble\");\n+        try {\n+            return (double)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH,\"clang_EvalResult_getAsStr\");\n+    }\n+    public static MemoryAddress clang_EvalResult_getAsStr ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH, \"clang_EvalResult_getAsStr\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH,\"clang_EvalResult_dispose\");\n+    }\n+    public static void clang_EvalResult_dispose ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH, \"clang_EvalResult_dispose\");\n+        try {\n+            mh$.invokeExact(E);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXResult_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXResult_Invalid() {\n+        return (int)1L;\n+    }\n+    public static int CXResult_VisitBreak() {\n+        return (int)2L;\n+    }\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":2874,"deletions":0,"binary":false,"changes":2874,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.jextract.clang.libclang;\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+\n+final class RuntimeHelper {\n+\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+    private final static SymbolLookup SYMBOL_LOOKUP;\n+\n+    final static SegmentAllocator CONSTANT_ALLOCATOR =\n+            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n+    static {\n+        \/\/ Manual change to handle platform specific library name difference\n+        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\")? \"libclang\" : \"clang\";\n+        System.loadLibrary(libName);\n+\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n+        return SYMBOL_LOOKUP.lookup(name).map(\n+                addr -> {\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        return LINKER.downcallHandle(fdesc);\n+    }\n+\n+    static final <Z> NativeSymbol upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final NativeSymbol symbol;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(NativeSymbol symbol, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(NativeSymbol symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return JAVA_LONG;\n+            } else if (c == double.class) {\n+                return JAVA_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return ADDRESS;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/RuntimeHelper.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$0 {\n+\n+    static final FunctionDescriptor clang_getCString$FUNC = FunctionDescriptor.of(ADDRESS,\n+        MemoryLayout.structLayout(\n+            ADDRESS.withName(\"data\"),\n+            JAVA_INT.withName(\"private_flags\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_getCString$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCString\",\n+        constants$0.clang_getCString$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeString$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            ADDRESS.withName(\"data\"),\n+            JAVA_INT.withName(\"private_flags\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_disposeString$MH = RuntimeHelper.downcallHandle(\n+        \"clang_disposeString\",\n+        constants$0.clang_disposeString$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_createIndex$FUNC = FunctionDescriptor.of(ADDRESS,\n+        JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_createIndex$MH = RuntimeHelper.downcallHandle(\n+        \"clang_createIndex\",\n+        constants$0.clang_createIndex$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeIndex$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_disposeIndex$MH = RuntimeHelper.downcallHandle(\n+        \"clang_disposeIndex\",\n+        constants$0.clang_disposeIndex$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFileName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getFileName$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getFileName\",\n+        constants$0.clang_getFileName$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNullLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ));\n+    static final MethodHandle clang_getNullLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getNullLocation\",\n+        constants$0.clang_getNullLocation$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$0.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$1 {\n+\n+    static final FunctionDescriptor clang_equalLocations$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_equalLocations$MH = RuntimeHelper.downcallHandle(\n+        \"clang_equalLocations\",\n+        constants$1.clang_equalLocations$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getLocation\",\n+        constants$1.clang_getLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getLocationForOffset$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getLocationForOffset$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getLocationForOffset\",\n+        constants$1.clang_getLocationForOffset$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Location_isInSystemHeader$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_Location_isInSystemHeader$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Location_isInSystemHeader\",\n+        constants$1.clang_Location_isInSystemHeader$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Location_isFromMainFile$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_Location_isFromMainFile$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Location_isFromMainFile\",\n+        constants$1.clang_Location_isFromMainFile$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Range_isNull$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"begin_int_data\"),\n+            JAVA_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_Range_isNull$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Range_isNull\",\n+        constants$1.clang_Range_isNull$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$1.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$10 {\n+\n+    static final FunctionDescriptor clang_getPointeeType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getPointeeType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getPointeeType\",\n+        constants$10.clang_getPointeeType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeDeclaration$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypeDeclaration$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTypeDeclaration\",\n+        constants$10.clang_getTypeDeclaration$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getTypeKindSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTypeKindSpelling\",\n+        constants$10.clang_getTypeKindSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFunctionTypeCallingConv$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getFunctionTypeCallingConv$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getFunctionTypeCallingConv\",\n+        constants$10.clang_getFunctionTypeCallingConv$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getResultType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getResultType\",\n+        constants$10.clang_getResultType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNumArgTypes$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getNumArgTypes$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getNumArgTypes\",\n+        constants$10.clang_getNumArgTypes$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$10.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$11 {\n+\n+    static final FunctionDescriptor clang_getArgType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        ),\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getArgType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getArgType\",\n+        constants$11.clang_getArgType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isFunctionTypeVariadic$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isFunctionTypeVariadic$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isFunctionTypeVariadic\",\n+        constants$11.clang_isFunctionTypeVariadic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorResultType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorResultType\",\n+        constants$11.clang_getCursorResultType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getElementType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getElementType\",\n+        constants$11.clang_getElementType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNumElements$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getNumElements$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getNumElements\",\n+        constants$11.clang_getNumElements$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getArrayElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getArrayElementType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getArrayElementType\",\n+        constants$11.clang_getArrayElementType$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$11.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$12 {\n+\n+    static final FunctionDescriptor clang_getArraySize$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getArraySize$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getArraySize\",\n+        constants$12.clang_getArraySize$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Type_getSizeOf$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Type_getSizeOf$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Type_getSizeOf\",\n+        constants$12.clang_Type_getSizeOf$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Type_getOffsetOf$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_Type_getOffsetOf$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Type_getOffsetOf\",\n+        constants$12.clang_Type_getOffsetOf$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isAnonymous$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isAnonymous$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isAnonymous\",\n+        constants$12.clang_Cursor_isAnonymous$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isAnonymousRecordDecl$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isAnonymousRecordDecl\",\n+        constants$12.clang_Cursor_isAnonymousRecordDecl$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isBitField$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isBitField$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isBitField\",\n+        constants$12.clang_Cursor_isBitField$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$12.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$13 {\n+\n+    static final FunctionDescriptor CXCursorVisitor$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        ADDRESS\n+    );\n+    static final MethodHandle CXCursorVisitor$MH = RuntimeHelper.downcallHandle(\n+        constants$13.CXCursorVisitor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_visitChildren$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_visitChildren$MH = RuntimeHelper.downcallHandle(\n+        \"clang_visitChildren\",\n+        constants$13.clang_visitChildren$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorUSR$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorUSR$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorUSR\",\n+        constants$13.clang_getCursorUSR$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorSpelling\",\n+        constants$13.clang_getCursorSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_PrintingPolicy_getProperty$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_PrintingPolicy_getProperty$MH = RuntimeHelper.downcallHandle(\n+        \"clang_PrintingPolicy_getProperty\",\n+        constants$13.clang_PrintingPolicy_getProperty$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$13.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$14 {\n+\n+    static final FunctionDescriptor clang_PrintingPolicy_setProperty$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS,\n+        JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_PrintingPolicy_setProperty$MH = RuntimeHelper.downcallHandle(\n+        \"clang_PrintingPolicy_setProperty\",\n+        constants$14.clang_PrintingPolicy_setProperty$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorPrintingPolicy$FUNC = FunctionDescriptor.of(ADDRESS,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorPrintingPolicy$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorPrintingPolicy\",\n+        constants$14.clang_getCursorPrintingPolicy$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_PrintingPolicy_dispose$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_PrintingPolicy_dispose$MH = RuntimeHelper.downcallHandle(\n+        \"clang_PrintingPolicy_dispose\",\n+        constants$14.clang_PrintingPolicy_dispose$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorPrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getCursorPrettyPrinted$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorPrettyPrinted\",\n+        constants$14.clang_getCursorPrettyPrinted$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorDisplayName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorDisplayName$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorDisplayName\",\n+        constants$14.clang_getCursorDisplayName$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorReferenced$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorReferenced$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorReferenced\",\n+        constants$14.clang_getCursorReferenced$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$14.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$15 {\n+\n+    static final FunctionDescriptor clang_getCursorDefinition$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorDefinition\",\n+        constants$15.clang_getCursorDefinition$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isCursorDefinition$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isCursorDefinition\",\n+        constants$15.clang_isCursorDefinition$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isVariadic$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isVariadic$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isVariadic\",\n+        constants$15.clang_Cursor_isVariadic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getMangling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getMangling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_getMangling\",\n+        constants$15.clang_Cursor_getMangling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenKind$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"int_data\"),\n+            ADDRESS.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenKind$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTokenKind\",\n+        constants$15.clang_getTokenKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"int_data\"),\n+            ADDRESS.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTokenSpelling\",\n+        constants$15.clang_getTokenSpelling$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$15.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$16 {\n+\n+    static final FunctionDescriptor clang_getTokenLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"int_data\"),\n+            ADDRESS.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTokenLocation\",\n+        constants$16.clang_getTokenLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"begin_int_data\"),\n+        JAVA_INT.withName(\"end_int_data\")\n+    ),\n+        ADDRESS,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"int_data\"),\n+            ADDRESS.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenExtent$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTokenExtent\",\n+        constants$16.clang_getTokenExtent$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_tokenize$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"begin_int_data\"),\n+            JAVA_INT.withName(\"end_int_data\")\n+        ),\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_tokenize$MH = RuntimeHelper.downcallHandle(\n+        \"clang_tokenize\",\n+        constants$16.clang_tokenize$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeTokens$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_disposeTokens$MH = RuntimeHelper.downcallHandle(\n+        \"clang_disposeTokens\",\n+        constants$16.clang_disposeTokens$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getCursorKindSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorKindSpelling\",\n+        constants$16.clang_getCursorKindSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getClangVersion$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ));\n+    static final MethodHandle clang_getClangVersion$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getClangVersion\",\n+        constants$16.clang_getClangVersion$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$16.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$17 {\n+\n+    static final FunctionDescriptor clang_toggleCrashRecovery$FUNC = FunctionDescriptor.ofVoid(\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_toggleCrashRecovery$MH = RuntimeHelper.downcallHandle(\n+        \"clang_toggleCrashRecovery\",\n+        constants$17.clang_toggleCrashRecovery$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_Evaluate$FUNC = FunctionDescriptor.of(ADDRESS,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_Evaluate$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_Evaluate\",\n+        constants$17.clang_Cursor_Evaluate$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getKind$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getKind$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getKind\",\n+        constants$17.clang_EvalResult_getKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsInt$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getAsInt$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getAsInt\",\n+        constants$17.clang_EvalResult_getAsInt$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsLongLong$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getAsLongLong$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getAsLongLong\",\n+        constants$17.clang_EvalResult_getAsLongLong$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_isUnsignedInt$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_isUnsignedInt$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_isUnsignedInt\",\n+        constants$17.clang_EvalResult_isUnsignedInt$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$17.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$18 {\n+\n+    static final FunctionDescriptor clang_EvalResult_getAsUnsigned$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getAsUnsigned$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getAsUnsigned\",\n+        constants$18.clang_EvalResult_getAsUnsigned$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsDouble$FUNC = FunctionDescriptor.of(JAVA_DOUBLE,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getAsDouble$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getAsDouble\",\n+        constants$18.clang_EvalResult_getAsDouble$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsStr$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_getAsStr$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_getAsStr\",\n+        constants$18.clang_EvalResult_getAsStr$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_dispose$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_EvalResult_dispose$MH = RuntimeHelper.downcallHandle(\n+        \"clang_EvalResult_dispose\",\n+        constants$18.clang_EvalResult_dispose$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$18.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$2 {\n+\n+    static final FunctionDescriptor clang_getExpansionLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getExpansionLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getExpansionLocation\",\n+        constants$2.clang_getExpansionLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getSpellingLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getSpellingLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getSpellingLocation\",\n+        constants$2.clang_getSpellingLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getFileLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getFileLocation\",\n+        constants$2.clang_getFileLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getRangeStart$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"begin_int_data\"),\n+            JAVA_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getRangeStart$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getRangeStart\",\n+        constants$2.clang_getRangeStart$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getRangeEnd$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+            JAVA_INT.withName(\"begin_int_data\"),\n+            JAVA_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getRangeEnd$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getRangeEnd\",\n+        constants$2.clang_getRangeEnd$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getChildDiagnostics$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getChildDiagnostics$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getChildDiagnostics\",\n+        constants$2.clang_getChildDiagnostics$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$2.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$3 {\n+\n+    static final FunctionDescriptor clang_getNumDiagnostics$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getNumDiagnostics\",\n+        constants$3.clang_getNumDiagnostics$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnostic$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_getDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getDiagnostic\",\n+        constants$3.clang_getDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeDiagnostic$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_disposeDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        \"clang_disposeDiagnostic\",\n+        constants$3.clang_disposeDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_formatDiagnostic$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_formatDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        \"clang_formatDiagnostic\",\n+        constants$3.clang_formatDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_defaultDiagnosticDisplayOptions$FUNC = FunctionDescriptor.of(JAVA_INT);\n+    static final MethodHandle clang_defaultDiagnosticDisplayOptions$MH = RuntimeHelper.downcallHandle(\n+        \"clang_defaultDiagnosticDisplayOptions\",\n+        constants$3.clang_defaultDiagnosticDisplayOptions$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnosticSeverity$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getDiagnosticSeverity$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getDiagnosticSeverity\",\n+        constants$3.clang_getDiagnosticSeverity$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$3.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$4 {\n+\n+    static final FunctionDescriptor clang_getDiagnosticLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getDiagnosticLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getDiagnosticLocation\",\n+        constants$4.clang_getDiagnosticLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnosticSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getDiagnosticSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getDiagnosticSpelling\",\n+        constants$4.clang_getDiagnosticSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_parseTranslationUnit$FUNC = FunctionDescriptor.of(ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT,\n+        ADDRESS,\n+        JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_parseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        \"clang_parseTranslationUnit\",\n+        constants$4.clang_parseTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_parseTranslationUnit2$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT,\n+        ADDRESS,\n+        JAVA_INT,\n+        JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_parseTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n+        \"clang_parseTranslationUnit2\",\n+        constants$4.clang_parseTranslationUnit2$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_saveTranslationUnit$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_saveTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        \"clang_saveTranslationUnit\",\n+        constants$4.clang_saveTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeTranslationUnit$FUNC = FunctionDescriptor.ofVoid(\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_disposeTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        \"clang_disposeTranslationUnit\",\n+        constants$4.clang_disposeTranslationUnit$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$4.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$5 {\n+\n+    static final FunctionDescriptor clang_defaultReparseOptions$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_defaultReparseOptions$MH = RuntimeHelper.downcallHandle(\n+        \"clang_defaultReparseOptions\",\n+        constants$5.clang_defaultReparseOptions$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_reparseTranslationUnit$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        ADDRESS,\n+        JAVA_INT,\n+        ADDRESS,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_reparseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        \"clang_reparseTranslationUnit\",\n+        constants$5.clang_reparseTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNullCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ));\n+    static final MethodHandle clang_getNullCursor$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getNullCursor\",\n+        constants$5.clang_getNullCursor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTranslationUnitCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ),\n+        ADDRESS\n+    );\n+    static final MethodHandle clang_getTranslationUnitCursor$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTranslationUnitCursor\",\n+        constants$5.clang_getTranslationUnitCursor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_equalCursors$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_equalCursors$MH = RuntimeHelper.downcallHandle(\n+        \"clang_equalCursors\",\n+        constants$5.clang_equalCursors$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isNull$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isNull$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isNull\",\n+        constants$5.clang_Cursor_isNull$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$5.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$6 {\n+\n+    static final FunctionDescriptor clang_getCursorKind$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorKind$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorKind\",\n+        constants$6.clang_getCursorKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isDeclaration$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_isDeclaration$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isDeclaration\",\n+        constants$6.clang_isDeclaration$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isAttribute$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_isAttribute$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isAttribute\",\n+        constants$6.clang_isAttribute$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isInvalid$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_isInvalid$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isInvalid\",\n+        constants$6.clang_isInvalid$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isPreprocessing$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_isPreprocessing$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isPreprocessing\",\n+        constants$6.clang_isPreprocessing$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorLanguage$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorLanguage$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorLanguage\",\n+        constants$6.clang_getCursorLanguage$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$6.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$7 {\n+\n+    static final FunctionDescriptor clang_Cursor_getTranslationUnit$FUNC = FunctionDescriptor.of(ADDRESS,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_getTranslationUnit\",\n+        constants$7.clang_Cursor_getTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorLocation$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorLocation\",\n+        constants$7.clang_getCursorLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"ptr_data\"),\n+        JAVA_INT.withName(\"begin_int_data\"),\n+        JAVA_INT.withName(\"end_int_data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorExtent$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorExtent\",\n+        constants$7.clang_getCursorExtent$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCursorType\",\n+        constants$7.clang_getCursorType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypeSpelling$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTypeSpelling\",\n+        constants$7.clang_getTypeSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypedefDeclUnderlyingType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypedefDeclUnderlyingType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTypedefDeclUnderlyingType\",\n+        constants$7.clang_getTypedefDeclUnderlyingType$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$7.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$8 {\n+\n+    static final FunctionDescriptor clang_getEnumDeclIntegerType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumDeclIntegerType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getEnumDeclIntegerType\",\n+        constants$8.clang_getEnumDeclIntegerType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getEnumConstantDeclValue$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumConstantDeclValue$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getEnumConstantDeclValue\",\n+        constants$8.clang_getEnumConstantDeclValue$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$FUNC = FunctionDescriptor.of(JAVA_LONG,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumConstantDeclUnsignedValue$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getEnumConstantDeclUnsignedValue\",\n+        constants$8.clang_getEnumConstantDeclUnsignedValue$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFieldDeclBitWidth$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getFieldDeclBitWidth$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getFieldDeclBitWidth\",\n+        constants$8.clang_getFieldDeclBitWidth$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getNumArguments$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getNumArguments$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_getNumArguments\",\n+        constants$8.clang_Cursor_getNumArguments$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getArgument$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        JAVA_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        ),\n+        JAVA_INT\n+    );\n+    static final MethodHandle clang_Cursor_getArgument$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_getArgument\",\n+        constants$8.clang_Cursor_getArgument$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$8.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package org.openjdk.jextract.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+class constants$9 {\n+\n+    static final FunctionDescriptor clang_equalTypes$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_equalTypes$MH = RuntimeHelper.downcallHandle(\n+        \"clang_equalTypes\",\n+        constants$9.clang_equalTypes$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCanonicalType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCanonicalType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getCanonicalType\",\n+        constants$9.clang_getCanonicalType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isConstQualifiedType$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isConstQualifiedType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isConstQualifiedType\",\n+        constants$9.clang_isConstQualifiedType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isMacroFunctionLike$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            JAVA_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isMacroFunctionLike$MH = RuntimeHelper.downcallHandle(\n+        \"clang_Cursor_isMacroFunctionLike\",\n+        constants$9.clang_Cursor_isMacroFunctionLike$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isVolatileQualifiedType$FUNC = FunctionDescriptor.of(JAVA_INT,\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isVolatileQualifiedType$MH = RuntimeHelper.downcallHandle(\n+        \"clang_isVolatileQualifiedType\",\n+        constants$9.clang_isVolatileQualifiedType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypedefName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        ADDRESS.withName(\"data\"),\n+        JAVA_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, ADDRESS).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypedefName$MH = RuntimeHelper.downcallHandle(\n+        \"clang_getTypedefName\",\n+        constants$9.clang_getTypedefName$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$9.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+public class ClangException extends RuntimeException {\n+    private static final long serialVersionUID = 0L;\n+\n+    public ClangException(String message) {\n+        super(message);\n+    }\n+\n+    public ClangException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public ClangException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClangException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Superclass for .java source generator classes.\n+ *\/\n+abstract class ClassSourceBuilder extends JavaSourceBuilder {\n+\n+    enum Kind {\n+        CLASS(\"class\"),\n+        INTERFACE(\"interface\");\n+\n+        final String kindName;\n+\n+        Kind(String kindName) {\n+            this.kindName = kindName;\n+        }\n+    }\n+\n+    final Kind kind;\n+    final ClassDesc desc;\n+    protected final JavaSourceBuilder enclosing;\n+\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    ClassSourceBuilder(JavaSourceBuilder enclosing, Kind kind, String name) {\n+        this.enclosing = enclosing;\n+        this.align = (enclosing instanceof ClassSourceBuilder) ?\n+            ((ClassSourceBuilder) enclosing).align : 0;\n+        this.kind = kind;\n+        this.desc = ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(name));\n+    }\n+\n+    boolean isNested() {\n+        return enclosing instanceof ClassSourceBuilder;\n+    }\n+\n+    String className() {\n+        return desc.displayName();\n+    }\n+\n+    String fullName() {\n+        return isNested() ?\n+                ((ClassSourceBuilder)enclosing).className() + \".\" + className() :\n+                className();\n+    }\n+\n+    @Override\n+    public final String packageName() {\n+        return desc.packageName();\n+    }\n+\n+    String superClass() {\n+        return null;\n+    }\n+\n+    String mods() {\n+        return (!isNested() || kind == Kind.INTERFACE) ?\n+                    \"public \" : \"public static \";\n+    }\n+\n+    void classBegin() {\n+        if (isNested()) {\n+            incrAlign();\n+        }\n+        emitPackagePrefix();\n+        emitImportSection();\n+\n+        indent();\n+        append(mods());\n+        append(kind.kindName + \" \" + className());\n+        if (superClass() != null) {\n+            append(\" extends \");\n+            append(superClass());\n+        }\n+        append(\" {\\n\\n\");\n+    }\n+\n+    JavaSourceBuilder classEnd() {\n+        indent();\n+        append(\"}\\n\\n\");\n+        if (isNested()) {\n+            decrAlign();\n+            ((ClassSourceBuilder)enclosing).append(build());\n+            sb = null;\n+        }\n+        return enclosing;\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> toFiles() {\n+        if (isNested()) {\n+            throw new UnsupportedOperationException(\"Nested builder!\");\n+        }\n+        String res = build();\n+        sb = null;\n+        return List.of(Utils.fileFromString(packageName(), className(), res));\n+    }\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    String build() {\n+        String s = sb.toString();\n+        return s;\n+    }\n+\n+    \/\/ is the name enclosed enclosed by a class of the same name?\n+    boolean isEnclosedBySameName(String name) {\n+        return className().equals(name) ||\n+                (isNested() && enclosing.isEnclosedBySameName(name));\n+    }\n+\n+    protected void emitPackagePrefix() {\n+        if (!isNested()) {\n+            assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n+            append(\"\/\/ Generated by jextract\\n\\n\");\n+            if (!packageName().isEmpty()) {\n+                append(\"package \");\n+                append(packageName());\n+                append(\";\\n\\n\");\n+            }\n+        }\n+    }\n+\n+    protected void emitImportSection() {\n+        if (!isNested()) {\n+            append(\"import java.lang.invoke.MethodHandle;\\n\");\n+            append(\"import java.lang.invoke.VarHandle;\\n\");\n+            append(\"import java.nio.ByteOrder;\\n\");\n+            append(\"import jdk.incubator.foreign.*;\\n\");\n+            append(\"import static jdk.incubator.foreign.ValueLayout.*;\\n\");\n+        }\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n+        emitGetter(mods, type, name, access, false, null);\n+    }\n+\n+    ToplevelBuilder toplevel() {\n+        JavaSourceBuilder encl = enclosing;\n+        while (encl instanceof ClassSourceBuilder) {\n+            encl = ((ClassSourceBuilder) encl).enclosing;\n+        }\n+        return (ToplevelBuilder)encl;\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ClassSourceBuilder.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+\/\/ This is verbatim copy of com.sun.tools.javac.main.CommandLine except for package name\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * Various utility methods for processing Java tool command line arguments.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class CommandLine {\n+    \/**\n+     * Process Win32-style command files for the specified command line\n+     * arguments and return the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with @files expanded\n+     * @throws IOException if there is a problem reading any of the @files\n+     *\/\n+    public static List<String> parse(List<String> args) throws IOException {\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, args);\n+        return newArgs;\n+    }\n+\n+    private static void appendParsedCommandArgs(List<String> newArgs, List<String> args) throws IOException {\n+        for (String arg : args) {\n+            if (arg.length() > 1 && arg.charAt(0) == '@') {\n+                arg = arg.substring(1);\n+                if (arg.charAt(0) == '@') {\n+                    newArgs.add(arg);\n+                } else {\n+                    loadCmdFile(arg, newArgs);\n+                }\n+            } else {\n+                newArgs.add(arg);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Process the given environment variable and appends any Win32-style\n+     * command files for the specified command line arguments and return\n+     * the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param envVariable the env variable to process\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with environment variable's content and expansion of @files\n+     * @throws IOException if there is a problem reading any of the @files\n+     * @throws org.openjdk.jextract.impl.CommandLine.UnmatchedQuote\n+     *\/\n+    public static List<String> parse(String envVariable, List<String> args)\n+            throws IOException, UnmatchedQuote {\n+\n+        List<String> inArgs = new ArrayList<>();\n+        appendParsedEnvVariables(inArgs, envVariable);\n+        inArgs.addAll(args);\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, inArgs);\n+        return newArgs;\n+    }\n+\n+    private static void loadCmdFile(String name, List<String> args) throws IOException {\n+        try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {\n+            Tokenizer t = new Tokenizer(r);\n+            String s;\n+            while ((s = t.nextToken()) != null) {\n+                args.add(s);\n+            }\n+        }\n+    }\n+\n+    public static class Tokenizer {\n+        private final Reader in;\n+        private int ch;\n+\n+        public Tokenizer(Reader in) throws IOException {\n+            this.in = in;\n+            ch = in.read();\n+        }\n+\n+        public String nextToken() throws IOException {\n+            skipWhite();\n+            if (ch == -1) {\n+                return null;\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            char quoteChar = 0;\n+\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\f':\n+                        if (quoteChar == 0) {\n+                            return sb.toString();\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    case '\\n':\n+                    case '\\r':\n+                        return sb.toString();\n+\n+                    case '\\'':\n+                    case '\"':\n+                        if (quoteChar == 0) {\n+                            quoteChar = (char) ch;\n+                        } else if (quoteChar == ch) {\n+                            quoteChar = 0;\n+                        } else {\n+                            sb.append((char) ch);\n+                        }\n+                        break;\n+\n+                    case '\\\\':\n+                        if (quoteChar != 0) {\n+                            ch = in.read();\n+                            switch (ch) {\n+                                case '\\n':\n+                                case '\\r':\n+                                    while (ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == '\\f') {\n+                                        ch = in.read();\n+                                    }\n+                                    continue;\n+\n+                                case 'n':\n+                                    ch = '\\n';\n+                                    break;\n+                                case 'r':\n+                                    ch = '\\r';\n+                                    break;\n+                                case 't':\n+                                    ch = '\\t';\n+                                    break;\n+                                case 'f':\n+                                    ch = '\\f';\n+                                    break;\n+                            }\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    default:\n+                        sb.append((char) ch);\n+                }\n+\n+                ch = in.read();\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        void skipWhite() throws IOException {\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\f':\n+                        break;\n+\n+                    case '#':\n+                        ch = in.read();\n+                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n+                            ch = in.read();\n+                        }\n+                        break;\n+\n+                    default:\n+                        return;\n+                }\n+\n+                ch = in.read();\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private static void appendParsedEnvVariables(List<String> newArgs, String envVariable)\n+            throws UnmatchedQuote {\n+\n+        if (envVariable == null) {\n+            return;\n+        }\n+        String in = System.getenv(envVariable);\n+        if (in == null || in.trim().isEmpty()) {\n+            return;\n+        }\n+\n+        final char NUL = (char)0;\n+        final int len = in.length();\n+\n+        int pos = 0;\n+        StringBuilder sb = new StringBuilder();\n+        char quote = NUL;\n+        char ch;\n+\n+        loop:\n+        while (pos < len) {\n+            ch = in.charAt(pos);\n+            switch (ch) {\n+                case '\\\"': case '\\'':\n+                    if (quote == NUL) {\n+                        quote = ch;\n+                    } else if (quote == ch) {\n+                        quote = NUL;\n+                    } else {\n+                        sb.append(ch);\n+                    }\n+                    pos++;\n+                    break;\n+                case '\\f': case '\\n': case '\\r': case '\\t': case ' ':\n+                    if (quote == NUL) {\n+                        newArgs.add(sb.toString());\n+                        sb.setLength(0);\n+                        while (ch == '\\f' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' ') {\n+                            pos++;\n+                            if (pos >= len) {\n+                                break loop;\n+                            }\n+                            ch = in.charAt(pos);\n+                        }\n+                        break;\n+                    }\n+                    \/\/ fall through\n+                default:\n+                    sb.append(ch);\n+                    pos++;\n+            }\n+        }\n+        if (sb.length() != 0) {\n+            newArgs.add(sb.toString());\n+        }\n+        if (quote != NUL) {\n+            throw new UnmatchedQuote(envVariable);\n+        }\n+    }\n+\n+    public static class UnmatchedQuote extends Exception {\n+        private static final long serialVersionUID = 0;\n+\n+        public final String variableName;\n+\n+        UnmatchedQuote(String variable) {\n+            this.variableName = variable;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CommandLine.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+public class CompilationFailedException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public CompilationFailedException(String msg) {\n+        super(msg);\n+    }\n+\n+    public CompilationFailedException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/CompilationFailedException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ConstantBuilder extends ClassSourceBuilder {\n+\n+    \/\/ set of names generates already\n+    private final Map<String, Constant> namesGenerated = new HashMap<>();\n+\n+    public ConstantBuilder(JavaSourceBuilder enclosing, String className) {\n+        super(enclosing, Kind.CLASS, className);\n+    }\n+\n+    String memberMods() {\n+        return kind == ClassSourceBuilder.Kind.CLASS ?\n+                \"static final \" : \"\";\n+    }\n+\n+    \/\/ public API\n+\n+    public Constant addLayout(String javaName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.LAYOUT,\n+                () -> emitLayoutField(javaName, layout));\n+    }\n+\n+    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n+    }\n+\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n+        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n+    }\n+\n+    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                String rootLayoutName, List<String> prefixElementNames) {\n+        return emitIfAbsent(javaName, Constant.Kind.VAR_HANDLE,\n+                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n+    }\n+\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n+    }\n+\n+    public Constant addSegment(String javaName, String nativeName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                () -> emitSegmentField(javaName, nativeName, layout));\n+    }\n+\n+    public Constant addFunctionDesc(String javaName, FunctionDescriptor desc) {\n+        return emitIfAbsent(javaName, Constant.Kind.FUNCTION_DESCRIPTOR,\n+                () -> emitFunctionDescField(javaName, desc));\n+    }\n+\n+    public Constant addConstantDesc(String javaName, Class<?> type, Object value) {\n+        if (type == MemorySegment.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                    () -> emitConstantSegment(javaName, value));\n+        } else if (type == MemoryAddress.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.ADDRESS,\n+                    () -> emitConstantAddress(javaName, value));\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class Constant {\n+\n+        enum Kind {\n+            LAYOUT(MemoryLayout.class, \"$LAYOUT\"),\n+            METHOD_HANDLE(MethodHandle.class, \"$MH\"),\n+            VAR_HANDLE(VarHandle.class, \"$VH\"),\n+            FUNCTION_DESCRIPTOR(FunctionDescriptor.class, \"$FUNC\"),\n+            ADDRESS(MemoryAddress.class, \"$ADDR\"),\n+            SEGMENT(MemorySegment.class, \"$SEGMENT\");\n+\n+            final Class<?> type;\n+            final String nameSuffix;\n+\n+            Kind(Class<?> type, String nameSuffix) {\n+                this.type = type;\n+                this.nameSuffix = nameSuffix;\n+            }\n+\n+            String fieldName(String javaName) {\n+                return javaName + nameSuffix;\n+            }\n+        }\n+\n+        private final String className;\n+        private final String javaName;\n+        private final Kind kind;\n+\n+        Constant(String className, String javaName, Kind kind) {\n+            this.className = className;\n+            this.javaName = javaName;\n+            this.kind = kind;\n+        }\n+\n+        List<String> getterNameParts() {\n+            return List.of(className, javaName, kind.nameSuffix);\n+        }\n+\n+        String accessExpression() {\n+            return className + \".\" + kind.fieldName(javaName);\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression());\n+            return this;\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression(), true, symbolName);\n+            return this;\n+        }\n+\n+        static final Function<List<String>, String> QUALIFIED_NAME =\n+                l -> l.stream().skip(1).collect(Collectors.joining());\n+\n+        static final Function<List<String>, String> JAVA_NAME =\n+                l -> l.get(1);\n+\n+        static final Function<List<String>, String> SUFFIX_ONLY =\n+                l -> l.get(2);\n+    }\n+\n+    \/\/ private generators\n+\n+    public Constant emitIfAbsent(String name, Constant.Kind kind, Supplier<Constant> constantFactory) {\n+        String lookupName = kind.fieldName(name);\n+        Constant constant = namesGenerated.get(lookupName);\n+        if (constant == null) {\n+            constant = constantFactory.get();\n+            if (constant.kind != kind) {\n+                throw new AssertionError(\"Factory return wrong kind of constant; expected: \"\n+                        + kind + \"; found: \" + constant.kind);\n+            }\n+            namesGenerated.put(lookupName, constant);\n+        }\n+        return constant;\n+    }\n+\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n+        incrAlign();\n+        indent();\n+        if (!virtual) {\n+            append(\"\\\"\" + nativeName + \"\\\"\");\n+            append(\",\\n\");\n+            indent();\n+        }\n+        append(functionDesc.accessExpression());\n+        append(\", \");\n+        \/\/ isVariadic\n+        append(functionInfo.isVarargs());\n+        append(\"\\n\");\n+        decrAlign();\n+        indent();\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+    }\n+\n+    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootLayoutName, List<String> prefixElementNames) {\n+        String layoutAccess = rootLayoutName != null ?\n+                Constant.Kind.LAYOUT.fieldName(rootLayoutName) :\n+                addLayout(javaName, varInfo.layout()).accessExpression();\n+        incrAlign();\n+        String typeName = varInfo.carrier().getName();\n+        indent();\n+        String fieldName = Constant.Kind.VAR_HANDLE.fieldName(javaName);\n+        append(memberMods() + \"VarHandle \" + fieldName + \" = \");\n+        append(layoutAccess);\n+        append(\".varHandle(\");\n+        String prefix = \"\";\n+        if (rootLayoutName != null) {\n+            for (String prefixElementName : prefixElementNames) {\n+                append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+                prefix = \", \";\n+            }\n+            append(prefix + \"MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+        }\n+        append(\")\");\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.VAR_HANDLE);\n+    }\n+\n+    private Constant emitLayoutField(String javaName, MemoryLayout layout) {\n+        String fieldName = Constant.Kind.LAYOUT.fieldName(javaName);\n+        incrAlign();\n+        indent();\n+        String layoutClassName = layout.getClass().getSimpleName();\n+        append(memberMods() + \" \" + layoutClassName + \" \" + fieldName + \" = \");\n+        emitLayoutString(layout);\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.LAYOUT);\n+    }\n+\n+    protected String primitiveLayoutString(ValueLayout layout) {\n+        return toplevel().rootConstants().resolvePrimitiveLayout(layout).accessExpression();\n+    }\n+\n+    private void emitLayoutString(MemoryLayout l) {\n+        if (l instanceof ValueLayout val) {\n+            append(primitiveLayoutString(val));\n+        } else if (l instanceof SequenceLayout seq) {\n+            append(\"MemoryLayout.sequenceLayout(\");\n+            if (seq.elementCount().isPresent()) {\n+                append(seq.elementCount().getAsLong() + \", \");\n+            }\n+            emitLayoutString(seq.elementLayout());\n+            append(\")\");\n+        } else if (l instanceof GroupLayout group) {\n+            if (group.isStruct()) {\n+                append(\"MemoryLayout.structLayout(\\n\");\n+            } else {\n+                append(\"MemoryLayout.unionLayout(\\n\");\n+            }\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : group.memberLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+            append(\")\");\n+        } else {\n+            \/\/ padding (or unsupported)\n+            append(\"MemoryLayout.paddingLayout(\" + l.bitSize() + \")\");\n+        }\n+        if (l.name().isPresent()) {\n+            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+        }\n+    }\n+\n+    private Constant emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.FUNCTION_DESCRIPTOR.fieldName(javaName);\n+        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+        append(memberMods());\n+        append(\"FunctionDescriptor \");\n+        append(fieldName);\n+        append(\" = \");\n+        if (desc.returnLayout().isPresent()) {\n+            append(\"FunctionDescriptor.of(\");\n+            emitLayoutString(desc.returnLayout().get());\n+            if (!noArgs) {\n+                append(\",\");\n+            }\n+        } else {\n+            append(\"FunctionDescriptor.ofVoid(\");\n+        }\n+        if (!noArgs) {\n+            append(\"\\n\");\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : desc.argumentLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.FUNCTION_DESCRIPTOR);\n+    }\n+\n+    private Constant emitConstantSegment(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String(\\\"\");\n+        append(Utils.quote(Objects.toString(value)));\n+        append(\"\\\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    private Constant emitConstantAddress(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.ADDRESS.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemoryAddress \");\n+        append(fieldName);\n+        append(\" = MemoryAddress.ofLong(\");\n+        append(((Number)value).longValue());\n+        append(\"L);\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.ADDRESS);\n+    }\n+\n+    private Constant emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n+        Constant layoutConstant = addLayout(javaName, layout);\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = \");\n+        append(\"RuntimeHelper.lookupGlobalVariable(\");\n+        append(\"\\\"\" + nativeName + \"\\\", \");\n+        append(layoutConstant.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        constantConsumer.accept(this);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Position;\n+import org.openjdk.jextract.Type;\n+\n+public abstract class DeclarationImpl implements Declaration {\n+\n+    private final String name;\n+    private final Position pos;\n+    private final Optional<Map<String, List<Constable>>> attributes;\n+\n+    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+        this.name = name;\n+        this.pos = pos;\n+        this.attributes = Optional.ofNullable(attrs);\n+    }\n+\n+    public String toString() {\n+        return new PrettyPrinter().print(this);\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Position pos() {\n+        return pos;\n+    }\n+\n+    @Override\n+    public Optional<List<Constable>> getAttribute(String name) {\n+        return attributes.map(attrs -> attrs.get(name));\n+    }\n+\n+    @Override\n+    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n+            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n+    }\n+\n+    @Override\n+    public Declaration withAttribute(String name, Constable... values) {\n+        if (values == null || values.length == 0) {\n+            return withAttributes(null);\n+        }\n+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n+        attrs.put(name, List.of(values));\n+        return withAttributes(attrs);\n+    }\n+\n+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof Declaration)) return false;\n+        Declaration decl = (Declaration) o;\n+        return name().equals(decl.name());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name);\n+    }\n+\n+    public static final class TypedefImpl extends DeclarationImpl implements Declaration.Typedef {\n+        final Type type;\n+\n+        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitTypedef(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n+            return new TypedefImpl(type, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Typedef stripAttributes() {\n+            return new TypedefImpl(type, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Typedef)) return false;\n+\n+            Declaration.Typedef other = (Declaration.Typedef) o;\n+            return name().equals(other.name()) &&\n+                    type.equals(other.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n+\n+        final Variable.Kind kind;\n+        final Type type;\n+        final Optional<MemoryLayout> layout;\n+\n+        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.type = Objects.requireNonNull(type);\n+            this.layout = Objects.requireNonNull(layout);\n+        }\n+\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            this(type, TypeImpl.getLayout(type), kind, name, pos, null);\n+        }\n+\n+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n+            this(type, Optional.of(layout), kind, name, pos, null);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitVariable(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n+            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Variable stripAttributes() {\n+            return new VariableImpl(type, layout, kind, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Variable)) return false;\n+\n+            Declaration.Variable variable = (Declaration.Variable) o;\n+            if (!super.equals(o)) return false;\n+            return kind == variable.kind() &&\n+                    type.equals(variable.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, type);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {\n+\n+        final List<Variable> params;\n+        final Type.Function type;\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {\n+            this(type, params, name, pos, null);\n+        }\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.params = Objects.requireNonNull(params);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public List<Variable> parameters() {\n+            return params;\n+        }\n+\n+        @Override\n+        public Type.Function type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Function withAttributes(Map<String, List<Constable>> attrs) {\n+            return new FunctionImpl(type, params, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Function stripAttributes() {\n+            return new FunctionImpl(type, params, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Function)) return false;\n+            if (!super.equals(o)) return false;\n+\n+            Declaration.Function function = (Declaration.Function) o;\n+            return type.equals(function.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {\n+\n+        private final Scoped.Kind kind;\n+        private final List<Declaration> declarations;\n+        private final Optional<MemoryLayout> optLayout;\n+\n+        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.of(layout), declarations, name, pos, null);\n+        }\n+\n+        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.empty(), declarations, name, pos, null);\n+        }\n+\n+        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n+                String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.declarations = Objects.requireNonNull(declarations);\n+            this.optLayout = Objects.requireNonNull(optLayout);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitScoped(this, data);\n+        }\n+\n+        @Override\n+        public List<Declaration> members() {\n+            return declarations;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return optLayout;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Scoped stripAttributes() {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Scoped)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Scoped scoped = (Declaration.Scoped) o;\n+            return kind == scoped.kind() &&\n+                    declarations.equals(scoped.members());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, declarations);\n+        }\n+    }\n+\n+    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {\n+\n+        final Object value;\n+        final Type type;\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos) {\n+            this(type, value, name, pos, null);\n+        }\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.value = Objects.requireNonNull(value);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitConstant(this, data);\n+        }\n+\n+        @Override\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ConstantImpl(type, value, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Constant stripAttributes() {\n+            return new ConstantImpl(type, value, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Constant)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Constant constant = (Declaration.Constant) o;\n+            return value.equals(constant.value()) &&\n+                    type.equals(constant.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), value, type);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/DeclarationImpl.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+\n+import org.openjdk.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"static\";\n+\n+    private final MethodType fiType;\n+    private final MethodType downcallType;\n+    private final FunctionDescriptor fiDesc;\n+    private final Optional<List<String>> parameterNames;\n+\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className,\n+                               FunctionInfo functionInfo) {\n+        super(enclosing, Kind.INTERFACE, className);\n+        this.fiType = functionInfo.methodType();\n+        this.downcallType = functionInfo.reverseMethodType();\n+        this.fiDesc = functionInfo.descriptor();\n+        this.parameterNames = functionInfo.parameterNames();\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        emitFunctionalInterfaceMethod();\n+        emitFunctionalFactories();\n+        emitFunctionalFactoryForPointer();\n+        return super.classEnd();\n+    }\n+\n+    \/\/ private generation\n+\n+    private String parameterName(int i) {\n+        String name = \"\";\n+        if (parameterNames.isPresent()) {\n+            name = parameterNames.get().get(i);\n+        }\n+        return name.isEmpty()? \"_x\" + i : Utils.javaSafeIdentifier(name);\n+    }\n+\n+    private void emitFunctionalInterfaceMethod() {\n+        incrAlign();\n+        indent();\n+        append(fiType.returnType().getName() + \" apply(\");\n+        String delim = \"\";\n+        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+            append(delim + fiType.parameterType(i).getName());\n+            append(\" \");\n+            append(parameterName(i));\n+            delim = \", \";\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionalFactories() {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant functionDesc = constantBuilder.addFunctionDesc(className(), fiDesc);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" NativeSymbol allocate(\" + className() + \" fi, ResourceScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\", scope);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+\n+    private void emitFunctionalFactoryForPointer() {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(),\n+                 FunctionInfo.ofFunctionPointer(downcallType, fiType, fiDesc, parameterNames), true);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemoryAddress addr, ResourceScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"NativeSymbol symbol = NativeSymbol.ofAddress(\");\n+            append(\"\\\"\" + className() + \"::\\\" + Long.toHexString(addr.toRawLongValue()), addr, scope);\\n\");\n+            append(\"return (\");\n+            String delim = \"\";\n+            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+                append(delim + fiType.parameterType(i).getName());\n+                append(\" \");\n+                append(parameterName(i));\n+                delim = \", \";\n+            }\n+            append(\") -> {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"try {\\n\");\n+            incrAlign();\n+            indent();\n+            if (!fiType.returnType().equals(void.class)) {\n+                append(\"return (\" + fiType.returnType().getName() + \")\");\n+                if (fiType.returnType() != downcallType.returnType()) {\n+                    \/\/ add cast for invokeExact\n+                    append(\"(\" + downcallType.returnType().getName() + \")\");\n+                }\n+            }\n+            append(mhConstant.accessExpression() + \".invokeExact(symbol\");\n+            if (fiType.parameterCount() > 0) {\n+                String params = IntStream.range(0, fiType.parameterCount())\n+                        .mapToObj(i -> {\n+                            String paramExpr = parameterName(i);\n+                            if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n+                                \/\/ add cast for invokeExact\n+                                return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n+                            } else {\n+                                return paramExpr;\n+                            }\n+                        })\n+                        .collect(Collectors.joining(\", \"));\n+                append(\", \" + params);\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"} catch (Throwable ex$) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"};\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+    private final Set<FunctionDescriptor> descriptors;\n+\n+    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {\n+        this.descriptors = descriptors;\n+    }\n+\n+    Declaration.Scoped scan(Declaration.Scoped decl) {\n+        decl.accept(this, descriptors);\n+        return decl;\n+    }\n+\n+    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+        t.accept(new TypeScanner(), functionDescriptors);\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {\n+        d.members().forEach(m -> m.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type().returnType(), functionDescriptors);\n+        d.parameters().forEach(p -> p.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+        @Override\n+        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.type().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {\n+            t.returnType().accept(this, functionDescriptors);\n+            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));\n+            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);\n+            if (descriptor.isPresent()) {\n+                functionDescriptors.add(descriptor.get());\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.elementType().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceScanner.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Type;\n+\n+import org.openjdk.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+abstract class HeaderFileBuilder extends ClassSourceBuilder {\n+\n+    static final String MEMBER_MODS = \"public static\";\n+\n+    private final String superclass;\n+\n+    HeaderFileBuilder(ToplevelBuilder enclosing, String name, String superclass) {\n+        super(enclosing, Kind.CLASS, name);\n+        this.superclass = superclass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superclass;\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            });\n+        } else {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addLayout(javaName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                if (varInfo.fiName().isPresent()) {\n+                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n+            if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+                \/\/ emit scoped overload\n+                emitFunctionWrapperScopedOverload(javaName, functionInfo);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addConstantDesc(javaName, type, value)\n+                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n+            });\n+        } else {\n+            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+        }\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        MethodType declType = functionInfo.methodType();\n+        List<String> paramNames = functionInfo.parameterNames().get();\n+        if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+            \/\/ needs allocator parameter\n+            declType = declType.insertParameterTypes(0, SegmentAllocator.class);\n+            paramNames = new ArrayList<>(paramNames);\n+            paramNames.add(0, \"allocator\");\n+        }\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, functionInfo.isVarargs(), paramNames);\n+        append(\" {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionWrapperScopedOverload(String javaName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        List<String> paramNames = new ArrayList<>(functionInfo.parameterNames().get());\n+        paramNames.add(0, \"scope\");\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName,\n+        functionInfo.methodType().insertParameterTypes(0, ResourceScope.class),\n+        functionInfo.isVarargs(),\n+        paramNames);\n+        String param = pExprs.remove(0);\n+        pExprs.add(0, \"SegmentAllocator.nativeAllocator(\" + param + \")\");\n+        append(\" {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return \");\n+        }\n+        append(javaName + \"(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private List<String> emitFunctionWrapperDecl(String javaName, MethodType methodType, boolean isVarargs, List<String> paramNames) {\n+        append(methodType.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            pExprs.add(pName);\n+            Class<?> pType = methodType.parameterType(i);\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (isVarargs) {\n+            String lastArg = \"x\" + numParams;\n+            append(delim + \"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\")\");\n+        return pExprs;\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" () {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get(), ResourceScope.globalScope());\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+        Type.Primitive.Kind kind = primType.kind();\n+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS);\n+            append(\" \" + primType.kind().layout().orElseThrow().getClass().getSimpleName());\n+            append(\" \" + uniqueNestedClassName(name));\n+            append(\" = \");\n+            append(toplevel().rootConstants().resolvePrimitiveLayout((ValueLayout)kind.layout().get()).accessExpression());\n+            append(\";\\n\");\n+            decrAlign();\n+        }\n+    }\n+\n+    void emitPointerTypedef(String name) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" OfAddress \");\n+        append(uniqueNestedClassName(name));\n+        append(\" = \");\n+        append(toplevel().rootConstants().resolvePrimitiveLayout(TypeImpl.PointerImpl.POINTER_LAYOUT).accessExpression());\n+        append(\";\\n\");\n+        decrAlign();\n+    }\n+\n+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n+        return switch(kind) {\n+            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private String getConstantString(Class<?> type, Object value) {\n+        StringBuilder buf = new StringBuilder();\n+        if (type == float.class) {\n+            float f = ((Number)value).floatValue();\n+            if (Float.isFinite(f)) {\n+                buf.append(value);\n+                buf.append(\"f\");\n+            } else {\n+                buf.append(\"Float.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else if (type == long.class) {\n+            buf.append(value);\n+            buf.append(\"L\");\n+        } else if (type == double.class) {\n+            double d = ((Number)value).doubleValue();\n+            if (Double.isFinite(d)) {\n+                buf.append(value);\n+                buf.append(\"d\");\n+            } else {\n+                buf.append(\"Double.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else {\n+            buf.append(\"(\" + type.getName() + \")\");\n+            buf.append(value + \"L\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \") \");\n+        append(vhConstant.accessExpression());\n+        append(\".get(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"), x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.*;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+final class InMemoryJavaCompiler {\n+    private InMemoryJavaCompiler() {}\n+\n+    static List<JavaFileObject> compile(List<JavaFileObject> files,\n+                                        String... options) {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n+\n+        Writer writer = new StringWriter();\n+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n+        if (!exitCode) {\n+            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n+        }\n+        return fileManager.getCompiledFiles();\n+    }\n+\n+    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(bytes);\n+            }\n+        };\n+    }\n+\n+    static JavaFileObject jfoFromString(URI uri, String contents) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    \/\/ Wraper for class byte array\n+    private static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        protected ClassFile(String name) {\n+            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+\n+        @Override\n+        public InputStream openInputStream() {\n+            return new ByteArrayInputStream(baos.toByteArray());\n+        }\n+    }\n+\n+    \/\/ File manager which spawns ClassFile instances on demand\n+    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private final List<JavaFileObject> compiled = new ArrayList<>();\n+\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n+            JavaFileObject out = new ClassFile(name);\n+            compiled.add(out);\n+            return out;\n+        }\n+\n+        public List<JavaFileObject> getCompiledFiles() {\n+            return compiled;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/InMemoryJavaCompiler.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Comparator;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+\n+public class IncludeHelper {\n+\n+    public enum IncludeKind {\n+        MACRO,\n+        VAR,\n+        FUNCTION,\n+        TYPEDEF,\n+        STRUCT,\n+        UNION;\n+\n+        public String optionName() {\n+            return \"include-\" + name().toLowerCase();\n+        }\n+\n+        static IncludeKind fromDeclaration(Declaration d) {\n+            if (d instanceof Declaration.Constant) {\n+                return MACRO;\n+            } else if (d instanceof Declaration.Variable) {\n+                return VAR;\n+            } else if (d instanceof Declaration.Function) {\n+                return FUNCTION;\n+            } else if (d instanceof Declaration.Typedef) {\n+                return TYPEDEF;\n+            } else if (d instanceof Declaration.Scoped scoped) {\n+                return fromScoped(scoped);\n+            } else {\n+                throw new IllegalStateException(\"Cannot get here!\");\n+            }\n+        }\n+\n+        static IncludeKind fromScoped(Declaration.Scoped scoped) {\n+            return switch (scoped.kind()) {\n+                case STRUCT -> IncludeKind.STRUCT;\n+                case UNION ->  IncludeKind.UNION;\n+                default -> throw new IllegalStateException(\"Cannot get here!\");\n+            };\n+        }\n+    }\n+\n+    private final EnumMap<IncludeKind, Set<String>> includesSymbolNamesByKind = new EnumMap<>(IncludeKind.class);\n+    private final Set<Declaration> usedDeclarations = new HashSet<>();\n+    public String dumpIncludesFile;\n+\n+    public void addSymbol(IncludeKind kind, String symbolName) {\n+        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+        names.add(symbolName);\n+    }\n+\n+    public boolean isIncluded(Declaration.Variable variable) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.VAR, variable);\n+    }\n+\n+    public boolean isIncluded(Declaration.Function function) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.FUNCTION, function);\n+    }\n+\n+    public boolean isIncluded(Declaration.Constant constant) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.MACRO, constant);\n+    }\n+\n+    public boolean isIncluded(Declaration.Typedef typedef) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.TYPEDEF, typedef);\n+    }\n+\n+    public boolean isIncluded(Declaration.Scoped scoped) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.fromScoped(scoped), scoped);\n+    }\n+\n+    private boolean checkIncludedAndAddIfNeeded(IncludeKind kind, Declaration declaration) {\n+        boolean included = isIncludedInternal(kind, declaration);\n+        if (included && dumpIncludesFile != null) {\n+            usedDeclarations.add(declaration);\n+        }\n+        return included;\n+    }\n+\n+    private boolean isIncludedInternal(IncludeKind kind, Declaration declaration) {\n+        if (!isEnabled()) {\n+            return true;\n+        } else {\n+            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+            return names.contains(declaration.name());\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return includesSymbolNamesByKind.size() > 0;\n+    }\n+\n+    public void dumpIncludes() {\n+        try (var writer = Files.newBufferedWriter(Path.of(dumpIncludesFile), StandardOpenOption.CREATE)) {\n+            Map<Path, Set<Declaration>> declsByPath = usedDeclarations.stream()\n+                    .collect(Collectors.groupingBy(d -> d.pos().path(),\n+                            () -> new TreeMap<>(Path::compareTo),\n+                            Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Declaration::name)))));\n+            String lineSep = \"\";\n+            for (Map.Entry<Path, Set<Declaration>> pathEntries : declsByPath.entrySet()) {\n+                writer.append(lineSep);\n+                writer.append(\"#### Extracted from: \" + pathEntries.getKey().toString() + \"\\n\\n\");\n+                Map<IncludeKind, List<Declaration>> declsByKind = pathEntries.getValue().stream()\n+                        .collect(Collectors.groupingBy(IncludeKind::fromDeclaration));\n+                int maxLengthOptionCol = pathEntries.getValue().stream().mapToInt(d -> d.name().length()).max().getAsInt();\n+                maxLengthOptionCol += 2; \/\/ --\n+                maxLengthOptionCol += IncludeKind.FUNCTION.optionName().length(); \/\/ max option name\n+                maxLengthOptionCol += 1; \/\/ space\n+                for (Map.Entry<IncludeKind, List<Declaration>> kindEntries : declsByKind.entrySet()) {\n+                    for (Declaration d : kindEntries.getValue()) {\n+                        writer.append(String.format(\"%-\" + maxLengthOptionCol + \"s %s\",\n+                                \"--\" + kindEntries.getKey().optionName() + \" \" + d.name(),\n+                                       \"# header: \" + pathEntries.getKey() + \"\\n\"));\n+                    }\n+                }\n+                lineSep = \"\\n\";\n+            }\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/IncludeHelper.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+public abstract class JavaSourceBuilder {\n+\n+    \/\/ public API (used by OutputFactory)\n+\n+    public static record FunctionInfo(\n+            MethodType methodType,\n+            MethodType reverseMethodType,\n+            FunctionDescriptor descriptor,\n+            boolean isVarargs,\n+            Optional<List<String>> parameterNames) {\n+\n+        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n+            return new FunctionInfo(methodType, null, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+        }\n+\n+        static FunctionInfo ofFunctionPointer(MethodType upcallType, MethodType downcallType, FunctionDescriptor functionDescriptor,\n+                 Optional<List<String>> parameterNames) {\n+            return new FunctionInfo(upcallType, downcallType, functionDescriptor, false, parameterNames);\n+        }\n+   }\n+\n+    public static record VarInfo(\n+            Class<?> carrier,\n+            MemoryLayout layout,\n+            Optional<String> fiName) {\n+\n+        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n+            return new VarInfo(carrier, layout, Optional.empty());\n+        }\n+\n+        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n+            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n+        }\n+    }\n+\n+    public void addVar(String javaName, String nativeName, ClassSourceBuilder.VarInfo varInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addFunction(String javaName, String nativeName, ClassSourceBuilder.FunctionInfo functionInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addTypedef(String name, String superClass, Type type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String addFunctionalInterface(String name, ClassSourceBuilder.FunctionInfo fInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    abstract public List<JavaFileObject> toFiles();\n+\n+    public abstract String packageName();\n+\n+    Set<String> nestedClassNames = new HashSet<>();\n+    int nestedClassNameCount = 0;\n+\n+    \/*\n+     * We may have case-insensitive name collision! A C program may have\n+     * defined structs\/unions\/typedefs with the names FooS, fooS, FoOs, fOOs.\n+     * Because we map structs\/unions\/typedefs to nested classes of header classes,\n+     * such a case-insensitive name collision is problematic. This is because in\n+     * a case-insensitive file system javac will overwrite classes for\n+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by\n+     * generating unique case-insensitive names for nested classes.\n+     *\/\n+    final String uniqueNestedClassName(String name) {\n+        name = Utils.javaSafeIdentifier(name);\n+        var notSeen = nestedClassNames.add(name.toLowerCase());\n+        var notEnclosed = !isEnclosedBySameName(name.toLowerCase());\n+        return notSeen && notEnclosed? name : (name + \"$\" + nestedClassNameCount++);\n+    }\n+\n+    abstract boolean isEnclosedBySameName(String name);\n+\n+    abstract protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer);\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/JavaSourceBuilder.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,379 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Position;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.JextractTool;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.CursorKind;\n+import org.openjdk.jextract.clang.Diagnostic;\n+import org.openjdk.jextract.clang.EvalResult;\n+import org.openjdk.jextract.clang.Index;\n+import org.openjdk.jextract.clang.LibClang;\n+import org.openjdk.jextract.clang.TranslationUnit;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+class MacroParserImpl {\n+\n+    private final ClangReparser reparser;\n+    private final TreeMaker treeMaker;\n+    final MacroTable macroTable;\n+\n+    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {\n+        this.reparser = reparser;\n+        this.treeMaker = treeMaker;\n+        this.macroTable = new MacroTable();\n+    }\n+\n+    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n+        ClangReparser reparser;\n+        try {\n+            reparser = new ClangReparser(tu, args);\n+        } catch (IOException | Index.ParsingFailedException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        return new MacroParserImpl(reparser, treeMaker);\n+    }\n+\n+    \/**\n+     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made\n+     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.\n+     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall\n+     * back to use clang evaluation support.\n+     *\/\n+    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n+        if (!(pos instanceof TreeMaker.CursorPosition)) {\n+            return Optional.empty();\n+        } else {\n+            Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();\n+            if (cursor.isMacroFunctionLike()) {\n+                return Optional.empty();\n+            } else if (tokens.length == 2) {\n+                \/\/check for fast path\n+                Integer num = toNumber(tokens[1]);\n+                if (num != null) {\n+                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n+                }\n+            }\n+            macroTable.enterMacro(name, tokens, cursor);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Integer toNumber(String str) {\n+        try {\n+            \/\/ Integer.decode supports '#' hex literals which is not valid in C.\n+            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;\n+        } catch (NumberFormatException nfe) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * This class allows client to reparse a snippet of code against a given set of include files.\n+     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled\n+     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.\n+     *\/\n+    static class ClangReparser {\n+        final Path macro;\n+        final Index macroIndex = LibClang.createIndex(true);\n+        final TranslationUnit macroUnit;\n+\n+        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n+            Path precompiled = Files.createTempFile(\"jextract$\", \".pch\");\n+            precompiled.toFile().deleteOnExit();\n+            tu.save(precompiled);\n+            this.macro = Files.createTempFile(\"jextract$\", \".h\");\n+            this.macro.toFile().deleteOnExit();\n+            String[] patchedArgs = Stream.concat(\n+                Stream.of(\n+                    \/\/ Avoid system search path, use bundled instead\n+                    \"-nostdinc\",\n+                    \"-ferror-limit=0\",\n+                    \/\/ precompiled header\n+                    \"-include-pch\", precompiled.toAbsolutePath().toString()),\n+                args.stream()).toArray(String[]::new);\n+            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),\n+                    this::processDiagnostics,\n+                    false, \/\/add serialization support (needed for macros)\n+                    patchedArgs);\n+        }\n+\n+        void processDiagnostics(Diagnostic diag) {\n+            if (JextractTool.DEBUG) {\n+                System.err.println(\"Error while processing macro: \" + diag.spelling());\n+            }\n+        }\n+\n+        public Stream<Cursor> reparse(String snippet) {\n+            macroUnit.reparse(this::processDiagnostics,\n+                    Index.UnsavedFile.of(macro, snippet));\n+            return macroUnit.getCursor().children();\n+        }\n+    }\n+\n+    \/**\n+     * This abstraction is used to collect all macros which could not be interpreted during {@link #parseConstant(Position, String, String[])}.\n+     * All unparsed macros in the table can have three different states: UNPARSED (which means the macro has not been parsed yet),\n+     * SUCCESS (which means the macro has been parsed and has a type and a value) and FAILURE, which means the macro has been\n+     * parsed with some errors, but for which we were at least able to infer a type.\n+     *\n+     * The reparsing process goes as follows:\n+     * 1. all unparsed macros are added to the table in the UNPARSED state.\n+     * 2. a snippet for all macros in the UNPARSED state is compiled and the table state is updated\n+     * 3. a recovery snippet for all macros in the FAILURE state is compiled and the table state is updated again\n+     * 4. we repeat from (2) until no further progress is made.\n+     * 5. we return a list of macro which are in the SUCCESS state.\n+     *\n+     * State transitions in the table are as follows:\n+     * - an UNPARSED macro can go to either SUCCESS, to FAILURE or be removed (if not even a type can be inferred)\n+     * - a FAILURE macro can go to either SUCCESS (if recovery step succeds) or be removed\n+     * - a SUCCESS macro cannot go in any other state\n+     *\/\n+    class MacroTable {\n+\n+        final Map<String, Entry> macrosByMangledName = new LinkedHashMap<>();\n+\n+        abstract class Entry {\n+            final String name;\n+            final String[] tokens;\n+            final Cursor cursor;\n+\n+            Entry(String name, String[] tokens, Cursor cursor) {\n+                this.name = name;\n+                this.tokens = tokens;\n+                this.cursor = cursor;\n+            }\n+\n+            String mangledName() {\n+                return \"jextract$macro$\" + name;\n+            }\n+\n+            Entry success(Type type, Object value) {\n+                throw new IllegalStateException();\n+            }\n+\n+            Entry failure(Type type) {\n+                throw new IllegalStateException();\n+            }\n+\n+            boolean isSuccess() {\n+                return false;\n+            }\n+            boolean isRecoverableFailure() {\n+                return false;\n+            }\n+            boolean isUnparsed() {\n+                return false;\n+            }\n+\n+            void update() {\n+                macrosByMangledName.put(mangledName(), this);\n+            }\n+        }\n+\n+        class Unparsed extends Entry {\n+            Unparsed(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return type != null ?\n+                        new RecoverableFailure(name, tokens, cursor, type) :\n+                        new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isUnparsed() {\n+                return true;\n+            }\n+\n+            @Override\n+            void update() {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        class RecoverableFailure extends Entry {\n+\n+            final Type type;\n+\n+            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, this.type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isRecoverableFailure() {\n+                return true;\n+            }\n+        }\n+\n+        class Success extends Entry {\n+            final Type type;\n+            final Object value;\n+\n+            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+                this.value = value;\n+            }\n+\n+            @Override\n+            boolean isSuccess() {\n+                return true;\n+            }\n+\n+            public Object value() {\n+                return value;\n+            }\n+        }\n+\n+        class UnparseableMacro extends Entry {\n+\n+            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            void update() {\n+                macrosByMangledName.remove(mangledName());\n+            }\n+        };\n+\n+        void enterMacro(String name, String[] tokens, Cursor cursor) {\n+            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n+            macrosByMangledName.put(unparsed.mangledName(), unparsed);\n+        }\n+\n+        public List<Declaration.Constant> reparseConstants() {\n+            int last = -1;\n+            while (macrosByMangledName.size() > 0 && last != macrosByMangledName.size()) {\n+                last = macrosByMangledName.size();\n+                \/\/ step 1 - try parsing macros as var declarations\n+                reparseMacros(false);\n+                \/\/ step 2 - retry failed parsed macros as pointers\n+                reparseMacros(true);\n+            }\n+            treeMaker.typeMaker.resolveTypeReferences();\n+            return macrosByMangledName.values().stream()\n+                    .filter(Entry::isSuccess)\n+                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+            String mangledName = decl.spelling();\n+            Entry entry = macrosByMangledName.get(mangledName);\n+            try (EvalResult result = decl.eval()) {\n+                Entry newEntry = switch (result.getKind()) {\n+                    case Integral -> {\n+                        long value = result.getAsInt();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case FloatingPoint -> {\n+                        double value = result.getAsFloat();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case StrLiteral -> {\n+                        String value = result.getAsString();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    default -> {\n+                        Type type = decl.type().equals(decl.type().canonicalType()) ?\n+                                null : typeMaker.makeType(decl.type());\n+                        yield entry.failure(type);\n+                    }\n+                };\n+                newEntry.update();\n+            }\n+        }\n+\n+        void reparseMacros(boolean recovery) {\n+            String snippet = macroDecl(recovery);\n+            TreeMaker treeMaker = new TreeMaker();\n+            try {\n+                reparser.reparse(snippet)\n+                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n+                                c.spelling().contains(\"jextract$\"))\n+                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n+            } finally {\n+                treeMaker.typeMaker.resolveTypeReferences();\n+            }\n+        }\n+\n+        String macroDecl(boolean recovery) {\n+            StringBuilder buf = new StringBuilder();\n+            if (recovery) {\n+                buf.append(\"#include <stdint.h>\\n\");\n+            }\n+            macrosByMangledName.values().stream()\n+                    .filter(e -> !e.isSuccess()) \/\/ skip macros that already have passed\n+                    .filter(recovery ? Entry::isRecoverableFailure : Entry::isUnparsed)\n+                    .forEach(e -> {\n+                        buf.append(\"__auto_type \")\n+                                .append(e.mangledName())\n+                                .append(\" = \");\n+                        if (recovery) {\n+                            buf.append(\"(uintptr_t)\");\n+                        }\n+                        buf.append(e.name)\n+                                .append(\";\\n\");\n+                    });\n+            return buf.toString();\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/MacroParserImpl.java","additions":379,"deletions":0,"binary":false,"changes":379,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Options {\n+\n+    \/\/ The args for parsing C\n+    public final List<String> clangArgs;\n+    \/\/ The list of library names\n+    public final List<String> libraryNames;\n+    public final List<String> filters;\n+    \/\/ target package\n+    public final String targetPackage;\n+    \/\/ output directory\n+    public final String outputDir;\n+    public final boolean source;\n+    public final IncludeHelper includeHelper;\n+\n+    private Options(List<String> clangArgs, List<String> libraryNames,\n+            List<String> filters, String targetPackage,\n+            String outputDir, boolean source, IncludeHelper includeHelper) {\n+        this.clangArgs = clangArgs;\n+        this.libraryNames = libraryNames;\n+        this.filters = filters;\n+        this.targetPackage = targetPackage;\n+        this.outputDir = outputDir;\n+        this.source = source;\n+        this.includeHelper = includeHelper;\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Options createDefault() {\n+        return builder().build();\n+    }\n+\n+    public static class Builder {\n+        private final List<String> clangArgs;\n+        private final List<String> libraryNames;\n+        private final List<String> filters;\n+        private String targetPackage;\n+        private String outputDir;\n+        private boolean source;\n+        private IncludeHelper includeHelper = new IncludeHelper();\n+\n+        public Builder() {\n+            this.clangArgs = new ArrayList<>();\n+            this.libraryNames = new ArrayList<>();\n+            this.filters = new ArrayList<>();\n+            this.targetPackage = \"\";\n+            this.outputDir = \".\";\n+            this.source = false;\n+        }\n+\n+        public Options build() {\n+            return new Options(\n+                    Collections.unmodifiableList(clangArgs),\n+                    Collections.unmodifiableList(libraryNames),\n+                    Collections.unmodifiableList(filters),\n+                    targetPackage, outputDir, source, includeHelper\n+            );\n+        }\n+\n+        public void addClangArg(String arg) {\n+            clangArgs.add(arg);\n+        }\n+\n+        public void addLibraryName(String name) {\n+            libraryNames.add(name);\n+        }\n+\n+        public void setOutputDir(String outputDir) {\n+            this.outputDir = outputDir;\n+        }\n+\n+        public void setTargetPackage(String pkg) {\n+            this.targetPackage = pkg;\n+        }\n+\n+        public void addFilter(String filter) {\n+            filters.add(filter);\n+        }\n+\n+        public void setGenerateSource() {\n+            source = true;\n+        }\n+\n+        public void setDumpIncludeFile(String dumpIncludesFile) {\n+            includeHelper.dumpIncludesFile = dumpIncludesFile;\n+        }\n+\n+        public void addIncludeSymbol(IncludeHelper.IncludeKind kind, String symbolName) {\n+            includeHelper.addSymbol(kind, symbolName);\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Options.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,500 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.JextractTool;\n+import org.openjdk.jextract.Type;\n+\n+import org.openjdk.jextract.impl.JavaSourceBuilder.VarInfo;\n+import org.openjdk.jextract.impl.JavaSourceBuilder.FunctionInfo;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * Scan a header file and generate Java source items for entities defined in that header\n+ * file. Tree visitor visit methods return true\/false depending on whether a\n+ * particular Tree is processed or skipped.\n+ *\/\n+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {\n+    \/\/ internal symbol used by clang for \"va_list\"\n+    private static final String VA_LIST_TAG = \"__va_list_tag\";\n+    private final Set<String> constants = new HashSet<>();\n+    \/\/ To detect duplicate Variable and Function declarations.\n+    private final Set<String> variables = new HashSet<>();\n+    private final Set<Declaration.Function> functions = new HashSet<>();\n+\n+    protected final ToplevelBuilder toplevelBuilder;\n+    protected JavaSourceBuilder currentBuilder;\n+    protected final TypeTranslator typeTranslator = new TypeTranslator();\n+    private final String pkgName;\n+    private final Map<Declaration, String> structClassNames = new HashMap<>();\n+    private final Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n+    private final IncludeHelper includeHelper;\n+\n+    private void addStructDefinition(Declaration decl, String name) {\n+        structClassNames.put(decl, name);\n+    }\n+\n+    private boolean structDefinitionSeen(Declaration decl) {\n+        return structClassNames.containsKey(decl);\n+    }\n+\n+    private String structDefinitionName(Declaration decl) {\n+        return structClassNames.get(decl);\n+    }\n+\n+    private void addFunctionTypedef(Type.Delegated typedef, String name) {\n+        functionTypeDefNames.put(typedef, name);\n+    }\n+\n+    private boolean functionTypedefSeen(Type.Delegated typedef) {\n+        return functionTypeDefNames.containsKey(typedef);\n+    }\n+\n+    private String functionTypedefName(Type.Delegated decl) {\n+        return functionTypeDefNames.get(decl);\n+    }\n+\n+    \/\/ have we seen this Variable earlier?\n+    protected boolean variableSeen(Declaration.Variable tree) {\n+        return !variables.add(tree.name());\n+    }\n+\n+    \/\/ have we seen this Function earlier?\n+    protected boolean functionSeen(Declaration.Function tree) {\n+        return !functions.add(tree);\n+    }\n+\n+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName,\n+                String pkgName, IncludeHelper includeHelper, List<String> libraryNames) {\n+        String clsName = Utils.javaSafeIdentifier(headerName.replace(\".h\", \"_h\"), true);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName);\n+        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl, libraryNames.toArray(new String[0]));\n+    }\n+\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, IncludeHelper includeHelper) {\n+        this.pkgName = pkgName;\n+        this.toplevelBuilder = toplevelBuilder;\n+        this.currentBuilder = toplevelBuilder;\n+        this.includeHelper = includeHelper;\n+    }\n+\n+    JavaFileObject[] generate(Declaration.Scoped decl, String[] libs) {\n+        \/\/generate all decls\n+        decl.members().forEach(this::generateDecl);\n+        \/\/ check if unresolved typedefs can be resolved now!\n+        for (Declaration.Typedef td : unresolvedStructTypedefs) {\n+            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n+            toplevelBuilder.addTypedef(td.name(),\n+                    structDefinitionSeen(structDef) ? structDefinitionName(structDef) : null, td.type());\n+        }\n+        try {\n+            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n+            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource(libs)));\n+            return files.toArray(new JavaFileObject[0]);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (URISyntaxException ex2) {\n+            throw new RuntimeException(ex2);\n+        }\n+    }\n+\n+    private String getRuntimeHelperSource(String[] libraries) throws URISyntaxException, IOException {\n+        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n+        String template = (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+                        String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())));\n+        List<String> loadLibrariesStr = new ArrayList<>();\n+        for (String lib : libraries) {\n+            String quotedLibName = quoteLibraryName(lib);\n+            if (quotedLibName.indexOf(File.separatorChar) != -1) {\n+                loadLibrariesStr.add(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n+            } else {\n+                loadLibrariesStr.add(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n+            }\n+        }\n+        return template.replace(\"#LOAD_LIBRARIES#\", loadLibrariesStr.stream().collect(Collectors.joining(\" \")));\n+    }\n+\n+    private String quoteLibraryName(String lib) {\n+        return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+    }\n+\n+    private void generateDecl(Declaration tree) {\n+        try {\n+            tree.accept(this, null);\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + \".java\"), contents);\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {\n+        if (!constants.add(constant.name()) || !includeHelper.isIncluded(constant)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(constant.type());\n+        if (clazz == null) {\n+            warn(\"skipping \" + constant.name() + \" because of unsupported type usage\");\n+            return null;\n+        }\n+        toplevelBuilder.addConstant(Utils.javaSafeIdentifier(constant.name()),\n+                constant.value() instanceof String ? MemorySegment.class :\n+                getJavaType(constant.type()), constant.value());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {\n+        if (d.layout().isEmpty() || structDefinitionSeen(d)) {\n+            \/\/skip decl\n+            return null;\n+        }\n+        boolean isStructKind = switch (d.kind()) {\n+            case STRUCT, UNION -> true;\n+            default -> false;\n+        };\n+        StructBuilder structBuilder = null;\n+        if (isStructKind) {\n+            String className = d.name();\n+            if (!className.isEmpty() && !includeHelper.isIncluded(d)) {\n+                return null;\n+            }\n+            GroupLayout layout = (GroupLayout) layoutFor(d);\n+            currentBuilder = structBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            structBuilder.classBegin();\n+            if (!className.isEmpty()) {\n+                addStructDefinition(d, structBuilder.fullName());\n+            }\n+        }\n+        try {\n+            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        } finally {\n+            if (isStructKind) {\n+                currentBuilder = structBuilder.classEnd();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String generateFunctionalInterface(Type.Function func, String name) {\n+        return functionInfo(func, name, false,\n+                 (mtype, desc) -> FunctionInfo.ofFunctionPointer(mtype, getMethodType(func, true), desc, func.parameterNames()))\n+                 .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n+                 .orElse(null);\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {\n+        if (functionSeen(funcTree) ||\n+                !includeHelper.isIncluded(funcTree)) {\n+            return null;\n+        }\n+\n+        String mhName = Utils.javaSafeIdentifier(funcTree.name());\n+        \/\/generate static wrapper for function\n+        List<String> paramNames = funcTree.parameters()\n+                                          .stream()\n+                                          .map(Declaration.Variable::name)\n+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)\n+                                          .collect(Collectors.toList());\n+\n+        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n+                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n+\n+        if (functionInfo.isPresent()) {\n+            int i = 0;\n+            for (Declaration.Variable param : funcTree.parameters()) {\n+                Type.Function f = getAsFunctionPointer(param.type());\n+                if (f != null) {\n+                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                    if (generateFunctionalInterface(f, name) == null) {\n+                        return null;\n+                    }\n+                    i++;\n+                }\n+            }\n+\n+            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n+        }\n+\n+        return null;\n+    }\n+\n+    Optional<String> getAsFunctionPointerTypedef(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n+                functionTypedefSeen(delegated)) {\n+            return Optional.of(functionTypedefName(delegated));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    Type.Function getAsFunctionPointer(Type type) {\n+        if (type instanceof Type.Function) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return (Type.Function) type;\n+        } else if (Utils.isPointerType(type)) {\n+            return getAsFunctionPointer(((Type.Delegated)type).type());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {\n+        if (!includeHelper.isIncluded(tree)) {\n+            return null;\n+        }\n+        Type type = tree.type();\n+        if (type instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) type).tree();\n+            if (!s.name().equals(tree.name())) {\n+                switch (s.kind()) {\n+                    case STRUCT, UNION -> {\n+                        if (s.name().isEmpty()) {\n+                            visitScoped(s, tree);\n+                        } else {\n+                            \/*\n+                             * If typedef is seen after the struct\/union definition, we can generate subclass\n+                             * right away. If not, we've to save it and revisit after all the declarations are\n+                             * seen. This is to support forward declaration of typedefs.\n+                             *\n+                             * typedef struct Foo Bar;\n+                             *\n+                             * struct Foo {\n+                             *     int x, y;\n+                             * };\n+                             *\/\n+                            if (structDefinitionSeen(s)) {\n+                                toplevelBuilder.addTypedef(tree.name(), structDefinitionName(s), tree.type());\n+                            } else {\n+                                \/*\n+                                 * Definition of typedef'ed struct\/union not seen yet. May be the definition comes later.\n+                                 * Save it to visit at the end of all declarations.\n+                                 *\/\n+                                unresolvedStructTypedefs.add(tree);\n+                            }\n+                        }\n+                    }\n+                    default -> visitScoped(s, tree);\n+                }\n+            }\n+        } else if (type instanceof Type.Primitive) {\n+             toplevelBuilder.addTypedef(tree.name(), null, type);\n+        } else {\n+            Type.Function func = getAsFunctionPointer(type);\n+            if (func != null) {\n+                String funcIntfName = generateFunctionalInterface(func, tree.name());\n+                if (funcIntfName != null) {\n+                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), funcIntfName);\n+                }\n+            } else if (((TypeImpl)type).isPointer()) {\n+                toplevelBuilder.addTypedef(tree.name(), null, type);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {\n+        if (parent == null && (variableSeen(tree) || !includeHelper.isIncluded(tree))) {\n+            return null;\n+        }\n+\n+        String fieldName = tree.name();\n+        String symbol = tree.name();\n+        assert !symbol.isEmpty();\n+        assert !fieldName.isEmpty();\n+        fieldName = Utils.javaSafeIdentifier(fieldName);\n+\n+        Type type = tree.type();\n+\n+        if (type instanceof Type.Declared) {\n+            \/\/ declared type - visit declaration recursively\n+            ((Type.Declared) type).tree().accept(this, tree);\n+        }\n+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));\n+        if (layout == null) {\n+            \/\/no layout - abort\n+            return null;\n+        }\n+\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(type);\n+        if (unsupportedType != null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(type);\n+        if (clazz == null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage\");\n+            return null;\n+        }\n+\n+\n+        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n+        Type.Function func = getAsFunctionPointer(type);\n+        String fiName;\n+        if (func != null) {\n+            fiName = generateFunctionalInterface(func, fieldName);\n+            if (fiName != null) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n+            }\n+        } else {\n+            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n+            if (funcTypedef.isPresent()) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, Utils.javaSafeIdentifier(funcTypedef.get()));\n+            }\n+        }\n+\n+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        boolean sizeAvailable;\n+        try {\n+            layout.byteSize();\n+            sizeAvailable = true;\n+        } catch (Exception ignored) {\n+            sizeAvailable = false;\n+        }\n+        if (sizeAvailable) {\n+            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n+        } else {\n+            warn(\"Layout size not available for \" + fieldName);\n+        }\n+\n+        return null;\n+    }\n+\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean downcall,\n+                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n+        if (descriptor == null) {\n+            \/\/abort\n+            return Optional.empty();\n+        }\n+\n+        \/\/generate functional interface\n+        if (!downcall && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n+            return Optional.empty();\n+        }\n+\n+        String unsupportedType = UnsupportedLayouts.firstUnsupportedType(funcPtr);\n+        if (unsupportedType != null) {\n+            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n+                    unsupportedType);\n+            return Optional.empty();\n+        }\n+\n+        MethodType mtype = getMethodType(funcPtr, downcall);\n+        return mtype != null ?\n+                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n+                Optional.empty();\n+    }\n+\n+    protected static MemoryLayout layoutFor(Declaration decl) {\n+        if (decl instanceof Declaration.Typedef) {\n+            Declaration.Typedef alias = (Declaration.Typedef) decl;\n+            return Type.layoutFor(alias.type()).orElseThrow();\n+        } else if (decl instanceof Declaration.Scoped) {\n+            return ((Declaration.Scoped) decl).layout().orElseThrow();\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected parent declaration\");\n+        }\n+        \/\/ case like `typedef struct { ... } Foo`\n+    }\n+\n+    static void warn(String msg) {\n+        System.err.println(\"WARNING: \" + msg);\n+    }\n+\n+    private Class<?> getJavaType(Type type) {\n+        try {\n+            return typeTranslator.getJavaType(type, false);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private MethodType getMethodType(Type.Function type, boolean downcall) {\n+        try {\n+            return typeTranslator.getMethodType(type, downcall);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/OutputFactory.java","additions":500,"deletions":0,"binary":false,"changes":500,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.CursorKind;\n+import org.openjdk.jextract.clang.Diagnostic;\n+import org.openjdk.jextract.clang.Index;\n+import org.openjdk.jextract.clang.LibClang;\n+import org.openjdk.jextract.clang.SourceLocation;\n+import org.openjdk.jextract.clang.SourceRange;\n+import org.openjdk.jextract.clang.TranslationUnit;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class Parser {\n+    private final TreeMaker treeMaker;\n+\n+    public Parser() {\n+        this.treeMaker = new TreeMaker();\n+    }\n+\n+    public Declaration.Scoped parse(Path path, Collection<String> args) {\n+        final Index index = LibClang.createIndex(false);\n+\n+        TranslationUnit tu = index.parse(path.toString(),\n+            d -> {\n+                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n+                    throw new ClangException(d.toString());\n+                }\n+            },\n+            true, args.toArray(new String[0]));\n+\n+        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);\n+\n+        List<Declaration> decls = new ArrayList<>();\n+        Cursor tuCursor = tu.getCursor();\n+        tuCursor.children().\n+            forEach(c -> {\n+                SourceLocation loc = c.getSourceLocation();\n+                if (loc == null) {\n+                    return;\n+                }\n+\n+                SourceLocation.Location src = loc.getFileLocation();\n+                if (src == null) {\n+                    return;\n+                }\n+\n+\n+                if (c.isDeclaration()) {\n+                    if (c.kind() == CursorKind.UnexposedDecl ||\n+                        c.kind() == CursorKind.Namespace) {\n+                        c.children().map(treeMaker::createTree)\n+                                .filter(t -> t != null)\n+                                .forEach(decls::add);\n+                    } else {\n+                        Declaration decl = treeMaker.createTree(c);\n+                        if (decl != null) {\n+                            decls.add(decl);\n+                        }\n+                    }\n+                } else if (isMacro(c) && src.path() != null) {\n+                    SourceRange range = c.getExtent();\n+                    String[] tokens = c.getTranslationUnit().tokens(range);\n+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(TreeMaker.CursorPosition.of(c), c.spelling(), tokens);\n+                    if (constant.isPresent()) {\n+                        decls.add(constant.get());\n+                    }\n+                }\n+            });\n+\n+        decls.addAll(macroParser.macroTable.reparseConstants());\n+        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n+        treeMaker.freeze();\n+        index.close();\n+        return rv;\n+    }\n+\n+    private boolean isMacro(Cursor c) {\n+        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Parser.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Position;\n+import org.openjdk.jextract.Type;\n+\n+public class PrettyPrinter implements Declaration.Visitor<Void, Void> {\n+\n+    private static String SPACES = \" \".repeat(92);\n+    int align = 0;\n+\n+    void incr() {\n+        align += 4;\n+    }\n+\n+    void decr() {\n+        align -= 4;\n+    }\n+\n+    void indent() {\n+        builder.append(SPACES.substring(0, align));\n+    }\n+\n+    StringBuilder builder = new StringBuilder();\n+\n+    private void getAttributes(Declaration decl) {\n+        Set<String> attrs = decl.attributeNames();\n+        if (attrs.isEmpty()) {\n+            return;\n+        }\n+        incr();\n+        indent();\n+        for (String k: attrs) {\n+            builder.append(\"Attr: \");\n+            builder.append(k);\n+            builder.append(\" -> [\");\n+            builder.append(decl.getAttribute(k).get().stream()\n+                .map(Constable::toString)\n+                .collect(Collectors.joining(\", \")));\n+            builder.append(\"]\\n\");\n+        }\n+        decr();\n+    }\n+\n+    public String print(Declaration decl) {\n+        decl.accept(this, null);\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n+        indent();\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.members().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Void aVoid) {\n+        indent();\n+        builder.append(\"Function: \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.parameters().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Void aVoid) {\n+        indent();\n+        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Void aVoid) {\n+        indent();\n+        builder.append(\"Constant: \" + d.name() + \" \" + d.value() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef d, Void aVoid) {\n+        indent();\n+        builder.append(\"Typedef: \").append(d.name()).append(\" = \")\n+               .append(d.type().accept(typeVisitor, null)).append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void aVoid) {\n+            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void aVoid) {\n+            switch (t.kind()) {\n+                case TYPEDEF:\n+                    return \"typedef \" + t.name() + \" = \" + t.type().accept(this, null);\n+                case POINTER:\n+                    return \"(\" + t.type().accept(this, null) + \")*\";\n+                default:\n+                    return t.kind() + \" = \" + t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void aVoid) {\n+            String res = t.returnType().accept(this, null);\n+            String args = t.argumentTypes().stream()\n+                    .map(a -> a.accept(this, null))\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            return res + args;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void aVoid) {\n+            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void aVoid) {\n+            String brackets = String.format(\"%s[%s]\", t.kind() == Type.Array.Kind.VECTOR ? \"v\" : \"\",\n+                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n+            return t.elementType().accept(this, null) + brackets;\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void aVoid) {\n+            return \"Unknown type: \" + t.getClass().getName();\n+        }\n+    };\n+\n+    public static String type(Type type) {\n+        return type.accept(typeVisitor, null);\n+    }\n+\n+    public static String position(Position pos) {\n+        return String.format(\"%s:%d:%d\",\n+                pos.path() == null ? \"N\/A\" : pos.path().toString(),\n+                pos.line(), pos.col());\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/PrettyPrinter.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.CursorKind;\n+import org.openjdk.jextract.clang.Type;\n+import org.openjdk.jextract.clang.TypeKind;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Base class for C struct, union MemoryLayout computer helper classes.\n+ *\/\n+abstract class RecordLayoutComputer {\n+    \/\/ enclosing struct type (or this struct type for top level structs)\n+    final Type parent;\n+    \/\/ this struct type\n+    final Type type;\n+    \/\/ cursor of this struct\n+    final Cursor cursor;\n+    final List<Declaration> fieldDecls;\n+    final List<MemoryLayout> fieldLayouts;\n+\n+    final TypeMaker typeMaker;\n+\n+    private int anonCount = 0;\n+\n+    RecordLayoutComputer(TypeMaker typeMaker, Type parent, Type type) {\n+        this.parent = parent;\n+        this.type = type;\n+        this.cursor = type.getDeclarationCursor().getDefinition();\n+        this.fieldDecls = new ArrayList<>();\n+        this.fieldLayouts = new ArrayList<>();\n+        this.typeMaker = typeMaker;\n+    }\n+\n+    static org.openjdk.jextract.Type compute(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        return computeInternal(typeMaker, offsetInParent, parent, type, null);\n+    }\n+\n+    private static org.openjdk.jextract.Type computeAnonymous(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n+        return computeInternal(typeMaker, offsetInParent, parent, type, name);\n+    }\n+\n+    static final org.openjdk.jextract.Type.Declared ERRONEOUS = org.openjdk.jextract.Type.declared(\n+            Declaration.struct(TreeMaker.CursorPosition.NO_POSITION, \"\", MemoryLayout.paddingLayout(64)));\n+\n+    private static org.openjdk.jextract.Type computeInternal(TypeMaker typeMaker, long offsetInParent, Type parent, Type type, String name) {\n+        Cursor cursor = type.getDeclarationCursor().getDefinition();\n+        if (cursor.isInvalid()) {\n+            return ERRONEOUS;\n+        }\n+\n+        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n+        return isUnion? new UnionLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name) :\n+                new StructLayoutComputer(typeMaker, offsetInParent, parent, type).compute(name);\n+    }\n+\n+    final org.openjdk.jextract.Type.Declared compute(String anonName) {\n+        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);\n+        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n+            \/*\n+             * Ignore bitfields of zero width.\n+             *\n+             * struct Foo {\n+             *     int i:0;\n+             * }\n+             *\n+             * And bitfields without a name.\n+             * (padding is computed automatically)\n+             *\/\n+            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n+                startBitfield();\n+                continue;\n+            }\n+\n+            processField(fc);\n+        }\n+\n+        return finishRecord(anonName);\n+    }\n+\n+    abstract void startBitfield();\n+    abstract void processField(Cursor c);\n+    abstract org.openjdk.jextract.Type.Declared finishRecord(String anonName);\n+\n+    void addField(Declaration declaration) {\n+        fieldDecls.add(declaration);\n+        MemoryLayout layout = null;\n+        if (declaration instanceof Declaration.Scoped scoped) {\n+            layout = scoped.layout().orElse(null);\n+        } else if (declaration instanceof Declaration.Variable var) {\n+            layout = var.layout().orElse(null);\n+        }\n+        if (layout != null) {\n+            \/\/fieldLayouts.add(layout.name().isEmpty() ? layout.withName(declaration.name()) : layout);\n+            fieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n+        }\n+    }\n+\n+    void addPadding(long bits) {\n+        fieldLayouts.add(MemoryLayout.paddingLayout(bits));\n+    }\n+\n+    void addField(long offset, Type parent, Cursor c) {\n+        if (c.isAnonymousStruct()) {\n+            addField(((org.openjdk.jextract.Type.Declared)computeAnonymous(typeMaker, offset, parent, c.type(), nextAnonymousName())).tree());\n+        } else {\n+            addField(field(c));\n+        }\n+    }\n+\n+    private String nextAnonymousName() {\n+        return \"$anon$\" + anonCount++;\n+    }\n+\n+    Declaration field(Cursor c) {\n+        org.openjdk.jextract.Type type = typeMaker.makeType(c.type());\n+        String name = c.spelling();\n+        if (c.isBitField()) {\n+            MemoryLayout sublayout = MemoryLayout.paddingLayout(c.getBitFieldWidth());\n+            return Declaration.bitfield(TreeMaker.CursorPosition.of(c), name, type, sublayout.withName(name));\n+        } else if (c.isAnonymousStruct() && type instanceof org.openjdk.jextract.Type.Declared decl) {\n+            return decl.tree();\n+        } else {\n+            return Declaration.field(TreeMaker.CursorPosition.of(c), name, type);\n+        }\n+    }\n+\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        }\n+        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n+    }\n+\n+    Declaration.Scoped bitfield(List<MemoryLayout> sublayouts, Declaration.Variable... declarations) {\n+        return Declaration.bitfields(declarations[0].pos(), MemoryLayout.structLayout(sublayouts.toArray(new MemoryLayout[0])), declarations);\n+    }\n+\n+    long offsetOf(Type parent, Cursor c) {\n+        if (c.kind() == CursorKind.FieldDecl) {\n+            return parent.getOffsetOf(c.spelling());\n+        } else {\n+            return Utils.flattenableChildren(c)\n+                    .mapToLong(child -> offsetOf(parent, child))\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalStateException(\n+                            \"Can not find offset of: \" + c + \", in: \" + parent));\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+\n+\/**\n+ * This class generates static utilities class for C structs, unions.\n+ *\/\n+class StructBuilder extends ConstantBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final GroupLayout structLayout;\n+    private final Type structType;\n+    private final Deque<String> prefixElementNames;\n+\n+    StructBuilder(JavaSourceBuilder enclosing, String name, GroupLayout structLayout, Type structType) {\n+        super(enclosing, name);\n+        this.structLayout = structLayout;\n+        this.structType = structType;\n+        prefixElementNames = new ArrayDeque<>();\n+    }\n+\n+    private String safeParameterName(String paramName) {\n+        return isEnclosedBySameName(paramName)? paramName + \"$\" : paramName;\n+    }\n+\n+    void pushPrefixElement(String prefixElementName) {\n+        prefixElementNames.push(prefixElementName);\n+    }\n+\n+    void popPrefixElement() {\n+        prefixElementNames.pop();\n+    }\n+\n+    private List<String> prefixNamesList() {\n+        List<String> prefixes = new ArrayList<>(prefixElementNames);\n+        Collections.reverse(prefixes);\n+        return Collections.unmodifiableList(prefixes);\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        if (!inAnonymousNested()) {\n+            super.classBegin();\n+            addLayout(layoutField(), ((Type.Declared) structType).tree().layout().get())\n+                    .emitGetter(this, MEMBER_MODS, Constant.SUFFIX_ONLY);\n+        }\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        if (!inAnonymousNested()) {\n+            emitSizeof();\n+            emitAllocatorAllocate();\n+            emitAllocatorAllocateArray();\n+            emitScopeAllocate();\n+            emitScopeAllocateArray();\n+            emitOfAddressScoped();\n+            return super.classEnd();\n+        } else {\n+            \/\/ we're in an anonymous struct which got merged into this one, return this very builder and keep it open\n+            popPrefixElement();\n+            return this;\n+        }\n+    }\n+\n+    boolean inAnonymousNested() {\n+        return !prefixElementNames.isEmpty();\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        if (name.isEmpty() && (parent instanceof Declaration.Scoped)) {\n+            \/\/nested anon struct - merge into this builder!\n+            String anonName = layout.name().orElseThrow();\n+            pushPrefixElement(anonName);\n+            return this;\n+        } else {\n+            return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n+        }\n+    }\n+\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        try {\n+            structLayout.byteOffset(elementPaths(nativeName));\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ bad layout - do nothing\n+            OutputFactory.warn(\"skipping '\" + className() + \".\" + nativeName + \"' : \" + uoe.toString());\n+            return;\n+        }\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n+        } else {\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            if (varInfo.fiName().isPresent()) {\n+                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+            }\n+        }\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" (MemorySegment segment, ResourceScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get(segment), scope);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\"\n+                + vhConstant.accessExpression() + \".get(\" + seg + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String param = MemorySegment.class.getSimpleName() + \" \" + seg;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" \" + x + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression() + \".set(\" + seg + \", \" + x + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private MemoryLayout.PathElement[] elementPaths(String nativeFieldName) {\n+        List<String> prefixElements = prefixNamesList();\n+        MemoryLayout.PathElement[] elems = new MemoryLayout.PathElement[prefixElements.size() + 1];\n+        int i = 0;\n+        for (; i < prefixElements.size(); i++) {\n+            elems[i] = MemoryLayout.PathElement.groupElement(prefixElements.get(i));\n+        }\n+        elems[i] = MemoryLayout.PathElement.groupElement(nativeFieldName);\n+        return elems;\n+    }\n+\n+    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" MemorySegment \" + javaName + \"$slice(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + seg + \".asSlice(\");\n+        append(structLayout.byteOffset(elementPaths(nativeName)));\n+        append(\", \");\n+        append(layout.byteSize());\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitSizeof() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatorAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatorAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, SegmentAllocator allocator) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, ResourceScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return allocateArray(len, SegmentAllocator.nativeAllocator(scope));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitOfAddressScoped() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg + \", long \" + index;\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\");\n+        append(vhConstant.accessExpression());\n+        append(\".get(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg +\n+            \", long \" + index + \", \" + type.getSimpleName() + \" \" + x;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()), \");\n+        append(x);\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private String qualifiedName(ClassSourceBuilder builder) {\n+        if (builder.isNested()) {\n+            String prefix = qualifiedName((ClassSourceBuilder)builder.enclosing);\n+            return prefix.isEmpty() ?\n+                    builder.className() :\n+                    prefix + \"$\" + builder.className();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    private String layoutField() {\n+        String suffix = structLayout.isUnion() ? \"union\" : \"struct\";\n+        return qualifiedName(this) + \"$\" + suffix;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C structs.\n+ *\/\n+final class StructLayoutComputer extends RecordLayoutComputer {\n+    private long offset;\n+    private long actualSize = 0L;\n+    \/\/ List to collect bitfield fields to process later, may be null\n+    private List<Declaration> bitfieldDecls;\n+    private List<MemoryLayout> bitfieldLayouts;\n+\n+    StructLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        super(typeMaker, parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void addField(Declaration declaration) {\n+        if (bitfieldDecls != null) {\n+            bitfieldDecls.add(declaration);\n+            MemoryLayout layout = null;\n+            if (declaration instanceof Declaration.Scoped scoped) {\n+                layout = scoped.layout().orElse(null);\n+            } else if (declaration instanceof Declaration.Variable var) {\n+                layout = var.layout().orElse(null);\n+            }\n+            if (layout != null) {\n+                bitfieldLayouts.add(declaration.name().isEmpty() ? layout : layout.withName(declaration.name()));\n+            }\n+        } else {\n+            super.addField(declaration);\n+        }\n+    }\n+\n+    @Override\n+    void addPadding(long bits) {\n+        if (bitfieldDecls != null) {\n+            bitfieldLayouts.add(MemoryLayout.paddingLayout(bits));\n+        } else {\n+            super.addPadding(bits);\n+        }\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/*\n+         * In a struct, a bitfield field is seen after a non-bitfield.\n+         * Initialize bitfieldLayouts list to collect this and subsequent\n+         * bitfield layouts.\n+         *\/\n+        if (bitfieldDecls == null) {\n+            bitfieldDecls = new ArrayList<>();\n+            bitfieldLayouts = new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        boolean isBitfield = c.isBitField();\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            addPadding(expectedOffset - offset);\n+            actualSize += (expectedOffset - offset);\n+            offset = expectedOffset;\n+        }\n+\n+        if (isBitfield) {\n+            startBitfield();\n+        } else { \/\/ !isBitfield\n+            \/*\n+             * We may be crossing from bit fields to non-bitfield field.\n+             *\n+             * struct Foo {\n+             *     int i:12;\n+             *     int j:20;\n+             *     int k; \/\/ <-- processing this\n+             *     int m;\n+             * }\n+             *\/\n+            handleBitfields();\n+        }\n+\n+        addField(offset, parent, c);\n+        long size = fieldSize(c);\n+        offset += size;\n+        actualSize += size;\n+    }\n+\n+    @Override\n+    org.openjdk.jextract.Type.Declared finishRecord(String anonName) {\n+        \/\/ pad at the end, if any\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            addPadding(expectedSize - actualSize);\n+        }\n+\n+        \/*\n+         * Handle bitfields at the end, if any.\n+         *\n+         * struct Foo {\n+         *     int i,j, k;\n+         *     int f:10;\n+         *     int pad:12;\n+         * }\n+         *\/\n+        handleBitfields();\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.structLayout(fields);\n+        if (!cursor.spelling().isEmpty()) {\n+            g = g.withName(cursor.spelling());\n+        } else if (anonName != null) {\n+            g = g.withName(anonName);\n+        }\n+        return org.openjdk.jextract.Type.declared(Declaration.struct(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n+    }\n+\n+    \/\/ process bitfields if any and clear bitfield layouts\n+    private void handleBitfields() {\n+        if (bitfieldDecls != null) {\n+            List<MemoryLayout> prevBitfieldLayouts = bitfieldLayouts;\n+            List<Declaration> prevBitfieldDecls = bitfieldDecls;\n+            bitfieldDecls = null;\n+            if (!prevBitfieldDecls.isEmpty()) {\n+                addField(bitfield(prevBitfieldLayouts, prevBitfieldDecls.toArray(new Declaration.Variable[0])));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+class ToplevelBuilder extends JavaSourceBuilder {\n+\n+    private int declCount;\n+    private final List<JavaSourceBuilder> builders = new ArrayList<>();\n+    private SplitHeader lastHeader;\n+    private RootConstants rootConstants;\n+    private int headersCount;\n+    private final ClassDesc headerDesc;\n+\n+    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n+\n+    ToplevelBuilder(String packageName, String headerClassName) {\n+        this.headerDesc = ClassDesc.of(packageName, headerClassName);\n+        SplitHeader first = lastHeader = new FirstHeader(headerClassName);\n+        rootConstants = new RootConstants();\n+        first.classBegin();\n+        builders.add(first);\n+    }\n+\n+    public RootConstants rootConstants() {\n+        return rootConstants;\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        if (constantBuilder != null) {\n+            constantBuilder.classEnd();\n+        }\n+        lastHeader.classEnd();\n+        builders.addAll(constantBuilders);\n+        builders.add(rootConstants);\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.addAll(builders.stream()\n+                .flatMap(b -> b.toFiles().stream())\n+                .collect(Collectors.toList()));\n+        return files;\n+    }\n+\n+    public String headerClassName() {\n+        return headerDesc.displayName();\n+    }\n+\n+    @Override\n+    boolean isEnclosedBySameName(String name) {\n+        return false;\n+    }\n+\n+    @Override\n+    public String packageName() {\n+        return headerDesc.packageName();\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        nextHeader().addVar(javaName, nativeName, varInfo);\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        nextHeader().addFunction(javaName, nativeName, functionInfo);\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        nextHeader().addConstant(javaName, type, value);\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            nextHeader().emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else if (((TypeImpl)type).isPointer()) {\n+            \/\/ pointer typedef\n+            nextHeader().emitPointerTypedef(name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builders.add(builder);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        String structName = name.isEmpty() ? parent.name() : name;\n+        StructBuilder structBuilder = new StructBuilder(this, structName, layout, type);\n+        builders.add(structBuilder);\n+        return structBuilder;\n+    }\n+\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n+        builders.add(builder);\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n+    }\n+\n+    private SplitHeader nextHeader() {\n+        if (declCount == DECLS_PER_HEADER_CLASS) {\n+            boolean hasSuper = !(lastHeader instanceof FirstHeader);\n+            SplitHeader headerFileBuilder = new SplitHeader(headerDesc.displayName() + \"_\" + ++headersCount,\n+                    hasSuper ? lastHeader.className() : null);\n+            lastHeader.classEnd();\n+            headerFileBuilder.classBegin();\n+            builders.add(headerFileBuilder);\n+            lastHeader = headerFileBuilder;\n+            declCount = 1;\n+            return headerFileBuilder;\n+        } else {\n+            declCount++;\n+            return lastHeader;\n+        }\n+    }\n+\n+    class SplitHeader extends HeaderFileBuilder {\n+        SplitHeader(String name, String superclass) {\n+            super(ToplevelBuilder.this, name, superclass);\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \" \";\n+        }\n+    }\n+\n+    class FirstHeader extends SplitHeader {\n+\n+        FirstHeader(String name) {\n+            super(name, \"#{SUPER}\");\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \"public \";\n+        }\n+\n+        @Override\n+        void classBegin() {\n+            super.classBegin();\n+            emitConstructor();\n+            \/\/ emit basic primitive types\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Bool), \"C_BOOL\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Char), \"C_CHAR\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Short), \"C_SHORT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Int), \"C_INT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Long), \"C_LONG\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.LongLong), \"C_LONG_LONG\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Float), \"C_FLOAT\");\n+            emitPrimitiveTypedef(Type.primitive(Type.Primitive.Kind.Double), \"C_DOUBLE\");\n+            emitPointerTypedef(\"C_POINTER\");\n+        }\n+\n+        void emitConstructor() {\n+            incrAlign();\n+            indent();\n+            append(\"\/* package-private *\/ \");\n+            append(className());\n+            append(\"() {}\");\n+            append('\\n');\n+            decrAlign();\n+        }\n+\n+        @Override\n+        String build() {\n+            HeaderFileBuilder last = lastHeader;\n+            return super.build().replace(\"extends #{SUPER}\",\n+                    last != this ? \"extends \" + last.className() : \"\");\n+        }\n+    }\n+\n+    \/\/ constant support\n+\n+    class RootConstants extends ConstantBuilder {\n+\n+        private final Map<ValueLayout, Constant> primitiveLayouts = new HashMap<>();\n+\n+        public RootConstants() {\n+            super(ToplevelBuilder.this, \"Constants$root\");\n+            classBegin();\n+            addPrimitiveLayout(\"C_BOOL\", Type.Primitive.Kind.Bool);\n+            addPrimitiveLayout(\"C_CHAR\", Type.Primitive.Kind.Char);\n+            addPrimitiveLayout(\"C_SHORT\", Type.Primitive.Kind.Short);\n+            addPrimitiveLayout(\"C_INT\", Type.Primitive.Kind.Int);\n+            addPrimitiveLayout(\"C_LONG\", Type.Primitive.Kind.Long);\n+            addPrimitiveLayout(\"C_LONG_LONG\", Type.Primitive.Kind.LongLong);\n+            addPrimitiveLayout(\"C_FLOAT\", Type.Primitive.Kind.Float);\n+            addPrimitiveLayout(\"C_DOUBLE\", Type.Primitive.Kind.Double);\n+            addPrimitiveLayout(\"C_POINTER\", TypeImpl.PointerImpl.POINTER_LAYOUT);\n+            classEnd();\n+        }\n+\n+        @Override\n+        protected String primitiveLayoutString(ValueLayout vl) {\n+            if (vl.carrier() == boolean.class) {\n+                return \"JAVA_BOOLEAN\";\n+            } else if (vl.carrier() == char.class) {\n+                return \"JAVA_CHAR.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == byte.class) {\n+                return \"JAVA_BYTE\";\n+            } else if (vl.carrier() == short.class) {\n+                return \"JAVA_SHORT.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == int.class) {\n+                return \"JAVA_INT.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == float.class) {\n+                return \"JAVA_FLOAT.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == long.class) {\n+                return \"JAVA_LONG.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == double.class) {\n+                return \"JAVA_DOUBLE.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == MemoryAddress.class) {\n+                return \"ADDRESS.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else {\n+                return \"MemoryLayout.paddingLayout(\" + vl.bitSize() +  \")\";\n+            }\n+        }\n+\n+        private Constant addPrimitiveLayout(String javaName, ValueLayout layout) {\n+            ValueLayout layoutNoName = layoutNoName(layout);\n+            Constant layoutConstant = super.addLayout(javaName, layoutNoName);\n+            primitiveLayouts.put(layoutNoName, layoutConstant);\n+            return layoutConstant;\n+        }\n+\n+        private Constant addPrimitiveLayout(String javaName, Type.Primitive.Kind kind) {\n+            return addPrimitiveLayout(javaName, (ValueLayout)kind.layout().get());\n+        }\n+\n+        private ValueLayout layoutNoName(ValueLayout layout) {\n+            \/\/ drop name if present\n+            return MemoryLayout.valueLayout(layout.carrier(), layout.order())\n+                    .withBitAlignment(layout.bitAlignment());\n+        }\n+\n+        public Constant resolvePrimitiveLayout(ValueLayout layout) {\n+            return primitiveLayouts.get(layoutNoName(layout));\n+        }\n+    }\n+\n+    \/\/ other constants\n+\n+    int constant_counter = 0;\n+    int constant_class_index = 0;\n+    List<ConstantBuilder> constantBuilders = new ArrayList<>();\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+    ConstantBuilder constantBuilder;\n+\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n+            if (constantBuilder != null) {\n+                constantBuilder.classEnd();\n+            }\n+            constant_counter = 0;\n+            constantBuilder = new ConstantBuilder(this, \"constants$\" + constant_class_index++) {\n+                @Override\n+                String mods() {\n+                    return \"\"; \/\/ constants package-private!\n+                }\n+            };\n+            constantBuilders.add(constantBuilder);\n+            constantBuilder.classBegin();\n+        }\n+        constantConsumer.accept(constantBuilder);\n+        constant_counter++;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.nio.ByteOrder;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Position;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.CursorKind;\n+import org.openjdk.jextract.clang.CursorLanguage;\n+import org.openjdk.jextract.clang.SourceLocation;\n+\n+class TreeMaker {\n+    public TreeMaker() {}\n+\n+    TypeMaker typeMaker = new TypeMaker(this);\n+\n+    public void freeze() {\n+        typeMaker.resolveTypeReferences();\n+    }\n+\n+    interface ScopedFactoryLayout {\n+        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n+    }\n+\n+    interface ScopedFactoryNoLayout {\n+        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n+    }\n+\n+    interface VarFactoryNoLayout {\n+        Declaration.Variable make(Position pos, String name, Type type);\n+    }\n+\n+    Map<String, List<Constable>> collectAttributes(Cursor c) {\n+        return c.children().filter(Cursor::isAttribute)\n+                .collect(Collectors.groupingBy(\n+                        attr -> attr.kind().name(),\n+                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n+                ));\n+    }\n+\n+    public Declaration createTree(Cursor c) {\n+        Objects.requireNonNull(c);\n+        CursorLanguage lang = c.language();\n+        if (lang != CursorLanguage.C && lang != CursorLanguage.Invalid) {\n+            throw new RuntimeException(\"Unsupported language: \" + c.language());\n+        }\n+        var rv = (DeclarationImpl) createTreeInternal(c);\n+        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+    }\n+\n+    private Declaration createTreeInternal(Cursor c) {\n+        switch (c.kind()) {\n+            case EnumDecl:\n+                return createEnum(c, Declaration::enum_, Declaration::enum_);\n+            case EnumConstantDecl:\n+                return createEnumConstant(c);\n+            case FieldDecl:\n+                return createVar(c.isBitField() ?\n+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n+            case ParmDecl:\n+                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n+            case FunctionDecl:\n+                return createFunction(c);\n+            case StructDecl:\n+                return createRecord(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n+            case UnionDecl:\n+                return createRecord(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n+            case TypedefDecl: {\n+                return createTypedef(c);\n+            }\n+            case VarDecl:\n+                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    static class CursorPosition implements Position {\n+        private final Cursor cursor;\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+\n+        private CursorPosition(Cursor cursor) {\n+            this.cursor = cursor;\n+            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();\n+            this.path = loc.path();\n+            this.line = loc.line();\n+            this.column = loc.column();\n+        }\n+\n+        static Position of(Cursor cursor) {\n+            SourceLocation loc = cursor.getSourceLocation();\n+            if (loc == null) {\n+                return NO_POSITION;\n+            }\n+            SourceLocation.Location sloc = loc.getFileLocation();\n+            if (sloc == null) {\n+                return NO_POSITION;\n+            }\n+            return new CursorPosition(cursor);\n+        }\n+\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return line;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return column;\n+        }\n+\n+        public Cursor cursor() {\n+            return cursor;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return PrettyPrinter.position(this);\n+        }\n+    }\n+\n+    public Declaration.Function createFunction(Cursor c) {\n+        checkCursor(c, CursorKind.FunctionDecl);\n+        List<Declaration.Variable> params = new ArrayList<>();\n+        for (int i = 0 ; i < c.numberOfArgs() ; i++) {\n+            params.add((Declaration.Variable)createTree(c.getArgument(i)));\n+        }\n+        Type type = toType(c);\n+        Type funcType = canonicalType(type);\n+        return Declaration.function(CursorPosition.of(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0]));\n+    }\n+\n+    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n+        checkCursorAny(c, CursorKind.MacroDefinition);\n+        return Declaration.constant(CursorPosition.of(c), name, value, type);\n+    }\n+\n+    public Declaration.Constant createEnumConstant(Cursor c) {\n+        return Declaration.constant(CursorPosition.of(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+    }\n+\n+    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {\n+        return Declaration.toplevel(CursorPosition.of(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+    }\n+\n+    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        Type.Declared t = (Type.Declared)RecordLayoutComputer.compute(typeMaker, 0, c.type(), c.type());\n+        List<Declaration> decls = filterNestedDeclarations(t.tree().members());\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            return factoryLayout.make(CursorPosition.of(c), c.spelling(), t.tree().layout().get(), decls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n+                    scopeKind == Declaration.Scoped.Kind.UNION ||\n+                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n+                \/\/if there's a real definition somewhere else, skip this redundant declaration\n+                if (!c.getDefinition().isInvalid()) {\n+                    return null;\n+                }\n+            }\n+            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    public Declaration.Scoped createEnum(Cursor c, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        List<Declaration> decls = filterNestedDeclarations(c.children()\n+                .filter(fc -> {\n+                    if (fc.isBitField()) {\n+                        \/\/ only non-empty and named bit fields are generated\n+                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n+                    }\n+                    return true;\n+                })\n+                .map(this::createTree).collect(Collectors.toList()));\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            MemoryLayout layout = TypeMaker.valueLayoutForSize(c.type().size() * 8).layout().orElseThrow();\n+            return factoryLayout.make(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n+            if (!c.getDefinition().isInvalid()) {\n+                return null;\n+            }\n+            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    private static boolean isEnum(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;\n+    }\n+\n+    private static boolean isBitfield(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.BITFIELDS;\n+    }\n+\n+    private static boolean isAnonymousStruct(Declaration declaration) {\n+        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n+    }\n+\n+    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+        return declarations.stream()\n+                .filter(Objects::nonNull)\n+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d) || isBitfield(d))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Declaration.Typedef createTypedef(Cursor c) {\n+        Type cursorType = toType(c);\n+        Type canonicalType = canonicalType(cursorType);\n+        if (canonicalType instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) canonicalType).tree();\n+            if (s.name().equals(c.spelling())) {\n+                \/\/ typedef record with the same name, no need to present twice\n+                return null;\n+            }\n+        }\n+        Type.Function funcType = null;\n+        boolean isFuncPtrType = false;\n+        if (canonicalType instanceof Type.Function) {\n+            funcType = (Type.Function)canonicalType;\n+        } else if (Utils.isPointerType(canonicalType)) {\n+            Type pointeeType = null;\n+            try {\n+                pointeeType = ((Type.Delegated)canonicalType).type();\n+            } catch (NullPointerException npe) {\n+                \/\/ exception thrown for unresolved pointee type. Ignore if we hit that case.\n+            }\n+            if (pointeeType instanceof Type.Function) {\n+                funcType = (Type.Function)pointeeType;\n+                isFuncPtrType = true;\n+            }\n+        }\n+        if (funcType != null) {\n+            List<String> params = c.children().\n+                filter(ch -> ch.kind() == CursorKind.ParmDecl).\n+                map(this::createTree).\n+                map(Declaration.Variable.class::cast).\n+                map(Declaration::name).\n+                collect(Collectors.toList());\n+            if (!params.isEmpty()) {\n+                canonicalType = funcType.withParameterNames(params);\n+                if (isFuncPtrType) {\n+                   canonicalType = new TypeImpl.PointerImpl(canonicalType);\n+                }\n+            }\n+        }\n+        return Declaration.typedef(CursorPosition.of(c), c.spelling(), canonicalType);\n+    }\n+\n+    private Type canonicalType(Type t) {\n+        if (t instanceof Type.Delegated delegated &&\n+           delegated.kind() == Type.Delegated.Kind.TYPEDEF) {\n+            return delegated.type();\n+        } else {\n+            return t;\n+        }\n+    }\n+\n+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);\n+        if (c.isBitField()) {\n+            return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n+                    MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n+        } else {\n+            Type type = null;\n+            try {\n+                type = toType(c);\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+                return null;\n+            }\n+            return varFactory.make(CursorPosition.of(c), c.spelling(), type);\n+        }\n+    }\n+\n+    private Type toType(Cursor c) {\n+        return typeMaker.makeType(c.type());\n+    }\n+\n+    private void checkCursor(Cursor c, CursorKind k) {\n+        if (c.kind() != k) {\n+            throw new IllegalArgumentException(\"Invalid cursor kind\");\n+        }\n+    }\n+\n+    private void checkCursorAny(Cursor c, CursorKind... kinds) {\n+        CursorKind expected = Objects.requireNonNull(c.kind());\n+        for (CursorKind k : kinds) {\n+            if (k == expected) {\n+                return;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid cursor kind\");\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+\n+public abstract class TypeImpl implements Type {\n+\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    @Override\n+    public boolean isErroneous() {\n+        return false;\n+    }\n+\n+    static boolean equals(Type t1, Type.Delegated t2) {\n+        assert t1 != null;\n+        assert t2 != null;\n+\n+        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());\n+    }\n+\n+    public static final TypeImpl ERROR = new TypeImpl() {\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitType(this, data);\n+        }\n+\n+        @Override\n+        public boolean isErroneous() {\n+            return true;\n+        }\n+    };\n+\n+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {\n+\n+        private final Primitive.Kind kind;\n+\n+        public PrimitiveImpl(Kind kind) {\n+            this.kind = Objects.requireNonNull(kind);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitPrimitive(this, data);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Primitive)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated)o);\n+            }\n+            Type.Primitive primitive = (Type.Primitive) o;\n+            return kind == primitive.kind();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind);\n+        }\n+    }\n+\n+    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {\n+        Delegated.Kind kind;\n+        Optional<String> name;\n+\n+        DelegatedBase(Kind kind, Optional<String> name) {\n+            this.kind = Objects.requireNonNull(kind);\n+            this.name = Objects.requireNonNull(name);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDelegated(this, data);\n+        }\n+\n+        @Override\n+        public final Delegated.Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public final Optional<String> name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) {\n+                return (o instanceof Type) && equals((Type)o, this);\n+            }\n+            Type.Delegated that = (Type.Delegated) o;\n+            return kind == that.kind() &&\n+                    name.equals(that.name());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, name);\n+        }\n+    }\n+\n+    public static final class QualifiedImpl extends DelegatedBase {\n+        private final Type type;\n+\n+        public QualifiedImpl(Kind kind, Type type) {\n+            this(kind, Optional.empty(), type);\n+        }\n+\n+        public QualifiedImpl(Kind kind, String name, Type type) {\n+            this(kind, Optional.of(name), type);\n+        }\n+\n+        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {\n+            super(kind, name);\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) return false;\n+            if (!super.equals(o)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Delegated qualified = (Type.Delegated) o;\n+            return Objects.equals(type, qualified.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class PointerImpl extends DelegatedBase {\n+        public static final ValueLayout.OfAddress POINTER_LAYOUT = ADDRESS.withBitAlignment(64);\n+\n+        private final Supplier<Type> pointeeFactory;\n+\n+        public PointerImpl(Supplier<Type> pointeeFactory) {\n+            super(Kind.POINTER, Optional.empty());\n+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);\n+        }\n+\n+        public PointerImpl(Type pointee) {\n+            this(() -> pointee);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return pointeeFactory.get();\n+        }\n+    }\n+\n+    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {\n+\n+        private final Declaration.Scoped declaration;\n+\n+        public DeclaredImpl(Declaration.Scoped declaration) {\n+            super();\n+            this.declaration = Objects.requireNonNull(declaration);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDeclared(this, data);\n+        }\n+\n+        @Override\n+        public Declaration.Scoped tree() {\n+            return declaration;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Declared)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Declared declared = (Type.Declared) o;\n+            return declaration.equals(declared.tree());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(declaration);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends TypeImpl implements Type.Function {\n+\n+        private final boolean varargs;\n+        private final List<Type> argtypes;\n+        private final Type restype;\n+        private final Optional<List<String>> paramNames;\n+\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype, List<String> paramNames) {\n+            super();\n+            this.varargs = varargs;\n+            this.argtypes = Objects.requireNonNull(argtypes);\n+            this.restype = Objects.requireNonNull(restype);\n+            this.paramNames = Optional.ofNullable(paramNames);\n+        }\n+\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {\n+            this(varargs, argtypes, restype, null);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public boolean varargs() {\n+            return varargs;\n+        }\n+\n+        @Override\n+        public List<Type> argumentTypes() {\n+            return argtypes;\n+        }\n+\n+        @Override\n+        public Type returnType() {\n+            return restype;\n+        }\n+\n+        @Override\n+        public Type.Function withParameterNames(List<String> paramNames) {\n+            Objects.requireNonNull(paramNames);\n+            return new FunctionImpl(varargs, argtypes, restype, paramNames);\n+        }\n+\n+        @Override\n+        public Optional<List<String>> parameterNames() {\n+            return paramNames;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Function)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Function function = (Type.Function) o;\n+            return varargs == function.varargs() &&\n+                    argtypes.equals(function.argumentTypes()) &&\n+                    restype.equals(function.returnType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(varargs, argtypes, restype);\n+        }\n+    }\n+\n+    public static final class ArrayImpl extends TypeImpl implements Type.Array {\n+\n+        private final Kind kind;\n+        private final OptionalLong elemCount;\n+        private final Type elemType;\n+\n+        public ArrayImpl(Kind kind, long count, Type elemType) {\n+            this(kind, elemType, OptionalLong.of(count));\n+        }\n+\n+        public ArrayImpl(Kind kind, Type elemType) {\n+            this(kind, elemType, OptionalLong.empty());\n+        }\n+\n+        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {\n+            super();\n+            this.kind = Objects.requireNonNull(kind);\n+            this.elemCount = Objects.requireNonNull(elemCount);\n+            this.elemType = Objects.requireNonNull(elemType);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitArray(this, data);\n+        }\n+\n+        @Override\n+        public OptionalLong elementCount() {\n+            return elemCount;\n+        }\n+\n+        @Override\n+        public Type elementType() {\n+            return elemType;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Array)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Array array = (Type.Array) o;\n+            return kind == array.kind() &&\n+                    elemType.equals(array.elementType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, elemType);\n+        }\n+    }\n+\n+    public boolean isPointer() {\n+        return this instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.POINTER;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return PrettyPrinter.type(this);\n+    }\n+\n+    \/\/ Utilities to fetch layouts\/descriptor from types\n+\n+    public static Optional<MemoryLayout> getLayout(org.openjdk.jextract.Type t) {\n+        try {\n+            return Optional.of(getLayoutInternal(t));\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Optional<FunctionDescriptor> getDescriptor(Function t) {\n+        try {\n+            MemoryLayout[] args = t.argumentTypes().stream()\n+                    .map(TypeImpl::getLayoutInternal)\n+                    .toArray(MemoryLayout[]::new);\n+            Type retType = t.returnType();\n+            if (isVoidType(retType)) {\n+                return Optional.of(FunctionDescriptor.ofVoid(args));\n+            } else {\n+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n+            }\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isVoidType(org.openjdk.jextract.Type type) {\n+        if (type instanceof org.openjdk.jextract.Type.Primitive) {\n+            org.openjdk.jextract.Type.Primitive pt = (org.openjdk.jextract.Type.Primitive)type;\n+            return pt.kind() == org.openjdk.jextract.Type.Primitive.Kind.Void;\n+        } else if (type instanceof org.openjdk.jextract.Type.Delegated) {\n+            org.openjdk.jextract.Type.Delegated dt = (org.openjdk.jextract.Type.Delegated)type;\n+            return dt.kind() == org.openjdk.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n+        }\n+        return false;\n+    }\n+\n+    public static MemoryLayout getLayoutInternal(org.openjdk.jextract.Type t) {\n+        return t.accept(layoutMaker, null);\n+    }\n+\n+    private static org.openjdk.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new org.openjdk.jextract.Type.Visitor<>() {\n+        @Override\n+        public MemoryLayout visitPrimitive(org.openjdk.jextract.Type.Primitive t, Void _ignored) {\n+            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDelegated(org.openjdk.jextract.Type.Delegated t, Void _ignored) {\n+            if (t.kind() == org.openjdk.jextract.Type.Delegated.Kind.POINTER) {\n+                return PointerImpl.POINTER_LAYOUT;\n+            } else {\n+                return t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitFunction(org.openjdk.jextract.Type.Function t, Void _ignored) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return PointerImpl.POINTER_LAYOUT;\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDeclared(org.openjdk.jextract.Type.Declared t, Void _ignored) {\n+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitArray(org.openjdk.jextract.Type.Array t, Void _ignored) {\n+            MemoryLayout elem = t.elementType().accept(this, null);\n+            if (t.elementCount().isPresent()) {\n+                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n+            } else {\n+                return MemoryLayout.sequenceLayout(elem);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitType(org.openjdk.jextract.Type t, Void _ignored) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.Type.Primitive;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.TypeKind;\n+\n+class TypeMaker {\n+\n+    TreeMaker treeMaker;\n+    private final Map<org.openjdk.jextract.clang.Type, Type> typeCache = new HashMap<>();\n+    private List<ClangTypeReference> unresolved = new ArrayList<>();\n+\n+    private class ClangTypeReference implements Supplier<Type> {\n+        org.openjdk.jextract.clang.Type origin;\n+        Type derived;\n+\n+        private ClangTypeReference(org.openjdk.jextract.clang.Type origin) {\n+            this.origin = origin;\n+            derived = typeCache.get(origin);\n+        }\n+\n+        public boolean isUnresolved() {\n+            return null == derived;\n+        }\n+\n+        public void resolve() {\n+            derived = makeType(origin);\n+            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n+        }\n+\n+        public Type get() {\n+            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n+            return derived;\n+        }\n+    }\n+\n+    private ClangTypeReference reference(org.openjdk.jextract.clang.Type type) {\n+        ClangTypeReference ref = new ClangTypeReference(type);\n+        if (ref.isUnresolved()) {\n+            unresolved.add(ref);\n+        }\n+        return ref;\n+    }\n+\n+    public TypeMaker(TreeMaker treeMaker) {\n+        this.treeMaker = treeMaker;\n+    }\n+\n+    \/**\n+     * Resolve all type references. This method should be called before discard clang cursors\/types\n+     *\/\n+    void resolveTypeReferences() {\n+        List<ClangTypeReference> resolving = unresolved;\n+        unresolved = new ArrayList<>();\n+        while (! resolving.isEmpty()) {\n+            resolving.forEach(ClangTypeReference::resolve);\n+            resolving = unresolved;\n+            unresolved = new ArrayList<>();\n+        }\n+    }\n+\n+    Type makeType(org.openjdk.jextract.clang.Type t) {\n+        Type rv = typeCache.get(t);\n+        if (rv != null) {\n+            return rv;\n+        }\n+        rv = makeTypeInternal(t);\n+        if (null != rv && typeCache.put(t, rv) != null) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return rv;\n+    }\n+\n+    static class TypeException extends RuntimeException {\n+        static final long serialVersionUID = 1L;\n+\n+        TypeException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    Type makeTypeInternal(org.openjdk.jextract.clang.Type t) {\n+        switch(t.kind()) {\n+            case Auto:\n+                return makeType(t.canonicalType());\n+            case Void:\n+                return Type.void_();\n+            case Char_S:\n+            case Char_U:\n+                return Type.primitive(Primitive.Kind.Char);\n+            case Short:\n+                return Type.primitive(Primitive.Kind.Short);\n+            case Int:\n+                return Type.primitive(Primitive.Kind.Int);\n+            case Long:\n+                return Type.primitive(Primitive.Kind.Long);\n+            case LongLong:\n+                return Type.primitive(Primitive.Kind.LongLong);\n+            case SChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.SIGNED, chType);\n+            }\n+            case UShort: {\n+                Type chType = Type.primitive(Primitive.Kind.Short);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UInt: {\n+                Type chType = Type.primitive(Primitive.Kind.Int);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULong: {\n+                Type chType = Type.primitive(Primitive.Kind.Long);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULongLong: {\n+                Type chType = Type.primitive(Primitive.Kind.LongLong);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+\n+            case Bool:\n+                return Type.primitive(Primitive.Kind.Bool);\n+            case Double:\n+                return Type.primitive(Primitive.Kind.Double);\n+            case Float:\n+                return Type.primitive(Primitive.Kind.Float);\n+            case Unexposed:\n+            case Elaborated:\n+                org.openjdk.jextract.clang.Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return makeType(canonical);\n+            case ConstantArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(t.getNumberOfElements(), elem);\n+            }\n+            case IncompleteArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(elem);\n+            }\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                List<Type> args = new ArrayList<>();\n+                for (int i = 0; i < t.numberOfArgs(); i++) {\n+                    \/\/ argument could be function pointer declared locally\n+                    args.add(lowerFunctionType(t.argType(i)));\n+                }\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+            }\n+            case Enum:\n+            case Record: {\n+                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+            }\n+            case BlockPointer:\n+            case Pointer: {\n+                \/\/ TODO: We can always erase type for macro evaluation, should we?\n+                if (t.getPointeeType().kind() == TypeKind.FunctionProto) {\n+                    return new TypeImpl.PointerImpl(makeType(t.getPointeeType()));\n+                } else {\n+                    return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+                }\n+            }\n+            case Typedef: {\n+                Type __type = makeType(t.canonicalType());\n+                return Type.typedef(t.spelling(), __type);\n+            }\n+            case Complex: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.qualified(Delegated.Kind.COMPLEX, __type);\n+            }\n+            case Vector: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.vector(t.getNumberOfElements(), __type);\n+            }\n+            case WChar: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.WChar);\n+            case Char16: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Char16);\n+            case Half: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.HalfFloat);\n+            case Int128: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Int128);\n+            case LongDouble: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.LongDouble);\n+            case UInt128: { \/\/unsupported\n+                Type iType = Type.primitive(Primitive.Kind.Int128);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, iType);\n+            }\n+            default:\n+                return TypeImpl.ERROR;\n+        }\n+    }\n+\n+    private Type lowerFunctionType(org.openjdk.jextract.clang.Type t) {\n+        Type t2 = makeType(t);\n+        return t2.accept(lowerFunctionType, null);\n+    }\n+\n+    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+        @Override\n+        public Type visitArray(Type.Array t, Void aVoid) {\n+            return Type.pointer(t.elementType());\n+        }\n+\n+        @Override\n+        public Type visitDelegated(Type.Delegated t, Void aVoid) {\n+            if (t.kind() == Delegated.Kind.TYPEDEF && t.type() instanceof Type.Array) {\n+                return visitArray((Type.Array)t.type(), aVoid);\n+            }\n+            return visitType(t, aVoid);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void aVoid) {\n+            return t;\n+        }\n+    };\n+\n+    public static Primitive.Kind valueLayoutForSize(long size) {\n+        return switch ((int) size) {\n+            case 8 -> Primitive.Kind.Char;\n+            case 16 -> Primitive.Kind.Short;\n+            case 32 -> Primitive.Kind.Int;\n+            case 64 -> Primitive.Kind.LongLong;\n+            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n+        };\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeMaker.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Type.Primitive;\n+import org.openjdk.jextract.Type;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodType;\n+\n+public class TypeTranslator implements Type.Visitor<Class<?>, Boolean> {\n+    @Override\n+    public Class<?> visitPrimitive(Type.Primitive t, Boolean isArg) {\n+        if (t.kind().layout().isEmpty()) {\n+            return void.class;\n+        } else {\n+            return layoutToClass(isFloatingPoint(t), t.kind().layout().orElseThrow(UnsupportedOperationException::new));\n+        }\n+    }\n+\n+    private boolean isFloatingPoint(Type.Primitive t) {\n+        switch (t.kind()) {\n+            case Float:\n+            case Float128:\n+            case HalfFloat:\n+            case Double:\n+            case LongDouble:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    static Class<?> layoutToClass(boolean fp, MemoryLayout layout) {\n+        switch ((int)layout.bitSize()) {\n+            case 8: return byte.class;\n+            case 16: return short.class;\n+            case 32: return !fp ? int.class : float.class;\n+            case 64:\n+            case 128: return !fp ? long.class : double.class;\n+            default:\n+                throw new UnsupportedOperationException(\"size: \" + (int)layout.bitSize());\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitDelegated(Type.Delegated t, Boolean isArg) {\n+        return t.kind() == Type.Delegated.Kind.POINTER ?\n+                (isArg ? Addressable.class : MemoryAddress.class) :\n+                t.type().accept(this, isArg);\n+    }\n+\n+    @Override\n+    public Class<?> visitFunction(Type.Function t, Boolean isArg) {\n+        return isArg ? Addressable.class : MemoryAddress.class; \/\/ function pointer\n+    }\n+\n+    @Override\n+    public Class<?> visitDeclared(Type.Declared t, Boolean isArg) {\n+        return switch (t.tree().kind()) {\n+            case UNION, STRUCT -> MemorySegment.class;\n+            case ENUM -> layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n+            default -> throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n+        };\n+    }\n+\n+    @Override\n+    public Class<?> visitArray(Type.Array t, Boolean isArg) {\n+        if (t.kind() == Type.Array.Kind.VECTOR) {\n+            throw new UnsupportedOperationException(\"vector\");\n+        } else {\n+            return MemorySegment.class;\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitType(Type t, Boolean isArg) {\n+        throw new UnsupportedOperationException(t.getClass().toString());\n+    }\n+\n+    Class<?> getJavaType(Type t, boolean isArg) {\n+        return t.accept(this, isArg);\n+    }\n+\n+    MethodType getMethodType(Type.Function type, boolean downcall) {\n+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType(), !downcall));\n+        for (Type arg : type.argumentTypes()) {\n+            mtype = mtype.appendParameterTypes(getJavaType(arg, downcall));\n+        }\n+        if (downcall && type.varargs()) {\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+        }\n+        return mtype;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeTranslator.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+public class TypedefBuilder extends ClassSourceBuilder {\n+\n+    private final String superClass;\n+\n+    public TypedefBuilder(JavaSourceBuilder enclosing, String name, String superClass) {\n+        super(enclosing, Kind.CLASS, name);\n+        this.superClass = superClass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superClass;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        return super.classEnd();\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefBuilder.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.clang.Cursor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * This visitor handles certain typedef declarations.\n+ *\n+ * 1. Remove redundant typedefs.\n+ * 2. Rename typedef'ed anonymous type definitions like\n+ *        typedef struct { int x; int y; } Point;\n+ *\/\n+final class TypedefHandler implements Declaration.Visitor<Void, Void> {\n+\n+    TreeMaker maker;\n+\n+    public TypedefHandler(TreeMaker maker) {\n+        this.maker = maker;\n+    }\n+\n+    \/\/ Potential Tree instances that will go into transformed HeaderTree\n+    \/\/ are collected in this list.\n+    private List<Declaration> decls = new ArrayList<>();\n+\n+    \/\/ Tree instances that are to be replaced from \"decls\" list are\n+    \/\/ saved in the following Map. One or more Trees can replace a Tree.\n+    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();\n+\n+    public Declaration.Scoped transform(Declaration.Scoped ht) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        ht.accept(this, null);\n+\n+\/\/        \/\/ Replace trees from this.decls with Trees found in this.replacements.\n+\/\/        \/\/ We need this two step process so that named StructTree instances\n+\/\/        \/\/ will replace with original unnamed StructTree instances.\n+\/\/        List<Declaration> newDecls = decls.stream().flatMap(tx -> {\n+\/\/            if (replacements.containsKey(tx.cursor())) {\n+\/\/                return replacements.get(tx.cursor()).stream();\n+\/\/            } else {\n+\/\/                return Stream.of(tx);\n+\/\/            }\n+\/\/        }).collect(Collectors.toList());\n+\/\/\n+\/\/        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);\n+        return ht;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration d, Void aVoid) {\n+        decls.add(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped ht, Void v) {\n+        ht.members().forEach(decl -> decl.accept(this, null));\n+        return null;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypedefHandler.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.Type;\n+import org.openjdk.jextract.clang.TypeKind;\n+\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C unions.\n+ *\/\n+final class UnionLayoutComputer extends RecordLayoutComputer {\n+    private final long offset;\n+    private long actualSize = 0L;\n+\n+    UnionLayoutComputer(TypeMaker typeMaker, long offsetInParent, Type parent, Type type) {\n+        super(typeMaker, parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            throw new IllegalStateException(\"No padding in union elements!\");\n+        }\n+\n+        addField(offset, parent, c);\n+        actualSize = Math.max(actualSize, fieldSize(c));\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    Declaration field(Cursor c) {\n+        if (c.isBitField()) {\n+            Declaration.Variable var = (Declaration.Variable)super.field(c);\n+            return bitfield(List.of(var.layout().get()), var);\n+        } else {\n+            return super.field(c);\n+        }\n+    }\n+\n+    @Override\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        } else if (c.isBitField()) {\n+            return c.getBitFieldWidth();\n+        } else {\n+            return c.type().size() * 8;\n+        }\n+    }\n+\n+    @Override\n+    org.openjdk.jextract.Type.Declared finishRecord(String anonName) {\n+        \/\/ size mismatch indicates use of bitfields in union\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n+            addPadding(expectedSize);\n+        } else if (actualSize > expectedSize) {\n+            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n+        }\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.unionLayout(fields);\n+        if (!cursor.spelling().isEmpty()) {\n+            g = g.withName(cursor.spelling());\n+        } else if (anonName != null) {\n+            g = g.withName(anonName);\n+        }\n+        return org.openjdk.jextract.Type.declared(Declaration.union(TreeMaker.CursorPosition.of(cursor), cursor.spelling(), g, fieldDecls.stream().toArray(Declaration[]::new)));\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * Layouts for the primitive types not supported by ABI implementations.\n+ *\/\n+public final class UnsupportedLayouts {\n+    private UnsupportedLayouts() {}\n+\n+    public static final MemoryLayout __INT128 = makeUnsupportedLayout(128, \"__int128\");\n+\n+    public static final MemoryLayout LONG_DOUBLE = makeUnsupportedLayout(128, \"long double\");\n+\n+    public static final MemoryLayout _FLOAT128 = makeUnsupportedLayout(128, \"_float128\");\n+\n+    public static final MemoryLayout __FP16 = makeUnsupportedLayout(16, \"__fp16\");\n+\n+    public static final MemoryLayout CHAR16 = makeUnsupportedLayout(16, \"char16\");\n+\n+    public static final MemoryLayout WCHAR_T = makeUnsupportedLayout(16, \"wchar_t\");\n+\n+    static String firstUnsupportedType(Type type) {\n+        return type.accept(unsupportedVisitor, null);\n+    }\n+\n+    private static MemoryLayout makeUnsupportedLayout(long size, String name) {\n+        return MemoryLayout.paddingLayout(size).withBitAlignment(size).withName(name);\n+    }\n+\n+    static Type.Visitor<String, Void> unsupportedVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void unused) {\n+            MemoryLayout layout = t.kind().layout().orElse(MemoryLayout.paddingLayout(64));\n+            if (layout.equals(__INT128) || layout.equals(LONG_DOUBLE) || layout.equals(_FLOAT128) || layout.equals(__FP16)) {\n+                return layout.name().get();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void unused) {\n+            for (Type arg : t.argumentTypes()) {\n+                String unsupported = firstUnsupportedType(arg);\n+                if (unsupported != null) {\n+                    return unsupported;\n+                }\n+            }\n+            String unsupported = firstUnsupportedType(t.returnType());\n+            if (unsupported != null) {\n+                return unsupported;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void unused) {\n+            for (Declaration d : t.tree().members()) {\n+                if (d instanceof Declaration.Variable) {\n+                    String unsupported = firstUnsupportedType(((Declaration.Variable) d).type());\n+                    if (unsupported != null) {\n+                        return unsupported;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void unused) {\n+            return t.kind() == Type.Delegated.Kind.TYPEDEF ?\n+                    firstUnsupportedType(t.type()) :\n+                    null;\n+            \/\/in principle we should always do this:\n+            \/\/ return firstUnsupportedType(t.type());\n+            \/\/ but if we do that, we might end up with infinite recursion. Old code did not have that issue\n+            \/\/ as it was layout-based, but doing so it also missed unsupported pointer types (e.g. *long double)\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void unused) {\n+            return firstUnsupportedType(t.elementType());\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void unused) {\n+            return null;\n+        }\n+    };\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnsupportedLayouts.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.Type.Delegated;\n+import org.openjdk.jextract.clang.Cursor;\n+import org.openjdk.jextract.clang.CursorKind;\n+import org.openjdk.jextract.clang.SourceLocation;\n+import org.openjdk.jextract.clang.Type;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * General utility functions\n+ *\/\n+class Utils {\n+    public static String qualifiedClassName(String packageName, String simpleName) {\n+        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n+    }\n+\n+    private static URI fileName(String pkgName, String clsName, String extension) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return URI.create(pkgPrefix + clsName + extension);\n+    }\n+\n+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n+        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    static String javaSafeIdentifier(String name) {\n+        return javaSafeIdentifier(name, false);\n+    }\n+\n+    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n+        if (checkAllChars) {\n+            StringBuilder buf = new StringBuilder();\n+            char[] chars = name.toCharArray();\n+            if (Character.isJavaIdentifierStart(chars[0])) {\n+                buf.append(chars[0]);\n+            } else {\n+                buf.append('_');\n+            }\n+            if (chars.length > 1) {\n+                for (int i = 1; i < chars.length; i++) {\n+                    char ch = chars[i];\n+                    if (Character.isJavaIdentifierPart(ch)) {\n+                        buf.append(ch);\n+                    } else {\n+                        buf.append('_');\n+                    }\n+                }\n+            }\n+            return buf.toString();\n+        } else {\n+            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n+            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n+            assert SourceVersion.isIdentifier(name);\n+\n+            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) || isJavaTypeName(name)? (name + \"_\") : name;\n+        }\n+    }\n+\n+    private static boolean isRestrictedTypeName(String name) {\n+        return switch (name) {\n+            case \"var\", \"yield\", \"record\",\n+                \"sealed\", \"permits\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private static boolean isJavaTypeName(String name) {\n+        \/\/ Java types that are used unqualified in the generated code\n+        return switch (name) {\n+            case \"String\", \"MethodHandle\",\n+                \"VarHandle\", \"ByteOrder\",\n+                \"FunctionDescriptor\", \"LibraryLookup\",\n+                \"MemoryAddress\", \"MemoryLayout\",\n+                \"MemorySegment\", \"ValueLayout\",\n+                \"RuntimeHelper\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static void validSimpleIdentifier(String name) {\n+        int length = name.length();\n+        if (length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        int ch = name.codePointAt(0);\n+        if (length == 1 && ch == '_') {\n+            throw new IllegalArgumentException(\"'_' is no longer valid identifier.\");\n+        }\n+\n+        if (!Character.isJavaIdentifierStart(ch)) {\n+            throw new IllegalArgumentException(\"Invalid start character for an identifier: \" + ch);\n+        }\n+\n+        for (int i = 1; i < length; i++) {\n+            ch = name.codePointAt(i);\n+            if (!Character.isJavaIdentifierPart(ch)) {\n+                throw new IllegalArgumentException(\"Invalid character for an identifier: \" + ch);\n+            }\n+        }\n+    }\n+\n+    static void validPackageName(String name) {\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+        int idx = name.lastIndexOf('.');\n+        if (idx == -1) {\n+           validSimpleIdentifier(name);\n+        } else {\n+            validSimpleIdentifier(name.substring(idx + 1));\n+            validPackageName(name.substring(0, idx));\n+        }\n+    }\n+\n+    static String toJavaIdentifier(String str) {\n+        final int size = str.length();\n+        StringBuilder sb = new StringBuilder(size);\n+        if (! Character.isJavaIdentifierStart(str.charAt(0))) {\n+            sb.append('_');\n+        }\n+        for (int i = 0; i < size; i++) {\n+            char ch = str.charAt(i);\n+            if (Character.isJavaIdentifierPart(ch)) {\n+                sb.append(ch);\n+            } else {\n+                sb.append('_');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toSafeName(String name) {\n+        StringBuilder sb = new StringBuilder(name.length());\n+        name = toJavaIdentifier(name);\n+        sb.append(name);\n+        if (SourceVersion.isKeyword(name)) {\n+            sb.append(\"$\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toClassName(String cname) {\n+        return toSafeName(cname);\n+    }\n+\n+    static String toMacroName(String mname) {\n+        return toSafeName(mname);\n+    }\n+\n+    static String toInternalName(String pkg, String name, String... nested) {\n+        if ((pkg == null || pkg.isEmpty()) && nested == null) {\n+            return name;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        if (pkg != null && ! pkg.isEmpty()) {\n+            sb.append(pkg.replace('.', '\/'));\n+            if (sb.charAt(sb.length() - 1) != '\/') {\n+                sb.append('\/');\n+            }\n+        }\n+        sb.append(name);\n+        for (String n: nested) {\n+            sb.append('$');\n+            sb.append(n);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static Stream<Cursor> flattenableChildren(Cursor c) {\n+        return c.children()\n+                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n+    }\n+\n+    \/\/ return builtin Record types accessible from the given Type\n+    static Stream<Cursor> getBuiltinRecordTypes(Type type) {\n+        List<Cursor> recordTypes = new ArrayList<>();\n+        fillBuiltinRecordTypes(type, recordTypes);\n+        return recordTypes.stream().distinct();\n+    }\n+\n+    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {\n+        Type canonicalType = type.canonicalType();\n+        switch (canonicalType.kind()) {\n+            case ConstantArray:\n+            case IncompleteArray:\n+                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);\n+                break;\n+\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                final int numArgs = canonicalType.numberOfArgs();\n+                for (int i = 0; i < numArgs; i++) {\n+                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);\n+                }\n+                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);\n+            }\n+            break;\n+\n+            case Record: {\n+                Cursor c = canonicalType.getDeclarationCursor();\n+                if (c.isDefinition()) {\n+                    SourceLocation sloc = c.getSourceLocation();\n+                    if (sloc != null && sloc.getFileLocation().path() == null) {\n+                        recordTypes.add(c);\n+                    }\n+                }\n+            }\n+            break;\n+\n+            case BlockPointer:\n+            case Pointer:\n+                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);\n+                break;\n+\n+            case Unexposed:\n+                if (! canonicalType.equalType(type)) {\n+                    fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                }\n+                break;\n+\n+            case Elaborated:\n+            case Typedef:\n+                fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                break;\n+\n+            default: \/\/ nothing to do\n+        }\n+    }\n+\n+    \/\/ return the absolute path of the library of given name by searching\n+    \/\/ in the given array of paths.\n+    static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n+        return Arrays.stream(paths).\n+                map(p -> p.resolve(System.mapLibraryName(libName))).\n+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n+    }\n+\n+    \/*\n+     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit\n+     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'\n+     * are from javac source. See also com.sun.tools.javac.util.Convert.java.\n+     *\/\n+\n+    \/**\n+     * Escapes each character in a string that has an escape sequence or\n+     * is non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+        case '\\b':  return \"\\\\b\";\n+        case '\\f':  return \"\\\\f\";\n+        case '\\n':  return \"\\\\n\";\n+        case '\\r':  return \"\\\\r\";\n+        case '\\t':  return \"\\\\t\";\n+        case '\\'':  return \"\\\\'\";\n+        case '\\\"':  return \"\\\\\\\"\";\n+        case '\\\\':  return \"\\\\\\\\\";\n+        default:\n+            return (isPrintableAscii(ch))\n+                ? String.valueOf(ch)\n+                : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    static boolean isPointerType(org.openjdk.jextract.Type type) {\n+        if (type instanceof Delegated) {\n+            Delegated delegated = (Delegated) type;\n+            return delegated.kind() == Delegated.Kind.POINTER;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    private static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class Writer {\n+    private final List<? extends JavaFileObject> files;\n+    private final Path dest;\n+\n+    public Writer(Path dest, List<? extends JavaFileObject> files) {\n+        this.files = files;\n+        this.dest = dest;\n+    }\n+\n+    private List<JavaFileObject> ensureSourcesCompiled() {\n+        List<JavaFileObject> sources = sources();\n+        if (sources.isEmpty()) {\n+            return List.of();\n+        } else {\n+            return InMemoryJavaCompiler.compile(sources,\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \/\/ \"--release\", \"18\",\n+                \"-d\", dest.toAbsolutePath().toString(),\n+                \"-cp\", dest.toAbsolutePath().toString());\n+        }\n+    }\n+\n+    public void writeAll(boolean compileSources) throws IOException {\n+        writeClassFiles(resources());\n+        writeClassFiles(classes());\n+        if (compileSources) {\n+            writeClassFiles(ensureSourcesCompiled());\n+        } else {\n+            writeSourceFiles();\n+        }\n+    }\n+\n+    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : files) {\n+            String path = entry.getName();\n+            Path fullPath = destDir.resolve(path).normalize();\n+            Files.createDirectories(fullPath.getParent());\n+            try (InputStream is = entry.openInputStream()) {\n+                Files.write(fullPath, is.readAllBytes());\n+            }\n+        }\n+    }\n+\n+    void writeSourceFiles() throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : sources()) {\n+            String srcPath = entry.getName();\n+            Path fullPath = destDir.resolve(srcPath).normalize();\n+            Path dir = fullPath.getParent();\n+            \/\/ In case the folder exist and is a link to a folder, this should be OK\n+            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n+            if (Files.exists(dir)) {\n+                if (!Files.isDirectory(dir)) {\n+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n+                }\n+            } else {\n+                Files.createDirectories(fullPath.getParent());\n+            }\n+            Files.write(fullPath, List.of(entry.getCharContent(false)));\n+        }\n+    }\n+\n+    private List<JavaFileObject> sources() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> classes() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> resources() {\n+        return files.stream()\n+                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Path createOutputDir() throws IOException {\n+        Path absDest = dest.toAbsolutePath();\n+        if (!Files.exists(absDest)) {\n+            Files.createDirectories(absDest);\n+        }\n+        if (!Files.isDirectory(absDest)) {\n+            throw new IOException(\"Not a directory: \" + dest);\n+        }\n+        return absDest;\n+    }\n+}\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Writer.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/\/ Generated by jextract\n+\n+import java.lang.invoke.VarHandle;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryCopy;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class C-X {\n+    C-X() {}\n+\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(LAYOUT);\n+    }\n+\n+    public static MemorySegment allocate(${CARRIER} val, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocate(LAYOUT);\n+        MemoryAccess.set${CAPITALIZED_CARRIER}AtOffset(segment, 0, val);\n+        return segment;\n+    }\n+\n+    public static MemorySegment allocateArray(long size, SegmentAllocator allocator) {\n+        return allocator.allocateArray(LAYOUT, size);\n+    }\n+\n+    public static MemorySegment allocateArray(${CARRIER}[] values, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocateArray(LAYOUT, values.length);\n+        MemoryCopy.copyFromArray(values, 0, values.length, segment, 0);\n+        return segment;\n+    }\n+    \n+    public static ${CARRIER} get(MemorySegment segment, long offset) {\n+        return MemoryAccess.get${CAPITALIZED_CARRIER}AtOffset(segment, offset);\n+    }\n+\n+    public static void set(MemorySegment segment, long offset, ${CARRIER} value) {\n+        MemoryAccess.set${CAPITALIZED_CARRIER}AtOffset(segment, offset, value);\n+    }\n+\n+    public static long sizeof() {\n+        return LAYOUT.byteSize();\n+    }\n+\n+    public static ${CARRIER}[] toJavaArray(MemorySegment seg) {\n+        var segSize = seg.byteSize();\n+        var elemSize = sizeof();\n+        if (segSize % elemSize != 0) {\n+            throw new UnsupportedOperationException(\"segment cannot contain integral number of elements\");\n+        }\n+        ${CARRIER}[] array = new ${CARRIER}[(int) (segSize \/ elemSize)];\n+        MemoryCopy.copyToArray(seg, 0, array, 0, array.length);\n+        return array;\n+    }\n+\n+    public static final MemoryLayout LAYOUT = ${LAYOUT};\n+}\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/C-X.java.template","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+#\n+#  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+# \n+#  This code is free software; you can redistribute it and\/or modify it\n+#  under the terms of the GNU General Public License version 2 only, as\n+#  published by the Free Software Foundation.\n+# \n+#  This code is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  version 2 for more details (a copy is included in the LICENSE file that\n+#  accompanied this code).\n+# \n+#  You should have received a copy of the GNU General Public License version\n+#  2 along with this work; if not, write to the Free Software Foundation,\n+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+# \n+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#  or visit www.oracle.com if you need additional information or have any\n+#  questions.\n+#\n+\n+# error message\n+cannot.read.header.file=cannot read header file: {0}\n+not.a.file=not a file: {0}\n+l.option.value.invalid=option value for -l option should be a name or an absolute path\n+\n+# help messages for options\n+help.C=pass through argument for clang\n+help.I=specify include files path\n+help.d=specify where to place generated files\n+help.include-macro=name of constant macro to include\n+help.include-var=name of global variable to include\n+help.include-function=name of function to include\n+help.include-typedef=name of type definition to include\n+help.include-struct=name of struct definition to include\n+help.include-union=name of union definition to include\n+help.dump-includes=dump included symbols into specified file\n+help.h=print help\n+help.header-class-name=name of the header class\n+help.l=specify a library\n+help.source=generate java sources\n+help.t=target package for specified header files\n+help.non.option=header file\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/Messages.properties","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n+\n+final class RuntimeHelper {\n+\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.systemCLinker();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+    private final static SymbolLookup SYMBOL_LOOKUP;\n+\n+    final static SegmentAllocator CONSTANT_ALLOCATOR =\n+            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n+    static {\n+        #LOAD_LIBRARIES#\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n+        return SYMBOL_LOOKUP.lookup(name).map(\n+                addr -> {\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, fdesc) :\n+                        LINKER.downcallHandle(addr, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        return LINKER.downcallHandle(fdesc);\n+    }\n+\n+    static final <Z> NativeSymbol upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final NativeSymbol symbol;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(NativeSymbol symbol, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(NativeSymbol symbol, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);\n+            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);\n+            for (MemoryLayout layout : function.argumentLayouts()) {\n+                mtype = mtype.appendParameterTypes(carrier(layout, false));\n+            }\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+            if (mtype.returnType().equals(MemorySegment.class)) {\n+                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(mtype);\n+        }\n+\n+        static Class<?> carrier(MemoryLayout layout, boolean ret) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n+                        valueLayout.carrier() : Addressable.class;\n+            } else if (layout instanceof GroupLayout) {\n+                return MemorySegment.class;\n+            } else {\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argLayouts[pos] = variadicLayout(normalize(o.getClass()));\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, f);\n+            if (mh.type().returnType() == MemorySegment.class) {\n+                mh = mh.bindTo(allocator);\n+            }\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return JAVA_LONG;\n+            } else if (c == double.class) {\n+                return JAVA_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return ADDRESS;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#include <stdarg.h>\n+\n+int getpid();\n","filename":"test.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+# Test libraries\n+lib.dirs = .\/lib\n+\n+# This file identifies root(s) of the test-ng hierarchy.\n+TestNG.dirs = .\/java\n+\n+# To help out with foreign memory access Spliterator tests\n+modules = jdk.incubator.foreign\n+\n+groups=TEST.groups\n+\n","filename":"test\/TEST.ROOT","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+# tests that use shared library compiled from associated C code\n+native_tests = \\\n+    generator\/funcPointerInvokers\/TestFuncPointerInvokers.java \\\n+    generator\/test8239918\/LibTest8239918Test.java \\\n+    generator\/test8244938\/Test8244938.java \\\n+    generator\/test8244959\/Test8244959.java \\\n+    generator\/test8245003\/Test8245003.java \\\n+    generator\/test8246341\/LibTest8246341Test.java \\\n+    generator\/test8246341\/LibTest8246341Test.java \\\n+    generator\/test8246400\/LibTest8246400Test.java \\\n+    generator\/test8249757\/LibTest8249757Test.java \\\n+    generator\/test8252016\/Test8252016.java \\\n+    generator\/test8252121\/Test8252121.java \\\n+    generator\/test8253102\/LibTest8253102Test.java \\\n+    generator\/test8257892\/LibUnsupportedTest.java \\\n+    generator\/test8258605\/LibTest8258605Test.java \\\n+    generator\/test8261511\/Test8261511.java \\\n+    generator\/testFunctionPointer\/LibFuncPtrTest.java \\\n+    generator\/testStruct\/LibStructTest.java \\\n+    java\/org\/openjdk\/jextract\/test\/toolprovider\/ConstantsTest.java \\\n+    java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240811.java \\\n+    java\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java\n+\n+pure_java_tests = \\\n+    generator \\\n+    java \\\n+    -:native_tests\n","filename":"test\/TEST.groups","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.*;\n+\n+import static test.jextract.funcpointers.func_h.*;\n+import test.jextract.funcpointers.*;\n+\n+\/*\n+ * @test id=classes\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Func -t test.jextract.funcpointers func.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFuncPointerInvokers\n+ *\/\n+\/*\n+ * @test id=sources\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Func -t test.jextract.funcpointers func.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFuncPointerInvokers\n+ *\/\n+public class TestFuncPointerInvokers {\n+    @Test\n+    public void testStructFieldTypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Bar.foo(bar, scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFITypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddress(Bar.foo$get(bar), scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalTypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            f().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFITypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddress(f$get(), scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp(baz, scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFIFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp.ofAddress(Baz.fp$get(baz), scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFIFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp.ofAddress(fp$get(), scope).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFIFunctionPointerAddress() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            fp_addr$set(fp_addr.allocate((addr) -> MemoryAddress.ofLong(addr.toRawLongValue() + 1), scope).address());\n+            assertEquals(fp_addr.ofAddress(fp_addr$get(), scope).apply(MemoryAddress.ofLong(42)), MemoryAddress.ofLong(43));\n+        }\n+    }\n+}\n","filename":"test\/generator\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void (*Foo)(int arg);\n+\n+struct Bar {\n+   Foo foo;\n+};\n+\n+EXPORT Foo f;\n+\n+struct Baz {\n+   void (*fp)(int arg);\n+};\n+\n+EXPORT void (*fp)(int arg);\n+\n+EXPORT int* (*fp_addr)(int *arg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/funcPointerInvokers\/func.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"func.h\"\n","filename":"test\/generator\/funcPointerInvokers\/libFunc.c","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8239918.test8239918_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8239918 -t test.jextract.test8239918 test8239918.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8239918Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8239918 -t test.jextract.test8239918 test8239918.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8239918Test\n+ *\/\n+public class LibTest8239918Test {\n+    @Test\n+    public void testRand() {\n+        assertEquals(rand(), 1729);\n+    }\n+}\n","filename":"test\/generator\/test8239918\/LibTest8239918Test.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8239918.h\"\n+\n+EXPORT int rand(void) {\n+    return 1729;\n+}\n","filename":"test\/generator\/test8239918\/libTest8239918.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int rand(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8239918\/test8239918.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8240373.test8240373_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.test8240373 test8240373.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Lib8240373Test\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\/..\/lib\n+ *\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8240373 test8240373.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Lib8240373Test\n+ *\/\n+\n+public class Lib8240373Test {\n+    @Test\n+    public void test() {\n+        assertTrue(A() == 0);\n+        assertTrue(B() == 1);\n+        assertTrue(C() == 2);\n+        assertTrue(E_INVALID() == -1);\n+    }\n+}\n","filename":"test\/generator\/test8240373\/Lib8240373Test.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+typedef enum E { A, B, C } E;\n+#define E_INVALID ((E)-1)\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8240373\/test8240373.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+import test.jextract.test8244412.*;\n+import static test.jextract.test8244412.test8244412_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run main\/othervm JtregJextract -t test.jextract.test8244412 test8244412.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8244412Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8244412 test8244412.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8244412Test\n+ *\/\n+public class LibTest8244412Test {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            var addr = allocator.allocate(mysize_t, 0L);\n+            assertEquals(addr.get(C_LONG_LONG, 0), 0L);\n+            addr.set(C_LONG_LONG, 0, 13455566L);\n+            assertEquals(addr.get(C_LONG_LONG, 0), 13455566L);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8244412\/LibTest8244412Test.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef long long mysize_t;\n+typedef long long MYSIZE_T;\n","filename":"test\/generator\/test8244412\/test8244412.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.ResourceScope;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8244938.test8244938_h.*;\n+import test.jextract.test8244938.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8244938 -t test.jextract.test8244938 test8244938.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244938\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8244938 -t test.jextract.test8244938 test8244938.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244938\n+ *\/\n+public class Test8244938 {\n+    @Test\n+    public void testNestedStructReturn() {\n+         try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             var seg = func(scope);\n+             assertEquals(seg.byteSize(), Point.sizeof());\n+             assertEquals(Point.k$get(seg), 44);\n+             var point2dSeg = Point.point2d$slice(seg);\n+             assertEquals(Point2D.i$get(point2dSeg), 567);\n+             assertEquals(Point2D.j$get(point2dSeg), 33);\n+         }\n+    }\n+}\n","filename":"test\/generator\/test8244938\/Test8244938.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8244938.h\"\n+\n+static struct Point point = { 44, { 567, 33 } };\n+EXPORT struct Point func(void) {\n+    return point;\n+}\n","filename":"test\/generator\/test8244938\/libTest8244938.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point2D {\n+   int i, j;\n+};\n+\n+struct Point {\n+  int k;\n+  struct Point2D point2d;\n+};\n+\n+EXPORT struct Point func(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8244938\/test8244938.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.printf.printf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.printf -l Printf printf.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.printf -l Printf printf.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244959\n+ *\/\n+public class Test8244959 {\n+    @Test\n+    public void testsPrintf() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            MemorySegment s = allocator.allocate(1024);\n+            my_sprintf(s,\n+                    allocator.allocateUtf8String(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n+                    (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n+            String str = s.getUtf8String(0);\n+            assertEquals(str, \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\");\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8244959\/Test8244959.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"printf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...) {\n+    va_list list;\n+    va_start(list, arg_num);\n+    int result = vsprintf(buf, fmt, list);\n+    va_end(list);\n+    return result;\n+}\n","filename":"test\/generator\/test8244959\/libPrintf.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...);\n","filename":"test\/generator\/test8244959\/printf.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import test.jextract.test8245003.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static test.jextract.test8245003.test8245003_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8245003 -t test.jextract.test8245003 test8245003.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8245003\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8245003 -t test.jextract.test8245003 test8245003.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8245003\n+ *\/\n+public class Test8245003 {\n+    @Test\n+    public void testStructAccessor() {\n+        var seg = special_pt$SEGMENT();\n+        assertEquals(seg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(seg), 56);\n+        assertEquals(Point.y$get(seg), 75);\n+\n+        seg = special_pt3d$SEGMENT();\n+        assertEquals(seg.byteSize(), Point3D.sizeof());\n+        assertEquals(Point3D.z$get(seg), 35);\n+        var pointSeg = Point3D.p$slice(seg);\n+        assertEquals(pointSeg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(pointSeg), 43);\n+        assertEquals(Point.y$get(pointSeg), 45);\n+    }\n+\n+    @Test\n+    public void testArrayAccessor() {\n+        var seg = iarr$SEGMENT();\n+        assertEquals(seg.byteSize(), C_INT.byteSize()*5);\n+        int[] arr = seg.toArray(C_INT);\n+        assertEquals(arr.length, 5);\n+        assertEquals(arr[0], 2);\n+        assertEquals(arr[1], -2);\n+        assertEquals(arr[2], 42);\n+        assertEquals(arr[3], -42);\n+        assertEquals(arr[4], 345);\n+\n+        seg = foo$SEGMENT();\n+        assertEquals(seg.byteSize(), Foo.sizeof());\n+        assertEquals(Foo.count$get(seg), 37);\n+        var greeting = Foo.greeting$slice(seg);\n+        byte[] barr = greeting.toArray(C_CHAR);\n+        assertEquals(new String(barr), \"hello\");\n+    }\n+}\n","filename":"test\/generator\/test8245003\/Test8245003.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8245003.h\"\n+\n+EXPORT Point special_pt = { 56, 75 };\n+\n+EXPORT Point3D special_pt3d = { 35, { 43, 45 } };\n+\n+EXPORT int iarr[5] = { 2, -2, 42, -42, 345 };\n+\n+EXPORT Foo foo = { 37, { 'h', 'e', 'l', 'l', 'o' } };\n","filename":"test\/generator\/test8245003\/libTest8245003.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point special_pt;\n+\n+typedef struct Point3D {\n+    int z;\n+    struct Point p;\n+} Point3D;\n+\n+EXPORT Point3D special_pt3d;\n+\n+EXPORT int iarr[5];\n+\n+typedef struct Foo {\n+    int count;\n+    char greeting[5];\n+} Foo;\n+\n+EXPORT Foo foo;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8245003\/test8245003.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246341.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246341.test8246341_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8246341 -t test.jextract.test8246341 test8246341.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8246341Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8246341 -t test.jextract.test8246341 test8246341.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8246341Test\n+ *\/\n+public class LibTest8246341Test {\n+    @Test\n+    public void testPointerArray() {\n+        boolean[] callbackCalled = new boolean[1];\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var callback = func$callback.allocate((argc, argv) -> {\n+                callbackCalled[0] = true;\n+                var addr = MemorySegment.ofAddress(argv, C_POINTER.byteSize() * argc, scope);\n+                assertEquals(argc, 4);\n+                assertEquals(addr.get(C_POINTER, 0).getUtf8String(0), \"java\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 1).getUtf8String(0), \"python\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 2).getUtf8String(0), \"javascript\");\n+                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 3).getUtf8String(0), \"c++\");\n+            }, scope);\n+            func(callback);\n+        }\n+        assertTrue(callbackCalled[0]);\n+    }\n+\n+    @Test\n+    public void testPointerAllocate() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(C_POINTER.byteSize(), scope);\n+            var addr = allocator.allocate(C_POINTER);\n+            addr.set(C_POINTER, 0, MemoryAddress.NULL);\n+            fillin(addr);\n+            assertEquals(addr.get(C_POINTER, 0).getUtf8String(0), \"hello world\");\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8246341\/LibTest8246341Test.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246341.h\"\n+\n+#define NUM_STRINGS 4\n+\n+static char* table[NUM_STRINGS] = { \"java\", \"python\", \"javascript\", \"c++\" };\n+static char* msg = \"hello world\";\n+\n+EXPORT void func(void (*callback)(int argc, char** argv)) {\n+    callback(NUM_STRINGS, table);\n+}\n+\n+EXPORT void fillin(char** pmsg) {\n+    *pmsg = msg;\n+}\n","filename":"test\/generator\/test8246341\/libTest8246341.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void func(void (*callback)(int argc, char** argv));\n+EXPORT void fillin(char** pmsg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8246341\/test8246341.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246400.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246400.test8246400_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8246400 -t test.jextract.test8246400 test8246400.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED  LibTest8246400Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8246400 -t test.jextract.test8246400 test8246400.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8246400Test\n+ *\/\n+public class LibTest8246400Test {\n+    @Test\n+    public void testSegmentRegister() {\n+        MemorySegment sum = null;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var v1 = Vector.allocate(scope);\n+            Vector.x$set(v1, 1.0);\n+            Vector.y$set(v1, 0.0);\n+\n+            var v2 = Vector.allocate(scope);\n+            Vector.x$set(v2, 0.0);\n+            Vector.y$set(v2, 1.0);\n+\n+            sum = add(scope, v1, v2);\n+\n+            assertEquals(Vector.x$get(sum), 1.0, 0.1);\n+            assertEquals(Vector.y$get(sum), 1.0, 0.1);\n+\n+            Addressable callback = cosine_similarity$dot.allocate((a, b) -> {\n+                return (Vector.x$get(a) * Vector.x$get(b)) +\n+                    (Vector.y$get(a) * Vector.y$get(b));\n+            }, scope);\n+\n+            var value = cosine_similarity(v1, v2, callback);\n+            assertEquals(value, 0.0, 0.1);\n+\n+            value = cosine_similarity(v1, v1, callback);\n+            assertEquals(value, 1.0, 0.1);\n+        }\n+        assertTrue(!sum.scope().isAlive());\n+    }\n+}\n","filename":"test\/generator\/test8246400\/LibTest8246400Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246400.h\"\n+#include <math.h>\n+\n+EXPORT Vector add(Vector v1, Vector v2) {\n+    Vector res = { v1.x + v2.x, v1.y + v2. y };\n+    return res;\n+}\n+\n+EXPORT double cosine_similarity(Vector v1, Vector v2,\n+        double (*dot)(Vector, Vector)) {\n+    double normv1 = sqrt(dot(v1, v1));\n+    double normv2 = sqrt(dot(v2, v2));\n+    return dot(v1, v2)\/(normv1 * normv2);\n+}\n","filename":"test\/generator\/test8246400\/libTest8246400.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Vector {\n+    double x;\n+    double y;\n+} Vector;\n+\n+EXPORT Vector add(Vector v1, Vector v2);\n+EXPORT double cosine_similarity(Vector v1, Vector v2, double (*dot)(Vector, Vector));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8246400\/test8246400.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8249757.test8249757_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run main\/othervm JtregJextract -libpath Test8249757 -t test.jextract.test8249757 test8249757.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8249757Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run main\/othervm JtregJextractSources -libpath Test8249757 -t test.jextract.test8249757 test8249757.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8249757Test\n+ *\/\n+public class LibTest8249757Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(square(5), 25);\n+        assertEquals(square(16), 256);\n+        assertEquals(square(20), 400);\n+    }\n+}\n","filename":"test\/generator\/test8249757\/LibTest8249757Test.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8249757.h\"\n+\n+EXPORT int square(int x) {\n+    return x*x;\n+}\n","filename":"test\/generator\/test8249757\/libTest8249757.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int square(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8249757\/test8249757.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.VaList;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.vsprintf.vsprintf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.vsprintf -l VSPrintf vsprintf.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8252016\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.vsprintf -l VSPrintf vsprintf.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8252016\n+ *\/\n+public class Test8252016 {\n+    @Test\n+    public void testsVsprintf() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.newNativeArena(scope);\n+            MemorySegment s = allocator.allocate(1024);\n+            VaList vaList = VaList.make(b -> {\n+                b.addVarg(C_INT, 12);\n+                b.addVarg(C_DOUBLE, 5.5d);\n+                b.addVarg(C_LONG_LONG, -200L);\n+                b.addVarg(C_LONG_LONG, Long.MAX_VALUE);\n+            }, scope);\n+            my_vsprintf(s, allocator.allocateUtf8String(\"%hhd %.2f %lld %lld\"), vaList);\n+            String str = s.getUtf8String(0);\n+            assertEquals(str, \"12 5.50 -200 \" + Long.MAX_VALUE);\n+       }\n+    }\n+}\n","filename":"test\/generator\/test8252016\/Test8252016.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"vsprintf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg) {\n+    return vsprintf(s, format, arg);\n+}\n","filename":"test\/generator\/test8252016\/libVSPrintf.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg);\n","filename":"test\/generator\/test8252016\/vsprintf.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.stream.IntStream;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static org.testng.Assert.assertEquals;\n+\n+import test.jextract.arrayparam.*;\n+import static test.jextract.arrayparam.arrayparam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.arrayparam -l Arrayparam arrayparam.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8252121\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.arrayparam -l Arrayparam arrayparam.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8252121\n+ *\/\n+public class Test8252121 {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.nativeAllocator(scope);\n+            int[] array = { 3, 5, 89, 34, -33 };\n+            MemorySegment seg = allocator.allocateArray(C_INT, array);\n+            assertEquals(IntStream.of(array).sum(), sum(seg));\n+            assertEquals(IntStream.of(array).reduce(1, (a,b) -> a*b), mul(seg));\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8252121\/Test8252121.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define NUM_ELEMENTS 5\n+typedef int Array[NUM_ELEMENTS];\n+\n+typedef Array MyArray;\n+\n+EXPORT int sum(Array a);\n+EXPORT int mul(MyArray a);\n","filename":"test\/generator\/test8252121\/arrayparam.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"arrayparam.h\"\n+\n+int sum(Array a) {\n+    int res = 0;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res += a[i];\n+    }\n+    return res;\n+}\n+\n+int mul(MyArray a) {\n+    int res = 1;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res *= a[i];\n+    }\n+    return res;\n+}\n","filename":"test\/generator\/test8252121\/libArrayparam.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+import test.jextract.test8252465.*;\n+import static test.jextract.test8252465.test8252465_h.*;\n+import test.jextract.test8252465.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.test8252465 test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8252465 test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+public class LibTest8252465Test {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var foo = Foo.allocate(scope);\n+            Foo.x$set(foo, 3.14f);\n+            assertEquals(Foo.x$get(foo), 3.14f, 0.001f);\n+            var bar = Bar.allocate(scope);\n+            Bar.x$set(bar, -42);\n+            assertEquals(Bar.x$get(bar), -42);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8252465\/LibTest8252465Test.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    float x;\n+};\n+\n+struct Bar {\n+    int x;\n+};\n","filename":"test\/generator\/test8252465\/test8252465.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8253102.test8253102_h.*;\n+import test.jextract.test8253102.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8253102 -t test.jextract.test8253102 test8253102.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253102Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8253102 -t test.jextract.test8253102 test8253102.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253102Test\n+ *\/\n+public class LibTest8253102Test {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress addr = make(14, 99);\n+            MemorySegment seg = Point.ofAddress(addr, scope);\n+            assertEquals(Point.x$get(seg), 14);\n+            assertEquals(Point.y$get(seg), 99);\n+            freePoint(addr);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8253102\/LibTest8253102Test.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8253102.h\"\n+#include <stdlib.h>\n+\n+EXPORT Point* make(int x, int y) {\n+    Point* p = (Point*)malloc(sizeof(Point));\n+    p->x = x; p->y = y;\n+    return p;\n+}\n+\n+EXPORT void freePoint(struct Point* ptr) {\n+    free(ptr);\n+}\n","filename":"test\/generator\/test8253102\/libTest8253102.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point* make(int x, int y);\n+\n+EXPORT void freePoint(struct Point*);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8253102\/test8253102.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8253390.test8253390_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run main\/othervm JtregJextract -t test.jextract.test8253390 test8253390.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253390Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8253390 test8253390.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8253390Test\n+ *\/\n+public class LibTest8253390Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(GREETING().getUtf8String(0), \"hello\\nworld\");\n+        assertEquals(GREETING2().getUtf8String(0), \"hello\\tworld\");\n+    }\n+}\n","filename":"test\/generator\/test8253390\/LibTest8253390Test.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define GREETING \"hello\\nworld\"\n+#define GREETING2 \"hello\\tworld\"\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8253390\/test8253390.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8254983.test8254983_h.*;\n+import test.jextract.test8254983.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run main\/othervm JtregJextract -t test.jextract.test8254983 test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8254983 test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+public class LibTest8254983Test {\n+    @Test\n+    public void testOuterStruct() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            assertEquals(((GroupLayout)Foo._struct.$LAYOUT()).memberLayouts().size(), 1);\n+            MemorySegment str = Foo._struct.allocate(scope);\n+            Foo._struct.x$set(str, 42);\n+            assertEquals(Foo._struct.x$get(str), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testInnerStruct() {\n+        assertEquals(((GroupLayout)Foo._union._struct.$LAYOUT()).memberLayouts().size(), 2);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment str = Foo._union._struct.allocate(scope);\n+            Foo._union._struct.x$set(str, 42);\n+            assertEquals(Foo._union._struct.x$get(str), 42);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8254983\/LibTest8254983Test.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+   struct {\n+       int x;\n+   } _struct;\n+\n+   union {\n+       struct {\n+           int u;\n+           int x;\n+       } _struct;\n+   } _union;\n+};\n","filename":"test\/generator\/test8254983\/test8254983.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import test.jextract.unsupported.unsupported_h;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static test.jextract.unsupported.unsupported_h.*;\n+import test.jextract.unsupported.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Unsupported -t test.jextract.unsupported unsupported.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibUnsupportedTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ *\n+ * @run main\/othervm JtregJextractSources -l Unsupported -t test.jextract.unsupported unsupported.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibUnsupportedTest\n+ *\/\n+\n+public class LibUnsupportedTest {\n+    @Test\n+    public void testAllocateFoo() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Foo.allocate(scope);\n+            Foo.i$set(seg, 32);\n+            Foo.c$set(seg, (byte)'z');\n+            assertEquals(Foo.i$get(seg), 32);\n+            assertEquals(Foo.c$get(seg), (byte)'z');\n+        }\n+    }\n+\n+    @Test\n+    public void testGetFoo() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = MemorySegment.ofAddress(getFoo(), Foo.sizeof(), scope);\n+            Foo.i$set(seg, 42);\n+            Foo.c$set(seg, (byte)'j');\n+            assertEquals(Foo.i$get(seg), 42);\n+            assertEquals(Foo.c$get(seg), (byte)'j');\n+        }\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)Foo.$LAYOUT();\n+        checkField(g, \"i\", C_INT);\n+        checkField(g, \"c\", C_CHAR);\n+    }\n+\n+    @Test\n+    public void testIgnoredMethods() {\n+        assertNull(findMethod(unsupported_h.class, \"func\"));\n+        assertNull(findMethod(unsupported_h.class, \"func2\"));\n+        assertNull(findMethod(unsupported_h.class, \"func3\"));\n+        assertNull(findMethod(unsupported_h.class, \"func4\"));\n+        assertNull(findMethod(unsupported_h.class, \"makeFoo\"));\n+        assertNull(findMethod(unsupported_h.class, \"copyFoo\"));\n+    }\n+\n+    private Method findMethod(Class<?> cls, String name) {\n+        for (Method m : cls.getMethods()) {\n+            if (m.getName().equals(name)) {\n+                return m;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/generator\/test8257892\/LibUnsupportedTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"unsupported.h\"\n+\n+static Foo f = { 42, 343.55, 'j' };\n+\n+EXPORT Foo* getFoo() {\n+    return &f;\n+}\n","filename":"test\/generator\/test8257892\/libUnsupported.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Foo {\n+    int i;\n+    long double ld;\n+    char c;\n+} Foo;\n+\n+EXPORT void func(long double ll);\n+EXPORT void func2(void (*f)(long double l));\n+EXPORT void func3(long double (*f)());\n+EXPORT void func4(void (*f)(Foo f));\n+EXPORT Foo* getFoo();\n+EXPORT Foo makeFoo();\n+EXPORT void copyFoo(Foo f1, Foo f2);\n+\n+long double ld;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8257892\/unsupported.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8258605.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8258605.funcParam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l FuncParam -t test.jextract.test8258605 funcParam.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8258605Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l FuncParam -t test.jextract.test8258605 funcParam.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8258605Test\n+ *\/\n+public class LibTest8258605Test {\n+    @Test\n+    public void testFunctionCallback() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+             f(CB.allocate(i -> {\n+                 assertTrue(i == 10);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFunctionPointerCallback() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+\n+             \/\/ get struct Foo instance\n+             var foo = getFoo(scope);\n+             \/\/ make sure that foo.bar is not NULL\n+             assertFalse(Foo.bar$get(foo).equals(NULL));\n+\n+             f2(foo, CB.allocate(i -> {\n+                 assertTrue(i == 42);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8258605\/LibTest8258605Test.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void CB(int);\n+\n+EXPORT void f(CB x);\n+\n+struct Foo {\n+    void (*bar)(CB cb);\n+};\n+\n+\/* get initialised Foo struct instance *\/\n+EXPORT struct Foo getFoo();\n+\n+\/* first param should be initialized struct instance returned by getFoo *\/\n+EXPORT void f2(struct Foo foo, CB cb);\n","filename":"test\/generator\/test8258605\/funcParam.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcParam.h\"\n+\n+EXPORT void f(CB x) {\n+    x(10);\n+}\n+\n+static void barFunc(CB cb) {\n+    cb(42);\n+}\n+\n+static struct Foo theFoo;\n+\n+EXPORT struct Foo getFoo() {\n+    theFoo.bar = barFunc;\n+    return theFoo;\n+}\n+\n+EXPORT void f2(struct Foo foo, CB cb) {\n+    foo.bar(cb);\n+}\n","filename":"test\/generator\/test8258605\/libFuncParam.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import test.jextract.test8259473.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8259473.test8259473_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.test8259473 test8259473.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.test8259473 test8259473.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibTest8259473Test\n+ *\/\n+public class LibTest8259473Test {\n+    @Test\n+    public void nullChecksTest() {\n+        try {\n+            func();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            func$MH();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            x$get();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$set(1);\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            y$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: y\"));\n+        }\n+\n+        try {\n+            pt$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: pt\"));\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8259473\/LibTest8259473Test.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+void func();\n+extern int x;\n+extern int y[10];\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+extern struct Point pt;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8259473\/test8259473.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.ResourceScope;\n+import test.jextract.test8261511.*;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8261511.test8261511_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Test8261511 -t test.jextract.test8261511 test8261511.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8261511\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8261511 -t test.jextract.test8261511 test8261511.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8261511\n+ *\/\n+public class Test8261511 {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var funcPtr = Foo.sum$get(get_foo(scope));\n+            var sumIface = Foo.sum.ofAddress(funcPtr, scope);\n+            assertEquals(sumIface.apply(15,20), 35);\n+            assertEquals(sum(1.2, 4.5), 5.7, 0.001);\n+        }\n+    }\n+}\n","filename":"test\/generator\/test8261511\/Test8261511.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8261511.h\"\n+#include <stdio.h>\n+\n+struct Foo theFoo;\n+\n+int foo_sum(int x, int y) {\n+    printf(\"foo_sum called\\n\");\n+    return x + y;\n+}\n+\n+EXPORT struct Foo get_foo() {\n+    theFoo.sum = foo_sum;\n+    return theFoo;\n+}\n+\n+EXPORT double sum(double x, double y) {\n+    printf(\"sum called\\n\");\n+    return x + y;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8261511\/libTest8261511.c","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+    int (*sum)(int x, int y);\n+};\n+\n+EXPORT struct Foo get_foo();\n+EXPORT double sum(double x, double y);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/test8261511\/test8261511.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import test.jextract.test8281764.*;\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8281764\n+ * @summary jextract does not generate parameter names for function pointer typedefs\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8281764 -t test.jextract.test8281764 test8281764.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8281764\n+ *\/\n+public class Test8281764 {\n+    @Test\n+    public void testFunctionalInterfaceParameterNames() throws NoSuchMethodException {\n+        var apply = func.class.getMethod(\"apply\", int.class);\n+        assertEquals(apply.getParameters()[0].getName(), \"foo\");\n+        apply = fptr.class.getMethod(\"apply\", int.class, int.class);\n+        assertEquals(apply.getParameters()[0].getName(), \"x\");\n+        assertEquals(apply.getParameters()[1].getName(), \"y\");\n+    }\n+}\n","filename":"test\/generator\/test8281764\/Test8281764.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void func(int foo);\n+typedef void (*fptr)(int x, int y);\n","filename":"test\/generator\/test8281764\/test8281764.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import test.jextract.test8282235.*;\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8282235\n+ * @summary jextract crashes when a Java keyword is used in as a function pointer typedef parameter name\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l Test8282235 -t test.jextract.test8282235 test8282235.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8282235\n+ *\/\n+public class Test8282235 {\n+    @Test\n+    public void testFunctionalInterfaceParameterNames() throws NoSuchMethodException {\n+        var apply = func.class.getMethod(\"apply\", int.class);\n+        assertEquals(apply.getParameters()[0].getName(), \"abstract_\");\n+        apply = fptr.class.getMethod(\"apply\", int.class, int.class);\n+        assertEquals(apply.getParameters()[0].getName(), \"public_\");\n+        assertEquals(apply.getParameters()[1].getName(), \"interface_\");\n+    }\n+}\n+\n","filename":"test\/generator\/test8282235\/Test8282235.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void func(int abstract);\n+typedef void (*fptr)(int public, int interface);\n","filename":"test\/generator\/test8282235\/test8282235.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.fp.funcPtr_h.*;\n+import test.jextract.fp.*;\n+\n+\/*\n+ * @test id=classes\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l FuncPtr -t test.jextract.fp funcPtr.h\n+ * @run testng\/othervm LibFuncPtrTest\n+ *\/\n+ \/*\n+ * @test id=sources\n+  * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -l FuncPtr -t test.jextract.fp funcPtr.h\n+ * @run testng\/othervm LibFuncPtrTest\n+ *\/\n+public class LibFuncPtrTest {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var handle = func$f.allocate(x -> x * x, scope);\n+            assertEquals(func(handle, 35), 35 * 35 + 35);\n+        }\n+    }\n+}\n","filename":"test\/generator\/testFunctionPointer\/LibFuncPtrTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int func(int (*f)(int), int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/testFunctionPointer\/funcPtr.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcPtr.h\"\n+\n+EXPORT int func(int (*f)(int), int x) {\n+    return x + f(x);\n+}\n","filename":"test\/generator\/testFunctionPointer\/libFuncPtr.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.redef.*;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.redef.redef_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -t test.jextract.redef redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextractSources -t test.jextract.redef redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+public class TestGlobalRedefinition {\n+    @Test\n+    public void test() throws Throwable {\n+        Method mGet = redef_h.class.getMethod(\"x$get\");\n+        assertEquals(mGet.getReturnType(), int.class);\n+\n+        Method mSet = redef_h.class.getMethod(\"x$set\", int.class);\n+        assertEquals(mSet.getParameterTypes()[0], int.class);\n+    }\n+}\n","filename":"test\/generator\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+typedef int MyInt;\n+\n+extern const int x;\n+extern const MyInt x;\n","filename":"test\/generator\/testGlobalRedefinition\/redef.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.struct.struct_h.*;\n+import test.jextract.struct.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\/..\/lib\n+ * @run main\/othervm JtregJextract -l Struct -t test.jextract.struct struct.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibStructTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\/..\/lib\n+ *\n+ * @run main\/othervm JtregJextractSources -l Struct -t test.jextract.struct struct.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibStructTest\n+ *\/\n+\n+public class LibStructTest {\n+    @Test\n+    public void testMakePoint() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = makePoint(scope, 42, -39);\n+            assertEquals(Point.x$get(seg), 42);\n+            assertEquals(Point.y$get(seg), -39);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocate() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Point.allocate(scope);\n+            Point.x$set(seg, 56);\n+            Point.y$set(seg, 65);\n+            assertEquals(Point.x$get(seg), 56);\n+            assertEquals(Point.y$get(seg), 65);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateArray() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Point.allocateArray(3, scope);\n+            for (int i = 0; i < 3; i++) {\n+                Point.x$set(seg, i, 56 + i);\n+                Point.y$set(seg, i, 65 + i);\n+            }\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(Point.x$get(seg, i), 56 + i);\n+                assertEquals(Point.y$get(seg, i), 65 + i);\n+            }\n+        }\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)AllTypes.$LAYOUT();\n+        checkField(g, \"sc\", C_CHAR);\n+        checkField(g, \"uc\", C_CHAR);\n+        checkField(g, \"s\",  C_SHORT);\n+        checkField(g, \"us\", C_SHORT);\n+        checkField(g, \"i\",  C_INT);\n+        checkField(g, \"ui\", C_INT);\n+        checkField(g, \"l\",  C_LONG);\n+        checkField(g, \"ul\", C_LONG);\n+        checkField(g, \"ll\", C_LONG_LONG);\n+        checkField(g, \"ull\",C_LONG_LONG);\n+        checkField(g, \"f\",  C_FLOAT);\n+        checkField(g, \"d\",  C_DOUBLE);\n+    }\n+}\n","filename":"test\/generator\/testStruct\/LibStructTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"struct.h\"\n+\n+EXPORT Point makePoint(int x, int y) {\n+    Point pt = { x, y };\n+    return pt;\n+}\n","filename":"test\/generator\/testStruct\/libStruct.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point makePoint(int x, int y);\n+\n+struct AllTypes {\n+    signed char sc;\n+    unsigned char uc;\n+    short s;\n+    unsigned short us;\n+    int i;\n+    unsigned int ui;\n+    long l;\n+    unsigned long ul;\n+    long long ll;\n+    unsigned long long ull;\n+    float f;\n+    double d;\n+    long double ld;\n+};\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/generator\/testStruct\/struct.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestUtils {\n+\n+    public static Loader classLoader(Path... paths) {\n+        try {\n+            URL[] urls = new URL[paths.length];\n+            for (int i = 0; i < paths.length; i++) {\n+                urls[i] = paths[i].toUri().toURL();\n+            }\n+            URLClassLoader ucl = new URLClassLoader(urls,\n+                    TestUtils.class.getClassLoader());\n+            return new Loader(ucl);\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static class Loader implements AutoCloseable {\n+\n+        private final URLClassLoader loader;\n+\n+        public Loader(URLClassLoader loader) {\n+            this.loader = loader;\n+        }\n+\n+        public Class<?> loadClass(String className) {\n+            try {\n+                return Class.forName(className, false, loader);\n+            } catch (ClassNotFoundException e) {\n+                \/\/ return null so caller can check if class loading\n+                \/\/ was successful with assertNotNull\/assertNull\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            try {\n+                loader.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static void deleteDirIfExists(Path path) {\n+        if (Files.exists(path)) {\n+            deleteDir(path);\n+        }\n+    }\n+\n+    public static void deleteDir(Path path) {\n+        try {\n+            deleteFileTreeWithRetry(path);\n+        } catch (IOException ioExp) {\n+            throw new RuntimeException(ioExp);\n+        }\n+    }\n+\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;\n+    private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;\n+\n+    \/**\n+     * Deletes a file, retrying if necessary.\n+     * No exception thrown if file doesn't exist.\n+     *\n+     * @param path  the file to delete\n+     *\n+     * @throws NoSuchFileException\n+     *         if the file does not exist (optional specific exception)\n+     * @throws DirectoryNotEmptyException\n+     *         if the file is a directory and could not otherwise be deleted\n+     *         because the directory is not empty (optional specific exception)\n+     * @throws IOException\n+     *         if an I\/O error occurs\n+     *\/\n+    public static void deleteFileIfExistsWithRetry(Path path) throws IOException {\n+        try {\n+            if (!Files.notExists(path)) {\n+                deleteFileWithRetry0(path);\n+            }\n+        } catch (InterruptedException x) {\n+            throw new IOException(\"Interrupted while deleting.\", x);\n+        }\n+    }\n+\n+    private static void deleteFileWithRetry0(Path path)\n+            throws IOException, InterruptedException {\n+        int times = 0;\n+        IOException ioe = null;\n+        while (true) {\n+            try {\n+                Files.delete(path);\n+                \/\/ Checks for absence of the file. Semantics of Files.exists() is not the same.\n+                while (!Files.notExists(path)) {\n+                    times++;\n+                    if (times > MAX_RETRY_DELETE_TIMES) {\n+                        throw new IOException(\"File still exists after \" + times + \" waits.\");\n+                    }\n+                    Thread.sleep(RETRY_DELETE_MILLIS);\n+                }\n+                break;\n+            } catch (NoSuchFileException | DirectoryNotEmptyException x) {\n+                throw x;\n+            } catch (IOException x) {\n+                \/\/ Backoff\/retry in case another process is accessing the file\n+                times++;\n+                if (ioe == null) {\n+                    ioe = x;\n+                } else {\n+                    ioe.addSuppressed(x);\n+                }\n+\n+                if (times > MAX_RETRY_DELETE_TIMES) {\n+                    throw ioe;\n+                }\n+                Thread.sleep(RETRY_DELETE_MILLIS);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Deletes a directory and its subdirectories, retrying if necessary.\n+     *\n+     * @param dir  the directory to delete\n+     *\n+     * @throws  IOException\n+     *          If an I\/O error occurs. Any such exceptions are caught\n+     *          internally. If only one is caught, then it is re-thrown.\n+     *          If more than one exception is caught, then the second and\n+     *          following exceptions are added as suppressed exceptions of the\n+     *          first one caught, which is then re-thrown.\n+     *\/\n+    public static void deleteFileTreeWithRetry(Path dir) throws IOException {\n+        IOException ioe = null;\n+        final List<IOException> excs = deleteFileTreeUnchecked(dir);\n+        if (!excs.isEmpty()) {\n+            ioe = excs.remove(0);\n+            for (IOException x : excs) {\n+                ioe.addSuppressed(x);\n+            }\n+        }\n+        if (ioe != null) {\n+            throw ioe;\n+        }\n+    }\n+\n+    public static List<IOException> deleteFileTreeUnchecked(Path dir) {\n+        final List<IOException> excs = new ArrayList<>();\n+        try {\n+            java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                    try {\n+                        deleteFileWithRetry0(file);\n+                    } catch (IOException x) {\n+                        excs.add(x);\n+                    } catch (InterruptedException x) {\n+                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n+                        return FileVisitResult.TERMINATE;\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n+                    try {\n+                        deleteFileWithRetry0(dir);\n+                    } catch (IOException x) {\n+                        excs.add(x);\n+                    } catch (InterruptedException x) {\n+                        excs.add(new IOException(\"Interrupted while deleting.\", x));\n+                        return FileVisitResult.TERMINATE;\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n+                    excs.add(exc);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException x) {\n+            excs.add(x);\n+        }\n+        return excs;\n+    }\n+\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/TestUtils.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.JextractTool;\n+import org.openjdk.jextract.Type;\n+\n+import static org.testng.Assert.*;\n+\n+public class JextractApiTestBase {\n+    static final boolean isMacOSX =\n+            System.getProperty(\"os.name\", \"unknown\").contains(\"OS X\");\n+    static final boolean isWindows =\n+            System.getProperty(\"os.name\", \"unknown\").startsWith(\"Windows\");\n+\n+    public static  Declaration.Scoped parse(String headerFilename, String... parseOptions) {\n+        Path header = Paths.get(System.getProperty(\"test.root\", \".\"),\n+                \"java\", \"org\", \"openjdk\", \"jextract\", \"test\", \"api\", headerFilename);\n+        return JextractTool.parse(List.of(header), parseOptions);\n+    }\n+\n+    public static void checkNames(List<Declaration> members, String... fields) {\n+        assertEquals(members.size(), fields.length);\n+        for (int i = 0; i < fields.length; i++) {\n+            assertEquals(members.get(i).name(), fields[i]);\n+        }\n+    }\n+\n+    public static Declaration.Scoped checkScoped(Declaration.Scoped toplevel, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        Declaration.Scoped scoped = findDecl(toplevel, name, Declaration.Scoped.class);\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(scoped.members(), fields);\n+        return scoped;\n+    }\n+\n+    private static List<Declaration> getNamedFields(Declaration.Scoped scoped) {\n+        List<Declaration> fields = new ArrayList<>();\n+        scoped.members().forEach(d -> {\n+            if (d instanceof Declaration.Variable) {\n+                Declaration.Variable v = (Declaration.Variable) d;\n+                if (v.kind() == Declaration.Variable.Kind.FIELD) {\n+                    assert (!v.name().isEmpty());\n+                    fields.add(v);\n+                }\n+            } else if (d instanceof Declaration.Scoped) {\n+                Declaration.Scoped record = (Declaration.Scoped) d;\n+                if (record.name().isEmpty()) {\n+                    fields.addAll(getNamedFields(record));\n+                } else {\n+                    fields.add(record);\n+                }\n+            }\n+        });\n+        return fields;\n+    }\n+\n+    public static Declaration.Scoped checkRecord(Declaration.Scoped scoped, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(getNamedFields(scoped), fields);\n+        return scoped;\n+    }\n+\n+    public static Declaration.Scoped checkStruct(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.STRUCT, fields);\n+    }\n+\n+    public static Declaration.Scoped checkBitfields(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.BITFIELDS, fields);\n+    }\n+\n+    public static Declaration.Scoped checkUnion(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.UNION, fields);\n+    }\n+\n+    public static Declaration.Variable checkVariable(Declaration.Scoped scope, String name, Type type) {\n+        Declaration.Variable var = findDecl(scope, name, Declaration.Variable.class);\n+        assertTypeEquals(type, var.type());\n+        return var;\n+    }\n+\n+    public static Declaration.Variable checkGlobal(Declaration.Scoped toplevel, String name, Type type) {\n+        Declaration.Variable global = checkVariable(toplevel, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.GLOBAL);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkField(Declaration.Scoped record, String name, Type type) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.FIELD);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkBitField(Declaration.Scoped record, String name, Type type, int size) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.BITFIELD);\n+        assertEquals(global.layout().get().bitSize(), size);\n+        return global;\n+    }\n+\n+    public static void checkFunction(Declaration.Function function, Type ret, Type... params) {\n+        assertTypeEquals(ret, function.type().returnType());\n+        assertEquals(function.parameters().size(), params.length);\n+        for (int i = 0 ; i < params.length ; i++) {\n+            assertTypeEquals(params[i], function.type().argumentTypes().get(i));\n+            Type paramType = function.parameters().get(i).type();\n+            if (paramType instanceof Type.Array) {\n+                assertTypeEquals(params[i], Type.pointer(((Type.Array) paramType).elementType()));\n+            } else {\n+                assertTypeEquals(params[i], function.parameters().get(i).type());\n+            }\n+        }\n+    }\n+\n+    public static Declaration.Function checkFunction(Declaration.Scoped toplevel,String name , Type ret, Type... params) {\n+        Declaration.Function function = findDecl(toplevel, name, Declaration.Function.class);\n+        checkFunction(function, ret,params);\n+        return function;\n+    }\n+\n+    public static Declaration.Constant checkConstant(Declaration.Scoped toplevel, String name, Type type, Object value) {\n+        Declaration.Constant constant = findDecl(toplevel, name, Declaration.Constant.class);\n+        assertTypeEquals(type, constant.type());\n+        assertEquals(value, constant.value());\n+        return constant;\n+    }\n+\n+    public static Predicate<Declaration> byName(final String name) {\n+        return d -> d.name().equals(name);\n+    }\n+\n+    public static Predicate<Declaration> byNameAndType(final String name, Class<? extends Declaration> declType) {\n+        return d -> declType.isAssignableFrom(d.getClass()) && d.name().equals(name);\n+    }\n+\n+    public static Optional<Declaration> findDecl(Declaration.Scoped toplevel, Predicate<Declaration> filter) {\n+        return toplevel.members().stream().filter(filter).findAny();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <D extends Declaration> D findDecl(Declaration.Scoped toplevel, String name, Class<D> declType) {\n+        Optional<Declaration> d = findDecl(toplevel, byNameAndType(name, declType));\n+        if (d.isEmpty()) {\n+            fail(\"No declaration with name \" + name + \" found in \" + toplevel);\n+            return null;\n+        }\n+        return (D) d.get();\n+    }\n+\n+    public static void assertTypeEquals(Type expected, Type found) {\n+        assertEquals(expected.getClass(), found.getClass());\n+        if (expected instanceof Type.Primitive) {\n+            assertEquals(expected, found);\n+        } else if (expected instanceof Type.Delegated) {\n+            assertEquals(((Type.Delegated)expected).kind(), ((Type.Delegated)found).kind());\n+            assertTypeEquals(((Type.Delegated)expected).type(), ((Type.Delegated)found).type());\n+        } else if (expected instanceof Type.Array) {\n+            assertEquals(((Type.Array)expected).kind(), ((Type.Array)found).kind());\n+            assertEquals(((Type.Array)expected).elementCount(), ((Type.Array)found).elementCount());\n+            assertTypeEquals(((Type.Array)expected).elementType(), ((Type.Array)found).elementType());\n+        } else if (expected instanceof Type.Declared) {\n+            assertEquals(((Type.Declared)expected).tree(), ((Type.Declared)found).tree());\n+        } else if (expected instanceof Type.Function) {\n+            assertTypeEquals(((Type.Function)expected).returnType(), ((Type.Function)found).returnType());\n+            assertEquals(((Type.Function)expected).argumentTypes().size(), ((Type.Function)found).argumentTypes().size());\n+            assertEquals(((Type.Function)expected).varargs(), ((Type.Function)found).varargs());\n+            for (int i = 0 ; i < ((Type.Function)expected).argumentTypes().size() ; i++) {\n+                assertTypeEquals(((Type.Function)expected).argumentTypes().get(i), ((Type.Function)found).argumentTypes().get(i));\n+            }\n+        }\n+    }\n+\n+    public static Type unwrapDelegatedType(Type type, Type.Delegated.Kind kind) {\n+        assertTrue(type instanceof Type.Delegated,\n+                \"Expecting Type.Delegated, got \" + type.getClass());\n+        Type.Delegated delegated = (Type.Delegated) type;\n+        assertEquals(delegated.kind(), kind);\n+        return delegated.type();\n+    }\n+\n+    public static Type unwrapPointerType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.POINTER);\n+    }\n+\n+    public static Type unwrapTypedefType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.TYPEDEF);\n+    }\n+\n+    public static Type unwrapArrayType(Type type, long size) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertEquals(arType.elementCount().getAsLong(), size);\n+        return arType.elementType();\n+    }\n+\n+    public static Type unwrapArrayType(Type type) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertTrue(arType.elementCount().isEmpty());\n+        return arType.elementType();\n+    }\n+\n+    static class TypeUnwrapper {\n+        private Type type;\n+\n+        private TypeUnwrapper(Type type) {\n+            this.type = type;\n+        }\n+\n+        public static TypeUnwrapper of(Type type) {\n+            return new TypeUnwrapper(type);\n+        }\n+\n+        public TypeUnwrapper unwrapPointer() {\n+            type = unwrapPointerType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapTypedef() {\n+            type = unwrapTypedefType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray(long size) {\n+            type = unwrapArrayType(type, size);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray() {\n+            type = unwrapArrayType(type);\n+            return this;\n+        }\n+\n+        public Type get() {\n+            return type;\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/JextractApiTestBase.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class SmokeTest extends JextractApiTestBase {\n+\n+    @Test\n+    public void testParser() {\n+        Declaration.Scoped d = parse(\"smoke.h\");\n+        Declaration.Scoped pointDecl = checkStruct(d, \"Point\", \"x\", \"y\");\n+        Type intType = ((Declaration.Variable)pointDecl.members().get(0)).type();\n+        checkGlobal(d, \"p\", Type.declared(pointDecl));\n+        checkFunction(d, \"distance\", intType, Type.declared(pointDecl), Type.declared(pointDecl));\n+        Declaration.Variable ch_ptr_ptr = findDecl(d, \"ch_ptr_ptr\", Declaration.Variable.class);\n+        checkFunction(d, \"pointers\", ch_ptr_ptr.type(), ch_ptr_ptr.type(), ch_ptr_ptr.type());\n+        checkConstant(d, \"ZERO\", intType, 0L);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/SmokeTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Forward reference of struct to cause ConcurrentModificationException\n+struct foo;\n+\n+\/\/ Declaration above is required, without it, the argument s cause\n+\/\/ a C warning as struct foo only visible to the function.\n+int withRecordTypeArg(int n, struct foo s);\n+struct foo returnRecordType(void);\n+\n+\/\/ Improper header may write such with definition in other file\n+struct bar returnBar(void);\n+void withBar(struct bar s);\n+\n+struct bar *nextBar(struct bar *current);\n+\n+struct foo {\n+    int n;\n+    struct foo *ptr;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8238712.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class Test8238712 extends JextractApiTestBase {\n+    @Test\n+    public void test8238712() {\n+        Declaration.Scoped d = parse(\"Test8238712.h\");\n+        Declaration.Scoped structFoo = checkStruct(d, \"foo\", \"n\", \"ptr\");\n+        Type intType = ((Declaration.Variable) structFoo.members().get(0)).type();\n+        Type fooType = Type.declared(structFoo);\n+        checkFunction(d, \"withRecordTypeArg\", intType, intType, fooType);\n+        checkFunction(d, \"returnRecordType\", fooType);\n+        \/\/ Opaque struct, have no field\n+        Declaration.Scoped structBar = checkStruct(d, \"bar\");\n+        assertTrue(structBar.layout().isEmpty());\n+        Type barType = Type.declared(structBar);\n+        \/\/ Function with opaque struct won't work but should have cursor for tool to handle\n+        checkFunction(d, \"returnBar\", barType);\n+        checkFunction(d, \"withBar\", Type.void_(), barType);\n+        \/\/ Function use pointer to opaque struct should be OK\n+        Type barPointer = Type.pointer(barType);\n+        checkFunction(d, \"nextBar\", barPointer, barPointer);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8238712.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    unsigned int a:1;\n+    unsigned int b:1;\n+    unsigned int c:30;\n+};\n+\n+struct Bar {\n+    unsigned int x:1;\n+    unsigned int y:31;\n+    struct Foo z[1];\n+};\n+\n+struct Baz {\n+    unsigned long long x:1;\n+    unsigned long long y:63;\n+    struct Bar z[1];\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8239490.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class Test8239490 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8239490.h\");\n+        \/\/ check Foo\n+        String[] fooBitfieldNames = { \"a\", \"b\", \"c\" };\n+        int[] fooBitfieldSizes = { 1, 1, 30 };\n+        Declaration.Scoped structFoo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped bitfieldsFoo = checkBitfields(structFoo, \"\", \"a\", \"b\", \"c\");\n+        Type intType = ((Declaration.Variable)bitfieldsFoo.members().get(0)).type();\n+        for (int i = 0 ; i < fooBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsFoo, fooBitfieldNames[i], intType, fooBitfieldSizes[i]);\n+        }\n+        \/\/ check Bar\n+        String[] barBitfieldNames = { \"x\", \"y\" };\n+        int[] barBitfieldSizes = { 1, 31 };\n+        Declaration.Scoped structBar = checkStruct(d, \"Bar\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBar = checkBitfields(structBar, \"\", \"x\", \"y\");\n+        for (int i = 0 ; i < barBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBar, barBitfieldNames[i], intType, barBitfieldSizes[i]);\n+        }\n+        checkField(structBar, \"z\", Type.array(1, Type.declared(structFoo)));\n+\n+        \/\/ check Baz\n+        String[] bazBitfieldNames = { \"x\", \"y\" };\n+        int[] bazBitfieldSizes = { 1, 63 };\n+        Declaration.Scoped structBaz = checkStruct(d, \"Baz\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBaz = checkBitfields(structBaz, \"\", \"x\", \"y\");\n+        Type longType = ((Declaration.Variable)bitfieldsBaz.members().get(0)).type();\n+        for (int i = 0 ; i < bazBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBaz, bazBitfieldNames[i], longType, bazBitfieldSizes[i]);\n+        }\n+        checkField(structBaz, \"z\", Type.array(1, Type.declared(structBar)));\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8239490.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void CB(int);\n+void func_cb(CB cb);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8240372.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class Test8240372 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8240372.h\");\n+\n+        Type funcType = Type.function(false, Type.void_(), Type.primitive(Type.Primitive.Kind.Int));\n+        Type typedefType = Type.typedef(\"CB\", funcType);\n+        checkFunction(d, \"func_cb\", Type.void_(), typedefType);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8240372.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+union Foo {\n+    int i;\n+    long long l;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8240853.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+public class Test8240853 extends JextractApiTestBase {\n+    @Test\n+    public void test8240853() {\n+        Declaration.Scoped d = parse(\"Test8240853.h\");\n+        \/\/ check Foo\n+        checkUnion(d, \"Foo\", \"i\", \"l\");\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8240853.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8241650\n+ * @summary jextract module should be mapped to application class loader\n+ * @run testng Test8241650\n+ *\/\n+public class Test8241650 {\n+    @Test\n+    public void testClassLoader() {\n+        assertTrue(ClassLoader.getSystemClassLoader() == Declaration.class.getClassLoader());\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/Test8241650.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import java.lang.constant.Constable;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestAttributes extends JextractApiTestBase {\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+    private final static String ASMLABEL = \"AsmLabelAttr\";\n+\n+    private void validateAsmLabel(Declaration d, boolean isAdd) {\n+        var attrs = d.getAttribute(ASMLABEL).get();\n+        String value = isMacOSX ? \"_\" : \"\";\n+        value += d.name();\n+        value += isAdd ? \"A\" : \"B\";\n+        assertEquals(attrs.get(0), value);\n+    }\n+\n+    private void validateHeader(Declaration.Scoped top, boolean isAdd) {\n+        if (isWindows) {\n+            \/\/ TODO: add Windows validation\n+            \/\/ Simply dump declaration for now\n+            System.out.println(top);\n+            return;\n+        }\n+        var list = top.members().stream()\n+                .filter(byNameAndType(\"foo\", Declaration.Variable.class))\n+                .map(Declaration.Variable.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(list.size(), 3);\n+        int hasAttrs = 0;\n+        for (Declaration.Variable foo: list) {\n+            assertEquals(Declaration.Variable.Kind.GLOBAL, foo.kind());\n+            assertTypeEquals(C_INT, foo.type());\n+            if (foo.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(foo, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+        var listFunc = top.members().stream()\n+                .filter(byNameAndType(\"func\", Declaration.Function.class))\n+                .map(Declaration.Function.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(listFunc.size(), 3);\n+        hasAttrs = 0;\n+        for (Declaration.Function func: listFunc) {\n+            checkFunction(func, C_INT, C_INT, C_INT);\n+            if (func.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(func, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+    }\n+\n+    @Test\n+    public void testA() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+    }\n+\n+    @Test\n+    public void testB() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        validateHeader(d, false);\n+    }\n+\n+    private static  Constable getSingleValue(Declaration d, String name) {\n+        List<Constable> values = d.getAttribute(name).get();\n+        assertEquals(1, values.size());\n+        return values.get(0);\n+    }\n+\n+    @Test\n+    public void testAddAttribute() {\n+        final String ts = \"timestamp\";\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n+        Declaration withAttrs = d.withAttribute(\"header\", d.name())\n+                .withAttribute(ts, timestamp);\n+\n+        assertEquals(getSingleValue(withAttrs, \"header\"), d.name());\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);\n+        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);\n+\n+        \/\/ Make sure original Declaration is not altered\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        \/\/ Add more value to same attribute\n+        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(\n+                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),\n+                Stream.of(timestamp2)\n+            ).toArray(Constable[]::new));\n+        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));\n+        assertEquals(getSingleValue(withNewAttrs,\"header\"), d.name());\n+\n+        \/\/ Remove attribute\n+        withAttrs = withNewAttrs.withAttribute(ts);\n+        assertTrue(withAttrs.getAttribute(ts).isEmpty());\n+\n+        \/\/ Strip attribute\n+        withNewAttrs = withNewAttrs.stripAttributes();\n+        assertTrue(withNewAttrs.attributeNames().isEmpty());\n+    }\n+\n+    private void assertTrue(boolean empty) {\n+    }\n+\n+    @Test\n+    public void replaceFunctionSymbol() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+\n+        var members = d.members().stream()\n+            .map(m -> m.getAttribute(ASMLABEL)\n+                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))\n+                    .orElse(m))\n+            .toArray(Declaration[]::new);\n+        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);\n+        validateHeader(patched, false);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/TestAttributes.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class TestMacros extends JextractApiTestBase {\n+    Declaration.Scoped badMacro;\n+    Declaration.Scoped foo;\n+    Declaration.Scoped bar;\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+\n+    @BeforeClass\n+    public void parse() {\n+        \/\/ We need stdint.h for pointer macro, otherwise evaluation failed and Constant declaration is not created\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        badMacro = parse(\"badMacros.h\", \"-I\", builtinInc.toString());\n+\n+        foo = checkStruct(badMacro, \"foo\", \"ptrFoo\", \"ptrBar\");\n+        bar = checkStruct(badMacro, \"bar\", \"ptrFoo\", \"arFooPtr\");\n+    }\n+\n+    @Test\n+    public void testBadMacros() {\n+        checkConstant(badMacro, \"INVALID_INT_CONSUMER\",\n+            Type.pointer(Type.function(false, Type.void_(), C_INT)),\n+            0L);\n+        \/\/ Record type in macro definition are erased to void\n+        checkConstant(badMacro, \"NO_FOO\", Type.pointer(Type.declared(foo)), 0L);\n+        checkConstant(badMacro, \"INVALID_INT_ARRAY_PTR\", Type.pointer(Type.pointer(C_INT)), 0L);\n+    }\n+\n+    @Test\n+    public void verifyFunctions() {\n+        checkFunction(badMacro, \"func\", Type.void_(),\n+            Type.pointer(Type.declared(bar)), Type.pointer(Type.declared(foo)));\n+        checkFunction(badMacro, \"withArray\", Type.void_(),\n+            Type.pointer(Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)))));\n+    }\n+\n+    @Test\n+    public void verifyGlobals() {\n+        checkGlobal(badMacro, \"op\", Type.pointer(\n+                Type.function(false, Type.void_(), C_INT, Type.pointer(C_INT))));\n+    }\n+\n+    @Test\n+    public void verifyFields() {\n+        Type foo_t = Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)));\n+        checkField(foo, \"ptrFoo\", foo_t);\n+        checkField(foo, \"ptrBar\", Type.pointer(Type.declared(bar)));\n+        checkField(bar, \"ptrFoo\", foo_t);\n+        checkField(bar, \"arFooPtr\", Type.pointer(foo_t));\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/TestMacros.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+public class TestNestedBitfields extends JextractApiTestBase {\n+\n+    @Test\n+    public void testNestedBitfields() {\n+        Declaration.Scoped d = parse(\"nestedbitfields.h\");\n+        Declaration.Scoped foo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped foo$anon = checkStruct(foo, \"\", \"\");\n+        checkBitfields(foo$anon, \"\", \"a\", \"b\");\n+\n+        Declaration.Scoped bar = checkStruct(d, \"Bar\", \"\");\n+        Declaration.Scoped bar$anon = checkStruct(bar, \"\", \"\");\n+        Declaration.Scoped bar$anon$anon = checkStruct(bar$anon, \"\", \"\");\n+        checkBitfields(bar$anon$anon, \"\", \"a\", \"b\");\n+    }\n+}\n+\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/TestNestedBitfields.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.api;\n+\n+import org.openjdk.jextract.Declaration;\n+import org.openjdk.jextract.Type;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestTypedef extends JextractApiTestBase {\n+    Declaration.Scoped root;\n+\n+    @BeforeClass\n+    public void parse() {\n+        root = parse(\"testTypedef.h\");\n+        System.out.println(root);\n+    }\n+\n+    private Declaration[] findAllWithName(Declaration.Scoped scope, String name) {\n+        return scope.members().stream().filter(byName(name)).toArray(Declaration[]::new);\n+    }\n+\n+    public static Type getTypedefType(Declaration.Scoped scope, String name) {\n+        Declaration.Typedef d = findDecl(scope, name, Declaration.Typedef.class);\n+        Type type = d.type();\n+        \/\/ Typedef declaration should return canonical type\n+        if (type instanceof Type.Delegated) {\n+            assertNotEquals(((Type.Delegated) type).kind(), Type.Delegated.Kind.TYPEDEF);\n+        }\n+        return d.type();\n+    }\n+\n+    private Declaration.Scoped assertDeclaredTypedef(Declaration.Typedef decl) {\n+        Type type = decl.type();\n+        assertTrue(type instanceof Type.Declared, \"Expecting Type.Declared, got \" + type.getClass());\n+        return ((Type.Declared) type).tree();\n+    }\n+\n+    private Declaration.Scoped assertAnonymousRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Typedef, \"Expectint Declaration.Typedef, but got \" + ar[0].getClass());\n+        Declaration.Scoped record = assertDeclaredTypedef((Declaration.Typedef) ar[0]);\n+        return record;\n+    }\n+\n+    private Declaration.Scoped assertNamedRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Scoped, \"Expectint Declaration.Scoped, but got \" + ar[0].getClass());\n+        return (Declaration.Scoped) ar[0];\n+    }\n+\n+    @Test\n+    public void NoDuplicateSameNameTypedef() {\n+        \/\/ When typedef a named record with the same name, present the scoped\n+        \/\/ declaration and ignore the typedef\n+        Declaration.Scoped s = assertNamedRecord(root, \"Point3D\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(s.members(), \"i\", \"j\", \"k\");\n+\n+        s = assertNamedRecord(root, \"SIZE\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(s.members(), \"XS\", \"S\", \"M\", \"L\", \"XL\");\n+    }\n+\n+    @Test\n+    public void TypedefReferences() {\n+        \/\/ When reference to a typedef, the Type should be Type.Delegated\n+        \/\/ With the type to be the referenced type\n+        Declaration.Scoped pt3d = checkStruct(root, \"Point3D\", \"i\", \"j\", \"k\");\n+        Declaration.Function drawParamid = findDecl(root, \"drawParamid\", Declaration.Function.class);\n+        Type.Function fnType = drawParamid.type();\n+        \/\/ Array in function argument is lowered to pointer\n+        Type type = TypeUnwrapper.of(fnType.argumentTypes().get(0))\n+                        .unwrapPointer().unwrapTypedef().get();\n+        assertEquals(type, Type.declared(pt3d));\n+\n+        Declaration.Function do_ops = findDecl(root, \"do_ops\", Declaration.Function.class);\n+        fnType = do_ops.type();\n+        type = unwrapTypedefType(fnType.returnType());\n+        assertEquals(type, getTypedefType(root, \"op_sequence\"));\n+        type = fnType.argumentTypes().get(0);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"int_op\"));\n+        type = fnType.argumentTypes().get(1);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"count_t\"));\n+    }\n+\n+    @Test\n+    public void TypedefsToSameType()  {\n+        \/\/ For typedef declaration, the type will be the canonical type\n+        \/\/ Which means, the type will not be another typedef\n+        \/\/ However, it can be other delegated type or an array\n+        Declaration.Scoped pt = checkStruct(root, \"Point\", \"i\", \"j\");\n+        Type.Declared type = Type.declared(pt);\n+        assertEquals(getTypedefType(root, \"POINT\"), type);\n+        assertEquals(getTypedefType(root, \"point_t\"), type);\n+\n+        Type canonical = TypeUnwrapper.of(getTypedefType(root, \"rectangle\"))\n+                .unwrapArray(4)\n+                \/\/ FIXME? If we would like to generate array using typedef type\n+                \/\/ then we need to use typedef as array element type and\n+                \/\/ requires following line to pass the test.\n+                \/\/ .unwrapTypedef()\n+                .get();\n+        assertEquals(canonical, type);\n+\n+        Declaration.Variable canvas = findDecl(root, \"canvas\", Declaration.Variable.class);\n+        assertEquals(canvas.kind(), Declaration.Variable.Kind.GLOBAL);\n+        Type ref = TypeUnwrapper.of(canvas.type())\n+            .unwrapTypedef()\n+            .unwrapArray(4)\n+            .get();\n+        assertEquals(ref, type);\n+\n+        getTypedefType(root, \"count_t\");\n+    }\n+\n+    @Test\n+    public void TypedefsArrays()  {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+\n+        \/\/ As noted earlier, we currently have canonical array element type from typedef\n+        Type type = getTypedefType(root, \"location2D\");\n+        Type elementType = unwrapArrayType(type, 2);\n+        assertEquals(elementType, intType);\n+\n+        Type count_t = getTypedefType(root, \"count_t\");\n+        type = getTypedefType(root, \"dimensions\");\n+        elementType = unwrapArrayType(type);\n+        assertEquals(elementType, count_t);\n+        type = getTypedefType(root, \"count_ptr\");\n+        assertEquals(type, Type.pointer(count_t));\n+    }\n+\n+    @Test\n+    public void AnonymousRecordTypedef() {\n+        \/\/ For anonymous typedef, present the typedef declaration and\n+        \/\/ the Scope declaration can be obtained via Variable.type()\n+        Declaration.Scoped record = assertAnonymousRecord(root, \"op_sequence\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(record.members(), \"times\", \"op\");\n+\n+        record = assertAnonymousRecord(root, \"IntOrFloat\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.UNION);\n+        checkNames(record.members(), \"i\", \"f\");\n+\n+        record = assertAnonymousRecord(root, \"codetype_t\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(record.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckAnonyousDeclarations() {\n+        \/\/ Should we expunge anonymous declaration?\n+        \/\/ They only needed if referenced as a field or gloabal variable\n+        \/\/ Exception enum, as they can be used as pleased, so we need to\n+        \/\/ elevate them into constants.\n+        \/\/ Anyhow, current implementation pass through enum, not elevate them.\n+        \/\/ So we just check that\n+        Declaration[] ar = findAllWithName(root, \"\");\n+        assertEquals(ar.length, 2);\n+        Declaration.Scoped e = (Declaration.Scoped) ar[0];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"RED\", \"GREEN\", \"BLUE\");\n+        e = (Declaration.Scoped) ar[1];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckFunctionPointers() {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+        Type intOpType = getTypedefType(root, \"int_op\");\n+        assertEquals(intOpType, Type.pointer(Type.function(false, intType, intType)));\n+        Type intOp2Type = getTypedefType(root, \"int_op2\");\n+        assertEquals(intOp2Type, Type.pointer(Type.function(false, intType, intType, intType)));\n+\n+        checkGlobal(root, \"another_int_op\", intOpType);\n+\n+        Declaration.Function getFn = findDecl(root, \"getFn\", Declaration.Function.class);\n+        assertEquals(getFn.parameters().size(), 0);\n+        Type.Delegated retType = (Type.Delegated) getFn.type().returnType();\n+        assertTrue(retType.kind() == Type.Delegated.Kind.POINTER);\n+        Type.Function fnType = (Type.Function) retType.type();\n+        assertEquals(fnType.returnType(), Type.void_());\n+        assertEquals(fnType.argumentTypes().get(1),\n+                Type.typedef(\"count_t\", getTypedefType(root, \"count_t\")));\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/TestTypedef.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Macro of constant function pointer\n+#define INVALID_INT_CONSUMER         (void (*)(int))0\n+\n+struct foo;\n+typedef struct foo *foo_t;\n+struct bar;\n+\n+\/\/ Macro of constant struct pointer\n+#define NO_FOO ((foo_t)0)\n+\n+\/\/ Cases where resolving introduce new type references\n+\/\/ Pointer to pointer in macro\n+#define INVALID_INT_ARRAY_PTR (int**) 0\n+\/\/ Function pointer with pointer type argument\n+void (*op)(int cnt, int* operands);\n+void func(struct bar *pBar, struct foo *pFoo);\n+\n+\/\/ Cyclic struct pointer within struct definitions\n+struct foo {\n+    foo_t ptrFoo;\n+    struct bar *ptrBar;\n+};\n+\n+struct bar {\n+    foo_t ptrFoo;\n+    foo_t *arFooPtr;\n+};\n+\n+\/\/ Function with array to pointer\n+void withArray(foo_t ar[2]);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/badMacros.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+  #ifdef IMPL\n+    #define EXPORT __declspec(dllexport)\n+  #else\n+    #define EXPORT __declspec(dllimport)\n+  #endif \/\/ IMPL\n+#else\n+#define EXPORT\n+#endif \/\/_WIN64\n+\n+#ifdef _WIN32\n+\/\/ Windows doesn't really support asm symbol, this is similar approach for C code to\n+\/\/ achieve similar, but this won't work with Panama until we support such Macro\n+#ifdef ADD\n+#define foo fooA\n+#define func funcA\n+#else\n+#define foo fooB\n+#define func funcB\n+#endif \/\/ADD\n+#define ALIAS(sym)\n+\n+#elif __APPLE__\n+#define ALIAS(sym) __asm(\"_\" #sym)\n+#else\n+#define ALIAS(sym) __asm__(#sym)\n+#endif \/\/ _WIN32\n+\n+\/\/ We do 3 declarations to make sure we will pick up alias no matter the sequence of encounter\n+\/\/ Without alias\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n+\/\/ With alias\n+#ifdef ADD\n+\n+EXPORT extern int foo ALIAS(fooA);\n+EXPORT int func (int x, int y) ALIAS(funcA);\n+\n+#else\n+\n+EXPORT extern int foo ALIAS(fooB);\n+EXPORT int func (int x, int y) ALIAS(funcB);\n+\n+#endif \/\/ ADD\n+\n+\/\/ Without alias again\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/libAsmSymbol.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct {\n+        int a : 7;\n+        int b : 25;\n+    };\n+};\n+\n+struct Bar {\n+    struct {\n+        struct {\n+            int a : 7;\n+            int b : 25;\n+        };\n+    };\n+};\n+\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/nestedbitfields.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/simple struct\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/global\n+struct Point p;\n+\n+\/\/function\n+int distance(struct Point p1, struct Point p2);\n+\n+\/\/function with arrays\n+char ** ch_ptr_ptr;\n+char** pointers(char* arr1[], char* arr2[]);\n+\n+\/\/and a constant\n+#define ZERO 0\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/smoke.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef unsigned long count_t;\n+typedef int (*int_op)(int);\n+typedef int (*int_op2)(int, int);\n+\n+typedef struct {\n+    count_t times;\n+    int_op op;\n+} op_sequence;\n+\n+int_op add;\n+\n+\/\/ Global variable with unnamed function type\n+int (*another_int_op)(int);\n+\n+\/\/ Function prototype\n+op_sequence do_ops(int_op op, count_t times);\n+\n+\/\/ anonymous typedef\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+\/\/ Completely anonymous enum\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum SIZE {\n+    XS,\n+    S,\n+    M,\n+    L,\n+    XL\n+} SIZE;\n+\n+\/\/ Typedef anonymous enum\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+\/\/ declaration only\n+struct Point;\n+\/\/ definition\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\/\/ different name struct typedef\n+typedef struct Point POINT;\n+\/\/ layered typedef\n+typedef POINT point_t;\n+typedef point_t rectangle[4];\n+\n+rectangle canvas;\n+\n+typedef int cordinate_t;\n+typedef cordinate_t location2D[2];\n+typedef count_t dimensions[];\n+typedef count_t *count_ptr;\n+\n+\/\/ same name struct typedef\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D;\n+\/\/ User of same name typedef\n+void drawParamid(Point3D vertices[4]);\n+\n+\/\/ anonymous types not references\n+struct {\n+    int foo;\n+    int bar;\n+};\n+\n+static union {\n+    int i;\n+    long l;\n+};\n+\n+\/\/ No way to declare anonymous function type\n+\/\/ But here is a function getFn to return a function type\n+void (*getFn(void))(int, count_t, int_op);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/api\/testTypedef.h","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+\/*\n+ * MSVC: (\/d1reportSingleClassLayoutFoo)\n+ * class Foo    size(24):\n+ *      +---\n+ *  0.    | a (bitstart=0,nbits=45)\n+ *  8.    | b (bitstart=0,nbits=24)\n+ *  8.    | c (bitstart=24,nbits=1)\n+ * 16.    | d (bitstart=0,nbits=58)\n+ *      +---\n+ *\n+ * SysV: (PAHole)\n+ * struct Foo {\n+ *     long long int a:45;                0:19   8\n+ *     long long int b:24;                0:251  8\n+ *     XXX 251 bits hole, try to pack\n+ *     long long int c:1;                 8:58   8\n+ *     long long int d:58;                8: 0   8\n+ *\n+ *     size: 16, cachelines: 1, members: 4\n+ *     bit holes: 1, sum bit holes: 251 bits\n+ *     bit_padding: 5 bits\n+ *     last cacheline: 16 bytes\n+ * };\n+ *\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+public class BadBitfieldTest extends JextractToolRunner {\n+    @Test\n+    public void testBadBitfield() {\n+        run(\"-d\", getOutputFilePath(\"badBitfieldsGen\").toString(),\n+                getInputFilePath(\"badBitfields.h\").toString()).checkSuccess();\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/BadBitfieldTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+public class ConstantsTest extends JextractToolRunner {\n+    private Class<?> constants;\n+    private Path dirPath;\n+    private TestUtils.Loader loader;\n+\n+    @BeforeTest\n+    public void setup() {\n+        dirPath = getOutputFilePath(\"ConstantsTest_output\");\n+        run( \"-d\", dirPath.toString(), getInputFilePath(\"constants.h\").toString()).checkSuccess();\n+        loader = TestUtils.classLoader(dirPath);\n+        constants = loader.loadClass(\"constants_h\");\n+    }\n+\n+    @AfterTest\n+    public void cleanup() {\n+        constants = null;\n+        loader.close();\n+        TestUtils.deleteDir(dirPath);\n+    }\n+\n+    @Test(dataProvider = \"definedConstants\")\n+    public void checkConstantsTypesAndValues(String name, Class<?> type, Consumer<Object> checker) throws ReflectiveOperationException {\n+        var f = findMethod(constants, name);\n+        assertNotNull(f);\n+        assertSame(f.getReturnType(), type);\n+        f.setAccessible(true);\n+        Object actual = f.invoke(null);\n+        checker.accept(actual);\n+    }\n+\n+    @Test(dataProvider = \"missingConstants\")\n+    public void checkMissingConstants(String name) {\n+        assertTrue(findMethod(constants, name) == null);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] definedConstants() {\n+        return new Object[][] {\n+                { \"SUP\", int.class, equalsTo(5) },\n+                { \"ZERO\", int.class, equalsTo(0) },\n+                { \"ONE\", int.class, equalsTo(1) },\n+                { \"TWO\", int.class, equalsTo(2) },\n+                { \"THREE\", int.class, equalsTo(3) },\n+                { \"FOUR\", long.class, equalsTo(4L) },\n+                { \"FIVE\", long.class, equalsTo(5L) },\n+                { \"SIX\", int.class, equalsTo(6) },\n+                { \"FLOAT_VALUE\", float.class, equalsTo(1.32f) },\n+                { \"DOUBLE_VALUE\", double.class, (Consumer<Double>) (actual -> assertEquals(actual, 1.32, 0.1)) },\n+                { \"CHAR_VALUE\", int.class, equalsTo(104) }, \/\/integer char constants have type int\n+                { \"MULTICHAR_VALUE\", int.class, equalsTo(26728) },  \/\/integer char constants have type int\n+                { \"BOOL_VALUE\", byte.class, equalsTo((byte)1) },\n+                { \"SUB\", int.class, equalsTo( 7 ) },\n+                \/\/ pointer type values\n+                { \"STR\", MemorySegment.class, equalsToJavaStr(\"Hello\") },\n+                { \"QUOTE\", MemorySegment.class, equalsToJavaStr(\"QUOTE\") },\n+                { \"ZERO_PTR\", MemoryAddress.class, equalsPtrContents(0) },\n+                { \"F_PTR\", MemoryAddress.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },\n+        };\n+    }\n+\n+    static Consumer<Object> equalsTo(Object expected) {\n+        return actual -> assertEquals(actual, expected);\n+    }\n+\n+    static Consumer<MemorySegment> equalsToJavaStr(String expected) {\n+        return actual -> assertEquals(actual.getUtf8String(0), expected);\n+    }\n+\n+    static Consumer<MemoryAddress> equalsPtrContents(long expected) {\n+        return actual -> assertEquals(actual.toRawLongValue(), expected);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] missingConstants() {\n+        return new Object[][] {\n+                { \"ID\" },\n+                { \"SUM\" },\n+                { \"BLOCK_BEGIN\" },\n+                { \"BLOCK_END\" },\n+                { \"INTEGER_MAX_VALUE\" },\n+                { \"CYCLIC_1\" },\n+                { \"CYCLIC_2\" },\n+                \/\/ array\n+                { \"ARRAY\" }\n+        };\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/ConstantsTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import java.nio.file.Path;\n+\n+public class IncompleteArrayTest extends JextractToolRunner {\n+\n+    @Test\n+    public void testIncompleteArray() {\n+        Path output = getOutputFilePath(\"incompleteArray_out\");\n+        Path input = getInputFilePath(\"incompleteArray.h\");\n+        run(\n+            \"-t\", \"org.jextract\",\n+            \"-d\", output,\n+            \"--\",\n+            input).checkSuccess();\n+        try (TestUtils.Loader loader = TestUtils.classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"org.jextract.Foo\");\n+            assertNotNull(cls);\n+\n+            MemoryLayout actualLayout = findLayout(cls);\n+            MemoryLayout expectedLayout = MemoryLayout.structLayout(\n+                C_INT.withName(\"size\"),\n+                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.sequenceLayout(C_POINTER).withName(\"data\")\n+            ).withName(\"Foo\");\n+            assertEquals(actualLayout, expectedLayout);\n+        } finally {\n+            \/\/deleteDir(output);\n+        }\n+    }\n+\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/IncompleteArrayTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void func(int);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/JDK-8248474.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+\n+import static org.testng.Assert.assertNotNull;\n+\n+public class JextractToolProviderTest extends JextractToolRunner {\n+    @Test\n+    public void testHelp() {\n+        run().checkFailure(OPTION_ERROR); \/\/ no options\n+        run(\"--help\").checkSuccess();\n+        run(\"-h\").checkSuccess();\n+        run(\"-?\").checkSuccess();\n+    }\n+\n+    \/\/ error for non-existent header file\n+    @Test\n+    public void testNonExistentHeader() {\n+        run(getInputFilePath(\"non_existent.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"cannot read header file\");\n+    }\n+\n+    \/\/ error for header including non_existent.h file\n+    @Test\n+    public void testNonExistentIncluder() {\n+        run(getInputFilePath(\"non_existent_includer.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"file not found\");\n+    }\n+\n+    @Test\n+    public void testDirectoryAsHeader() {\n+        run(getInputFilePath(\"directory.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"not a file\");\n+    }\n+\n+    \/\/ error for header with parser errors\n+    @Test\n+    public void testHeaderWithDeclarationErrors() {\n+        run(getInputFilePath(\"illegal_decls.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"cannot combine with previous 'short' declaration specifier\");\n+    }\n+\n+    \/\/ @bug 8267504: jextract should report unsupported language and exit rather\n+    \/\/ than generating partial nonworking code\n+    @Test\n+    public void testUnsupportedLanguage() {\n+        run(\"-C-xc++\", getInputFilePath(\"unsupported_lang.h\").toString())\n+            .checkFailure(RUNTIME_ERROR)\n+            .checkContainsOutput(\"Unsupported language: C++\");\n+    }\n+\n+    @Test\n+    public void testOutputClass() {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(\"-d\", helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            TestUtils.deleteDir(helloOutput);\n+        }\n+    }\n+\n+    private void testTargetPackage(String targetPkgOption) {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(targetPkgOption, \"com.acme\", \"-d\",\n+            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"com.acme.hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            TestUtils.deleteDir(helloOutput);\n+        }\n+    }\n+\n+    @Test\n+    public void testTargetPackageOption() {\n+        testTargetPackage(\"-t\");\n+    }\n+\n+    @Test\n+    public void testTargetPackageLongOption() {\n+        testTargetPackage(\"--target-package\");\n+    }\n+\n+    @Test\n+    public void testHeaderClassName() {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(\"--header-class-name\", \"MyHello\", \"-t\", \"com.acme\", \"-d\",\n+            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"com.acme.MyHello\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            TestUtils.deleteDir(helloOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jextract.JextractTool;\n+import org.openjdk.jextract.Type;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class JextractToolRunner {\n+\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+    public static final ValueLayout C_LONG = IS_WINDOWS ? ValueLayout.JAVA_INT.withBitAlignment(32) : ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+\n+    \/\/ (private) exit codes from jextract tool. Copied from JextractTool.\n+    static final int SUCCESS       = 0;\n+    static final int OPTION_ERROR  = 1;\n+    static final int INPUT_ERROR   = 2;\n+    static final int CLANG_ERROR   = 3;\n+    static final int RUNTIME_ERROR = 4;\n+    static final int OUTPUT_ERROR  = 5;\n+\n+    private static String safeFileName(String filename) {\n+        int ext = filename.lastIndexOf('.');\n+        return ext != -1 ? filename.substring(0, ext) : filename;\n+    }\n+\n+    private static final ToolProvider JEXTRACT_TOOL = new JextractTool.JextractToolProvider();\n+\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    protected JextractToolRunner() {\n+        this(null, null);\n+    }\n+\n+    protected JextractToolRunner(Path input, Path output) {\n+         inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.root\", \".\"),\n+                        \"java\", \"org\", \"openjdk\", \"jextract\", \"test\", \"toolprovider\");\n+         outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \"target\"), \"test-output\");\n+    }\n+\n+    protected Path getInputFilePath(String fileName) {\n+        return inputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected Path getOutputFilePath(String fileName) {\n+        return outputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected static class JextractResult {\n+        private int exitCode;\n+        private String output;\n+\n+        JextractResult(int exitCode, String output) {\n+            this.exitCode = exitCode;\n+            this.output = output;\n+        }\n+\n+        protected JextractResult checkSuccess() {\n+            assertEquals(exitCode, SUCCESS, \"Sucess expected, failed: \" + exitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure() {\n+            assertNotEquals(exitCode, SUCCESS, \"Failure expected, succeeded!\");\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure(int expectedExitCode) {\n+            assertEquals(exitCode, expectedExitCode, \"Expected error code \" + expectedExitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkContainsOutput(String expected) {\n+            Objects.requireNonNull(expected);\n+            assertTrue(output.contains(expected), \"Output does not contain string: \" + expected);\n+            return this;\n+        }\n+\n+        protected JextractResult checkMatchesOutput(String regex) {\n+            Objects.requireNonNull(regex);\n+            assertTrue(output.trim().matches(regex), \"Output does not match regex: \" + regex);\n+            return this;\n+        }\n+    }\n+\n+    protected static JextractResult run(Object... options) {\n+        return run(Arrays.stream(options).map(Objects::toString).toArray(String[]::new));\n+    }\n+\n+    protected static JextractResult run(String... options) {\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+        String[] args = new String[options.length + 1];\n+        int result = JEXTRACT_TOOL.run(pw, pw, options);\n+        String output = writer.toString();\n+        System.err.println(output);\n+        return new JextractResult(result, output);\n+    }\n+\n+    protected static Loader classLoader(Path... paths) {\n+        try {\n+            URL[] urls = new URL[paths.length];\n+            for (int i = 0; i < paths.length; i++) {\n+                urls[i] = paths[i].toUri().toURL();\n+            }\n+            URLClassLoader ucl = new URLClassLoader(urls,\n+                    JextractToolRunner.class.getClassLoader());\n+            return new Loader(ucl);\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    protected static Field findField(Class<?> cls, String name) {\n+        try {\n+            return cls.getField(name);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected Method checkIntGetter(Class<?> cls, String name, int value) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), int.class);\n+        try {\n+            assertEquals((int)method.invoke(null), value);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return method;\n+    }\n+\n+    protected static Method findMethod(Class<?> cls, String name, Class<?>... argTypes) {\n+        try {\n+            return cls.getMethod(name, argTypes);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Method findFirstMethod(Class<?> cls, String name) {\n+        try {\n+            for (Method m : cls.getMethods()) {\n+                if (name.equals(m.getName())) {\n+                    return m;\n+                }\n+            }\n+            return null;\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Class<?> findNestedClass(Class<?> clz, String name) {\n+        return findClass(clz.getClasses(), name);\n+    }\n+\n+    protected static Class<?> findClass(Class<?>[] clz, String name) {\n+        for (Class<?> cls: clz) {\n+            if (cls.getSimpleName().equals(name)) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, MethodType type) {\n+        return checkMethod(cls, name, type.returnType(), type.parameterArray());\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, Class<?> returnType, Class<?>... args) {\n+        Method m = findMethod(cls, name, args);\n+        assertNotNull(m);\n+        assertEquals(m.getReturnType(), returnType);\n+        assertEquals(m.getParameterTypes(), args);\n+        return m;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name + \"$LAYOUT\");\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), MemoryLayout.class);\n+        try {\n+            return (MemoryLayout)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return null;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls) {\n+        return findLayout(cls, \"\");\n+    }\n+\n+    protected static void checkField(MemoryLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    protected static class Loader implements AutoCloseable {\n+\n+        private final URLClassLoader loader;\n+\n+        public Loader(URLClassLoader loader) {\n+            this.loader = loader;\n+        }\n+\n+        public Class<?> loadClass(String className) {\n+            try {\n+                return Class.forName(className, false, loader);\n+            } catch (ClassNotFoundException e) {\n+                \/\/ return null so caller can check if class loading\n+                \/\/ was successful with assertNotNull\/assertNull\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            try {\n+                loader.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolRunner.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8240300\n+ * @summary jextract produces non compilable code with repeated declarations\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED RepeatedDeclsTest\n+ *\/\n+public class RepeatedDeclsTest extends JextractToolRunner {\n+    @Test\n+    public void repeatedDecls() throws Throwable {\n+        Path repeatedDeclsOutput = getOutputFilePath(\"repeatedDeclsgen\");\n+        Path repeatedDeclsH = getInputFilePath(\"repeatedDecls.h\");\n+        run(\"-d\", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(repeatedDeclsOutput)) {\n+            Class<?> cls = loader.loadClass(\"repeatedDecls_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+\n+            \/\/ check a method for \"void func2(int)\"\n+            assertNotNull(findMethod(cls, \"func2\", int.class));\n+\n+            \/\/ check a method for \"void func3(int*)\"\n+            assertNotNull(findMethod(cls, \"func3\", Addressable.class));\n+\n+            \/\/ check a method for \"void func4(int*)\"\n+            assertNotNull(findMethod(cls, \"func4\", Addressable.class));\n+\n+            \/\/ check a method for \"void func5(int)\"\n+            assertNotNull(findMethod(cls, \"func5\", int.class));\n+\n+            \/\/ check a method for \"double distance(struct Point)\"\n+            assertNotNull(findMethod(cls, \"distance\", MemorySegment.class));\n+\n+            \/\/ check a getter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$get\"));\n+\n+            \/\/ check a setter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$set\", int.class));\n+\n+            \/\/ make sure that enum constants are generated fine\n+            checkIntGetter(cls, \"R\", 0);\n+            checkIntGetter(cls, \"G\", 1);\n+            checkIntGetter(cls, \"B\", 2);\n+            checkIntGetter(cls, \"C\", 0);\n+            checkIntGetter(cls, \"M\", 1);\n+            checkIntGetter(cls, \"Y\", 2);\n+\n+            \/\/ check Point layout\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n+            checkPoint(pointCls);\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n+            checkPoint(point_tCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+            Class<?> point$0Cls = loader.loadClass(\"POINT$0\");\n+            checkPoint(point$0Cls);\n+            assertTrue(pointCls.isAssignableFrom(point$0Cls));\n+\n+            \/\/ check Point3D layout\n+            Class<?> point3DCls = loader.loadClass(\"Point3D\");\n+            checkPoint3D(point3DCls);\n+            Class<?> point3D_tCls = loader.loadClass(\"Point3D_t\");\n+            checkPoint3D(point3D_tCls);\n+            assertTrue(point3DCls.isAssignableFrom(point3D_tCls));\n+        } finally {\n+            TestUtils.deleteDir(repeatedDeclsOutput);\n+        }\n+    }\n+\n+    private void checkPoint(Class<?> pointCls) {\n+        MemoryLayout pointLayout = findLayout(pointCls);\n+        assertNotNull(pointLayout);\n+        assertTrue(((GroupLayout)pointLayout).isStruct());\n+        checkField(pointLayout, \"i\", C_INT);\n+        checkField(pointLayout, \"j\", C_INT);\n+    }\n+\n+    private void checkPoint3D(Class<?> point3DCls) {\n+        MemoryLayout point3DLayout = findLayout(point3DCls);\n+        assertNotNull(point3DLayout);\n+        assertTrue(((GroupLayout)point3DLayout).isStruct());\n+        checkField(point3DLayout, \"i\", C_INT);\n+        checkField(point3DLayout, \"j\", C_INT);\n+        checkField(point3DLayout, \"k\", C_INT);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/RepeatedDeclsTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240181\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED -Duser.language=en Test8240181\n+ *\/\n+public class Test8240181 extends JextractToolRunner {\n+    @Test\n+    public void testAnonymousEnum() {\n+        Path anonenumOutput = getOutputFilePath(\"anonenumgen\");\n+        Path anonenumH = getInputFilePath(\"anonenum.h\");\n+        run(\"-d\", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(anonenumOutput)) {\n+            Class<?> cls = loader.loadClass(\"anonenum_h\");\n+            checkIntGetter(cls, \"RED\", 0xff0000);\n+            checkIntGetter(cls, \"GREEN\", 0x00ff00);\n+            checkIntGetter(cls, \"BLUE\", 0x0000ff);\n+            checkIntGetter(cls, \"Java\", 0);\n+            checkIntGetter(cls, \"C\", 1);\n+            checkIntGetter(cls, \"CPP\", 2);\n+            checkIntGetter(cls, \"Python\", 3);\n+            checkIntGetter(cls, \"Ruby\", 4);\n+            checkIntGetter(cls, \"ONE\", 1);\n+            checkIntGetter(cls, \"TWO\", 2);\n+        } finally {\n+            TestUtils.deleteDir(anonenumOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240181.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240657\n+ * @summary when Java keywords are used as identifiers in C header, jextract generates non-compilable java code\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8240657\n+ *\/\n+public class Test8240657 extends JextractToolRunner {\n+    @Test\n+    public void testKeywordIdentifiers() {\n+        Path exportsOutput = getOutputFilePath(\"exportsgen\");\n+        Path exportsH = getInputFilePath(\"exports.h\");\n+        run(\"-d\", exportsOutput.toString(), exportsH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(exportsOutput)) {\n+            Class<?> cls = loader.loadClass(\"exports_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            TestUtils.deleteDir(exportsOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240657.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240752\n+ * @summary jextract generates non-compilable code for special floating point values\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8240752\n+ *\/\n+public class Test8240752 extends JextractToolRunner {\n+    private float getFloatConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), float.class);\n+        try {\n+            return (float)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0f;\n+    }\n+\n+    private double getDoubleConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), double.class);\n+        try {\n+            return (double)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0d;\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        Path floatConstsOutput = getOutputFilePath(\"floatconstsgen\");\n+        Path floatConstsH = getInputFilePath(\"float_constants.h\");\n+        run(\"-d\", floatConstsOutput.toString(), floatConstsH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(floatConstsOutput)) {\n+            Class<?> cls = loader.loadClass(\"float_constants_h\");\n+            assertNotNull(cls);\n+\n+            double d = getDoubleConstant(cls, \"NAN\");\n+            assertTrue(Double.isNaN(d));\n+            d = getDoubleConstant(cls, \"PINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d > 0);\n+            d = getDoubleConstant(cls, \"NINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d < 0);\n+\n+            float f = getFloatConstant(cls, \"NANF\");\n+            assertTrue(Float.isNaN(f));\n+            f = getFloatConstant(cls, \"PINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f > 0);\n+            f = getFloatConstant(cls, \"NINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f < 0);\n+        } finally {\n+            TestUtils.deleteDir(floatConstsOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240752.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240811\n+ * @summary jextract generates non-compilable code for name collision between a struct and a global variable\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8240811\n+ *\/\n+public class Test8240811 extends JextractToolRunner {\n+    @Test\n+    public void testNameCollision() {\n+        Path nameCollisionOutput = getOutputFilePath(\"name_collision_gen\");\n+        Path nameCollisionH = getInputFilePath(\"name_collision.h\");\n+        run(\"-d\", nameCollisionOutput.toString(), nameCollisionH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(nameCollisionOutput)) {\n+            Class<?> cls = loader.loadClass(\"name_collision_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ check foo layout\n+            Class<?> fooCls = loader.loadClass(\"foo\");\n+            MemoryLayout fooLayout = findLayout(fooCls);\n+            assertNotNull(fooLayout);\n+            assertTrue(((GroupLayout)fooLayout).isStruct());\n+            checkField(fooLayout, \"x\",  C_INT);\n+            checkField(fooLayout, \"y\",  C_INT);\n+            checkField(fooLayout, \"z\",  C_INT);\n+\n+            MemoryLayout fooVarLayout = findLayout(cls, \"foo\");\n+            assertNotNull(fooVarLayout);\n+\n+            \/\/ check foo2 layout\n+            Class<?> foo2Cls = loader.loadClass(\"foo2\");\n+            MemoryLayout foo2Layout = findLayout(foo2Cls);\n+            assertNotNull(foo2Layout);\n+            assertTrue(((GroupLayout)foo2Layout).isUnion());\n+            checkField(foo2Layout, \"i\", C_INT);\n+            checkField(foo2Layout, \"l\", C_LONG);\n+\n+            MemoryLayout foo2VarLayout = findLayout(cls, \"foo2\");\n+            assertNotNull(foo2VarLayout);\n+\n+            MemoryLayout barVarLayout = findLayout(cls, \"bar\");\n+            assertNotNull(barVarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> barCls = loader.loadClass(\"bar\");\n+            MemoryLayout barLayout = findLayout(barCls);\n+            assertNotNull(barLayout);\n+            assertTrue(((GroupLayout)barLayout).isStruct());\n+            checkField(barLayout, \"f1\", C_FLOAT);\n+            checkField(barLayout, \"f2\", C_FLOAT);\n+\n+            MemoryLayout bar2VarLayout = findLayout(cls, \"bar2\");\n+            assertNotNull(bar2VarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> bar2Cls = loader.loadClass(\"bar2\");\n+            MemoryLayout bar2Layout = findLayout(bar2Cls);\n+            assertNotNull(bar2Layout);\n+            assertTrue(((GroupLayout)bar2Layout).isUnion());\n+            checkField(bar2Layout, \"f\", C_FLOAT);\n+            checkField(bar2Layout, \"d\", C_DOUBLE);\n+        } finally {\n+            TestUtils.deleteDir(nameCollisionOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8240811.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8244412\n+ *\/\n+public class Test8244412 extends JextractToolRunner {\n+    @Test\n+    public void testPrimitiveTypedefs() {\n+        Path typedefsOutput = getOutputFilePath(\"typedefsgen\");\n+        Path typedefsH = getInputFilePath(\"typedefs.h\");\n+        run(\"-d\", typedefsOutput.toString(), typedefsH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(typedefsOutput)) {\n+            Class<?> headerCls = loader.loadClass(\"typedefs_h\");\n+            assertNotNull(findField(headerCls, \"byte_t\"));\n+            assertNotNull(findField(headerCls, \"mysize_t\"));\n+        } finally {\n+            TestUtils.deleteDir(typedefsOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8244412.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8245767\n+ * @summary jextract crashes with typedef on a opaque struct or union\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8245767\n+ *\/\n+public class Test8245767 extends JextractToolRunner {\n+    @Test\n+    public void testTypedefs() {\n+        Path test8245767Output = getOutputFilePath(\"test8245767_gen\");\n+        Path test8245767H = getInputFilePath(\"test8245767.h\");\n+        run(\"-d\", test8245767Output.toString(), test8245767H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8245767Output)) {\n+            Class<?> cls = loader.loadClass(\"test8245767_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ class should be generated for typedef on opaque struct\n+            Class<?> fooCls = loader.loadClass(\"Foo\");\n+            assertNotNull(fooCls);\n+\n+            \/\/ check Point_t\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n+            assertNotNull(point_tCls);\n+\n+            \/\/ check Point\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n+            assertNotNull(pointCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+        } finally {\n+            TestUtils.deleteDir(test8245767Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8245767.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8248415\n+ * @summary jextract does not generate getter and setter for pointer typed fields in structs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8248415\n+ *\/\n+public class Test8248415 extends JextractToolRunner {\n+\n+    @Test\n+    public void testPointerFields() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8248415.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> nodeClass = loader.loadClass(\"Node\");\n+\n+            \/\/ Check if getters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+\n+            \/\/ Check if setters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8248415.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8248474\n+ * @summary jextract uses header file name as part of identifier\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8248474\n+ *\/\n+public class Test8248474 extends JextractToolRunner {\n+    @Test\n+    public void testUnsafeHeaderName() {\n+        Path test8248474Output = getOutputFilePath(\"test8248474_gen\");\n+        Path test8248474H = getInputFilePath(\"JDK-8248474.h\");\n+        run(\"-d\", test8248474Output.toString(), test8248474H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8248474Output)) {\n+            Class<?> cls = loader.loadClass(\"JDK_8248474_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            TestUtils.deleteDir(test8248474Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8248474.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8249290\n+ * @summary jextract does not handle void typedef in function pointer argument\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8249290\n+ *\/\n+public class Test8249290 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249290\");\n+        Path headerFile = getInputFilePath(\"test8249290.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249290_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249290.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8249300\n+ * @summary jextract does not handle empty parameter list of a function pointer parameters\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8249300\n+ *\/\n+public class Test8249300 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249300\");\n+        Path headerFile = getInputFilePath(\"test8249300.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249300_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249300.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8251943\n+ * @summary jextract should not generate MemorySegment typed fields for variables, struct fields if layout size info is not available\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8251943\n+ *\/\n+public class Test8251943 extends JextractToolRunner {\n+\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8251943.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8251943_h\");\n+            assertNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n+\n+            Class<?> fooClass = loader.loadClass(\"Foo\");\n+            assertNotNull(findMethod(fooClass, \"bar$get\", MemorySegment.class));\n+            assertNull(findMethod(fooClass, \"names$get\", MemorySegment.class));\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8251943.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258223\n+ * @summary jextract throws exception when unsupport type is used in anonymous struct\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8258223\n+ *\/\n+public class Test8258223 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258223Output = getOutputFilePath(\"test8258223_gen\");\n+        Path test8258223H = getInputFilePath(\"test8258223.h\");\n+        run(\"-d\", test8258223Output.toString(), test8258223H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8258223Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258223_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            TestUtils.deleteDir(test8258223Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8258223.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258405\n+ * @summary functional interfaces are not generated for struct fields\/global variables with function pointers\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8258405\n+ *\/\n+public class Test8258405 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258405Output = getOutputFilePath(\"test8258405_gen\");\n+        Path test8258405H = getInputFilePath(\"test8258405.h\");\n+        run(\"-d\", test8258405Output.toString(), test8258405H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8258405Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258405_h\");\n+            assertNotNull(cls);\n+            \/\/ check global function pointer variable 'func'\n+            cls = loader.loadClass(\"func\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", int.class));\n+            \/\/ check function pointer member 'bar' of struct 'Foo'\n+            cls = loader.loadClass(\"Foo$bar\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", float.class, double.class));\n+        } finally {\n+            TestUtils.deleteDir(test8258405Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8258405.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260344\n+ * @summary jextract crashes with exception for log.h from libdebian-installer4-dev\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED -Duser.language=en Test8260344\n+ *\/\n+public class Test8260344 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8260344Output = getOutputFilePath(\"test8260344gen\");\n+        try {\n+            Path test8260344H = getInputFilePath(\"test8260344.h\");\n+            run(\"-d\", test8260344Output.toString(), test8260344H.toString()).checkSuccess();\n+        } finally {\n+            TestUtils.deleteDir(test8260344Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260344.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260705\n+ * @summary jextract crash with libbart's types.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8260705\n+ *\/\n+public class Test8260705 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260705.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"Foo\");\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class);\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, long.class, byte.class);\n+\n+            Class<?> Foo2Class = loader.loadClass(\"Foo2\");\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, long.class, int.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            assertNotNull(loader.loadClass(\"Foo3\"));\n+\n+            Class<?> Foo4Class = loader.loadClass(\"Foo4\");\n+            assertTrue(sizeof(Foo4Class) == 8L);\n+\n+            Class<?> Foo5Class = loader.loadClass(\"Foo5\");\n+            assertTrue(sizeof(Foo5Class) == 4L);\n+\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+\n+    private long sizeof(Class<?> cls) {\n+        Method m = findMethod(cls, \"sizeof\");\n+        try {\n+            return (long)m.invoke(null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n+\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260705.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260717\n+ * @summary jextract crashes with 'Crossing storage unit boundaries' for libcoap's block.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8260717\n+ *\/\n+public class Test8260717 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260717.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"foo_t\");\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class);\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, long.class, short.class);\n+\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260717.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with libdnet's rabdef.h\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8260929\n+ *\/\n+public class Test8260929 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260929.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            assertNotNull(loader.loadClass(\"rab\"));\n+            Class<?> rab2Class = loader.loadClass(\"rab2\");\n+            assertNotNull(rab2Class);\n+\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, long.class, short.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260929.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+public class Test8261578 extends JextractToolRunner {\n+    @Test\n+    public void test1() {\n+        Path outputPath = getOutputFilePath(\"output_1\");\n+        Path headerFile = getInputFilePath(\"test8261578_1.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> ndpi_class = loader.loadClass(\"ndpi_flow_tcp_struct\");\n+            assertNotNull(ndpi_class);\n+\n+            checkMethod(ndpi_class, \"gnutella_msg_id$slice\", MemorySegment.class, MemorySegment.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test2() {\n+        Path outputPath = getOutputFilePath(\"output_2\");\n+        Path headerFile = getInputFilePath(\"test8261578_2.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> foo_class = loader.loadClass(\"foo\");\n+            assertNotNull(foo_class);\n+\n+            checkMethod(foo_class, \"clear_color$slice\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$get\", int.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(foo_class, \"clear_s$get\", byte.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_s$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test3() {\n+        Path outputPath = getOutputFilePath(\"output_3\");\n+        Path headerFile = getInputFilePath(\"test8261578_3.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(outputPath)) {\n+            Class<?> plugin_class = loader.loadClass(\"PluginCodec_H323AudioG7231AnnexC\");\n+            assertNotNull(plugin_class);\n+\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$get\", byte.class, MemorySegment.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            TestUtils.deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8261578.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8261893\n+ * @summary jextract generates class names that are restricted type names\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED -Duser.language=en Test8261893\n+ *\/\n+public class Test8261893 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8261893Output = getOutputFilePath(\"test8261893gen\");\n+        Path test8261893H = getInputFilePath(\"test8261893.h\");\n+        run(\"-d\", test8261893Output.toString(), test8261893H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8261893Output)) {\n+            assertNotNull(loader.loadClass(\"permits_\"));\n+            assertNotNull(loader.loadClass(\"record_\"));\n+            assertNotNull(loader.loadClass(\"sealed_\"));\n+            assertNotNull(loader.loadClass(\"var_\"));\n+            assertNotNull(loader.loadClass(\"yield_\"));\n+        } finally {\n+            TestUtils.deleteDir(test8261893Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8261893.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262117\n+ * @summary jextract crashes with javac compilation error \"class u is already defined\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8262117\n+ *\/\n+public class Test8262117 extends JextractToolRunner {\n+    @Test\n+    public void testNameClash() {\n+        Path test8262117Output = getOutputFilePath(\"test8262117_gen\");\n+        Path test8262117H = getInputFilePath(\"test8262117.h\");\n+        run(\"-d\", test8262117Output.toString(), test8262117H.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(test8262117Output)) {\n+            Class<?> cls = loader.loadClass(\"test8262117_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(loader.loadClass(\"u\"));\n+            assertNotNull(loader.loadClass(\"u$outer$u$0\"));\n+            assertNotNull(loader.loadClass(\"v\"));\n+            assertNotNull(loader.loadClass(\"v$v$0\"));\n+        } finally {\n+            TestUtils.deleteDir(test8262117Output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262117.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262733\n+ * @summary jextract generates clashing names which results in compilation error with javac\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8262733\n+ *\/\n+public class Test8262733 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262733gen\");\n+        Path outputH = getInputFilePath(\"test8262733.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262733_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            TestUtils.deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262733.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262825\n+ * @summary jextract crashes when Java type names like String are used as identifiers in C header\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8262825\n+ *\/\n+public class Test8262825 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262825gen\");\n+        Path outputH = getInputFilePath(\"test8262825.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262825_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(findField(cls, \"MemoryLayout_\"));\n+            assertNotNull(findField(cls, \"ValueLayout_\"));\n+\n+            assertNotNull(loader.loadClass(\"RuntimeHelper_\"));\n+            assertNotNull(loader.loadClass(\"String_\"));\n+            assertNotNull(loader.loadClass(\"MemoryAddress_\"));\n+            assertNotNull(loader.loadClass(\"MemorySegment_\"));\n+        } finally {\n+            TestUtils.deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262825.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262851\n+ * @summary jextract crashes with \"Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test8262851\n+ *\/\n+public class Test8262851 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262851gen\");\n+        Path outputH = getInputFilePath(\"test8262851.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(output)) {\n+            assertNotNull(loader.loadClass(\"test8262851_h\"));\n+            assertNotNull(loader.loadClass(\"Odd\"));\n+            assertNotNull(loader.loadClass(\"Odd$before\"));\n+            assertNotNull(loader.loadClass(\"Odd$after\"));\n+        } finally {\n+            TestUtils.deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262851.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+\/*\n+ * @test\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=org.openjdk.jextract TestAttributedPointerTypedef\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+public class TestAttributedPointerTypedef extends JextractToolRunner {\n+    @Test\n+    public void testAttributedPointerTypedef() {\n+        run(\"-C-fms-extensions\", \"-d\", getOutputFilePath(\"attributedPointerTypedef\").toString(),\n+                getInputFilePath(\"attributedPointerTypedef.h\").toString()).checkSuccess();\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestAttributedPointerTypedef.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/\/@Ignore \/\/ FIXME needs native lib\n+public class TestClassGeneration extends JextractToolRunner {\n+\n+    private static final VarHandle VH_bytes = MemoryLayout.sequenceLayout(C_CHAR).varHandle(sequenceElement());\n+\n+    private Path outputDir;\n+    private TestUtils.Loader loader;\n+    private Class<?> cls;\n+\n+    @DataProvider\n+    public static Object[][] simpleConstants() {\n+        return new Object[][]{\n+            { \"macro_byte\",         byte.class,   (byte) 1                         },\n+            { \"macro_short\",        short.class, (short) 1                         },\n+            { \"macro_int\",          int.class,           1                         },\n+            { \"macro_long\",         long.class,          1L                        },\n+            { \"macro_float\",        float.class,         1.0F                      },\n+            { \"macro_double\",       double.class,        1.0D                      },\n+            { \"macro_address_NULL\", MemoryAddress.class, MemoryAddress.NULL        },\n+            { \"macro_address_123\",  MemoryAddress.class, MemoryAddress.ofLong(123) },\n+            { \"enum_0\",             int.class,           0                         },\n+            { \"enum_1\",             int.class,           1                         },\n+            { \"enum_2\",             int.class,           2                         },\n+            { \"enum_anon_0\",        int.class,           0                         },\n+            { \"enum_anon_1\",        int.class,           1                         },\n+            { \"enum_anon_2\",        int.class,           2                         },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] stringConstants() {\n+        return new Object[][]{\n+            { \"macro_string\",         \"abc\"      },\n+            { \"macro_string_noident\", \"123.asdf\" },\n+        };\n+    }\n+\n+    private static final Object[] NO_ARGS = {};\n+\n+    @DataProvider\n+    public static Object[][] method() {\n+        return new Object[][]{\n+            { \"func_byte\",   methodType(byte.class),   (byte) 1,  NO_ARGS },\n+            { \"func_short\",  methodType(short.class), (short) 2,  NO_ARGS },\n+            { \"func_int\",    methodType(int.class),           3,  NO_ARGS },\n+            { \"func_long\",   methodType(long.class),          4L, NO_ARGS },\n+            { \"func_float\",  methodType(float.class),         5F, NO_ARGS },\n+            { \"func_double\", methodType(double.class),        6D, NO_ARGS },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] globals() {\n+        return new Object[][]{\n+            { \"global_byte\",   byte.class,   C_CHAR,   (byte) 1  },\n+            { \"global_short\",  short.class,  C_SHORT, (short) 2  },\n+            { \"global_int\",    int.class,    C_INT,           3  },\n+            { \"global_long\",   long.class,   C_LONG_LONG,      4L },\n+            { \"global_float\",  float.class,  C_FLOAT,         5F },\n+            { \"global_double\", double.class, C_DOUBLE,        6D },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structMembers() {\n+        return new Object[][] {\n+            { \"Foo\", C_CHAR.withName(\"c\"),      byte.class,   (byte) 10  },\n+            { \"Foo\", C_SHORT.withName(\"s\"),     short.class, (short) 10  },\n+            { \"Foo\", C_INT.withName(\"i\"),       int.class,           10  },\n+            { \"Foo\", C_LONG_LONG.withName(\"ll\"), long.class,          10L },\n+            { \"Foo\", C_FLOAT.withName(\"f\"),     float.class,         10F },\n+            { \"Foo\", C_DOUBLE.withName(\"d\"),    double.class,        10D },\n+            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] functionalInterfaces() {\n+        return new Object[][]{\n+            { \"CB\", methodType(void.class, int.class) }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"simpleConstants\")\n+    public void testConstant(String name, Class<?> expectedType, Object expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, expectedType);\n+        assertEquals(getter.invoke(null), expectedValue);\n+    }\n+\n+    @Test(dataProvider = \"stringConstants\")\n+    public void testStringConstant(String name, String expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, MemorySegment.class);\n+        MemorySegment actual = (MemorySegment) getter.invoke(null);\n+        byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(actual.byteSize(), expected.length + 1);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"method\")\n+    public void testMethod(String name, MethodType expectedType, Object expectedReturn, Object[] args) throws Throwable {\n+        Method mh_getter = checkMethod(cls, name + \"$MH\", MethodHandle.class);\n+        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);\n+        assertEquals(mh.type(), expectedType);\n+\n+        Object actualReturn = mh.invokeWithArguments(args);\n+        assertEquals(actualReturn.getClass(), expectedReturn.getClass());\n+        assertEquals(actualReturn, expectedReturn);\n+\n+        Method func = checkMethod(cls, name, expectedType);\n+        assertEquals(func.invoke(null, args), expectedReturn);\n+    }\n+\n+    @Test(dataProvider = \"globals\")\n+    public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {\n+        Method layout_getter = checkMethod(cls, name + \"$LAYOUT\", MemoryLayout.class);\n+        assertEquals(layout_getter.invoke(null), expectedLayout);\n+\n+        Method addr_getter = checkMethod(cls, name + \"$SEGMENT\", MemorySegment.class);\n+        MemorySegment segment = (MemorySegment)addr_getter.invoke(null);\n+\n+        Method vh_getter = checkMethod(cls, name + \"$VH\", VarHandle.class);\n+        VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+        assertEquals(vh.varType(), expectedType);\n+        assertEquals(vh.get(segment), expectedValue);\n+\n+        checkMethod(cls, name + \"$get\", expectedType);\n+        checkMethod(cls, name + \"$set\", void.class, expectedType);\n+    }\n+\n+    @Test(dataProvider = \"structMembers\")\n+    public void testStructMember(String structName, MemoryLayout memberLayout, Class<?> expectedType, Object testValue) throws Throwable {\n+        String memberName = memberLayout.name().orElseThrow();\n+\n+        Class<?> structCls = loader.loadClass(\"com.acme.\" + structName);\n+        Method layout_getter = checkMethod(structCls, \"$LAYOUT\", MemoryLayout.class);\n+        MemoryLayout structLayout = (MemoryLayout) layout_getter.invoke(null);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(structLayout, scope);\n+            Method vh_getter = checkMethod(structCls, memberName + \"$VH\", VarHandle.class);\n+            VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+            assertEquals(vh.varType(), expectedType);\n+\n+            Method getter = checkMethod(structCls, memberName + \"$get\", expectedType, MemorySegment.class);\n+            Method setter = checkMethod(structCls, memberName + \"$set\", void.class, MemorySegment.class, expectedType);\n+            MemorySegment addr = struct;\n+            setter.invoke(null, addr, testValue);\n+            assertEquals(getter.invoke(null, addr), testValue);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"functionalInterfaces\")\n+    public void testFunctionalInterface(String name, MethodType type) {\n+        Class<?> fiClass = loader.loadClass(\"com.acme.\" + name);\n+        assertNotNull(fiClass);\n+        checkMethod(fiClass, \"apply\", type);\n+        checkMethod(fiClass, \"allocate\", NativeSymbol.class, fiClass, ResourceScope.class);\n+    }\n+\n+    @BeforeClass\n+    public void setup() {\n+        outputDir = getOutputFilePath(\"exmples_out\");\n+        Path inputHeader = getInputFilePath(\"examples.h\");\n+        run(\n+            \"-t\", \"com.acme\",\n+            \"-d\", outputDir,\n+            \"-l\", \"Examples\",\n+            \"--\",\n+            inputHeader\n+        ).checkSuccess();\n+        loader = TestUtils.classLoader(outputDir);\n+        cls = loader.loadClass(\"com.acme.examples_h\");\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        loader.close();\n+        TestUtils.deleteDir(outputDir);\n+    }\n+\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED -Duser.language=en TestFilters\n+ *\/\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.fail;\n+\n+public class TestFilters extends JextractToolRunner {\n+    @Test\n+    public void testFilter() {\n+        for (FilterKind expectedKind : FilterKind.values()) {\n+            Path filterOutput = getOutputFilePath(\"filters_\" + expectedKind);\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"-d\", filterOutput.toString(), expectedKind.filterOption, expectedKind.symbolName, filterH.toString()).checkSuccess();\n+            try (TestUtils.Loader loader = TestUtils.classLoader(filterOutput)) {\n+                Class<?> cls = loader.loadClass(\"filters_h\");\n+                for (FilterKind kind : FilterKind.values()) {\n+                    Object res = kind.get(cls);\n+                    if (kind == expectedKind) {\n+                        assertNotNull(res);\n+                    } else {\n+                        assertNull(res);\n+                    }\n+                }\n+            } finally {\n+                TestUtils.deleteDir(filterOutput);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDumpIncludes() throws IOException {\n+        Path filterOutput = getOutputFilePath(\"filters_dump\");\n+        try {\n+            Files.createDirectory(filterOutput);\n+            Path includes = filterOutput.resolve(\"test.conf\");\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"--dump-includes\", includes.toString(), filterH.toString()).checkSuccess();\n+            List<String> includeLines = Files.readAllLines(includes);\n+            outer: for (FilterKind kind : FilterKind.values()) {\n+                String filterLine = kind.filterOption + \" \" + kind.symbolName;\n+                Iterator<String> linesIt = includeLines.iterator();\n+                while (linesIt.hasNext()) {\n+                    String line = linesIt.next();\n+                    if (line.startsWith(filterLine)) {\n+                        linesIt.remove();\n+                        continue outer;\n+                    }\n+                }\n+                fail(\"Filter line not found: \" + filterLine);\n+            }\n+        } finally {\n+            TestUtils.deleteDir(filterOutput);\n+        }\n+    }\n+\n+    enum FilterKind {\n+        VAR(\"_global\", \"--include-var\"),\n+        FUNCTION(\"_function\", \"--include-function\"),\n+        CONSTANT(\"_constant\", \"--include-macro\"),\n+        TYPEDEF(\"_typedef\", \"--include-typedef\"),\n+        STRUCT(\"_struct\", \"--include-struct\"),\n+        UNION(\"_union\", \"--include-union\");\n+\n+        final String symbolName;\n+        final String filterOption;\n+\n+        FilterKind(String symbolName, String filterOption) {\n+            this.symbolName = symbolName;\n+            this.filterOption = filterOption;\n+        }\n+\n+        Object get(Class<?> headerClass) {\n+            return switch (this) {\n+                case FUNCTION, CONSTANT -> findMethod(headerClass, symbolName);\n+                case VAR -> findMethod(headerClass, symbolName + \"$get\");\n+                case TYPEDEF -> findField(headerClass, symbolName);\n+                case STRUCT, UNION -> {\n+                    try {\n+                        yield headerClass.getClassLoader().loadClass(symbolName);\n+                    } catch (ReflectiveOperationException ex) {\n+                        yield null;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestFilters.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.function.BiConsumer;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244512 8252759\n+ * @summary test nested structs and unions\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNested\n+ *\/\n+public class TestNested extends JextractToolRunner {\n+    @Test\n+    public void testNestedStructs() {\n+        Path nestedOutput = getOutputFilePath(\"nestedgen\");\n+        Path nestedH = getInputFilePath(\"nested.h\");\n+        run(\"-d\", nestedOutput.toString(), nestedH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(nestedOutput)) {\n+            checkClass(loader, \"Foo\",\n+                checkField(\"bar\", MemorySegment.class, 0),\n+                checkField(\"color\", int.class, 8)\n+            );\n+            checkClass(loader, \"Foo$Bar\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4)\n+            );\n+            checkClass(loader, \"U\",\n+                checkField(\"point\", MemorySegment.class, 0),\n+                checkField(\"rgb\", int.class, 0),\n+                checkField(\"i\", int.class, 0)\n+            );\n+            checkClass(loader, \"U$Point\",\n+                checkField(\"x\", short.class, 0),\n+                checkField(\"y\", short.class, 2)\n+            );\n+            checkClass(loader, \"MyStruct\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 4, \"$anon$0\"),\n+                checkField(\"c\", int.class, 8, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 12, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 13, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 16, \"$anon$1\"),\n+                checkField(\"h\", long.class, 16, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 24)\n+            );\n+            checkClass(loader, \"MyStruct$MyStruct_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyStruct$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", int.class, 4)\n+            );\n+            checkClass(loader, \"MyUnion\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 0, \"$anon$0\"),\n+                checkField(\"c\", int.class, 4, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 8, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 9, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 0, \"$anon$1\"),\n+                checkField(\"h\", int.class, 4, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$MyUnion_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", long.class, 0)\n+            );\n+            checkClass(loader, \"X\",\n+                checkField(\"Z\", MemorySegment.class, 0, \"$anon$0\")\n+            );\n+            checkClass(loader, \"X$Z\",\n+                checkField(\"y\", int.class, 0)\n+            );\n+            checkClass(loader, \"X2\",\n+                checkField(\"y\", int.class, 0, \"$anon$0\", \"$anon$0\")\n+            );\n+            checkClass(loader, \"NestedUnion\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4, \"$anon$0\"),\n+                checkField(\"z\", int.class, 4, \"$anon$0\")\n+            );\n+        } finally {\n+            TestUtils.deleteDir(nestedOutput);\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static void checkClass(TestUtils.Loader loader, String name, BiConsumer<Class<?>, MemoryLayout>... checks) {\n+        Class<?> cls = loader.loadClass(name);\n+        assertNotNull(cls);\n+        MemoryLayout layout = findLayout(cls);\n+        for (var check : checks) {\n+            check.accept(cls, layout);\n+        }\n+    }\n+\n+    private static BiConsumer<Class<?>, MemoryLayout> checkField(String fieldName, Class<?> fieldType,\n+                                                                 long expectedOffset, String... fieldPath) {\n+        MemoryLayout.PathElement[] path = new MemoryLayout.PathElement[fieldPath.length + 1];\n+        int i = 0;\n+        for (; i < fieldPath.length; i++) {\n+            path[i] = groupElement(fieldPath[i]);\n+        }\n+        path[i] = groupElement(fieldName);\n+        return (cls, layout) -> {\n+            assertEquals(layout.byteOffset(path), expectedOffset);\n+            checkAccessors(cls, layout, fieldName, fieldType, layout.select(path));\n+        };\n+    }\n+\n+    private static void checkAccessors(Class<?> cls, MemoryLayout layout, String fieldName, Class<?> type,\n+                                       MemoryLayout fieldLayout) {\n+        try {\n+            if (type == MemorySegment.class) {\n+                Method slicer = cls.getMethod(fieldName + \"$slice\", MemorySegment.class);\n+                assertEquals(slicer.getReturnType(), MemorySegment.class);\n+                try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                    MemorySegment struct = MemorySegment.allocateNative(layout, scope);\n+                    MemorySegment slice = (MemorySegment) slicer.invoke(null, struct);\n+                    assertEquals(slice.byteSize(), fieldLayout.byteSize());\n+                }\n+            } else {\n+                Method getter = cls.getMethod(fieldName + \"$get\", MemorySegment.class);\n+                assertEquals(getter.getReturnType(), type);\n+                Method setter = cls.getMethod(fieldName + \"$set\", MemorySegment.class, type);\n+                assertEquals(setter.getReturnType(), void.class);\n+\n+                Object zero = MethodHandles.zero(type).invoke();\n+                try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                    MemorySegment struct = MemorySegment.allocateNative(layout, scope);\n+                    setter.invoke(null, struct, zero);\n+                    Object actual = getter.invoke(null, struct);\n+                    assertEquals(actual, zero);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            fail(\"Unexpected exception\", t);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestNested.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import java.nio.file.Path;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Ignore\n+public class TestSplit extends JextractToolRunner {\n+    @Test\n+    public void testSplit() {\n+        Path splitOutput = getOutputFilePath(\"split\");\n+        Path splitH = getInputFilePath(\"split.h\");\n+        \/\/System.setProperty(\"-Djextract.decls.per.header\", \"1\");\n+        run(\"-d\", splitOutput.toString(), splitH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(splitOutput)) {\n+            checkPresent(loader, \"split_h\");\n+            checkPresent(loader, \"split_h_1\");\n+            checkPresent(loader, \"split_h_2\");\n+            checkPresent(loader, \"split_h_3\");\n+            checkPresent(loader, \"split_h_4\");\n+            checkMissing(loader, \"split_h_5\");\n+        } finally {\n+            TestUtils.deleteDir(splitOutput);\n+        }\n+    }\n+\n+    private static void checkPresent(TestUtils.Loader loader, String name) {\n+        assertNotNull(loader.loadClass(name));\n+    }\n+\n+    private static void checkMissing(TestUtils.Loader loader, String name) {\n+        assertNull(loader.loadClass(name));\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestSplit.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+\n+public class TestTypedefIsFunctionProto extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"outputTDIFP\");\n+        Path headerFile = getInputFilePath(\"funcproto.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        \/\/ nothing is generated that we can check, so we just check that jextract ran successfully\n+        TestUtils.deleteDir(outputPath);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/TestTypedefIsFunctionProto.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jextract.test.toolprovider;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.openjdk.jextract.test.TestUtils;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED UniondeclTest\n+ *\/\n+public class UniondeclTest extends JextractToolRunner {\n+    @Test\n+    public void unionDecl() {\n+        Path uniondeclOutput = getOutputFilePath(\"uniondecl.h\");\n+        Path uniondeclH = getInputFilePath(\"uniondecl.h\");\n+        run(\"-d\", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();\n+        try(TestUtils.Loader loader = TestUtils.classLoader(uniondeclOutput)) {\n+            Class<?> cls = loader.loadClass(\"uniondecl_h\");\n+            \/\/ check a method for \"void func(IntOrFloat*)\"\n+            assertNotNull(findMethod(cls, \"func\", Addressable.class));\n+            \/\/ check IntOrFloat layout\n+            Class<?> intOrFloatCls = loader.loadClass(\"IntOrFloat\");\n+            GroupLayout intOrFloatLayout = (GroupLayout)findLayout(intOrFloatCls);\n+            assertNotNull(intOrFloatLayout);\n+            assertTrue(intOrFloatLayout.isUnion());\n+            checkField(intOrFloatLayout, \"i\",  C_INT);\n+            checkField(intOrFloatLayout, \"f\", C_FLOAT);\n+        } finally {\n+            TestUtils.deleteDir(uniondeclOutput);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/UniondeclTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+enum SIZE {\n+   XS,\n+   S,\n+   M,\n+   L,\n+   XL,\n+   XXL\n+};\n+\n+typedef enum temp {\n+   ONE = 1,\n+   TWO\n+} temp_t;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/anonenum.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define POINTER_64 __ptr64\n+typedef void * POINTER_64 PVOID_64;\n+\n+#define CONST const\n+typedef void * CONST PVOID_CONST;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/attributedPointerTypedef.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma pack(1)\n+struct Foo {\n+    long long a: 45;\n+    long long b: 24;\n+    long long c: 1;\n+    long long d: 58;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/badBitfields.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"constants_aux.h\"\n+\n+#define ZERO 0\n+#define ONE ZERO + 1 \/\/backward ref\n+#define THREE ONE + TWO \/* forward ref *\/\n+#define TWO ONE + ONE\n+\n+#define FOUR (long long)0x1L + THREE \/\/hack: force long carrier\n+#define FIVE (long long)0x1UL + FOUR \/\/hack: force long carrier\n+\n+#define SIX ONE +\\\n+              TWO +\\\n+              THREE\n+\n+#define STR \"Hello\" \/\/ a string\n+\n+#define ID(x) x \/\/function-like\n+#define SUM(x,y) x + y \/\/function-like\n+\n+#define BLOCK_BEGIN { \/\/not a constant\n+#define BLOCK_END } \/\/not a constant\n+\n+#define INTEGER_MAX_VALUE Integer.MAX_VALUE \/\/constant in Java, not in C\n+#define QUOTE \"QUOTE\" \/\/should be ok\n+\n+#define FLOAT_VALUE 1.32F;\n+#define DOUBLE_VALUE 1.32;\n+\n+#define CYCLIC_1 1 + CYCLIC_1 \/\/cycle\n+\n+#define CYCLIC_2 1 + TEMP \/\/indirect cycle\n+#define TEMP 1 + CYCLIC_2\n+\n+#define CHAR_VALUE 'h'\n+#define MULTICHAR_VALUE 'hh'\n+\n+#define BOOL_VALUE (_Bool)1\n+\/\/we should have tests for char and shorts, but these are likely to be platform dependent\n+\n+#define SUB SUP + 2 \/\/dependency\n+\n+#define ZERO_PTR (void*)0;\n+#define F_PTR (void*) 0xFFFFFFFFFFFFFFFFLL; \/\/ all 1s\n+\n+#define ARRAY { 0, 1, 2, 3, 4, 5 }\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/constants.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define SUP 5 \/\/this is used by the main test header file\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/constants_aux.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+dummy file for this directory\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/directory.h\/DUMMY.TXT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define macro_byte (char) 1\n+#define macro_short (short) 1\n+#define macro_int 1\n+#define macro_long 1LL\n+#define macro_float 1.0F\n+#define macro_double 1.0\n+#define macro_address_NULL (void*) 0\n+#define macro_address_123 (void*) 123\n+#define macro_string \"abc\"\n+#define macro_string_noident \"123.asdf\"\n+\n+EXPORT char func_byte(void);\n+EXPORT short func_short(void);\n+EXPORT int func_int(void);\n+EXPORT long long func_long(void);\n+EXPORT float func_float(void);\n+EXPORT double func_double(void);\n+\n+EXPORT extern char global_byte;\n+EXPORT extern short global_short;\n+EXPORT extern int global_int;\n+EXPORT extern long long global_long;\n+EXPORT extern float global_float;\n+EXPORT extern double global_double;\n+\n+typedef void(*CB)(int);\n+EXPORT void func_cb(CB cb);\n+\n+struct Foo {\n+    char c;\n+    short s;\n+    int i;\n+    long long ll;\n+    float f;\n+    double d;\n+};\n+\n+typedef struct {\n+    int a;\n+    int b;\n+} Bar;\n+\n+enum Enum {\n+    enum_0,\n+    enum_1,\n+    enum_2,\n+};\n+\n+enum {\n+    enum_anon_0,\n+    enum_anon_1,\n+    enum_anon_2,\n+};\n\\ No newline at end of file\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/examples.h","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void foo(int boolean);\n+\n+int finally;\n+\n+struct abstract {\n+    short is;\n+    short throws;\n+} abstract;\n+\n+typedef char Byte;\n+void func(Byte byte, Byte* out);\n+\n+#define byte 1\n+#define content byte + 1\n+\n+typedef struct {\n+    short s1;\n+    short s2;\n+} Long;\n+\n+long twoShorts(Long s, Long* out, long* rv);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/exports.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int _global;\n+\n+EXPORT int _function(void);\n+\n+#define _constant 10\n+\n+typedef int _typedef;\n+\n+struct _struct { int x; };\n+\n+union _union { int y; };\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/filters.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define NANF (0.0f\/0.0f)\n+#define PINFINITYF (1.0f\/0.0f)\n+#define NINFINITYF (-1.0f\/0.0f)\n+\n+#define NAN (0.0\/0.0)\n+#define PINFINITY (1.0\/0.0)\n+#define NINFINITY (-1.0\/0.0)\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/float_constants.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void __stdcall foo();\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/funcproto.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* make sure compiler built-in headers can be included *\/\n+#include <stddef.h>\n+\n+void func(int);\n+int printf(char* fmt, ...);\n+void f();\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/hello.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+short long x;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/illegal_decls.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int size;\n+    void* data[]; \/\/ incomplete array\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/incompleteArray.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"examples.h\"\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT char func_byte(void) { return 1; }\n+EXPORT short func_short(void) { return 2; }\n+EXPORT int func_int(void) { return 3; }\n+EXPORT long long func_long(void) { return 4; }\n+EXPORT float func_float(void) { return 5; }\n+EXPORT double func_double(void) { return 6; }\n+\n+EXPORT char global_byte = 1;\n+EXPORT short global_short = 2;\n+EXPORT int global_int = 3;\n+EXPORT long long global_long = 4;\n+EXPORT float global_float = 5;\n+EXPORT double global_double = 6;\n+\n+EXPORT void func_cb(CB cb) {\n+    cb(1);\n+}\n\\ No newline at end of file\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/libExamples.c","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+  int x;\n+  int y;\n+  int z;\n+};\n+\n+\/\/ variable name clashing with struct name declared earlier\n+long foo;\n+\n+union foo2 {\n+   int i;\n+   long l;\n+};\n+\n+\/\/ variable name clashing with union name declared earlier\n+char foo2;\n+\n+int bar;\n+\n+\/\/ struct name clashing with variable name declared earlier\n+struct bar {\n+   float f1;\n+   float f2;\n+};\n+\n+int bar2;\n+\n+\/\/ union name clashing with variable name declared earlier\n+union bar2 {\n+   float f;\n+   double d;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/name_collision.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct Bar {\n+        int x, y;\n+    } bar;\n+\n+    enum Color {\n+        red, green, blue\n+    } color;\n+};\n+\n+union U {\n+    struct Point {\n+        short x, y;\n+    } point;\n+\n+    enum RGB {\n+        r, g, b\n+    } rgb;\n+\n+    int i;\n+};\n+\n+struct MyStruct {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyStruct_Z {\n+            char e;\n+        } f;\n+    };\n+    union {\n+        int g;\n+        long long h;\n+    };\n+    enum {\n+        X, Y, Z\n+    };\n+    struct {\n+        int i;\n+        int j;\n+    } k;\n+};\n+\n+union MyUnion {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyUnion_Z {\n+            char e;\n+        } f;\n+    };\n+    struct {\n+        int g;\n+        int h;\n+    };\n+    enum {\n+        A, B, C\n+    };\n+    union {\n+        int i;\n+        long long j;\n+    } k;\n+};\n+\n+struct X {\n+    struct {\n+        union {\n+            int y;\n+        } Z;\n+    };\n+};\n+\n+struct X2 {\n+    struct {\n+        union {\n+            int y;\n+        }; \/\/ no name this time\n+    };\n+};\n+\n+struct NestedUnion {\n+    int x;\n+    union {\n+        int y;\n+        int z;\n+    };\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/nested.h","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"non_existent.h\"\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/non_existent_includer.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Point;\n+struct Point;\n+\n+int i;\n+int i;\n+\n+void func(int);\n+void func(int abc);\n+void func(int xyz);\n+void func2(int);\n+void func2(int abc);\n+void func2(int xyz);\n+\n+typedef int INT;\n+void func(INT);\n+void func(INT abc);\n+void func(INT xyz);\n+void func2(INT);\n+void func2(INT abc);\n+void func2(INT xyz);\n+\n+typedef int* INTPTR;\n+void func3(INTPTR x);\n+void func3(int* x);\n+void func4(INTPTR x);\n+void func4(int* x);\n+\n+typedef int Integer;\n+void func(Integer x);\n+void func5(int x);\n+void func5(Integer x);\n+void func5(INT x);\n+\n+struct Point;\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\n+typedef struct Point POINT;\n+typedef struct Point Point_t;\n+\n+double distance(struct Point p);\n+double distance(POINT p);\n+\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D_t;\n+struct Point3D;\n+\n+enum RGBColor;\n+enum RGBColor {\n+   R, G, B\n+};\n+\n+enum CMYColor {\n+  C, M, Y\n+};\n+enum CMYColor;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/repeatedDecls.h","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int a();\n+EXPORT int b();\n+EXPORT int c();\n+EXPORT int d();\n+EXPORT int e();\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/split.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct _Bar Foo;\n+\n+typedef struct Point Point_t;\n+\n+struct Point {\n+    int x, y;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8245767.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Node {\n+  struct Node *next;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8248415.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)(MyVoid));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8249290.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)());\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8249300.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+extern char* tzname[];\n+\n+struct Foo {\n+   int bar;\n+   char* names[];\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8251943.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+  struct {\n+   long double dl;\n+  } x;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8258223.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+  int (*bar)(float, double);\n+};\n+\n+void (*func)(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8258405.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void di_log_handler (const char *message, void *user_data);\n+di_log_handler di_log_handler_default;\n+\n+struct json_object;\n+typedef void (json_object_delete_fn)(struct json_object *jso, void *userdata);\n+json_object_delete_fn json_object_free_userdata;\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8260344.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int: 0;\n+    char c;\n+};\n+\n+struct Foo2 {\n+    int z;\n+    int: 16;\n+    int y:16;\n+    int w;\n+};\n+\n+struct Foo3 {\n+    int: 0;\n+    int: 32;\n+};\n+\n+struct Foo4 {\n+  int    a:3;\n+  int    b:2;\n+  int     :0; \/\/ Force alignment to next boundary.\n+  int    c:4;\n+  int    d:3;\n+};\n+\n+struct Foo5 {\n+  int    a:3;\n+  int    b:2;\n+  int    c:4;\n+  int    d:3;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8260705.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  short s;\n+  int i1:1;\n+  int i2:1;\n+  void* ptr;\n+} foo_t;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8260717.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct {\n+     unsigned : 6;\n+     unsigned r1 : 8;\n+     unsigned r2 : 1;\n+     unsigned r3 : 1;\n+} rab;\n+\n+struct {\n+   int y;\n+   short x;\n+   int r1 : 23;\n+   int r2 : 5;\n+} rab2;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8260929.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct ndpi_flow_tcp_struct {\n+  char gnutella_msg_id[3];\n+  int irc_3a_counter:3;\n+  int irc_stage2:5;\n+  int irc_direction:2;\n+  int irc_0x1000_full:1;\n+  int soulseek_stage:2;\n+  int filetopia_stage:2;\n+  int tds_stage:3;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8261578_1.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+   int clear_color[2];\n+   int clear_z;\n+   char clear_s;\n+   int pad:24;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8261578_2.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct PluginCodec_H323AudioG7231AnnexC {\n+  unsigned char maxAl_sduAudioFrames;\n+  int silenceSuppression:1;\n+  int highRateMode0:6; \/\/ INTEGER (27..78), -- units octets\n+  int highRateMode1:6; \/\/ INTEGER (27..78), -- units octets\n+  int lowRateMode0:6; \/\/ INTEGER (23..66), -- units octets\n+  int lowRateMode1:6; \/\/ INTEGER (23..66), -- units octets\n+  int sidMode0:4; \/\/ INTEGER (6..17), -- units octets\n+  int sidMode1:4; \/\/ INTEGER (6..17), -- units octets\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8261578_3.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  int x, y;\n+} permits;\n+\n+struct record {\n+  int foo;\n+};\n+\n+union sealed {\n+  float i;\n+  int j;\n+};\n+\n+struct var {\n+  int x;\n+};\n+\n+typedef struct {\n+  int bar;\n+} yield;\n+\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8261893.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+union {\n+   struct {\n+      union {\n+         struct { int x; } inner;\n+      } u;\n+   } outer;\n+} u;\n+\n+\n+union {\n+    union {\n+       int x; long y;\n+    } v;\n+} v;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8262117.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+struct {\n+   int x, y;\n+} x;\n+\n+struct Foo {\n+   union {\n+       int i;\n+       float f;\n+   } x;\n+};\n+\n+struct seg {\n+  int x;\n+};\n+\n+struct index {\n+  int x;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8262733.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct String {\n+   int x, y;\n+};\n+\n+struct RuntimeHelper {\n+   int x;\n+};\n+\n+union MemorySegment {\n+   int x; float f;\n+};\n+\n+union MemoryAddress {\n+   long l; double d;\n+};\n+\n+typedef long MemoryLayout;\n+typedef double ValueLayout;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8262825.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Odd {\n+   struct {\n+    int size;\n+    char data[];\n+   } before;\n+   struct {\n+     int a; int b;\n+   } after;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/test8262851.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef char byte_t;\n+typedef long mysize_t;\n+typedef long MYSIZE_T;\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/typedefs.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+void func(IntOrFloat* value);\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/uniondecl.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class Point {\n+   public:\n+       int x, y;\n+};\n","filename":"test\/java\/org\/openjdk\/jextract\/test\/toolprovider\/unsupported_lang.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n+\n+import org.openjdk.jextract.JextractTool;\n+\n+import java.util.Date;\n+\n+\n+public class JtregJextract {\n+\n+    private static final ToolProvider JEXTRACT_TOOL = new JextractTool.JextractToolProvider();\n+\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    JtregJextract() {\n+        this(null, null);\n+    }\n+\n+    JtregJextract(Path input, Path output) {\n+        inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.src\", \".\"));\n+        outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+    }\n+\n+    protected String[] processArgs(String... args) {\n+        Pattern sysPropPattern = Pattern.compile(\"'?\\\\$\\\\((.*)\\\\)'?\");\n+        ArrayList<String> jextrOpts = new ArrayList<>();\n+\n+        jextrOpts.clear();\n+        jextrOpts.add(\"-C-nostdinc\");\n+        jextrOpts.add(\"-I\");\n+        jextrOpts.add(inputDir.toAbsolutePath().toString());\n+        jextrOpts.add(\"-d\");\n+        jextrOpts.add(outputDir.toAbsolutePath().toString());\n+\n+        int i = 0;\n+        while (i < args.length - 1) {\n+            String opt = args[i++];\n+            if (\"--\".equals(opt)) {\n+                break;\n+            }\n+\n+            if (\"-libpath\".equals(opt)) {\n+                String lib = args[i];\n+                jextrOpts.add(\"-l\");\n+                String libpath = System.getProperty(\"java.library.path\") + File.separator + System.mapLibraryName(lib);\n+                System.err.println(\"jextract driver libpath passed: \" + libpath);\n+                jextrOpts.add(libpath);\n+                i++;\n+                continue;\n+            }\n+\n+            if (\"-d\".equals(opt)) {\n+                i++;\n+                continue;\n+            }\n+            \/\/ Pattern $(system.property.name) is replaced with the\n+            \/\/ value of the System property of that name.\n+            Matcher m = sysPropPattern.matcher(opt);\n+            if (m.matches()) {\n+                jextrOpts.add(System.getProperty(m.group(1)));\n+            } else {\n+                jextrOpts.add(opt);\n+            }\n+        }\n+\n+        while (i < args.length) {\n+            jextrOpts.add(getInputFilePath(args[i++]).toString());\n+        }\n+\n+        return jextrOpts.toArray(String[]::new);\n+    }\n+\n+    protected int jextract(String... options) {\n+        try {\n+            StringWriter writer = new StringWriter();\n+            PrintWriter pw = new PrintWriter(writer);\n+            int result = JEXTRACT_TOOL.run(pw, pw, processArgs(options));\n+            if (result != 0) {\n+                System.err.println(writer.toString());\n+                throw new RuntimeException(\"jextract returns non-zero value\");\n+            }\n+            return result;\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+\n+    private Path getInputFilePath(String filename) {\n+        return inputDir.resolve(filename).toAbsolutePath();\n+    }\n+\n+    public static int main(String[] args) {\n+        JtregJextract jj =  new JtregJextract();\n+        return jj.jextract(args);\n+    }\n+}\n","filename":"test\/lib\/JtregJextract.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.jextract.JextractTool;\n+\n+public class JtregJextractSources {\n+\n+    private static final ToolProvider JEXTRACT_TOOL = new JextractTool.JextractToolProvider();\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"javac tool not found\")\n+            );\n+\n+    private static Path getJextractSourcePath() {\n+        Path testSrc = Path.of(System.getProperty(\"test.file\"));\n+        return Path.of(testSrc.toFile().getName() + \"_sources\");\n+    }\n+\n+    public static int main(String[] args) throws IOException {\n+        System.err.println(\"jextract --source mode\");\n+        Path sourcePath = getJextractSourcePath();\n+        JtregJextract jj =  new JtregJextract(null, sourcePath);\n+        String[] newArgs = new String[args.length + 1];\n+        newArgs[0] = \"--source\";\n+        System.arraycopy(args, 0, newArgs, 1, args.length);\n+        jj.jextract(newArgs);\n+\n+        Path outputDir = Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+        List<String> files = Files.find(sourcePath.toAbsolutePath(), 999, (path, ignored) -> path.toString().endsWith(\".java\"))\n+                .map(p -> p.toAbsolutePath().toString())\n+                .collect(Collectors.toList());\n+\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+\n+        try {\n+            System.err.println(\"compiling jextracted sources @ \" + sourcePath.toAbsolutePath());\n+            List<String> commands = new ArrayList<>();\n+            commands.add(\"-parameters\");\n+            commands.add(\"--add-modules\");\n+            commands.add(\"jdk.incubator.foreign\");\n+            commands.add(\"-d\");\n+            commands.add(outputDir.toAbsolutePath().toString());\n+            commands.addAll(files);\n+            int result = JAVAC_TOOL.run(pw, pw, commands.toArray(new String[0]));\n+            if (result != 0) {\n+                System.err.println(writer.toString());\n+                throw new RuntimeException(\"javac returns non-zero value\");\n+            }\n+            return result;\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n+    }\n+}\n","filename":"test\/lib\/JtregJextractSources.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+cmake_minimum_required(VERSION 3.14)\n+project(TestSupportLibs)\n+\n+option(TEST_SOURCE_ROOT \"src directory with test files\")\n+\n+file(GLOB_RECURSE TEST_LIBS ${TEST_SOURCE_ROOT}\/..\/*lib*.c)\n+\n+foreach(TEST_LIB ${TEST_LIBS})\n+    message(STATUS \"Processing test lib: ${TEST_LIB}\")\n+\n+    string(REGEX REPLACE \".*lib([A-Za-z0-9_]+)\\.c(pp)?\" \"\\\\1\" LIB_NAME ${TEST_LIB})\n+    string(REGEX REPLACE \"(.*)\/lib[A-Za-z0-9_]+\\.c(pp)?\" \"\\\\1\" PARENT_DIR ${TEST_LIB})\n+    message(STATUS \"Lib name: ${LIB_NAME}\")\n+\n+    add_library(${LIB_NAME} SHARED ${TEST_LIB})\n+    target_include_directories(${LIB_NAME}\n+      PRIVATE\n+        ${PARENT_DIR}\n+    )\n+\n+    install(\n+     TARGETS\n+       ${LIB_NAME}\n+    )\n+endforeach()\n+\n+\n","filename":"test\/test-support\/CMakeLists.txt","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+This directory contains files, script needed to update libclang binding in jextract code.\n+\n+Steps to update libclang binding\n+\n+* make sure jextract project is built\n+* cd updateclang (this directory)\n+* set PATH to point to directory where generated jextract tool lives\n+* run sh .\/extract.sh\n+\n+Manually update the following file:\n+\n+File: RuntimeHelper.java\n+\n+\n+    \/\/ Manual change to handle platform specific library name difference\n+    static {\n+        \/\/ Manual change to handle platform specific library name difference\n+        String libName = System.getProperty(\"os.name\").startsWith(\"Windows\")? \"libclang\" : \"clang\";\n+        System.loadLibrary(libName);\n+    }\n","filename":"updateclang\/README.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,1556 @@\n+###\n+\n+--include-macro __API_TO_BE_DEPRECATED\n+\n+###\n+\n+--include-macro __ENABLE_LEGACY_MAC_AVAILABILITY\n+--include-macro __MAC_OS_X_VERSION_MAX_ALLOWED\n+--include-macro __MAC_OS_X_VERSION_MIN_REQUIRED\n+\n+###\n+\n+--include-macro MAC_OS_VERSION_11_0\n+--include-macro MAC_OS_X_VERSION_10_0\n+--include-macro MAC_OS_X_VERSION_10_1\n+--include-macro MAC_OS_X_VERSION_10_10\n+--include-macro MAC_OS_X_VERSION_10_10_2\n+--include-macro MAC_OS_X_VERSION_10_10_3\n+--include-macro MAC_OS_X_VERSION_10_11\n+--include-macro MAC_OS_X_VERSION_10_11_2\n+--include-macro MAC_OS_X_VERSION_10_11_3\n+--include-macro MAC_OS_X_VERSION_10_11_4\n+--include-macro MAC_OS_X_VERSION_10_12\n+--include-macro MAC_OS_X_VERSION_10_12_1\n+--include-macro MAC_OS_X_VERSION_10_12_2\n+--include-macro MAC_OS_X_VERSION_10_12_4\n+--include-macro MAC_OS_X_VERSION_10_13\n+--include-macro MAC_OS_X_VERSION_10_13_1\n+--include-macro MAC_OS_X_VERSION_10_13_2\n+--include-macro MAC_OS_X_VERSION_10_13_4\n+--include-macro MAC_OS_X_VERSION_10_14\n+--include-macro MAC_OS_X_VERSION_10_14_1\n+--include-macro MAC_OS_X_VERSION_10_14_4\n+--include-macro MAC_OS_X_VERSION_10_14_6\n+--include-macro MAC_OS_X_VERSION_10_15\n+--include-macro MAC_OS_X_VERSION_10_15_1\n+--include-macro MAC_OS_X_VERSION_10_16\n+--include-macro MAC_OS_X_VERSION_10_2\n+--include-macro MAC_OS_X_VERSION_10_3\n+--include-macro MAC_OS_X_VERSION_10_4\n+--include-macro MAC_OS_X_VERSION_10_5\n+--include-macro MAC_OS_X_VERSION_10_6\n+--include-macro MAC_OS_X_VERSION_10_7\n+--include-macro MAC_OS_X_VERSION_10_8\n+--include-macro MAC_OS_X_VERSION_10_9\n+--include-macro __DRIVERKIT_19_0\n+--include-macro __DRIVERKIT_20_0\n+--include-macro __IPHONE_10_0\n+--include-macro __IPHONE_10_1\n+--include-macro __IPHONE_10_2\n+--include-macro __IPHONE_10_3\n+--include-macro __IPHONE_11_0\n+--include-macro __IPHONE_11_1\n+--include-macro __IPHONE_11_2\n+--include-macro __IPHONE_11_3\n+--include-macro __IPHONE_11_4\n+--include-macro __IPHONE_12_0\n+--include-macro __IPHONE_12_1\n+--include-macro __IPHONE_12_2\n+--include-macro __IPHONE_12_3\n+--include-macro __IPHONE_12_4\n+--include-macro __IPHONE_13_0\n+--include-macro __IPHONE_13_1\n+--include-macro __IPHONE_13_2\n+--include-macro __IPHONE_13_3\n+--include-macro __IPHONE_13_4\n+--include-macro __IPHONE_13_5\n+--include-macro __IPHONE_13_6\n+--include-macro __IPHONE_13_7\n+--include-macro __IPHONE_14_0\n+--include-macro __IPHONE_14_1\n+--include-macro __IPHONE_14_2\n+--include-macro __IPHONE_14_3\n+--include-macro __IPHONE_2_0\n+--include-macro __IPHONE_2_1\n+--include-macro __IPHONE_2_2\n+--include-macro __IPHONE_3_0\n+--include-macro __IPHONE_3_1\n+--include-macro __IPHONE_3_2\n+--include-macro __IPHONE_4_0\n+--include-macro __IPHONE_4_1\n+--include-macro __IPHONE_4_2\n+--include-macro __IPHONE_4_3\n+--include-macro __IPHONE_5_0\n+--include-macro __IPHONE_5_1\n+--include-macro __IPHONE_6_0\n+--include-macro __IPHONE_6_1\n+--include-macro __IPHONE_7_0\n+--include-macro __IPHONE_7_1\n+--include-macro __IPHONE_8_0\n+--include-macro __IPHONE_8_1\n+--include-macro __IPHONE_8_2\n+--include-macro __IPHONE_8_3\n+--include-macro __IPHONE_8_4\n+--include-macro __IPHONE_9_0\n+--include-macro __IPHONE_9_1\n+--include-macro __IPHONE_9_2\n+--include-macro __IPHONE_9_3\n+--include-macro __MAC_10_0\n+--include-macro __MAC_10_1\n+--include-macro __MAC_10_10\n+--include-macro __MAC_10_10_2\n+--include-macro __MAC_10_10_3\n+--include-macro __MAC_10_11\n+--include-macro __MAC_10_11_2\n+--include-macro __MAC_10_11_3\n+--include-macro __MAC_10_11_4\n+--include-macro __MAC_10_12\n+--include-macro __MAC_10_12_1\n+--include-macro __MAC_10_12_2\n+--include-macro __MAC_10_12_4\n+--include-macro __MAC_10_13\n+--include-macro __MAC_10_13_1\n+--include-macro __MAC_10_13_2\n+--include-macro __MAC_10_13_4\n+--include-macro __MAC_10_14\n+--include-macro __MAC_10_14_1\n+--include-macro __MAC_10_14_4\n+--include-macro __MAC_10_14_6\n+--include-macro __MAC_10_15\n+--include-macro __MAC_10_15_1\n+--include-macro __MAC_10_15_4\n+--include-macro __MAC_10_16\n+--include-macro __MAC_10_2\n+--include-macro __MAC_10_3\n+--include-macro __MAC_10_4\n+--include-macro __MAC_10_5\n+--include-macro __MAC_10_6\n+--include-macro __MAC_10_7\n+--include-macro __MAC_10_8\n+--include-macro __MAC_10_9\n+--include-macro __MAC_11_0\n+--include-macro __MAC_11_1\n+--include-macro __TVOS_10_0\n+--include-macro __TVOS_10_0_1\n+--include-macro __TVOS_10_1\n+--include-macro __TVOS_10_2\n+--include-macro __TVOS_11_0\n+--include-macro __TVOS_11_1\n+--include-macro __TVOS_11_2\n+--include-macro __TVOS_11_3\n+--include-macro __TVOS_11_4\n+--include-macro __TVOS_12_0\n+--include-macro __TVOS_12_1\n+--include-macro __TVOS_12_2\n+--include-macro __TVOS_12_3\n+--include-macro __TVOS_12_4\n+--include-macro __TVOS_13_0\n+--include-macro __TVOS_13_2\n+--include-macro __TVOS_13_3\n+--include-macro __TVOS_13_4\n+--include-macro __TVOS_14_0\n+--include-macro __TVOS_14_1\n+--include-macro __TVOS_14_2\n+--include-macro __TVOS_14_3\n+--include-macro __TVOS_9_0\n+--include-macro __TVOS_9_1\n+--include-macro __TVOS_9_2\n+--include-macro __WATCHOS_1_0\n+--include-macro __WATCHOS_2_0\n+--include-macro __WATCHOS_2_1\n+--include-macro __WATCHOS_2_2\n+--include-macro __WATCHOS_3_0\n+--include-macro __WATCHOS_3_1\n+--include-macro __WATCHOS_3_1_1\n+--include-macro __WATCHOS_3_2\n+--include-macro __WATCHOS_4_0\n+--include-macro __WATCHOS_4_1\n+--include-macro __WATCHOS_4_2\n+--include-macro __WATCHOS_4_3\n+--include-macro __WATCHOS_5_0\n+--include-macro __WATCHOS_5_1\n+--include-macro __WATCHOS_5_2\n+--include-macro __WATCHOS_5_3\n+--include-macro __WATCHOS_6_0\n+--include-macro __WATCHOS_6_1\n+--include-macro __WATCHOS_6_2\n+--include-macro __WATCHOS_7_0\n+--include-macro __WATCHOS_7_1\n+--include-macro __WATCHOS_7_2\n+\n+###\n+\n+--include-typedef __darwin_nl_item\n+--include-typedef __darwin_wctrans_t\n+--include-typedef __darwin_wctype_t\n+--include-macro _FORTIFY_SOURCE\n+--include-macro __DARWIN_WCHAR_MAX\n+--include-macro __DARWIN_WCHAR_MIN\n+--include-macro __DARWIN_WEOF\n+\n+###\n+\n+--include-typedef __darwin_clock_t\n+--include-typedef __darwin_ct_rune_t\n+--include-typedef __darwin_intptr_t\n+--include-typedef __darwin_mbstate_t\n+--include-typedef __darwin_natural_t\n+--include-typedef __darwin_ptrdiff_t\n+--include-typedef __darwin_rune_t\n+--include-typedef __darwin_size_t\n+--include-typedef __darwin_socklen_t\n+--include-typedef __darwin_ssize_t\n+--include-typedef __darwin_time_t\n+--include-typedef __darwin_va_list\n+--include-typedef __darwin_wchar_t\n+--include-typedef __darwin_wint_t\n+--include-typedef __int16_t\n+--include-typedef __int32_t\n+--include-typedef __int64_t\n+--include-typedef __int8_t\n+--include-typedef __mbstate_t\n+--include-typedef __uint16_t\n+--include-typedef __uint32_t\n+--include-typedef __uint64_t\n+--include-typedef __uint8_t\n+\n+###\n+\n+--include-typedef register_t\n+--include-typedef syscall_arg_t\n+--include-typedef user_addr_t\n+--include-typedef user_long_t\n+--include-typedef user_off_t\n+--include-typedef user_size_t\n+--include-typedef user_ssize_t\n+--include-typedef user_time_t\n+--include-typedef user_ulong_t\n+--include-macro USER_ADDR_NULL\n+\n+###\n+\n+--include-typedef __darwin_pthread_attr_t\n+--include-typedef __darwin_pthread_cond_t\n+--include-typedef __darwin_pthread_condattr_t\n+--include-typedef __darwin_pthread_key_t\n+--include-typedef __darwin_pthread_mutex_t\n+--include-typedef __darwin_pthread_mutexattr_t\n+--include-typedef __darwin_pthread_once_t\n+--include-typedef __darwin_pthread_rwlock_t\n+--include-typedef __darwin_pthread_rwlockattr_t\n+--include-typedef __darwin_pthread_t\n+--include-macro __PTHREAD_ATTR_SIZE__\n+--include-macro __PTHREAD_CONDATTR_SIZE__\n+--include-macro __PTHREAD_COND_SIZE__\n+--include-macro __PTHREAD_MUTEXATTR_SIZE__\n+--include-macro __PTHREAD_MUTEX_SIZE__\n+--include-macro __PTHREAD_ONCE_SIZE__\n+--include-macro __PTHREAD_RWLOCKATTR_SIZE__\n+--include-macro __PTHREAD_RWLOCK_SIZE__\n+--include-macro __PTHREAD_SIZE__\n+--include-struct __darwin_pthread_handler_rec\n+--include-struct _opaque_pthread_attr_t\n+--include-struct _opaque_pthread_cond_t\n+--include-struct _opaque_pthread_condattr_t\n+--include-struct _opaque_pthread_mutex_t\n+--include-struct _opaque_pthread_mutexattr_t\n+--include-struct _opaque_pthread_once_t\n+--include-struct _opaque_pthread_rwlock_t\n+--include-struct _opaque_pthread_rwlockattr_t\n+--include-struct _opaque_pthread_t\n+\n+###\n+\n+--include-typedef __darwin_blkcnt_t\n+--include-typedef __darwin_blksize_t\n+--include-typedef __darwin_dev_t\n+--include-typedef __darwin_fsblkcnt_t\n+--include-typedef __darwin_fsfilcnt_t\n+--include-typedef __darwin_gid_t\n+--include-typedef __darwin_id_t\n+--include-typedef __darwin_ino64_t\n+--include-typedef __darwin_ino_t\n+--include-typedef __darwin_mach_port_name_t\n+--include-typedef __darwin_mach_port_t\n+--include-typedef __darwin_mode_t\n+--include-typedef __darwin_off_t\n+--include-typedef __darwin_pid_t\n+--include-typedef __darwin_sigset_t\n+--include-typedef __darwin_suseconds_t\n+--include-typedef __darwin_uid_t\n+--include-typedef __darwin_useconds_t\n+--include-typedef __darwin_uuid_string_t\n+--include-typedef __darwin_uuid_t\n+--include-macro __DARWIN_NULL\n+\n+###\n+\n+--include-typedef clock_t\n+\n+###\n+\n+--include-typedef int16_t\n+\n+###\n+\n+--include-typedef int32_t\n+\n+###\n+\n+--include-typedef int64_t\n+\n+###\n+\n+--include-typedef int8_t\n+\n+###\n+\n+--include-typedef intptr_t\n+\n+###\n+\n+--include-macro NULL\n+\n+###\n+\n+--include-typedef size_t\n+\n+###\n+\n+--include-typedef time_t\n+\n+###\n+\n+--include-struct timespec\n+\n+###\n+\n+--include-typedef u_int16_t\n+\n+###\n+\n+--include-typedef u_int32_t\n+\n+###\n+\n+--include-typedef u_int64_t\n+\n+###\n+\n+--include-typedef u_int8_t\n+\n+###\n+\n+--include-typedef uintptr_t\n+\n+###\n+\n+--include-macro _DARWIN_FEATURE_64_BIT_INODE\n+--include-macro _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE\n+--include-macro _DARWIN_FEATURE_UNIX_CONFORMANCE\n+--include-macro __DARWIN_64_BIT_INO_T\n+--include-macro __DARWIN_C_ANSI\n+--include-macro __DARWIN_C_FULL\n+--include-macro __DARWIN_C_LEVEL\n+--include-macro __DARWIN_NON_CANCELABLE\n+--include-macro __DARWIN_NO_LONG_LONG\n+--include-macro __DARWIN_ONLY_64_BIT_INO_T\n+--include-macro __DARWIN_ONLY_UNIX_CONFORMANCE\n+--include-macro __DARWIN_ONLY_VERS_1050\n+--include-macro __DARWIN_SUF_1050\n+--include-macro __DARWIN_SUF_64_BIT_INO_T\n+--include-macro __DARWIN_SUF_EXTSN\n+--include-macro __DARWIN_UNIX03\n+--include-macro __DARWIN_VERS_1050\n+--include-macro __STDC_WANT_LIB_EXT1__\n+\n+###\n+\n+--include-typedef clockid_t\n+--include-function asctime\n+--include-function asctime_r\n+--include-function clock\n+--include-function clock_getres\n+--include-function clock_gettime\n+--include-function clock_gettime_nsec_np\n+--include-function clock_settime\n+--include-function ctime\n+--include-function ctime_r\n+--include-function difftime\n+--include-function getdate\n+--include-function gmtime\n+--include-function gmtime_r\n+--include-function localtime\n+--include-function localtime_r\n+--include-function mktime\n+--include-function nanosleep\n+--include-function posix2time\n+--include-function strftime\n+--include-function strptime\n+--include-function time\n+--include-function time2posix\n+--include-function timegm\n+--include-function timelocal\n+--include-function timespec_get\n+--include-function tzset\n+--include-function tzsetwall\n+--include-macro CLOCKS_PER_SEC\n+--include-macro CLOCK_MONOTONIC\n+--include-macro CLOCK_MONOTONIC_RAW\n+--include-macro CLOCK_MONOTONIC_RAW_APPROX\n+--include-macro CLOCK_PROCESS_CPUTIME_ID\n+--include-macro CLOCK_REALTIME\n+--include-macro CLOCK_THREAD_CPUTIME_ID\n+--include-macro CLOCK_UPTIME_RAW\n+--include-macro CLOCK_UPTIME_RAW_APPROX\n+--include-macro TIME_UTC\n+--include-macro _CLOCK_MONOTONIC\n+--include-macro _CLOCK_MONOTONIC_RAW\n+--include-macro _CLOCK_MONOTONIC_RAW_APPROX\n+--include-macro _CLOCK_PROCESS_CPUTIME_ID\n+--include-macro _CLOCK_REALTIME\n+--include-macro _CLOCK_THREAD_CPUTIME_ID\n+--include-macro _CLOCK_UPTIME_RAW\n+--include-macro _CLOCK_UPTIME_RAW_APPROX\n+--include-struct tm\n+--include-var daylight\n+--include-var getdate_err\n+--include-var timezone\n+--include-var tzname\n+\n+###\n+\n+--include-function clang_ModuleMapDescriptor_create\n+--include-function clang_ModuleMapDescriptor_dispose\n+--include-function clang_ModuleMapDescriptor_setFrameworkModuleName\n+--include-function clang_ModuleMapDescriptor_setUmbrellaHeader\n+--include-function clang_ModuleMapDescriptor_writeToBuffer\n+--include-function clang_VirtualFileOverlay_addFileMapping\n+--include-function clang_VirtualFileOverlay_create\n+--include-function clang_VirtualFileOverlay_dispose\n+--include-function clang_VirtualFileOverlay_setCaseSensitivity\n+--include-function clang_VirtualFileOverlay_writeToBuffer\n+--include-function clang_free\n+--include-function clang_getBuildSessionTimestamp\n+--include-typedef CXModuleMapDescriptor\n+--include-typedef CXVirtualFileOverlay\n+\n+###\n+\n+--include-macro CXError_ASTReadError\n+--include-macro CXError_Crashed\n+--include-macro CXError_Failure\n+--include-macro CXError_InvalidArguments\n+--include-macro CXError_Success\n+\n+###\n+\n+--include-function clang_disposeString\n+--include-function clang_disposeStringSet\n+--include-function clang_getCString\n+--include-typedef CXString\n+--include-typedef CXStringSet\n+\n+###\n+\n+--include-function clang_CXCursorSet_contains\n+--include-function clang_CXCursorSet_insert\n+--include-function clang_CXIndex_getGlobalOptions\n+--include-function clang_CXIndex_setGlobalOptions\n+--include-function clang_CXIndex_setInvocationEmissionPathOption\n+--include-function clang_CXXConstructor_isConvertingConstructor\n+--include-function clang_CXXConstructor_isCopyConstructor\n+--include-function clang_CXXConstructor_isDefaultConstructor\n+--include-function clang_CXXConstructor_isMoveConstructor\n+--include-function clang_CXXField_isMutable\n+--include-function clang_CXXMethod_isConst\n+--include-function clang_CXXMethod_isDefaulted\n+--include-function clang_CXXMethod_isPureVirtual\n+--include-function clang_CXXMethod_isStatic\n+--include-function clang_CXXMethod_isVirtual\n+--include-function clang_CXXRecord_isAbstract\n+--include-function clang_Cursor_Evaluate\n+--include-function clang_Cursor_getArgument\n+--include-function clang_Cursor_getBriefCommentText\n+--include-function clang_Cursor_getCXXManglings\n+--include-function clang_Cursor_getCommentRange\n+--include-function clang_Cursor_getMangling\n+--include-function clang_Cursor_getModule\n+--include-function clang_Cursor_getNumArguments\n+--include-function clang_Cursor_getNumTemplateArguments\n+--include-function clang_Cursor_getObjCDeclQualifiers\n+--include-function clang_Cursor_getObjCManglings\n+--include-function clang_Cursor_getObjCPropertyAttributes\n+--include-function clang_Cursor_getObjCPropertyGetterName\n+--include-function clang_Cursor_getObjCPropertySetterName\n+--include-function clang_Cursor_getObjCSelectorIndex\n+--include-function clang_Cursor_getOffsetOfField\n+--include-function clang_Cursor_getRawCommentText\n+--include-function clang_Cursor_getReceiverType\n+--include-function clang_Cursor_getSpellingNameRange\n+--include-function clang_Cursor_getStorageClass\n+--include-function clang_Cursor_getTemplateArgumentKind\n+--include-function clang_Cursor_getTemplateArgumentType\n+--include-function clang_Cursor_getTemplateArgumentUnsignedValue\n+--include-function clang_Cursor_getTemplateArgumentValue\n+--include-function clang_Cursor_getTranslationUnit\n+--include-function clang_Cursor_hasAttrs\n+--include-function clang_Cursor_isAnonymous\n+--include-function clang_Cursor_isAnonymousRecordDecl\n+--include-function clang_Cursor_isBitField\n+--include-function clang_Cursor_isDynamicCall\n+--include-function clang_Cursor_isExternalSymbol\n+--include-function clang_Cursor_isFunctionInlined\n+--include-function clang_Cursor_isInlineNamespace\n+--include-function clang_Cursor_isMacroBuiltin\n+--include-function clang_Cursor_isMacroFunctionLike\n+--include-function clang_Cursor_isNull\n+--include-function clang_Cursor_isObjCOptional\n+--include-function clang_Cursor_isVariadic\n+--include-function clang_EnumDecl_isScoped\n+--include-function clang_EvalResult_dispose\n+--include-function clang_EvalResult_getAsDouble\n+--include-function clang_EvalResult_getAsInt\n+--include-function clang_EvalResult_getAsLongLong\n+--include-function clang_EvalResult_getAsStr\n+--include-function clang_EvalResult_getAsUnsigned\n+--include-function clang_EvalResult_getKind\n+--include-function clang_EvalResult_isUnsignedInt\n+--include-function clang_File_isEqual\n+--include-function clang_File_tryGetRealPathName\n+--include-function clang_IndexAction_create\n+--include-function clang_IndexAction_dispose\n+--include-function clang_Location_isFromMainFile\n+--include-function clang_Location_isInSystemHeader\n+--include-function clang_Module_getASTFile\n+--include-function clang_Module_getFullName\n+--include-function clang_Module_getName\n+--include-function clang_Module_getNumTopLevelHeaders\n+--include-function clang_Module_getParent\n+--include-function clang_Module_getTopLevelHeader\n+--include-function clang_Module_isSystem\n+--include-function clang_PrintingPolicy_dispose\n+--include-function clang_PrintingPolicy_getProperty\n+--include-function clang_PrintingPolicy_setProperty\n+--include-function clang_Range_isNull\n+--include-function clang_TargetInfo_dispose\n+--include-function clang_TargetInfo_getPointerWidth\n+--include-function clang_TargetInfo_getTriple\n+--include-function clang_Type_getAlignOf\n+--include-function clang_Type_getCXXRefQualifier\n+--include-function clang_Type_getClassType\n+--include-function clang_Type_getModifiedType\n+--include-function clang_Type_getNamedType\n+--include-function clang_Type_getNullability\n+--include-function clang_Type_getNumObjCProtocolRefs\n+--include-function clang_Type_getNumObjCTypeArgs\n+--include-function clang_Type_getNumTemplateArguments\n+--include-function clang_Type_getObjCEncoding\n+--include-function clang_Type_getObjCObjectBaseType\n+--include-function clang_Type_getObjCProtocolDecl\n+--include-function clang_Type_getObjCTypeArg\n+--include-function clang_Type_getOffsetOf\n+--include-function clang_Type_getSizeOf\n+--include-function clang_Type_getTemplateArgumentAsType\n+--include-function clang_Type_isTransparentTagTypedef\n+--include-function clang_Type_visitFields\n+--include-function clang_annotateTokens\n+--include-function clang_codeCompleteAt\n+--include-function clang_codeCompleteGetContainerKind\n+--include-function clang_codeCompleteGetContainerUSR\n+--include-function clang_codeCompleteGetContexts\n+--include-function clang_codeCompleteGetDiagnostic\n+--include-function clang_codeCompleteGetNumDiagnostics\n+--include-function clang_codeCompleteGetObjCSelector\n+--include-function clang_constructUSR_ObjCCategory\n+--include-function clang_constructUSR_ObjCClass\n+--include-function clang_constructUSR_ObjCIvar\n+--include-function clang_constructUSR_ObjCMethod\n+--include-function clang_constructUSR_ObjCProperty\n+--include-function clang_constructUSR_ObjCProtocol\n+--include-function clang_createCXCursorSet\n+--include-function clang_createIndex\n+--include-function clang_createTranslationUnit\n+--include-function clang_createTranslationUnit2\n+--include-function clang_createTranslationUnitFromSourceFile\n+--include-function clang_defaultCodeCompleteOptions\n+--include-function clang_defaultDiagnosticDisplayOptions\n+--include-function clang_defaultEditingTranslationUnitOptions\n+--include-function clang_defaultReparseOptions\n+--include-function clang_defaultSaveOptions\n+--include-function clang_disposeCXCursorSet\n+--include-function clang_disposeCXPlatformAvailability\n+--include-function clang_disposeCXTUResourceUsage\n+--include-function clang_disposeCodeCompleteResults\n+--include-function clang_disposeDiagnostic\n+--include-function clang_disposeDiagnosticSet\n+--include-function clang_disposeIndex\n+--include-function clang_disposeOverriddenCursors\n+--include-function clang_disposeSourceRangeList\n+--include-function clang_disposeTokens\n+--include-function clang_disposeTranslationUnit\n+--include-function clang_enableStackTraces\n+--include-function clang_equalCursors\n+--include-function clang_equalLocations\n+--include-function clang_equalRanges\n+--include-function clang_equalTypes\n+--include-function clang_executeOnThread\n+--include-function clang_findIncludesInFile\n+--include-function clang_findIncludesInFileWithBlock\n+--include-function clang_findReferencesInFile\n+--include-function clang_findReferencesInFileWithBlock\n+--include-function clang_formatDiagnostic\n+--include-function clang_getAddressSpace\n+--include-function clang_getAllSkippedRanges\n+--include-function clang_getArgType\n+--include-function clang_getArrayElementType\n+--include-function clang_getArraySize\n+--include-function clang_getCXTUResourceUsage\n+--include-function clang_getCXXAccessSpecifier\n+--include-function clang_getCanonicalCursor\n+--include-function clang_getCanonicalType\n+--include-function clang_getChildDiagnostics\n+--include-function clang_getClangVersion\n+--include-function clang_getCompletionAnnotation\n+--include-function clang_getCompletionAvailability\n+--include-function clang_getCompletionBriefComment\n+--include-function clang_getCompletionChunkCompletionString\n+--include-function clang_getCompletionChunkKind\n+--include-function clang_getCompletionChunkText\n+--include-function clang_getCompletionFixIt\n+--include-function clang_getCompletionNumAnnotations\n+--include-function clang_getCompletionNumFixIts\n+--include-function clang_getCompletionParent\n+--include-function clang_getCompletionPriority\n+--include-function clang_getCursor\n+--include-function clang_getCursorAvailability\n+--include-function clang_getCursorCompletionString\n+--include-function clang_getCursorDefinition\n+--include-function clang_getCursorDisplayName\n+--include-function clang_getCursorExceptionSpecificationType\n+--include-function clang_getCursorExtent\n+--include-function clang_getCursorKind\n+--include-function clang_getCursorKindSpelling\n+--include-function clang_getCursorLanguage\n+--include-function clang_getCursorLexicalParent\n+--include-function clang_getCursorLinkage\n+--include-function clang_getCursorLocation\n+--include-function clang_getCursorPlatformAvailability\n+--include-function clang_getCursorPrettyPrinted\n+--include-function clang_getCursorPrintingPolicy\n+--include-function clang_getCursorReferenceNameRange\n+--include-function clang_getCursorReferenced\n+--include-function clang_getCursorResultType\n+--include-function clang_getCursorSemanticParent\n+--include-function clang_getCursorSpelling\n+--include-function clang_getCursorTLSKind\n+--include-function clang_getCursorType\n+--include-function clang_getCursorUSR\n+--include-function clang_getCursorVisibility\n+--include-function clang_getDeclObjCTypeEncoding\n+--include-function clang_getDefinitionSpellingAndExtent\n+--include-function clang_getDiagnostic\n+--include-function clang_getDiagnosticCategory\n+--include-function clang_getDiagnosticCategoryName\n+--include-function clang_getDiagnosticCategoryText\n+--include-function clang_getDiagnosticFixIt\n+--include-function clang_getDiagnosticInSet\n+--include-function clang_getDiagnosticLocation\n+--include-function clang_getDiagnosticNumFixIts\n+--include-function clang_getDiagnosticNumRanges\n+--include-function clang_getDiagnosticOption\n+--include-function clang_getDiagnosticRange\n+--include-function clang_getDiagnosticSetFromTU\n+--include-function clang_getDiagnosticSeverity\n+--include-function clang_getDiagnosticSpelling\n+--include-function clang_getElementType\n+--include-function clang_getEnumConstantDeclUnsignedValue\n+--include-function clang_getEnumConstantDeclValue\n+--include-function clang_getEnumDeclIntegerType\n+--include-function clang_getExceptionSpecificationType\n+--include-function clang_getExpansionLocation\n+--include-function clang_getFieldDeclBitWidth\n+--include-function clang_getFile\n+--include-function clang_getFileContents\n+--include-function clang_getFileLocation\n+--include-function clang_getFileName\n+--include-function clang_getFileTime\n+--include-function clang_getFileUniqueID\n+--include-function clang_getFunctionTypeCallingConv\n+--include-function clang_getIBOutletCollectionType\n+--include-function clang_getIncludedFile\n+--include-function clang_getInclusions\n+--include-function clang_getInstantiationLocation\n+--include-function clang_getLocation\n+--include-function clang_getLocationForOffset\n+--include-function clang_getModuleForFile\n+--include-function clang_getNullCursor\n+--include-function clang_getNullLocation\n+--include-function clang_getNullRange\n+--include-function clang_getNumArgTypes\n+--include-function clang_getNumCompletionChunks\n+--include-function clang_getNumDiagnostics\n+--include-function clang_getNumDiagnosticsInSet\n+--include-function clang_getNumElements\n+--include-function clang_getNumOverloadedDecls\n+--include-function clang_getOverloadedDecl\n+--include-function clang_getOverriddenCursors\n+--include-function clang_getPointeeType\n+--include-function clang_getPresumedLocation\n+--include-function clang_getRange\n+--include-function clang_getRangeEnd\n+--include-function clang_getRangeStart\n+--include-function clang_getRemappings\n+--include-function clang_getRemappingsFromFileList\n+--include-function clang_getResultType\n+--include-function clang_getSkippedRanges\n+--include-function clang_getSpecializedCursorTemplate\n+--include-function clang_getSpellingLocation\n+--include-function clang_getTUResourceUsageName\n+--include-function clang_getTemplateCursorKind\n+--include-function clang_getToken\n+--include-function clang_getTokenExtent\n+--include-function clang_getTokenKind\n+--include-function clang_getTokenLocation\n+--include-function clang_getTokenSpelling\n+--include-function clang_getTranslationUnitCursor\n+--include-function clang_getTranslationUnitSpelling\n+--include-function clang_getTranslationUnitTargetInfo\n+--include-function clang_getTypeDeclaration\n+--include-function clang_getTypeKindSpelling\n+--include-function clang_getTypeSpelling\n+--include-function clang_getTypedefDeclUnderlyingType\n+--include-function clang_getTypedefName\n+--include-function clang_hashCursor\n+--include-function clang_indexLoc_getCXSourceLocation\n+--include-function clang_indexLoc_getFileLocation\n+--include-function clang_indexSourceFile\n+--include-function clang_indexSourceFileFullArgv\n+--include-function clang_indexTranslationUnit\n+--include-function clang_index_getCXXClassDeclInfo\n+--include-function clang_index_getClientContainer\n+--include-function clang_index_getClientEntity\n+--include-function clang_index_getIBOutletCollectionAttrInfo\n+--include-function clang_index_getObjCCategoryDeclInfo\n+--include-function clang_index_getObjCContainerDeclInfo\n+--include-function clang_index_getObjCInterfaceDeclInfo\n+--include-function clang_index_getObjCPropertyDeclInfo\n+--include-function clang_index_getObjCProtocolRefListInfo\n+--include-function clang_index_isEntityObjCContainerKind\n+--include-function clang_index_setClientContainer\n+--include-function clang_index_setClientEntity\n+--include-function clang_isAttribute\n+--include-function clang_isConstQualifiedType\n+--include-function clang_isCursorDefinition\n+--include-function clang_isDeclaration\n+--include-function clang_isExpression\n+--include-function clang_isFileMultipleIncludeGuarded\n+--include-function clang_isFunctionTypeVariadic\n+--include-function clang_isInvalid\n+--include-function clang_isInvalidDeclaration\n+--include-function clang_isPODType\n+--include-function clang_isPreprocessing\n+--include-function clang_isReference\n+--include-function clang_isRestrictQualifiedType\n+--include-function clang_isStatement\n+--include-function clang_isTranslationUnit\n+--include-function clang_isUnexposed\n+--include-function clang_isVirtualBase\n+--include-function clang_isVolatileQualifiedType\n+--include-function clang_loadDiagnostics\n+--include-function clang_parseTranslationUnit\n+--include-function clang_parseTranslationUnit2\n+--include-function clang_parseTranslationUnit2FullArgv\n+--include-function clang_remap_dispose\n+--include-function clang_remap_getFilenames\n+--include-function clang_remap_getNumFiles\n+--include-function clang_reparseTranslationUnit\n+--include-function clang_saveTranslationUnit\n+--include-function clang_sortCodeCompletionResults\n+--include-function clang_suspendTranslationUnit\n+--include-function clang_toggleCrashRecovery\n+--include-function clang_tokenize\n+--include-function clang_visitChildren\n+--include-function clang_visitChildrenWithBlock\n+--include-typedef CXClientData\n+--include-typedef CXCodeCompleteResults\n+--include-typedef CXCompletionResult\n+--include-typedef CXCompletionString\n+--include-typedef CXCursor\n+--include-typedef CXCursorAndRangeVisitorBlock\n+--include-typedef CXCursorSet\n+--include-typedef CXCursorVisitor\n+--include-typedef CXCursorVisitorBlock\n+--include-typedef CXDiagnostic\n+--include-typedef CXDiagnosticSet\n+--include-typedef CXEvalResult\n+--include-typedef CXEvalResultKind\n+--include-typedef CXFieldVisitor\n+--include-typedef CXFile\n+--include-typedef CXFileUniqueID\n+--include-typedef CXGlobalOptFlags\n+--include-typedef CXIdxAttrInfo\n+--include-typedef CXIdxAttrKind\n+--include-typedef CXIdxBaseClassInfo\n+--include-typedef CXIdxCXXClassDeclInfo\n+--include-typedef CXIdxClientASTFile\n+--include-typedef CXIdxClientContainer\n+--include-typedef CXIdxClientEntity\n+--include-typedef CXIdxClientFile\n+--include-typedef CXIdxContainerInfo\n+--include-typedef CXIdxDeclInfo\n+--include-typedef CXIdxDeclInfoFlags\n+--include-typedef CXIdxEntityCXXTemplateKind\n+--include-typedef CXIdxEntityInfo\n+--include-typedef CXIdxEntityKind\n+--include-typedef CXIdxEntityLanguage\n+--include-typedef CXIdxEntityRefInfo\n+--include-typedef CXIdxEntityRefKind\n+--include-typedef CXIdxIBOutletCollectionAttrInfo\n+--include-typedef CXIdxImportedASTFileInfo\n+--include-typedef CXIdxIncludedFileInfo\n+--include-typedef CXIdxLoc\n+--include-typedef CXIdxObjCCategoryDeclInfo\n+--include-typedef CXIdxObjCContainerDeclInfo\n+--include-typedef CXIdxObjCContainerKind\n+--include-typedef CXIdxObjCInterfaceDeclInfo\n+--include-typedef CXIdxObjCPropertyDeclInfo\n+--include-typedef CXIdxObjCProtocolRefInfo\n+--include-typedef CXIdxObjCProtocolRefListInfo\n+--include-typedef CXInclusionVisitor\n+--include-typedef CXIndex\n+--include-typedef CXIndexAction\n+--include-typedef CXIndexOptFlags\n+--include-typedef CXModule\n+--include-typedef CXObjCDeclQualifierKind\n+--include-typedef CXObjCPropertyAttrKind\n+--include-typedef CXPrintingPolicy\n+--include-typedef CXRemapping\n+--include-typedef CXResult\n+--include-typedef CXSourceLocation\n+--include-typedef CXSourceRange\n+--include-typedef CXSourceRangeList\n+--include-typedef CXSymbolRole\n+--include-typedef CXTargetInfo\n+--include-typedef CXToken\n+--include-typedef CXTranslationUnit\n+--include-typedef CXType\n+--include-typedef IndexerCallbacks\n+--include-macro CINDEX_VERSION\n+--include-macro CINDEX_VERSION_MAJOR\n+--include-macro CINDEX_VERSION_MINOR\n+--include-macro CINDEX_VERSION_STRING\n+--include-macro CXAvailability_Available\n+--include-macro CXAvailability_Deprecated\n+--include-macro CXAvailability_NotAccessible\n+--include-macro CXAvailability_NotAvailable\n+--include-macro CXCallingConv_AAPCS\n+--include-macro CXCallingConv_AAPCS_VFP\n+--include-macro CXCallingConv_AArch64VectorCall\n+--include-macro CXCallingConv_C\n+--include-macro CXCallingConv_Default\n+--include-macro CXCallingConv_IntelOclBicc\n+--include-macro CXCallingConv_Invalid\n+--include-macro CXCallingConv_PreserveAll\n+--include-macro CXCallingConv_PreserveMost\n+--include-macro CXCallingConv_Swift\n+--include-macro CXCallingConv_Unexposed\n+--include-macro CXCallingConv_Win64\n+--include-macro CXCallingConv_X86FastCall\n+--include-macro CXCallingConv_X86Pascal\n+--include-macro CXCallingConv_X86RegCall\n+--include-macro CXCallingConv_X86StdCall\n+--include-macro CXCallingConv_X86ThisCall\n+--include-macro CXCallingConv_X86VectorCall\n+--include-macro CXCallingConv_X86_64SysV\n+--include-macro CXCallingConv_X86_64Win64\n+--include-macro CXChildVisit_Break\n+--include-macro CXChildVisit_Continue\n+--include-macro CXChildVisit_Recurse\n+--include-macro CXCodeComplete_IncludeBriefComments\n+--include-macro CXCodeComplete_IncludeCodePatterns\n+--include-macro CXCodeComplete_IncludeCompletionsWithFixIts\n+--include-macro CXCodeComplete_IncludeMacros\n+--include-macro CXCodeComplete_SkipPreamble\n+--include-macro CXCompletionChunk_Colon\n+--include-macro CXCompletionChunk_Comma\n+--include-macro CXCompletionChunk_CurrentParameter\n+--include-macro CXCompletionChunk_Equal\n+--include-macro CXCompletionChunk_HorizontalSpace\n+--include-macro CXCompletionChunk_Informative\n+--include-macro CXCompletionChunk_LeftAngle\n+--include-macro CXCompletionChunk_LeftBrace\n+--include-macro CXCompletionChunk_LeftBracket\n+--include-macro CXCompletionChunk_LeftParen\n+--include-macro CXCompletionChunk_Optional\n+--include-macro CXCompletionChunk_Placeholder\n+--include-macro CXCompletionChunk_ResultType\n+--include-macro CXCompletionChunk_RightAngle\n+--include-macro CXCompletionChunk_RightBrace\n+--include-macro CXCompletionChunk_RightBracket\n+--include-macro CXCompletionChunk_RightParen\n+--include-macro CXCompletionChunk_SemiColon\n+--include-macro CXCompletionChunk_Text\n+--include-macro CXCompletionChunk_TypedText\n+--include-macro CXCompletionChunk_VerticalSpace\n+--include-macro CXCompletionContext_AnyType\n+--include-macro CXCompletionContext_AnyValue\n+--include-macro CXCompletionContext_ArrowMemberAccess\n+--include-macro CXCompletionContext_CXXClassTypeValue\n+--include-macro CXCompletionContext_ClassTag\n+--include-macro CXCompletionContext_DotMemberAccess\n+--include-macro CXCompletionContext_EnumTag\n+--include-macro CXCompletionContext_IncludedFile\n+--include-macro CXCompletionContext_MacroName\n+--include-macro CXCompletionContext_Namespace\n+--include-macro CXCompletionContext_NaturalLanguage\n+--include-macro CXCompletionContext_NestedNameSpecifier\n+--include-macro CXCompletionContext_ObjCCategory\n+--include-macro CXCompletionContext_ObjCClassMessage\n+--include-macro CXCompletionContext_ObjCInstanceMessage\n+--include-macro CXCompletionContext_ObjCInterface\n+--include-macro CXCompletionContext_ObjCObjectValue\n+--include-macro CXCompletionContext_ObjCPropertyAccess\n+--include-macro CXCompletionContext_ObjCProtocol\n+--include-macro CXCompletionContext_ObjCSelectorName\n+--include-macro CXCompletionContext_ObjCSelectorValue\n+--include-macro CXCompletionContext_StructTag\n+--include-macro CXCompletionContext_Unexposed\n+--include-macro CXCompletionContext_UnionTag\n+--include-macro CXCompletionContext_Unknown\n+--include-macro CXCursor_AddrLabelExpr\n+--include-macro CXCursor_AlignedAttr\n+--include-macro CXCursor_AnnotateAttr\n+--include-macro CXCursor_ArraySubscriptExpr\n+--include-macro CXCursor_AsmLabelAttr\n+--include-macro CXCursor_AsmStmt\n+--include-macro CXCursor_BinaryOperator\n+--include-macro CXCursor_BlockExpr\n+--include-macro CXCursor_BreakStmt\n+--include-macro CXCursor_BuiltinBitCastExpr\n+--include-macro CXCursor_CStyleCastExpr\n+--include-macro CXCursor_CUDAConstantAttr\n+--include-macro CXCursor_CUDADeviceAttr\n+--include-macro CXCursor_CUDAGlobalAttr\n+--include-macro CXCursor_CUDAHostAttr\n+--include-macro CXCursor_CUDASharedAttr\n+--include-macro CXCursor_CXXAccessSpecifier\n+--include-macro CXCursor_CXXBaseSpecifier\n+--include-macro CXCursor_CXXBoolLiteralExpr\n+--include-macro CXCursor_CXXCatchStmt\n+--include-macro CXCursor_CXXConstCastExpr\n+--include-macro CXCursor_CXXDeleteExpr\n+--include-macro CXCursor_CXXDynamicCastExpr\n+--include-macro CXCursor_CXXFinalAttr\n+--include-macro CXCursor_CXXForRangeStmt\n+--include-macro CXCursor_CXXFunctionalCastExpr\n+--include-macro CXCursor_CXXMethod\n+--include-macro CXCursor_CXXNewExpr\n+--include-macro CXCursor_CXXNullPtrLiteralExpr\n+--include-macro CXCursor_CXXOverrideAttr\n+--include-macro CXCursor_CXXReinterpretCastExpr\n+--include-macro CXCursor_CXXStaticCastExpr\n+--include-macro CXCursor_CXXThisExpr\n+--include-macro CXCursor_CXXThrowExpr\n+--include-macro CXCursor_CXXTryStmt\n+--include-macro CXCursor_CXXTypeidExpr\n+--include-macro CXCursor_CallExpr\n+--include-macro CXCursor_CaseStmt\n+--include-macro CXCursor_CharacterLiteral\n+--include-macro CXCursor_ClassDecl\n+--include-macro CXCursor_ClassTemplate\n+--include-macro CXCursor_ClassTemplatePartialSpecialization\n+--include-macro CXCursor_CompoundAssignOperator\n+--include-macro CXCursor_CompoundLiteralExpr\n+--include-macro CXCursor_CompoundStmt\n+--include-macro CXCursor_ConditionalOperator\n+--include-macro CXCursor_ConstAttr\n+--include-macro CXCursor_Constructor\n+--include-macro CXCursor_ContinueStmt\n+--include-macro CXCursor_ConvergentAttr\n+--include-macro CXCursor_ConversionFunction\n+--include-macro CXCursor_DLLExport\n+--include-macro CXCursor_DLLImport\n+--include-macro CXCursor_DeclRefExpr\n+--include-macro CXCursor_DeclStmt\n+--include-macro CXCursor_DefaultStmt\n+--include-macro CXCursor_Destructor\n+--include-macro CXCursor_DoStmt\n+--include-macro CXCursor_EnumConstantDecl\n+--include-macro CXCursor_EnumDecl\n+--include-macro CXCursor_ExceptionSpecificationKind_BasicNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_ComputedNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_Dynamic\n+--include-macro CXCursor_ExceptionSpecificationKind_DynamicNone\n+--include-macro CXCursor_ExceptionSpecificationKind_MSAny\n+--include-macro CXCursor_ExceptionSpecificationKind_NoThrow\n+--include-macro CXCursor_ExceptionSpecificationKind_None\n+--include-macro CXCursor_ExceptionSpecificationKind_Unevaluated\n+--include-macro CXCursor_ExceptionSpecificationKind_Uninstantiated\n+--include-macro CXCursor_ExceptionSpecificationKind_Unparsed\n+--include-macro CXCursor_FieldDecl\n+--include-macro CXCursor_FirstAttr\n+--include-macro CXCursor_FirstDecl\n+--include-macro CXCursor_FirstExpr\n+--include-macro CXCursor_FirstExtraDecl\n+--include-macro CXCursor_FirstInvalid\n+--include-macro CXCursor_FirstPreprocessing\n+--include-macro CXCursor_FirstRef\n+--include-macro CXCursor_FirstStmt\n+--include-macro CXCursor_FixedPointLiteral\n+--include-macro CXCursor_FlagEnum\n+--include-macro CXCursor_FloatingLiteral\n+--include-macro CXCursor_ForStmt\n+--include-macro CXCursor_FriendDecl\n+--include-macro CXCursor_FunctionDecl\n+--include-macro CXCursor_FunctionTemplate\n+--include-macro CXCursor_GCCAsmStmt\n+--include-macro CXCursor_GNUNullExpr\n+--include-macro CXCursor_GenericSelectionExpr\n+--include-macro CXCursor_GotoStmt\n+--include-macro CXCursor_IBActionAttr\n+--include-macro CXCursor_IBOutletAttr\n+--include-macro CXCursor_IBOutletCollectionAttr\n+--include-macro CXCursor_IfStmt\n+--include-macro CXCursor_ImaginaryLiteral\n+--include-macro CXCursor_InclusionDirective\n+--include-macro CXCursor_IndirectGotoStmt\n+--include-macro CXCursor_InitListExpr\n+--include-macro CXCursor_IntegerLiteral\n+--include-macro CXCursor_InvalidCode\n+--include-macro CXCursor_InvalidFile\n+--include-macro CXCursor_LabelRef\n+--include-macro CXCursor_LabelStmt\n+--include-macro CXCursor_LambdaExpr\n+--include-macro CXCursor_LastAttr\n+--include-macro CXCursor_LastDecl\n+--include-macro CXCursor_LastExpr\n+--include-macro CXCursor_LastExtraDecl\n+--include-macro CXCursor_LastInvalid\n+--include-macro CXCursor_LastPreprocessing\n+--include-macro CXCursor_LastRef\n+--include-macro CXCursor_LastStmt\n+--include-macro CXCursor_LinkageSpec\n+--include-macro CXCursor_MSAsmStmt\n+--include-macro CXCursor_MacroDefinition\n+--include-macro CXCursor_MacroExpansion\n+--include-macro CXCursor_MacroInstantiation\n+--include-macro CXCursor_MemberRef\n+--include-macro CXCursor_MemberRefExpr\n+--include-macro CXCursor_ModuleImportDecl\n+--include-macro CXCursor_NSConsumed\n+--include-macro CXCursor_NSConsumesSelf\n+--include-macro CXCursor_NSReturnsAutoreleased\n+--include-macro CXCursor_NSReturnsNotRetained\n+--include-macro CXCursor_NSReturnsRetained\n+--include-macro CXCursor_Namespace\n+--include-macro CXCursor_NamespaceAlias\n+--include-macro CXCursor_NamespaceRef\n+--include-macro CXCursor_NoDeclFound\n+--include-macro CXCursor_NoDuplicateAttr\n+--include-macro CXCursor_NonTypeTemplateParameter\n+--include-macro CXCursor_NotImplemented\n+--include-macro CXCursor_NullStmt\n+--include-macro CXCursor_OMPArraySectionExpr\n+--include-macro CXCursor_OMPAtomicDirective\n+--include-macro CXCursor_OMPBarrierDirective\n+--include-macro CXCursor_OMPCancelDirective\n+--include-macro CXCursor_OMPCancellationPointDirective\n+--include-macro CXCursor_OMPCriticalDirective\n+--include-macro CXCursor_OMPDistributeDirective\n+--include-macro CXCursor_OMPDistributeParallelForDirective\n+--include-macro CXCursor_OMPDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPDistributeSimdDirective\n+--include-macro CXCursor_OMPFlushDirective\n+--include-macro CXCursor_OMPForDirective\n+--include-macro CXCursor_OMPForSimdDirective\n+--include-macro CXCursor_OMPMasterDirective\n+--include-macro CXCursor_OMPMasterTaskLoopDirective\n+--include-macro CXCursor_OMPMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPOrderedDirective\n+--include-macro CXCursor_OMPParallelDirective\n+--include-macro CXCursor_OMPParallelForDirective\n+--include-macro CXCursor_OMPParallelForSimdDirective\n+--include-macro CXCursor_OMPParallelMasterDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPParallelSectionsDirective\n+--include-macro CXCursor_OMPSectionDirective\n+--include-macro CXCursor_OMPSectionsDirective\n+--include-macro CXCursor_OMPSimdDirective\n+--include-macro CXCursor_OMPSingleDirective\n+--include-macro CXCursor_OMPTargetDataDirective\n+--include-macro CXCursor_OMPTargetDirective\n+--include-macro CXCursor_OMPTargetEnterDataDirective\n+--include-macro CXCursor_OMPTargetExitDataDirective\n+--include-macro CXCursor_OMPTargetParallelDirective\n+--include-macro CXCursor_OMPTargetParallelForDirective\n+--include-macro CXCursor_OMPTargetParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeSimdDirective\n+--include-macro CXCursor_OMPTargetUpdateDirective\n+--include-macro CXCursor_OMPTaskDirective\n+--include-macro CXCursor_OMPTaskLoopDirective\n+--include-macro CXCursor_OMPTaskLoopSimdDirective\n+--include-macro CXCursor_OMPTaskgroupDirective\n+--include-macro CXCursor_OMPTaskwaitDirective\n+--include-macro CXCursor_OMPTaskyieldDirective\n+--include-macro CXCursor_OMPTeamsDirective\n+--include-macro CXCursor_OMPTeamsDistributeDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTeamsDistributeSimdDirective\n+--include-macro CXCursor_ObjCAtCatchStmt\n+--include-macro CXCursor_ObjCAtFinallyStmt\n+--include-macro CXCursor_ObjCAtSynchronizedStmt\n+--include-macro CXCursor_ObjCAtThrowStmt\n+--include-macro CXCursor_ObjCAtTryStmt\n+--include-macro CXCursor_ObjCAutoreleasePoolStmt\n+--include-macro CXCursor_ObjCAvailabilityCheckExpr\n+--include-macro CXCursor_ObjCBoolLiteralExpr\n+--include-macro CXCursor_ObjCBoxable\n+--include-macro CXCursor_ObjCBridgedCastExpr\n+--include-macro CXCursor_ObjCCategoryDecl\n+--include-macro CXCursor_ObjCCategoryImplDecl\n+--include-macro CXCursor_ObjCClassMethodDecl\n+--include-macro CXCursor_ObjCClassRef\n+--include-macro CXCursor_ObjCDesignatedInitializer\n+--include-macro CXCursor_ObjCDynamicDecl\n+--include-macro CXCursor_ObjCEncodeExpr\n+--include-macro CXCursor_ObjCException\n+--include-macro CXCursor_ObjCExplicitProtocolImpl\n+--include-macro CXCursor_ObjCForCollectionStmt\n+--include-macro CXCursor_ObjCImplementationDecl\n+--include-macro CXCursor_ObjCIndependentClass\n+--include-macro CXCursor_ObjCInstanceMethodDecl\n+--include-macro CXCursor_ObjCInterfaceDecl\n+--include-macro CXCursor_ObjCIvarDecl\n+--include-macro CXCursor_ObjCMessageExpr\n+--include-macro CXCursor_ObjCNSObject\n+--include-macro CXCursor_ObjCPreciseLifetime\n+--include-macro CXCursor_ObjCPropertyDecl\n+--include-macro CXCursor_ObjCProtocolDecl\n+--include-macro CXCursor_ObjCProtocolExpr\n+--include-macro CXCursor_ObjCProtocolRef\n+--include-macro CXCursor_ObjCRequiresSuper\n+--include-macro CXCursor_ObjCReturnsInnerPointer\n+--include-macro CXCursor_ObjCRootClass\n+--include-macro CXCursor_ObjCRuntimeVisible\n+--include-macro CXCursor_ObjCSelectorExpr\n+--include-macro CXCursor_ObjCSelfExpr\n+--include-macro CXCursor_ObjCStringLiteral\n+--include-macro CXCursor_ObjCSubclassingRestricted\n+--include-macro CXCursor_ObjCSuperClassRef\n+--include-macro CXCursor_ObjCSynthesizeDecl\n+--include-macro CXCursor_OverloadCandidate\n+--include-macro CXCursor_OverloadedDeclRef\n+--include-macro CXCursor_PackExpansionExpr\n+--include-macro CXCursor_PackedAttr\n+--include-macro CXCursor_ParenExpr\n+--include-macro CXCursor_ParmDecl\n+--include-macro CXCursor_PreprocessingDirective\n+--include-macro CXCursor_PureAttr\n+--include-macro CXCursor_ReturnStmt\n+--include-macro CXCursor_SEHExceptStmt\n+--include-macro CXCursor_SEHFinallyStmt\n+--include-macro CXCursor_SEHLeaveStmt\n+--include-macro CXCursor_SEHTryStmt\n+--include-macro CXCursor_SizeOfPackExpr\n+--include-macro CXCursor_StaticAssert\n+--include-macro CXCursor_StmtExpr\n+--include-macro CXCursor_StringLiteral\n+--include-macro CXCursor_StructDecl\n+--include-macro CXCursor_SwitchStmt\n+--include-macro CXCursor_TemplateRef\n+--include-macro CXCursor_TemplateTemplateParameter\n+--include-macro CXCursor_TemplateTypeParameter\n+--include-macro CXCursor_TranslationUnit\n+--include-macro CXCursor_TypeAliasDecl\n+--include-macro CXCursor_TypeAliasTemplateDecl\n+--include-macro CXCursor_TypeRef\n+--include-macro CXCursor_TypedefDecl\n+--include-macro CXCursor_UnaryExpr\n+--include-macro CXCursor_UnaryOperator\n+--include-macro CXCursor_UnexposedAttr\n+--include-macro CXCursor_UnexposedDecl\n+--include-macro CXCursor_UnexposedExpr\n+--include-macro CXCursor_UnexposedStmt\n+--include-macro CXCursor_UnionDecl\n+--include-macro CXCursor_UsingDeclaration\n+--include-macro CXCursor_UsingDirective\n+--include-macro CXCursor_VarDecl\n+--include-macro CXCursor_VariableRef\n+--include-macro CXCursor_VisibilityAttr\n+--include-macro CXCursor_WarnUnusedAttr\n+--include-macro CXCursor_WarnUnusedResultAttr\n+--include-macro CXCursor_WhileStmt\n+--include-macro CXDiagnostic_DisplayCategoryId\n+--include-macro CXDiagnostic_DisplayCategoryName\n+--include-macro CXDiagnostic_DisplayColumn\n+--include-macro CXDiagnostic_DisplayOption\n+--include-macro CXDiagnostic_DisplaySourceLocation\n+--include-macro CXDiagnostic_DisplaySourceRanges\n+--include-macro CXDiagnostic_Error\n+--include-macro CXDiagnostic_Fatal\n+--include-macro CXDiagnostic_Ignored\n+--include-macro CXDiagnostic_Note\n+--include-macro CXDiagnostic_Warning\n+--include-macro CXEval_CFStr\n+--include-macro CXEval_Float\n+--include-macro CXEval_Int\n+--include-macro CXEval_ObjCStrLiteral\n+--include-macro CXEval_Other\n+--include-macro CXEval_StrLiteral\n+--include-macro CXEval_UnExposed\n+--include-macro CXGlobalOpt_None\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForAll\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForEditing\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForIndexing\n+--include-macro CXIdxAttr_IBAction\n+--include-macro CXIdxAttr_IBOutlet\n+--include-macro CXIdxAttr_IBOutletCollection\n+--include-macro CXIdxAttr_Unexposed\n+--include-macro CXIdxDeclFlag_Skipped\n+--include-macro CXIdxEntityLang_C\n+--include-macro CXIdxEntityLang_CXX\n+--include-macro CXIdxEntityLang_None\n+--include-macro CXIdxEntityLang_ObjC\n+--include-macro CXIdxEntityLang_Swift\n+--include-macro CXIdxEntityRef_Direct\n+--include-macro CXIdxEntityRef_Implicit\n+--include-macro CXIdxEntity_CXXClass\n+--include-macro CXIdxEntity_CXXConstructor\n+--include-macro CXIdxEntity_CXXConversionFunction\n+--include-macro CXIdxEntity_CXXDestructor\n+--include-macro CXIdxEntity_CXXInstanceMethod\n+--include-macro CXIdxEntity_CXXInterface\n+--include-macro CXIdxEntity_CXXNamespace\n+--include-macro CXIdxEntity_CXXNamespaceAlias\n+--include-macro CXIdxEntity_CXXStaticMethod\n+--include-macro CXIdxEntity_CXXStaticVariable\n+--include-macro CXIdxEntity_CXXTypeAlias\n+--include-macro CXIdxEntity_Enum\n+--include-macro CXIdxEntity_EnumConstant\n+--include-macro CXIdxEntity_Field\n+--include-macro CXIdxEntity_Function\n+--include-macro CXIdxEntity_NonTemplate\n+--include-macro CXIdxEntity_ObjCCategory\n+--include-macro CXIdxEntity_ObjCClass\n+--include-macro CXIdxEntity_ObjCClassMethod\n+--include-macro CXIdxEntity_ObjCInstanceMethod\n+--include-macro CXIdxEntity_ObjCIvar\n+--include-macro CXIdxEntity_ObjCProperty\n+--include-macro CXIdxEntity_ObjCProtocol\n+--include-macro CXIdxEntity_Struct\n+--include-macro CXIdxEntity_Template\n+--include-macro CXIdxEntity_TemplatePartialSpecialization\n+--include-macro CXIdxEntity_TemplateSpecialization\n+--include-macro CXIdxEntity_Typedef\n+--include-macro CXIdxEntity_Unexposed\n+--include-macro CXIdxEntity_Union\n+--include-macro CXIdxEntity_Variable\n+--include-macro CXIdxObjCContainer_ForwardRef\n+--include-macro CXIdxObjCContainer_Implementation\n+--include-macro CXIdxObjCContainer_Interface\n+--include-macro CXIndexOpt_IndexFunctionLocalSymbols\n+--include-macro CXIndexOpt_IndexImplicitTemplateInstantiations\n+--include-macro CXIndexOpt_None\n+--include-macro CXIndexOpt_SkipParsedBodiesInSession\n+--include-macro CXIndexOpt_SuppressRedundantRefs\n+--include-macro CXIndexOpt_SuppressWarnings\n+--include-macro CXLanguage_C\n+--include-macro CXLanguage_CPlusPlus\n+--include-macro CXLanguage_Invalid\n+--include-macro CXLanguage_ObjC\n+--include-macro CXLinkage_External\n+--include-macro CXLinkage_Internal\n+--include-macro CXLinkage_Invalid\n+--include-macro CXLinkage_NoLinkage\n+--include-macro CXLinkage_UniqueExternal\n+--include-macro CXLoadDiag_CannotLoad\n+--include-macro CXLoadDiag_InvalidFile\n+--include-macro CXLoadDiag_None\n+--include-macro CXLoadDiag_Unknown\n+--include-macro CXNameRange_WantQualifier\n+--include-macro CXNameRange_WantSinglePiece\n+--include-macro CXNameRange_WantTemplateArgs\n+--include-macro CXObjCDeclQualifier_Bycopy\n+--include-macro CXObjCDeclQualifier_Byref\n+--include-macro CXObjCDeclQualifier_In\n+--include-macro CXObjCDeclQualifier_Inout\n+--include-macro CXObjCDeclQualifier_None\n+--include-macro CXObjCDeclQualifier_Oneway\n+--include-macro CXObjCDeclQualifier_Out\n+--include-macro CXObjCPropertyAttr_assign\n+--include-macro CXObjCPropertyAttr_atomic\n+--include-macro CXObjCPropertyAttr_class\n+--include-macro CXObjCPropertyAttr_copy\n+--include-macro CXObjCPropertyAttr_getter\n+--include-macro CXObjCPropertyAttr_noattr\n+--include-macro CXObjCPropertyAttr_nonatomic\n+--include-macro CXObjCPropertyAttr_readonly\n+--include-macro CXObjCPropertyAttr_readwrite\n+--include-macro CXObjCPropertyAttr_retain\n+--include-macro CXObjCPropertyAttr_setter\n+--include-macro CXObjCPropertyAttr_strong\n+--include-macro CXObjCPropertyAttr_unsafe_unretained\n+--include-macro CXObjCPropertyAttr_weak\n+--include-macro CXPrintingPolicy_Alignof\n+--include-macro CXPrintingPolicy_AnonymousTagLocations\n+--include-macro CXPrintingPolicy_Bool\n+--include-macro CXPrintingPolicy_ConstantArraySizeAsWritten\n+--include-macro CXPrintingPolicy_ConstantsAsWritten\n+--include-macro CXPrintingPolicy_FullyQualifiedName\n+--include-macro CXPrintingPolicy_Half\n+--include-macro CXPrintingPolicy_IncludeNewlines\n+--include-macro CXPrintingPolicy_IncludeTagDefinition\n+--include-macro CXPrintingPolicy_Indentation\n+--include-macro CXPrintingPolicy_LastProperty\n+--include-macro CXPrintingPolicy_MSVCFormatting\n+--include-macro CXPrintingPolicy_MSWChar\n+--include-macro CXPrintingPolicy_PolishForDeclaration\n+--include-macro CXPrintingPolicy_Restrict\n+--include-macro CXPrintingPolicy_SuppressImplicitBase\n+--include-macro CXPrintingPolicy_SuppressInitializers\n+--include-macro CXPrintingPolicy_SuppressLifetimeQualifiers\n+--include-macro CXPrintingPolicy_SuppressScope\n+--include-macro CXPrintingPolicy_SuppressSpecifiers\n+--include-macro CXPrintingPolicy_SuppressStrongLifetime\n+--include-macro CXPrintingPolicy_SuppressTagKeyword\n+--include-macro CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors\n+--include-macro CXPrintingPolicy_SuppressUnwrittenScope\n+--include-macro CXPrintingPolicy_TerseOutput\n+--include-macro CXPrintingPolicy_UnderscoreAlignof\n+--include-macro CXPrintingPolicy_UseVoidForZeroParams\n+--include-macro CXRefQualifier_LValue\n+--include-macro CXRefQualifier_None\n+--include-macro CXRefQualifier_RValue\n+--include-macro CXReparse_None\n+--include-macro CXResult_Invalid\n+--include-macro CXResult_Success\n+--include-macro CXResult_VisitBreak\n+--include-macro CXSaveError_InvalidTU\n+--include-macro CXSaveError_None\n+--include-macro CXSaveError_TranslationErrors\n+--include-macro CXSaveError_Unknown\n+--include-macro CXSaveTranslationUnit_None\n+--include-macro CXSymbolRole_AddressOf\n+--include-macro CXSymbolRole_Call\n+--include-macro CXSymbolRole_Declaration\n+--include-macro CXSymbolRole_Definition\n+--include-macro CXSymbolRole_Dynamic\n+--include-macro CXSymbolRole_Implicit\n+--include-macro CXSymbolRole_None\n+--include-macro CXSymbolRole_Read\n+--include-macro CXSymbolRole_Reference\n+--include-macro CXSymbolRole_Write\n+--include-macro CXTLS_Dynamic\n+--include-macro CXTLS_None\n+--include-macro CXTLS_Static\n+--include-macro CXTUResourceUsage_AST\n+--include-macro CXTUResourceUsage_AST_SideTables\n+--include-macro CXTUResourceUsage_ExternalASTSource_Membuffer_MMap\n+--include-macro CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc\n+--include-macro CXTUResourceUsage_First\n+--include-macro CXTUResourceUsage_GlobalCompletionResults\n+--include-macro CXTUResourceUsage_Identifiers\n+--include-macro CXTUResourceUsage_Last\n+--include-macro CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN\n+--include-macro CXTUResourceUsage_MEMORY_IN_BYTES_END\n+--include-macro CXTUResourceUsage_PreprocessingRecord\n+--include-macro CXTUResourceUsage_Preprocessor\n+--include-macro CXTUResourceUsage_Preprocessor_HeaderSearch\n+--include-macro CXTUResourceUsage_Selectors\n+--include-macro CXTUResourceUsage_SourceManagerContentCache\n+--include-macro CXTUResourceUsage_SourceManager_DataStructures\n+--include-macro CXTUResourceUsage_SourceManager_Membuffer_MMap\n+--include-macro CXTUResourceUsage_SourceManager_Membuffer_Malloc\n+--include-macro CXTemplateArgumentKind_Declaration\n+--include-macro CXTemplateArgumentKind_Expression\n+--include-macro CXTemplateArgumentKind_Integral\n+--include-macro CXTemplateArgumentKind_Invalid\n+--include-macro CXTemplateArgumentKind_Null\n+--include-macro CXTemplateArgumentKind_NullPtr\n+--include-macro CXTemplateArgumentKind_Pack\n+--include-macro CXTemplateArgumentKind_Template\n+--include-macro CXTemplateArgumentKind_TemplateExpansion\n+--include-macro CXTemplateArgumentKind_Type\n+--include-macro CXToken_Comment\n+--include-macro CXToken_Identifier\n+--include-macro CXToken_Keyword\n+--include-macro CXToken_Literal\n+--include-macro CXToken_Punctuation\n+--include-macro CXTranslationUnit_CXXChainedPCH\n+--include-macro CXTranslationUnit_CacheCompletionResults\n+--include-macro CXTranslationUnit_CreatePreambleOnFirstParse\n+--include-macro CXTranslationUnit_DetailedPreprocessingRecord\n+--include-macro CXTranslationUnit_ForSerialization\n+--include-macro CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles\n+--include-macro CXTranslationUnit_IncludeAttributedTypes\n+--include-macro CXTranslationUnit_IncludeBriefCommentsInCodeCompletion\n+--include-macro CXTranslationUnit_Incomplete\n+--include-macro CXTranslationUnit_KeepGoing\n+--include-macro CXTranslationUnit_LimitSkipFunctionBodiesToPreamble\n+--include-macro CXTranslationUnit_None\n+--include-macro CXTranslationUnit_PrecompiledPreamble\n+--include-macro CXTranslationUnit_RetainExcludedConditionalBlocks\n+--include-macro CXTranslationUnit_SingleFileParse\n+--include-macro CXTranslationUnit_SkipFunctionBodies\n+--include-macro CXTranslationUnit_VisitImplicitAttributes\n+--include-macro CXTypeLayoutError_Dependent\n+--include-macro CXTypeLayoutError_Incomplete\n+--include-macro CXTypeLayoutError_Invalid\n+--include-macro CXTypeLayoutError_InvalidFieldName\n+--include-macro CXTypeLayoutError_NotConstantSize\n+--include-macro CXTypeLayoutError_Undeduced\n+--include-macro CXTypeNullability_Invalid\n+--include-macro CXTypeNullability_NonNull\n+--include-macro CXTypeNullability_Nullable\n+--include-macro CXTypeNullability_Unspecified\n+--include-macro CXType_Accum\n+--include-macro CXType_Attributed\n+--include-macro CXType_Auto\n+--include-macro CXType_BlockPointer\n+--include-macro CXType_Bool\n+--include-macro CXType_Char16\n+--include-macro CXType_Char32\n+--include-macro CXType_Char_S\n+--include-macro CXType_Char_U\n+--include-macro CXType_Complex\n+--include-macro CXType_ConstantArray\n+--include-macro CXType_Dependent\n+--include-macro CXType_DependentSizedArray\n+--include-macro CXType_Double\n+--include-macro CXType_Elaborated\n+--include-macro CXType_Enum\n+--include-macro CXType_ExtVector\n+--include-macro CXType_FirstBuiltin\n+--include-macro CXType_Float\n+--include-macro CXType_Float128\n+--include-macro CXType_Float16\n+--include-macro CXType_FunctionNoProto\n+--include-macro CXType_FunctionProto\n+--include-macro CXType_Half\n+--include-macro CXType_IncompleteArray\n+--include-macro CXType_Int\n+--include-macro CXType_Int128\n+--include-macro CXType_Invalid\n+--include-macro CXType_LValueReference\n+--include-macro CXType_LastBuiltin\n+--include-macro CXType_Long\n+--include-macro CXType_LongAccum\n+--include-macro CXType_LongDouble\n+--include-macro CXType_LongLong\n+--include-macro CXType_MemberPointer\n+--include-macro CXType_NullPtr\n+--include-macro CXType_OCLEvent\n+--include-macro CXType_OCLImage1dArrayRO\n+--include-macro CXType_OCLImage1dArrayRW\n+--include-macro CXType_OCLImage1dArrayWO\n+--include-macro CXType_OCLImage1dBufferRO\n+--include-macro CXType_OCLImage1dBufferRW\n+--include-macro CXType_OCLImage1dBufferWO\n+--include-macro CXType_OCLImage1dRO\n+--include-macro CXType_OCLImage1dRW\n+--include-macro CXType_OCLImage1dWO\n+--include-macro CXType_OCLImage2dArrayDepthRO\n+--include-macro CXType_OCLImage2dArrayDepthRW\n+--include-macro CXType_OCLImage2dArrayDepthWO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRW\n+--include-macro CXType_OCLImage2dArrayMSAADepthWO\n+--include-macro CXType_OCLImage2dArrayMSAARO\n+--include-macro CXType_OCLImage2dArrayMSAARW\n+--include-macro CXType_OCLImage2dArrayMSAAWO\n+--include-macro CXType_OCLImage2dArrayRO\n+--include-macro CXType_OCLImage2dArrayRW\n+--include-macro CXType_OCLImage2dArrayWO\n+--include-macro CXType_OCLImage2dDepthRO\n+--include-macro CXType_OCLImage2dDepthRW\n+--include-macro CXType_OCLImage2dDepthWO\n+--include-macro CXType_OCLImage2dMSAADepthRO\n+--include-macro CXType_OCLImage2dMSAADepthRW\n+--include-macro CXType_OCLImage2dMSAADepthWO\n+--include-macro CXType_OCLImage2dMSAARO\n+--include-macro CXType_OCLImage2dMSAARW\n+--include-macro CXType_OCLImage2dMSAAWO\n+--include-macro CXType_OCLImage2dRO\n+--include-macro CXType_OCLImage2dRW\n+--include-macro CXType_OCLImage2dWO\n+--include-macro CXType_OCLImage3dRO\n+--include-macro CXType_OCLImage3dRW\n+--include-macro CXType_OCLImage3dWO\n+--include-macro CXType_OCLIntelSubgroupAVCImeDualRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCImePayload\n+--include-macro CXType_OCLIntelSubgroupAVCImeResult\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeSingleRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCMcePayload\n+--include-macro CXType_OCLIntelSubgroupAVCMceResult\n+--include-macro CXType_OCLIntelSubgroupAVCRefPayload\n+--include-macro CXType_OCLIntelSubgroupAVCRefResult\n+--include-macro CXType_OCLIntelSubgroupAVCSicPayload\n+--include-macro CXType_OCLIntelSubgroupAVCSicResult\n+--include-macro CXType_OCLQueue\n+--include-macro CXType_OCLReserveID\n+--include-macro CXType_OCLSampler\n+--include-macro CXType_ObjCClass\n+--include-macro CXType_ObjCId\n+--include-macro CXType_ObjCInterface\n+--include-macro CXType_ObjCObject\n+--include-macro CXType_ObjCObjectPointer\n+--include-macro CXType_ObjCSel\n+--include-macro CXType_ObjCTypeParam\n+--include-macro CXType_Overload\n+--include-macro CXType_Pipe\n+--include-macro CXType_Pointer\n+--include-macro CXType_RValueReference\n+--include-macro CXType_Record\n+--include-macro CXType_SChar\n+--include-macro CXType_Short\n+--include-macro CXType_ShortAccum\n+--include-macro CXType_Typedef\n+--include-macro CXType_UAccum\n+--include-macro CXType_UChar\n+--include-macro CXType_UInt\n+--include-macro CXType_UInt128\n+--include-macro CXType_ULong\n+--include-macro CXType_ULongAccum\n+--include-macro CXType_ULongLong\n+--include-macro CXType_UShort\n+--include-macro CXType_UShortAccum\n+--include-macro CXType_Unexposed\n+--include-macro CXType_VariableArray\n+--include-macro CXType_Vector\n+--include-macro CXType_Void\n+--include-macro CXType_WChar\n+--include-macro CXVisibility_Default\n+--include-macro CXVisibility_Hidden\n+--include-macro CXVisibility_Invalid\n+--include-macro CXVisibility_Protected\n+--include-macro CXVisit_Break\n+--include-macro CXVisit_Continue\n+--include-macro CX_CXXInvalidAccessSpecifier\n+--include-macro CX_CXXPrivate\n+--include-macro CX_CXXProtected\n+--include-macro CX_CXXPublic\n+--include-macro CX_SC_Auto\n+--include-macro CX_SC_Extern\n+--include-macro CX_SC_Invalid\n+--include-macro CX_SC_None\n+--include-macro CX_SC_OpenCLWorkGroupLocal\n+--include-macro CX_SC_PrivateExtern\n+--include-macro CX_SC_Register\n+--include-macro CX_SC_Static\n+--include-struct CXCursorAndRangeVisitor\n+--include-struct CXPlatformAvailability\n+--include-struct CXTUResourceUsage\n+--include-struct CXTUResourceUsageEntry\n+--include-struct CXUnsavedFile\n+--include-struct CXVersion\n","filename":"updateclang\/clang.full.symbols","additions":1556,"deletions":0,"binary":false,"changes":1556,"status":"added"},{"patch":"@@ -0,0 +1,624 @@\n+###\n+\n+--include-macro CXError_ASTReadError\n+--include-macro CXError_Crashed\n+--include-macro CXError_Failure\n+--include-macro CXError_InvalidArguments\n+--include-macro CXError_Success\n+\n+###\n+\n+--include-function clang_disposeString\n+--include-function clang_getCString\n+\n+###\n+\n+--include-typedef CXCursorVisitor\n+--include-typedef CXIndex\n+--include-typedef CXToken\n+--include-typedef CXTranslationUnit\n+--include-typedef CXType\n+--include-struct CXUnsavedFile\n+--include-macro CXCallingConv_AAPCS\n+--include-macro CXCallingConv_AAPCS_VFP\n+--include-macro CXCallingConv_AArch64VectorCall\n+--include-macro CXCallingConv_C\n+--include-macro CXCallingConv_Default\n+--include-macro CXCallingConv_IntelOclBicc\n+--include-macro CXCallingConv_Invalid\n+--include-macro CXCallingConv_PreserveAll\n+--include-macro CXCallingConv_PreserveMost\n+--include-macro CXCallingConv_Swift\n+--include-macro CXCallingConv_Unexposed\n+--include-macro CXCallingConv_Win64\n+--include-macro CXCallingConv_X86FastCall\n+--include-macro CXCallingConv_X86Pascal\n+--include-macro CXCallingConv_X86RegCall\n+--include-macro CXCallingConv_X86StdCall\n+--include-macro CXCallingConv_X86ThisCall\n+--include-macro CXCallingConv_X86VectorCall\n+--include-macro CXCallingConv_X86_64SysV\n+--include-macro CXCallingConv_X86_64Win64\n+--include-macro CXChildVisit_Break\n+--include-macro CXChildVisit_Continue\n+--include-macro CXChildVisit_Recurse\n+--include-macro CXCursor_AddrLabelExpr\n+--include-macro CXCursor_AlignedAttr\n+--include-macro CXCursor_AnnotateAttr\n+--include-macro CXCursor_ArraySubscriptExpr\n+--include-macro CXCursor_AsmLabelAttr\n+--include-macro CXCursor_AsmStmt\n+--include-macro CXCursor_BinaryOperator\n+--include-macro CXCursor_BlockExpr\n+--include-macro CXCursor_BreakStmt\n+--include-macro CXCursor_BuiltinBitCastExpr\n+--include-macro CXCursor_CStyleCastExpr\n+--include-macro CXCursor_CUDAConstantAttr\n+--include-macro CXCursor_CUDADeviceAttr\n+--include-macro CXCursor_CUDAGlobalAttr\n+--include-macro CXCursor_CUDAHostAttr\n+--include-macro CXCursor_CUDASharedAttr\n+--include-macro CXCursor_CXXAccessSpecifier\n+--include-macro CXCursor_CXXBaseSpecifier\n+--include-macro CXCursor_CXXBoolLiteralExpr\n+--include-macro CXCursor_CXXCatchStmt\n+--include-macro CXCursor_CXXConstCastExpr\n+--include-macro CXCursor_CXXDeleteExpr\n+--include-macro CXCursor_CXXDynamicCastExpr\n+--include-macro CXCursor_CXXFinalAttr\n+--include-macro CXCursor_CXXForRangeStmt\n+--include-macro CXCursor_CXXFunctionalCastExpr\n+--include-macro CXCursor_CXXMethod\n+--include-macro CXCursor_CXXNewExpr\n+--include-macro CXCursor_CXXNullPtrLiteralExpr\n+--include-macro CXCursor_CXXOverrideAttr\n+--include-macro CXCursor_CXXReinterpretCastExpr\n+--include-macro CXCursor_CXXStaticCastExpr\n+--include-macro CXCursor_CXXThisExpr\n+--include-macro CXCursor_CXXThrowExpr\n+--include-macro CXCursor_CXXTryStmt\n+--include-macro CXCursor_CXXTypeidExpr\n+--include-macro CXCursor_CallExpr\n+--include-macro CXCursor_CaseStmt\n+--include-macro CXCursor_CharacterLiteral\n+--include-macro CXCursor_ClassDecl\n+--include-macro CXCursor_ClassTemplate\n+--include-macro CXCursor_ClassTemplatePartialSpecialization\n+--include-macro CXCursor_CompoundAssignOperator\n+--include-macro CXCursor_CompoundLiteralExpr\n+--include-macro CXCursor_CompoundStmt\n+--include-macro CXCursor_ConditionalOperator\n+--include-macro CXCursor_ConstAttr\n+--include-macro CXCursor_Constructor\n+--include-macro CXCursor_ContinueStmt\n+--include-macro CXCursor_ConvergentAttr\n+--include-macro CXCursor_ConversionFunction\n+--include-macro CXCursor_DLLExport\n+--include-macro CXCursor_DLLImport\n+--include-macro CXCursor_DeclRefExpr\n+--include-macro CXCursor_DeclStmt\n+--include-macro CXCursor_DefaultStmt\n+--include-macro CXCursor_Destructor\n+--include-macro CXCursor_DoStmt\n+--include-macro CXCursor_EnumConstantDecl\n+--include-macro CXCursor_EnumDecl\n+--include-macro CXCursor_ExceptionSpecificationKind_BasicNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_ComputedNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_Dynamic\n+--include-macro CXCursor_ExceptionSpecificationKind_DynamicNone\n+--include-macro CXCursor_ExceptionSpecificationKind_MSAny\n+--include-macro CXCursor_ExceptionSpecificationKind_NoThrow\n+--include-macro CXCursor_ExceptionSpecificationKind_None\n+--include-macro CXCursor_ExceptionSpecificationKind_Unevaluated\n+--include-macro CXCursor_ExceptionSpecificationKind_Uninstantiated\n+--include-macro CXCursor_ExceptionSpecificationKind_Unparsed\n+--include-macro CXCursor_FieldDecl\n+--include-macro CXCursor_FirstAttr\n+--include-macro CXCursor_FirstDecl\n+--include-macro CXCursor_FirstExpr\n+--include-macro CXCursor_FirstExtraDecl\n+--include-macro CXCursor_FirstInvalid\n+--include-macro CXCursor_FirstPreprocessing\n+--include-macro CXCursor_FirstRef\n+--include-macro CXCursor_FirstStmt\n+--include-macro CXCursor_FixedPointLiteral\n+--include-macro CXCursor_FlagEnum\n+--include-macro CXCursor_FloatingLiteral\n+--include-macro CXCursor_ForStmt\n+--include-macro CXCursor_FriendDecl\n+--include-macro CXCursor_FunctionDecl\n+--include-macro CXCursor_FunctionTemplate\n+--include-macro CXCursor_GCCAsmStmt\n+--include-macro CXCursor_GNUNullExpr\n+--include-macro CXCursor_GenericSelectionExpr\n+--include-macro CXCursor_GotoStmt\n+--include-macro CXCursor_IBActionAttr\n+--include-macro CXCursor_IBOutletAttr\n+--include-macro CXCursor_IBOutletCollectionAttr\n+--include-macro CXCursor_IfStmt\n+--include-macro CXCursor_ImaginaryLiteral\n+--include-macro CXCursor_InclusionDirective\n+--include-macro CXCursor_IndirectGotoStmt\n+--include-macro CXCursor_InitListExpr\n+--include-macro CXCursor_IntegerLiteral\n+--include-macro CXCursor_InvalidCode\n+--include-macro CXCursor_InvalidFile\n+--include-macro CXCursor_LabelRef\n+--include-macro CXCursor_LabelStmt\n+--include-macro CXCursor_LambdaExpr\n+--include-macro CXCursor_LastAttr\n+--include-macro CXCursor_LastDecl\n+--include-macro CXCursor_LastExpr\n+--include-macro CXCursor_LastExtraDecl\n+--include-macro CXCursor_LastInvalid\n+--include-macro CXCursor_LastPreprocessing\n+--include-macro CXCursor_LastRef\n+--include-macro CXCursor_LastStmt\n+--include-macro CXCursor_LinkageSpec\n+--include-macro CXCursor_MSAsmStmt\n+--include-macro CXCursor_MacroDefinition\n+--include-macro CXCursor_MacroExpansion\n+--include-macro CXCursor_MacroInstantiation\n+--include-macro CXCursor_MemberRef\n+--include-macro CXCursor_MemberRefExpr\n+--include-macro CXCursor_ModuleImportDecl\n+--include-macro CXCursor_NSConsumed\n+--include-macro CXCursor_NSConsumesSelf\n+--include-macro CXCursor_NSReturnsAutoreleased\n+--include-macro CXCursor_NSReturnsNotRetained\n+--include-macro CXCursor_NSReturnsRetained\n+--include-macro CXCursor_Namespace\n+--include-macro CXCursor_NamespaceAlias\n+--include-macro CXCursor_NamespaceRef\n+--include-macro CXCursor_NoDeclFound\n+--include-macro CXCursor_NoDuplicateAttr\n+--include-macro CXCursor_NonTypeTemplateParameter\n+--include-macro CXCursor_NotImplemented\n+--include-macro CXCursor_NullStmt\n+--include-macro CXCursor_OMPArraySectionExpr\n+--include-macro CXCursor_OMPAtomicDirective\n+--include-macro CXCursor_OMPBarrierDirective\n+--include-macro CXCursor_OMPCancelDirective\n+--include-macro CXCursor_OMPCancellationPointDirective\n+--include-macro CXCursor_OMPCriticalDirective\n+--include-macro CXCursor_OMPDistributeDirective\n+--include-macro CXCursor_OMPDistributeParallelForDirective\n+--include-macro CXCursor_OMPDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPDistributeSimdDirective\n+--include-macro CXCursor_OMPFlushDirective\n+--include-macro CXCursor_OMPForDirective\n+--include-macro CXCursor_OMPForSimdDirective\n+--include-macro CXCursor_OMPMasterDirective\n+--include-macro CXCursor_OMPMasterTaskLoopDirective\n+--include-macro CXCursor_OMPMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPOrderedDirective\n+--include-macro CXCursor_OMPParallelDirective\n+--include-macro CXCursor_OMPParallelForDirective\n+--include-macro CXCursor_OMPParallelForSimdDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPParallelSectionsDirective\n+--include-macro CXCursor_OMPSectionDirective\n+--include-macro CXCursor_OMPSectionsDirective\n+--include-macro CXCursor_OMPSimdDirective\n+--include-macro CXCursor_OMPSingleDirective\n+--include-macro CXCursor_OMPTargetDataDirective\n+--include-macro CXCursor_OMPTargetDirective\n+--include-macro CXCursor_OMPTargetEnterDataDirective\n+--include-macro CXCursor_OMPTargetExitDataDirective\n+--include-macro CXCursor_OMPTargetParallelDirective\n+--include-macro CXCursor_OMPTargetParallelForDirective\n+--include-macro CXCursor_OMPTargetParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeSimdDirective\n+--include-macro CXCursor_OMPTargetUpdateDirective\n+--include-macro CXCursor_OMPTaskDirective\n+--include-macro CXCursor_OMPTaskLoopDirective\n+--include-macro CXCursor_OMPTaskLoopSimdDirective\n+--include-macro CXCursor_OMPTaskgroupDirective\n+--include-macro CXCursor_OMPTaskwaitDirective\n+--include-macro CXCursor_OMPTaskyieldDirective\n+--include-macro CXCursor_OMPTeamsDirective\n+--include-macro CXCursor_OMPTeamsDistributeDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTeamsDistributeSimdDirective\n+--include-macro CXCursor_ObjCAtCatchStmt\n+--include-macro CXCursor_ObjCAtFinallyStmt\n+--include-macro CXCursor_ObjCAtSynchronizedStmt\n+--include-macro CXCursor_ObjCAtThrowStmt\n+--include-macro CXCursor_ObjCAtTryStmt\n+--include-macro CXCursor_ObjCAutoreleasePoolStmt\n+--include-macro CXCursor_ObjCAvailabilityCheckExpr\n+--include-macro CXCursor_ObjCBoolLiteralExpr\n+--include-macro CXCursor_ObjCBoxable\n+--include-macro CXCursor_ObjCBridgedCastExpr\n+--include-macro CXCursor_ObjCCategoryDecl\n+--include-macro CXCursor_ObjCCategoryImplDecl\n+--include-macro CXCursor_ObjCClassMethodDecl\n+--include-macro CXCursor_ObjCClassRef\n+--include-macro CXCursor_ObjCDesignatedInitializer\n+--include-macro CXCursor_ObjCDynamicDecl\n+--include-macro CXCursor_ObjCEncodeExpr\n+--include-macro CXCursor_ObjCException\n+--include-macro CXCursor_ObjCExplicitProtocolImpl\n+--include-macro CXCursor_ObjCForCollectionStmt\n+--include-macro CXCursor_ObjCImplementationDecl\n+--include-macro CXCursor_ObjCIndependentClass\n+--include-macro CXCursor_ObjCInstanceMethodDecl\n+--include-macro CXCursor_ObjCInterfaceDecl\n+--include-macro CXCursor_ObjCIvarDecl\n+--include-macro CXCursor_ObjCMessageExpr\n+--include-macro CXCursor_ObjCNSObject\n+--include-macro CXCursor_ObjCPreciseLifetime\n+--include-macro CXCursor_ObjCPropertyDecl\n+--include-macro CXCursor_ObjCProtocolDecl\n+--include-macro CXCursor_ObjCProtocolExpr\n+--include-macro CXCursor_ObjCProtocolRef\n+--include-macro CXCursor_ObjCRequiresSuper\n+--include-macro CXCursor_ObjCReturnsInnerPointer\n+--include-macro CXCursor_ObjCRootClass\n+--include-macro CXCursor_ObjCRuntimeVisible\n+--include-macro CXCursor_ObjCSelectorExpr\n+--include-macro CXCursor_ObjCSelfExpr\n+--include-macro CXCursor_ObjCStringLiteral\n+--include-macro CXCursor_ObjCSubclassingRestricted\n+--include-macro CXCursor_ObjCSuperClassRef\n+--include-macro CXCursor_ObjCSynthesizeDecl\n+--include-macro CXCursor_OverloadCandidate\n+--include-macro CXCursor_OverloadedDeclRef\n+--include-macro CXCursor_PackExpansionExpr\n+--include-macro CXCursor_PackedAttr\n+--include-macro CXCursor_ParenExpr\n+--include-macro CXCursor_ParmDecl\n+--include-macro CXCursor_PreprocessingDirective\n+--include-macro CXCursor_PureAttr\n+--include-macro CXCursor_ReturnStmt\n+--include-macro CXCursor_SEHExceptStmt\n+--include-macro CXCursor_SEHFinallyStmt\n+--include-macro CXCursor_SEHLeaveStmt\n+--include-macro CXCursor_SEHTryStmt\n+--include-macro CXCursor_SizeOfPackExpr\n+--include-macro CXCursor_StaticAssert\n+--include-macro CXCursor_StmtExpr\n+--include-macro CXCursor_StringLiteral\n+--include-macro CXCursor_StructDecl\n+--include-macro CXCursor_SwitchStmt\n+--include-macro CXCursor_TemplateRef\n+--include-macro CXCursor_TemplateTemplateParameter\n+--include-macro CXCursor_TemplateTypeParameter\n+--include-macro CXCursor_TranslationUnit\n+--include-macro CXCursor_TypeAliasDecl\n+--include-macro CXCursor_TypeAliasTemplateDecl\n+--include-macro CXCursor_TypeRef\n+--include-macro CXCursor_TypedefDecl\n+--include-macro CXCursor_UnaryExpr\n+--include-macro CXCursor_UnaryOperator\n+--include-macro CXCursor_UnexposedAttr\n+--include-macro CXCursor_UnexposedDecl\n+--include-macro CXCursor_UnexposedExpr\n+--include-macro CXCursor_UnexposedStmt\n+--include-macro CXCursor_UnionDecl\n+--include-macro CXCursor_UsingDeclaration\n+--include-macro CXCursor_UsingDirective\n+--include-macro CXCursor_VarDecl\n+--include-macro CXCursor_VariableRef\n+--include-macro CXCursor_VisibilityAttr\n+--include-macro CXCursor_WarnUnusedAttr\n+--include-macro CXCursor_WarnUnusedResultAttr\n+--include-macro CXCursor_WhileStmt\n+--include-macro CXDiagnostic_DisplayCategoryId\n+--include-macro CXDiagnostic_DisplayCategoryName\n+--include-macro CXDiagnostic_DisplayColumn\n+--include-macro CXDiagnostic_DisplayOption\n+--include-macro CXDiagnostic_DisplaySourceLocation\n+--include-macro CXDiagnostic_DisplaySourceRanges\n+--include-macro CXDiagnostic_Error\n+--include-macro CXDiagnostic_Fatal\n+--include-macro CXDiagnostic_Ignored\n+--include-macro CXDiagnostic_Note\n+--include-macro CXDiagnostic_Warning\n+--include-macro CXLanguage_C\n+--include-macro CXLanguage_CPlusPlus\n+--include-macro CXLanguage_Invalid\n+--include-macro CXLanguage_ObjC\n+--include-macro CXPrintingPolicy_Alignof\n+--include-macro CXPrintingPolicy_AnonymousTagLocations\n+--include-macro CXPrintingPolicy_Bool\n+--include-macro CXPrintingPolicy_ConstantArraySizeAsWritten\n+--include-macro CXPrintingPolicy_ConstantsAsWritten\n+--include-macro CXPrintingPolicy_FullyQualifiedName\n+--include-macro CXPrintingPolicy_Half\n+--include-macro CXPrintingPolicy_IncludeNewlines\n+--include-macro CXPrintingPolicy_IncludeTagDefinition\n+--include-macro CXPrintingPolicy_Indentation\n+--include-macro CXPrintingPolicy_LastProperty\n+--include-macro CXPrintingPolicy_MSVCFormatting\n+--include-macro CXPrintingPolicy_MSWChar\n+--include-macro CXPrintingPolicy_PolishForDeclaration\n+--include-macro CXPrintingPolicy_Restrict\n+--include-macro CXPrintingPolicy_SuppressImplicitBase\n+--include-macro CXPrintingPolicy_SuppressInitializers\n+--include-macro CXPrintingPolicy_SuppressLifetimeQualifiers\n+--include-macro CXPrintingPolicy_SuppressScope\n+--include-macro CXPrintingPolicy_SuppressSpecifiers\n+--include-macro CXPrintingPolicy_SuppressStrongLifetime\n+--include-macro CXPrintingPolicy_SuppressTagKeyword\n+--include-macro CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors\n+--include-macro CXPrintingPolicy_SuppressUnwrittenScope\n+--include-macro CXPrintingPolicy_TerseOutput\n+--include-macro CXPrintingPolicy_UnderscoreAlignof\n+--include-macro CXPrintingPolicy_UseVoidForZeroParams\n+--include-macro CXReparse_None\n+--include-macro CXResult_Invalid\n+--include-macro CXResult_Success\n+--include-macro CXResult_VisitBreak\n+--include-macro CXSaveError_InvalidTU\n+--include-macro CXSaveError_None\n+--include-macro CXSaveError_TranslationErrors\n+--include-macro CXSaveError_Unknown\n+--include-macro CXSaveTranslationUnit_None\n+--include-macro CXToken_Comment\n+--include-macro CXToken_Identifier\n+--include-macro CXToken_Keyword\n+--include-macro CXToken_Literal\n+--include-macro CXToken_Punctuation\n+--include-macro CXTranslationUnit_CXXChainedPCH\n+--include-macro CXTranslationUnit_CacheCompletionResults\n+--include-macro CXTranslationUnit_CreatePreambleOnFirstParse\n+--include-macro CXTranslationUnit_DetailedPreprocessingRecord\n+--include-macro CXTranslationUnit_ForSerialization\n+--include-macro CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles\n+--include-macro CXTranslationUnit_IncludeAttributedTypes\n+--include-macro CXTranslationUnit_IncludeBriefCommentsInCodeCompletion\n+--include-macro CXTranslationUnit_Incomplete\n+--include-macro CXTranslationUnit_KeepGoing\n+--include-macro CXTranslationUnit_LimitSkipFunctionBodiesToPreamble\n+--include-macro CXTranslationUnit_None\n+--include-macro CXTranslationUnit_PrecompiledPreamble\n+--include-macro CXTranslationUnit_RetainExcludedConditionalBlocks\n+--include-macro CXTranslationUnit_SingleFileParse\n+--include-macro CXTranslationUnit_SkipFunctionBodies\n+--include-macro CXTranslationUnit_VisitImplicitAttributes\n+--include-macro CXTypeLayoutError_Dependent\n+--include-macro CXTypeLayoutError_Incomplete\n+--include-macro CXTypeLayoutError_Invalid\n+--include-macro CXTypeLayoutError_InvalidFieldName\n+--include-macro CXTypeLayoutError_NotConstantSize\n+--include-macro CXTypeLayoutError_Undeduced\n+--include-macro CXTypeNullability_Invalid\n+--include-macro CXTypeNullability_NonNull\n+--include-macro CXTypeNullability_Nullable\n+--include-macro CXTypeNullability_Unspecified\n+--include-macro CXType_Accum\n+--include-macro CXType_Attributed\n+--include-macro CXType_Auto\n+--include-macro CXType_BlockPointer\n+--include-macro CXType_Bool\n+--include-macro CXType_Char16\n+--include-macro CXType_Char32\n+--include-macro CXType_Char_S\n+--include-macro CXType_Char_U\n+--include-macro CXType_Complex\n+--include-macro CXType_ConstantArray\n+--include-macro CXType_Dependent\n+--include-macro CXType_DependentSizedArray\n+--include-macro CXType_Double\n+--include-macro CXType_Elaborated\n+--include-macro CXType_Enum\n+--include-macro CXType_ExtVector\n+--include-macro CXType_FirstBuiltin\n+--include-macro CXType_Float\n+--include-macro CXType_Float128\n+--include-macro CXType_Float16\n+--include-macro CXType_FunctionNoProto\n+--include-macro CXType_FunctionProto\n+--include-macro CXType_Half\n+--include-macro CXType_IncompleteArray\n+--include-macro CXType_Int\n+--include-macro CXType_Int128\n+--include-macro CXType_Invalid\n+--include-macro CXType_LValueReference\n+--include-macro CXType_LastBuiltin\n+--include-macro CXType_Long\n+--include-macro CXType_LongAccum\n+--include-macro CXType_LongDouble\n+--include-macro CXType_LongLong\n+--include-macro CXType_MemberPointer\n+--include-macro CXType_NullPtr\n+--include-macro CXType_OCLEvent\n+--include-macro CXType_OCLImage1dArrayRO\n+--include-macro CXType_OCLImage1dArrayRW\n+--include-macro CXType_OCLImage1dArrayWO\n+--include-macro CXType_OCLImage1dBufferRO\n+--include-macro CXType_OCLImage1dBufferRW\n+--include-macro CXType_OCLImage1dBufferWO\n+--include-macro CXType_OCLImage1dRO\n+--include-macro CXType_OCLImage1dRW\n+--include-macro CXType_OCLImage1dWO\n+--include-macro CXType_OCLImage2dArrayDepthRO\n+--include-macro CXType_OCLImage2dArrayDepthRW\n+--include-macro CXType_OCLImage2dArrayDepthWO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRW\n+--include-macro CXType_OCLImage2dArrayMSAADepthWO\n+--include-macro CXType_OCLImage2dArrayMSAARO\n+--include-macro CXType_OCLImage2dArrayMSAARW\n+--include-macro CXType_OCLImage2dArrayMSAAWO\n+--include-macro CXType_OCLImage2dArrayRO\n+--include-macro CXType_OCLImage2dArrayRW\n+--include-macro CXType_OCLImage2dArrayWO\n+--include-macro CXType_OCLImage2dDepthRO\n+--include-macro CXType_OCLImage2dDepthRW\n+--include-macro CXType_OCLImage2dDepthWO\n+--include-macro CXType_OCLImage2dMSAADepthRO\n+--include-macro CXType_OCLImage2dMSAADepthRW\n+--include-macro CXType_OCLImage2dMSAADepthWO\n+--include-macro CXType_OCLImage2dMSAARO\n+--include-macro CXType_OCLImage2dMSAARW\n+--include-macro CXType_OCLImage2dMSAAWO\n+--include-macro CXType_OCLImage2dRO\n+--include-macro CXType_OCLImage2dRW\n+--include-macro CXType_OCLImage2dWO\n+--include-macro CXType_OCLImage3dRO\n+--include-macro CXType_OCLImage3dRW\n+--include-macro CXType_OCLImage3dWO\n+--include-macro CXType_OCLIntelSubgroupAVCImeDualRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCImePayload\n+--include-macro CXType_OCLIntelSubgroupAVCImeResult\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeSingleRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCMcePayload\n+--include-macro CXType_OCLIntelSubgroupAVCMceResult\n+--include-macro CXType_OCLIntelSubgroupAVCRefPayload\n+--include-macro CXType_OCLIntelSubgroupAVCRefResult\n+--include-macro CXType_OCLIntelSubgroupAVCSicPayload\n+--include-macro CXType_OCLIntelSubgroupAVCSicResult\n+--include-macro CXType_OCLQueue\n+--include-macro CXType_OCLReserveID\n+--include-macro CXType_OCLSampler\n+--include-macro CXType_ObjCClass\n+--include-macro CXType_ObjCId\n+--include-macro CXType_ObjCInterface\n+--include-macro CXType_ObjCObject\n+--include-macro CXType_ObjCObjectPointer\n+--include-macro CXType_ObjCSel\n+--include-macro CXType_ObjCTypeParam\n+--include-macro CXType_Overload\n+--include-macro CXType_Pipe\n+--include-macro CXType_Pointer\n+--include-macro CXType_RValueReference\n+--include-macro CXType_Record\n+--include-macro CXType_SChar\n+--include-macro CXType_Short\n+--include-macro CXType_ShortAccum\n+--include-macro CXType_Typedef\n+--include-macro CXType_UAccum\n+--include-macro CXType_UChar\n+--include-macro CXType_UInt\n+--include-macro CXType_UInt128\n+--include-macro CXType_ULong\n+--include-macro CXType_ULongAccum\n+--include-macro CXType_ULongLong\n+--include-macro CXType_UShort\n+--include-macro CXType_UShortAccum\n+--include-macro CXType_Unexposed\n+--include-macro CXType_VariableArray\n+--include-macro CXType_Vector\n+--include-macro CXType_Void\n+--include-macro CXType_WChar\n+--include-function clang_Cursor_Evaluate\n+--include-function clang_Cursor_getArgument\n+--include-function clang_Cursor_getMangling\n+--include-function clang_Cursor_getNumArguments\n+--include-function clang_Cursor_getTranslationUnit\n+--include-function clang_Cursor_isAnonymous\n+--include-function clang_Cursor_isAnonymousRecordDecl\n+--include-function clang_Cursor_isBitField\n+--include-function clang_Cursor_isMacroFunctionLike\n+--include-function clang_Cursor_isNull\n+--include-function clang_Cursor_isVariadic\n+--include-function clang_EvalResult_dispose\n+--include-function clang_EvalResult_getAsDouble\n+--include-function clang_EvalResult_getAsInt\n+--include-function clang_EvalResult_getAsLongLong\n+--include-function clang_EvalResult_getAsStr\n+--include-function clang_EvalResult_getAsUnsigned\n+--include-function clang_EvalResult_getKind\n+--include-function clang_EvalResult_isUnsignedInt\n+--include-function clang_Location_isFromMainFile\n+--include-function clang_Location_isInSystemHeader\n+--include-function clang_PrintingPolicy_dispose\n+--include-function clang_PrintingPolicy_getProperty\n+--include-function clang_PrintingPolicy_setProperty\n+--include-function clang_Range_isNull\n+--include-function clang_Type_getOffsetOf\n+--include-function clang_Type_getSizeOf\n+--include-function clang_createIndex\n+--include-function clang_defaultDiagnosticDisplayOptions\n+--include-function clang_defaultReparseOptions\n+--include-function clang_disposeDiagnostic\n+--include-function clang_disposeIndex\n+--include-function clang_disposeTokens\n+--include-function clang_disposeTranslationUnit\n+--include-function clang_equalCursors\n+--include-function clang_equalLocations\n+--include-function clang_equalTypes\n+--include-function clang_formatDiagnostic\n+--include-function clang_getArgType\n+--include-function clang_getArrayElementType\n+--include-function clang_getArraySize\n+--include-function clang_getCanonicalType\n+--include-function clang_getChildDiagnostics\n+--include-function clang_getClangVersion\n+--include-function clang_getCursorDefinition\n+--include-function clang_getCursorDisplayName\n+--include-function clang_getCursorExtent\n+--include-function clang_getCursorKind\n+--include-function clang_getCursorKindSpelling\n+--include-function clang_getCursorLanguage\n+--include-function clang_getCursorLocation\n+--include-function clang_getCursorPrettyPrinted\n+--include-function clang_getCursorPrintingPolicy\n+--include-function clang_getCursorReferenced\n+--include-function clang_getCursorResultType\n+--include-function clang_getCursorSpelling\n+--include-function clang_getCursorType\n+--include-function clang_getCursorUSR\n+--include-function clang_getDiagnostic\n+--include-function clang_getDiagnosticLocation\n+--include-function clang_getDiagnosticSeverity\n+--include-function clang_getDiagnosticSpelling\n+--include-function clang_getElementType\n+--include-function clang_getEnumConstantDeclUnsignedValue\n+--include-function clang_getEnumConstantDeclValue\n+--include-function clang_getEnumDeclIntegerType\n+--include-function clang_getExpansionLocation\n+--include-function clang_getFieldDeclBitWidth\n+--include-function clang_getFileLocation\n+--include-function clang_getFileName\n+--include-function clang_getFunctionTypeCallingConv\n+--include-function clang_getLocation\n+--include-function clang_getLocationForOffset\n+--include-function clang_getNullCursor\n+--include-function clang_getNullLocation\n+--include-function clang_getNumArgTypes\n+--include-function clang_getNumDiagnostics\n+--include-function clang_getNumElements\n+--include-function clang_getPointeeType\n+--include-function clang_getRangeStart\n+--include-function clang_getRangeEnd\n+--include-function clang_getResultType\n+--include-function clang_getSpellingLocation\n+--include-function clang_getTokenExtent\n+--include-function clang_getTokenKind\n+--include-function clang_getTokenLocation\n+--include-function clang_getTokenSpelling\n+--include-function clang_getTranslationUnitCursor\n+--include-function clang_getTypeDeclaration\n+--include-function clang_getTypeKindSpelling\n+--include-function clang_getTypePrettyPrinted\n+--include-function clang_getTypePrintingPolicy\n+--include-function clang_getTypeSpelling\n+--include-function clang_getTypedefDeclUnderlyingType\n+--include-function clang_getTypedefName\n+--include-function clang_isAttribute\n+--include-function clang_isConstQualifiedType\n+--include-function clang_isCursorDefinition\n+--include-function clang_isDeclaration\n+--include-function clang_isFunctionTypeVariadic\n+--include-function clang_isInvalid\n+--include-function clang_isPreprocessing\n+--include-function clang_isVolatileQualifiedType\n+--include-function clang_parseTranslationUnit\n+--include-function clang_parseTranslationUnit2\n+--include-function clang_reparseTranslationUnit\n+--include-function clang_saveTranslationUnit\n+--include-function clang_toggleCrashRecovery\n+--include-function clang_tokenize\n+--include-function clang_visitChildren\n","filename":"updateclang\/clang.symbols","additions":624,"deletions":0,"binary":false,"changes":624,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n","filename":"updateclang\/cp_header.txt","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#!\/bin\/bash\n+\n+jextract -d ..\/src\/main\/java \\\n+  --source -t org.openjdk.jextract.clang.libclang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  @clang.symbols \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+\n+for x in ..\/src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/*.java; do\n+head -$COPYRIGHTLEN $x | diff cp_header.txt - || ( ( cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n+mv \/tmp\/file $x )\n+done\n","filename":"updateclang\/extract.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"}]}