{"files":[{"patch":"@@ -33,2 +33,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -381,0 +379,12 @@\n+    \/**\n+     * Creates a new variable declaration with given kind, name and type.\n+     * @param kind the variable declaration kind.\n+     * @param pos the variable declaration position.\n+     * @param name the variable declaration name.\n+     * @param type the variable declaration type.\n+     * @return a new variable declaration with given kind, name and type.\n+     *\/\n+    static Declaration.Variable var(Variable.Kind kind, Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, kind, name, pos);\n+    }\n+\n@@ -388,1 +398,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -400,1 +410,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -412,1 +422,1 @@\n-        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(bitfields);\n@@ -424,1 +434,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -437,1 +447,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -449,1 +459,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -462,1 +472,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -474,1 +484,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -487,1 +497,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -499,1 +509,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -512,1 +522,1 @@\n-        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        List<Declaration> declList = List.of(decls);\n@@ -516,0 +526,27 @@\n+    \/**\n+     * Creates a new scoped declaration with given kind, name and member declarations.\n+     * @param kind the kind of the scoped declaration.\n+     * @param pos the scoped declaration position.\n+     * @param name the scoped declaration name.\n+     * @param decls the scoped declaration member declarations.\n+     * @return a new scoped declaration with given kind, name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = List.of(decls);\n+        return new DeclarationImpl.ScopedImpl(kind, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new scoped declaration with given kind, name, layout and member declarations.\n+     * @param kind the kind of the scoped declaration.\n+     * @param pos the scoped declaration position.\n+     * @param name the scoped declaration name.\n+     * @param layout the scoped declaration layout.\n+     * @param decls the scoped declaration member declarations.\n+     * @return a new scoped declaration with given kind, name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped scoped(Scoped.Kind kind, Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = List.of(decls);\n+        return new DeclarationImpl.ScopedImpl(kind, layout, declList, name, pos);\n+    }\n+\n@@ -525,1 +562,1 @@\n-        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());\n+        List<Variable> paramList = List.of(params);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/Declaration.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -55,12 +54,0 @@\n-    interface ScopedFactoryLayout {\n-        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n-    }\n-\n-    interface ScopedFactoryNoLayout {\n-        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n-    }\n-\n-    interface VarFactoryNoLayout {\n-        Declaration.Variable make(Position pos, String name, Type type);\n-    }\n-\n@@ -86,24 +73,14 @@\n-        switch (c.kind()) {\n-            case EnumDecl:\n-                return createEnum(c, Declaration::enum_, Declaration::enum_);\n-            case EnumConstantDecl:\n-                return createEnumConstant(c);\n-            case FieldDecl:\n-                return createVar(c.isBitField() ?\n-                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n-            case ParmDecl:\n-                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n-            case FunctionDecl:\n-                return createFunction(c);\n-            case StructDecl:\n-                return createRecord(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n-            case UnionDecl:\n-                return createRecord(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n-            case TypedefDecl: {\n-                return createTypedef(c);\n-            }\n-            case VarDecl:\n-                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n-            default:\n-                return null;\n-        }\n+        return switch (c.kind()) {\n+            case EnumDecl -> createEnum(c);\n+            case EnumConstantDecl -> createEnumConstant(c);\n+            case FieldDecl -> c.isBitField() ?\n+                        createBitfield(c) :\n+                        createVar(c, Declaration.Variable.Kind.FIELD);\n+            case ParmDecl -> createVar(c, Declaration.Variable.Kind.PARAMETER);\n+            case FunctionDecl -> createFunction(c);\n+            case StructDecl -> createRecord(c, Declaration.Scoped.Kind.STRUCT);\n+            case UnionDecl -> createRecord(c, Declaration.Scoped.Kind.UNION);\n+            case TypedefDecl -> createTypedef(c);\n+            case VarDecl -> createVar(c, Declaration.Variable.Kind.GLOBAL);\n+            default -> null; \/\/ skip\n+        };\n@@ -189,1 +166,1 @@\n-    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+    public Declaration.Scoped createRecord(Cursor c, Declaration.Scoped.Kind scopeKind) {\n@@ -194,1 +171,2 @@\n-            return factoryLayout.make(CursorPosition.of(c), c.spelling(), t.tree().layout().get(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(),\n+                                      t.tree().layout().get(), decls.toArray(new Declaration[0]));\n@@ -196,8 +174,3 @@\n-            \/\/just a declaration\n-            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n-                    scopeKind == Declaration.Scoped.Kind.UNION ||\n-                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n-                \/\/if there's a real definition somewhere else, skip this redundant declaration\n-                if (!c.getDefinition().isInvalid()) {\n-                    return null;\n-                }\n+            \/\/if there's a real definition somewhere else, skip this redundant declaration\n+            if (!c.getDefinition().isInvalid()) {\n+                return null;\n@@ -205,1 +178,1 @@\n-            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return Declaration.scoped(scopeKind, CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n@@ -209,1 +182,1 @@\n-    public Declaration.Scoped createEnum(Cursor c, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+    public Declaration.Scoped createEnum(Cursor c) {\n@@ -222,1 +195,1 @@\n-            return factoryLayout.make(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), layout, decls.toArray(new Declaration[0]));\n@@ -229,1 +202,1 @@\n-            return factoryNoLayout.make(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            return Declaration.enum_(CursorPosition.of(c), c.spelling(), decls.toArray(new Declaration[0]));\n@@ -306,1 +279,7 @@\n-    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+    private Declaration.Variable createBitfield(Cursor c) {\n+        checkCursorAny(c, CursorKind.FieldDecl);\n+        return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n+                MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n+    }\n+\n+    private Declaration.Variable createVar(Cursor c, Declaration.Variable.Kind kind) {\n@@ -308,13 +287,7 @@\n-        if (c.isBitField()) {\n-            return Declaration.bitfield(CursorPosition.of(c), c.spelling(), toType(c),\n-                    MemoryLayout.paddingLayout(c.getBitFieldWidth()));\n-        } else {\n-            Type type = null;\n-            try {\n-                type = toType(c);\n-            } catch (TypeMaker.TypeException ex) {\n-                System.err.println(ex);\n-                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n-                return null;\n-            }\n-            return varFactory.make(CursorPosition.of(c), c.spelling(), type);\n+        Type type;\n+        try {\n+            type = toType(c);\n+        } catch (TypeMaker.TypeException ex) {\n+            System.err.println(ex);\n+            System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+            return null;\n@@ -322,0 +295,1 @@\n+        return Declaration.var(kind, CursorPosition.of(c), c.spelling(), type);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TreeMaker.java","additions":40,"deletions":66,"binary":false,"changes":106,"status":"modified"}]}