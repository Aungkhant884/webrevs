{"files":[{"patch":"@@ -25,1 +25,1 @@\n-def jextract_version = \"19\"\n+def jextract_version = \"20\"\n@@ -43,1 +43,1 @@\n-    options.release = 19\n+    options.release = 20\n@@ -46,1 +46,1 @@\n-    options.forkOptions.executable = \"${jdk19_home}\/bin\/javac\"\n+    options.forkOptions.executable = \"${jdk20_home}\/bin\/javac\"\n@@ -86,1 +86,1 @@\n-    executable = \"${jdk19_home}\/bin\/jmod\"\n+    executable = \"${jdk20_home}\/bin\/jmod\"\n@@ -112,1 +112,1 @@\n-    executable = \"${jdk19_home}\/bin\/jlink\"\n+    executable = \"${jdk20_home}\/bin\/jlink\"\n@@ -148,1 +148,1 @@\n-    executable = \"${jdk19_home}\/bin\/jlink\"\n+    executable = \"${jdk20_home}\/bin\/jlink\"\n@@ -150,1 +150,1 @@\n-         \"--module-path=$jmods_dir\" + File.pathSeparator + \"$jdk19_home\/jmods\",\n+         \"--module-path=$jmods_dir\" + File.pathSeparator + \"$jdk20_home\/jmods\",\n","filename":"build.gradle","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n","filename":"samples\/cblas\/TestBlas.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-javac --enable-preview --source=19 blas\/*.java\n+javac --enable-preview --source=20 blas\/*.java\n","filename":"samples\/cblas\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-time java --enable-native-access=ALL-UNNAMED --enable-preview --source=19 \\\n+time java --enable-native-access=ALL-UNNAMED --enable-preview --source=20 \\\n","filename":"samples\/cblas\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            if (handle == MemoryAddress.NULL) {\n+            if (handle == MemorySegment.NULL) {\n@@ -51,2 +51,2 @@\n-                return addr == MemoryAddress.NULL ?\n-                            Optional.empty() : Optional.of(MemorySegment.ofAddress(addr, 0, session));\n+                return addr == MemorySegment.NULL ?\n+                            Optional.empty() : Optional.of(addr);\n","filename":"samples\/dlopen\/Dlopen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-javac --enable-preview --source=19 org\/unix\/*.java\n+javac --enable-preview --source=20 org\/unix\/*.java\n","filename":"samples\/dlopen\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   --enable-preview --source=19 \\\n+   --enable-preview --source=20 \\\n","filename":"samples\/dlopen\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-javac --enable-preview --source=19 org\/golang\/*.java\n+javac --enable-preview --source=20 org\/golang\/*.java\n","filename":"samples\/go\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-preview --source=19 --enable-native-access=ALL-UNNAMED Main.java\n+java --enable-preview --source=20 --enable-native-access=ALL-UNNAMED Main.java\n","filename":"samples\/go\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-javac --enable-preview --source=19 org\/hello\/*.java\n+javac --enable-preview --source=20 org\/hello\/*.java\n","filename":"samples\/helloworld\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED --enable-preview --source=19 HelloWorld.java\n+java --enable-native-access=ALL-UNNAMED --enable-preview --source=20 HelloWorld.java\n","filename":"samples\/helloworld\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-javac --enable-preview --source=19 lapack\/*.java\n+javac --enable-preview --source=20 lapack\/*.java\n","filename":"samples\/lapack\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-java --enable-native-access=ALL-UNNAMED --enable-preview --source=19 \\\n+java --enable-native-access=ALL-UNNAMED --enable-preview --source=20 \\\n","filename":"samples\/lapack\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/libclang\/ASTPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-javac --enable-preview --source=19 org\/llvm\/clang\/*.java\n+javac --enable-preview --source=20 org\/llvm\/clang\/*.java\n","filename":"samples\/libclang\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/libclang\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/libcurl\/CurlMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-javac --enable-preview --source=19 org\/jextract\/*.java\n+javac --enable-preview --source=20 org\/jextract\/*.java\n","filename":"samples\/libcurl\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/libcurl\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n@@ -107,1 +107,1 @@\n-            var formatCtx = MemorySegment.ofAddress(pFormatCtx, AVFormatContext.sizeof(), session);\n+            var formatCtx = MemorySegment.ofAddress(pFormatCtx.address(), AVFormatContext.sizeof(), session);\n@@ -113,1 +113,1 @@\n-            var streamsArray = MemorySegment.ofAddress(pStreams, nb_streams * C_POINTER.byteSize(), session);\n+            var streamsArray = MemorySegment.ofAddress(pStreams.address(), nb_streams * C_POINTER.byteSize(), session);\n@@ -123,1 +123,1 @@\n-                var stream = MemorySegment.ofAddress(pStream, AVStream.sizeof(), session);\n+                var stream = MemorySegment.ofAddress(pStream.address(), AVStream.sizeof(), session);\n@@ -126,1 +126,1 @@\n-                var avcodecCtx = MemorySegment.ofAddress(pCodecCtx, AVCodecContext.sizeof(), session);\n+                var avcodecCtx = MemorySegment.ofAddress(pCodecCtx.address(), AVCodecContext.sizeof(), session);\n@@ -168,1 +168,1 @@\n-            var codecCtx = MemorySegment.ofAddress(pCodecCtx, AVCodecContext.sizeof(), session);\n+            var codecCtx = MemorySegment.ofAddress(pCodecCtx.address(), AVCodecContext.sizeof(), session);\n@@ -178,1 +178,1 @@\n-            var frame = MemorySegment.ofAddress(pFrame, AVFrame.sizeof(), session);\n+            var frame = MemorySegment.ofAddress(pFrame.address(), AVFrame.sizeof(), session);\n@@ -182,1 +182,1 @@\n-            var frameRGB = MemorySegment.ofAddress(pFrameRGB, AVFrame.sizeof(), session);\n+            var frameRGB = MemorySegment.ofAddress(pFrameRGB.address(), AVFrame.sizeof(), session);\n@@ -284,1 +284,1 @@\n-                var pixelArray = MemorySegment.ofAddress(pdata.addOffset(y*linesize), 3*width, session);\n+                var pixelArray = MemorySegment.ofAddress(pdata.address() + y*linesize, 3*width, session);\n","filename":"samples\/libffmpeg\/LibffmpegMain.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/include \\\n","filename":"samples\/libffmpeg\/compile.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2\/include \\\n+  -I \/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/include \\\n@@ -11,1 +11,1 @@\n-javac --enable-preview --source=19 libffmpeg\/*.java\n+javac --enable-preview --source=20 libffmpeg\/*.java\n","filename":"samples\/libffmpeg\/compilesource.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-   --enable-preview --source=19 \\\n-   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.2\/lib LibffmpegMain.java $*\n+   --enable-preview --source=20 \\\n+   -Djava.library.path=\/usr\/local\/Cellar\/ffmpeg@4\/4.4.2_3\/lib LibffmpegMain.java $*\n","filename":"samples\/libffmpeg\/run.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -36,1 +35,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/libgit2\/GitClone.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-javac --enable-preview --source=19 com\/github\/*.java\n+javac --enable-preview --source=20 com\/github\/*.java\n","filename":"samples\/libgit2\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/libgit2\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/libjimage\/JImageFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-javac -d build --enable-preview --source=19 org\/openjdk\/*.java\n+javac -d build --enable-preview --source=20 org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compile.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-javac -d build --enable-preview --source=19 org\/openjdk\/*.java\n+javac -d build --enable-preview --source=20 org\/openjdk\/*.java\n","filename":"samples\/libjimage\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64);\n+    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64).asUnbounded();\n","filename":"samples\/libjimage\/org\/openjdk\/Constants$root.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    void apply(java.lang.foreign.MemoryAddress jimage);\n+    void apply(java.lang.foreign.MemorySegment jimage);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageClose_t.class, fi, constants$0.JImageClose_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;)V\", session);\n+        return RuntimeHelper.upcallStub(JImageClose_t.class, fi, constants$0.JImageClose_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageClose_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage) -> {\n+    static JImageClose_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage) -> {\n@@ -20,1 +20,1 @@\n-                constants$0.JImageClose_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage);\n+                constants$0.JImageClose_t$MH.invokeExact((MemorySegment)symbol, _jimage);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageClose_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    long apply(java.lang.foreign.MemoryAddress jimage, java.lang.foreign.MemoryAddress module_name, java.lang.foreign.MemoryAddress version, java.lang.foreign.MemoryAddress name, java.lang.foreign.MemoryAddress size);\n+    long apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment size);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageFindResource_t.class, fi, constants$1.JImageFindResource_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;)J\", session);\n+        return RuntimeHelper.upcallStub(JImageFindResource_t.class, fi, constants$1.JImageFindResource_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageFindResource_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage, java.lang.foreign.MemoryAddress _module_name, java.lang.foreign.MemoryAddress _version, java.lang.foreign.MemoryAddress _name, java.lang.foreign.MemoryAddress _size) -> {\n+    static JImageFindResource_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _size) -> {\n@@ -20,1 +20,1 @@\n-                return (long)constants$1.JImageFindResource_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage, (java.lang.foreign.Addressable)_module_name, (java.lang.foreign.Addressable)_version, (java.lang.foreign.Addressable)_name, (java.lang.foreign.Addressable)_size);\n+                return (long)constants$1.JImageFindResource_t$MH.invokeExact((MemorySegment)symbol, _jimage, _module_name, _version, _name, _size);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageFindResource_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    long apply(java.lang.foreign.MemoryAddress jimage, long location, java.lang.foreign.MemoryAddress buffer, long size);\n+    long apply(java.lang.foreign.MemorySegment jimage, long location, java.lang.foreign.MemorySegment buffer, long size);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageGetResource_t.class, fi, constants$2.JImageGetResource_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;JLjava\/lang\/foreign\/MemoryAddress;J)J\", session);\n+        return RuntimeHelper.upcallStub(JImageGetResource_t.class, fi, constants$2.JImageGetResource_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageGetResource_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage, long _location, java.lang.foreign.MemoryAddress _buffer, long _size) -> {\n+    static JImageGetResource_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage, long _location, java.lang.foreign.MemorySegment _buffer, long _size) -> {\n@@ -20,1 +20,1 @@\n-                return (long)constants$2.JImageGetResource_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage, _location, (java.lang.foreign.Addressable)_buffer, _size);\n+                return (long)constants$2.JImageGetResource_t$MH.invokeExact((MemorySegment)symbol, _jimage, _location, _buffer, _size);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageGetResource_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress name, java.lang.foreign.MemoryAddress error);\n+    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment error);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageOpen_t.class, fi, constants$0.JImageOpen_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;)Ljava\/lang\/foreign\/Addressable;\", session);\n+        return RuntimeHelper.upcallStub(JImageOpen_t.class, fi, constants$0.JImageOpen_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageOpen_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _name, java.lang.foreign.MemoryAddress _error) -> {\n+    static JImageOpen_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _error) -> {\n@@ -20,1 +20,1 @@\n-                return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)constants$0.JImageOpen_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_name, (java.lang.foreign.Addressable)_error);\n+                return (java.lang.foreign.MemorySegment)constants$0.JImageOpen_t$MH.invokeExact((MemorySegment)symbol, _name, _error);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageOpen_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress jimage, java.lang.foreign.MemoryAddress package_name);\n+    java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment package_name);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImagePackageToModule_t.class, fi, constants$1.JImagePackageToModule_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;)Ljava\/lang\/foreign\/Addressable;\", session);\n+        return RuntimeHelper.upcallStub(JImagePackageToModule_t.class, fi, constants$1.JImagePackageToModule_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImagePackageToModule_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage, java.lang.foreign.MemoryAddress _package_name) -> {\n+    static JImagePackageToModule_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _package_name) -> {\n@@ -20,1 +20,1 @@\n-                return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)constants$1.JImagePackageToModule_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage, (java.lang.foreign.Addressable)_package_name);\n+                return (java.lang.foreign.MemorySegment)constants$1.JImagePackageToModule_t$MH.invokeExact((MemorySegment)symbol, _jimage, _package_name);\n","filename":"samples\/libjimage\/org\/openjdk\/JImagePackageToModule_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    void apply(java.lang.foreign.MemoryAddress jimage, java.lang.foreign.MemoryAddress visitor, java.lang.foreign.MemoryAddress arg);\n+    void apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment visitor, java.lang.foreign.MemorySegment arg);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageResourceIterator_t.class, fi, constants$3.JImageResourceIterator_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;)V\", session);\n+        return RuntimeHelper.upcallStub(JImageResourceIterator_t.class, fi, constants$3.JImageResourceIterator_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageResourceIterator_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage, java.lang.foreign.MemoryAddress _visitor, java.lang.foreign.MemoryAddress _arg) -> {\n+    static JImageResourceIterator_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _visitor, java.lang.foreign.MemorySegment _arg) -> {\n@@ -20,1 +20,1 @@\n-                constants$3.JImageResourceIterator_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage, (java.lang.foreign.Addressable)_visitor, (java.lang.foreign.Addressable)_arg);\n+                constants$3.JImageResourceIterator_t$MH.invokeExact((MemorySegment)symbol, _jimage, _visitor, _arg);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceIterator_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    int apply(java.lang.foreign.MemoryAddress jimage, java.lang.foreign.MemoryAddress module_name, java.lang.foreign.MemoryAddress version, java.lang.foreign.MemoryAddress package_, java.lang.foreign.MemoryAddress name, java.lang.foreign.MemoryAddress extension, java.lang.foreign.MemoryAddress arg);\n+    int apply(java.lang.foreign.MemorySegment jimage, java.lang.foreign.MemorySegment module_name, java.lang.foreign.MemorySegment version, java.lang.foreign.MemorySegment package_, java.lang.foreign.MemorySegment name, java.lang.foreign.MemorySegment extension, java.lang.foreign.MemorySegment arg);\n@@ -14,1 +14,1 @@\n-        return RuntimeHelper.upcallStub(JImageResourceVisitor_t.class, fi, constants$2.JImageResourceVisitor_t$FUNC, \"(Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;Ljava\/lang\/foreign\/MemoryAddress;)I\", session);\n+        return RuntimeHelper.upcallStub(JImageResourceVisitor_t.class, fi, constants$2.JImageResourceVisitor_t$FUNC, session);\n@@ -16,3 +16,3 @@\n-    static JImageResourceVisitor_t ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemoryAddress _jimage, java.lang.foreign.MemoryAddress _module_name, java.lang.foreign.MemoryAddress _version, java.lang.foreign.MemoryAddress _package_, java.lang.foreign.MemoryAddress _name, java.lang.foreign.MemoryAddress _extension, java.lang.foreign.MemoryAddress _arg) -> {\n+    static JImageResourceVisitor_t ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _jimage, java.lang.foreign.MemorySegment _module_name, java.lang.foreign.MemorySegment _version, java.lang.foreign.MemorySegment _package_, java.lang.foreign.MemorySegment _name, java.lang.foreign.MemorySegment _extension, java.lang.foreign.MemorySegment _arg) -> {\n@@ -20,1 +20,1 @@\n-                return (int)constants$2.JImageResourceVisitor_t$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)_jimage, (java.lang.foreign.Addressable)_module_name, (java.lang.foreign.Addressable)_version, (java.lang.foreign.Addressable)_package_, (java.lang.foreign.Addressable)_name, (java.lang.foreign.Addressable)_extension, (java.lang.foreign.Addressable)_arg);\n+                return (int)constants$2.JImageResourceVisitor_t$MH.invokeExact((MemorySegment)symbol, _jimage, _module_name, _version, _package_, _name, _extension, _arg);\n","filename":"samples\/libjimage\/org\/openjdk\/JImageResourceVisitor_t.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-import java.lang.foreign.Addressable;\n@@ -9,1 +8,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -37,1 +35,1 @@\n-            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.global());\n@@ -64,1 +62,1 @@\n-        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.openShared())).orElse(null);\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.global())).orElse(null);\n@@ -67,7 +65,4 @@\n-    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {\n-        return SYMBOL_LOOKUP.lookup(name).map(\n-                addr -> {\n-                    return variadic ?\n-                        VarargsInvoker.make(addr, fdesc) :\n-                        LINKER.downcallHandle(addr, fdesc);\n-                }).orElse(null);\n+    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc) {\n+        return SYMBOL_LOOKUP.lookup(name).\n+                map(addr -> LINKER.downcallHandle(addr, fdesc)).\n+                orElse(null);\n@@ -76,4 +71,1 @@\n-    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {\n-        if (variadic) {\n-            throw new AssertionError(\"Cannot get here!\");\n-        }\n+    static final MethodHandle downcallHandle(FunctionDescriptor fdesc) {\n@@ -83,1 +75,7 @@\n-    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, MemorySession session) {\n+    static final MethodHandle downcallHandleVariadic(String name, FunctionDescriptor fdesc) {\n+        return SYMBOL_LOOKUP.lookup(name).\n+                map(addr -> VarargsInvoker.make(addr, fdesc)).\n+                orElse(null);\n+    }\n+\n+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, MemorySession session) {\n@@ -85,2 +83,1 @@\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n-                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", Linker.methodType(fdesc));\n@@ -94,2 +91,2 @@\n-    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, MemorySession session) {\n-         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), session);\n+    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, MemorySession session) {\n+         return MemorySegment.ofAddress(addr.address(), numElements * layout.byteSize(), session);\n@@ -126,1 +123,3 @@\n-            if (mtype.returnType().equals(MemorySegment.class)) {\n+            boolean needsAllocator = function.returnLayout().isPresent() &&\n+                                function.returnLayout().get() instanceof GroupLayout;\n+            if (needsAllocator) {\n@@ -136,2 +135,1 @@\n-                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n-                        valueLayout.carrier() : Addressable.class;\n+                return valueLayout.carrier();\n@@ -172,1 +170,3 @@\n-            if (mh.type().returnType() == MemorySegment.class) {\n+            boolean needsAllocator = function.returnLayout().isPresent() &&\n+                                            function.returnLayout().get() instanceof GroupLayout;\n+            if (needsAllocator) {\n@@ -222,4 +222,1 @@\n-            if (MemoryAddress.class.isAssignableFrom(c)) {\n-                return MemoryAddress.class;\n-            }\n-            if (MemorySegment.class.isAssignableFrom(c)) {\n+            if (c == MemorySegment.class) {\n@@ -236,1 +233,1 @@\n-            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+            } else if (c == MemorySegment.class) {\n","filename":"samples\/libjimage\/org\/openjdk\/RuntimeHelper.java","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        constants$0.JIMAGE_Open$FUNC, false\n+        constants$0.JIMAGE_Open$FUNC\n@@ -25,1 +25,1 @@\n-        constants$0.JImageOpen_t$FUNC, false\n+        constants$0.JImageOpen_t$FUNC\n@@ -32,1 +32,1 @@\n-        constants$0.JIMAGE_Close$FUNC, false\n+        constants$0.JIMAGE_Close$FUNC\n@@ -38,1 +38,1 @@\n-        constants$0.JImageClose_t$FUNC, false\n+        constants$0.JImageClose_t$FUNC\n","filename":"samples\/libjimage\/org\/openjdk\/constants$0.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        constants$1.JIMAGE_PackageToModule$FUNC, false\n+        constants$1.JIMAGE_PackageToModule$FUNC\n@@ -25,1 +25,1 @@\n-        constants$1.JImagePackageToModule_t$FUNC, false\n+        constants$1.JImagePackageToModule_t$FUNC\n@@ -36,1 +36,1 @@\n-        constants$1.JIMAGE_FindResource$FUNC, false\n+        constants$1.JIMAGE_FindResource$FUNC\n@@ -46,1 +46,1 @@\n-        constants$1.JImageFindResource_t$FUNC, false\n+        constants$1.JImageFindResource_t$FUNC\n","filename":"samples\/libjimage\/org\/openjdk\/constants$1.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-        constants$2.JIMAGE_GetResource$FUNC, false\n+        constants$2.JIMAGE_GetResource$FUNC\n@@ -29,1 +29,1 @@\n-        constants$2.JImageGetResource_t$FUNC, false\n+        constants$2.JImageGetResource_t$FUNC\n@@ -41,1 +41,1 @@\n-        constants$2.JImageResourceVisitor_t$FUNC, false\n+        constants$2.JImageResourceVisitor_t$FUNC\n@@ -50,1 +50,1 @@\n-        constants$2.JIMAGE_ResourceIterator$FUNC, false\n+        constants$2.JIMAGE_ResourceIterator$FUNC\n","filename":"samples\/libjimage\/org\/openjdk\/constants$2.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        constants$3.JImageResourceIterator_t$FUNC, false\n+        constants$3.JImageResourceIterator_t$FUNC\n","filename":"samples\/libjimage\/org\/openjdk\/constants$3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-    public static MemoryAddress JIMAGE_Open ( Addressable name,  Addressable error) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$0.JIMAGE_Open$MH, \"JIMAGE_Open\");\n+    public static MemorySegment JIMAGE_Open ( MemorySegment name,  MemorySegment error) {\n+        var mh$ = JIMAGE_Open$MH();\n@@ -33,1 +33,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(name, error);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(name, error);\n@@ -41,2 +41,2 @@\n-    public static void JIMAGE_Close ( Addressable jimage) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$0.JIMAGE_Close$MH, \"JIMAGE_Close\");\n+    public static void JIMAGE_Close ( MemorySegment jimage) {\n+        var mh$ = JIMAGE_Close$MH();\n@@ -52,2 +52,2 @@\n-    public static MemoryAddress JIMAGE_PackageToModule ( Addressable jimage,  Addressable package_name) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$1.JIMAGE_PackageToModule$MH, \"JIMAGE_PackageToModule\");\n+    public static MemorySegment JIMAGE_PackageToModule ( MemorySegment jimage,  MemorySegment package_name) {\n+        var mh$ = JIMAGE_PackageToModule$MH();\n@@ -55,1 +55,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(jimage, package_name);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(jimage, package_name);\n@@ -63,2 +63,2 @@\n-    public static long JIMAGE_FindResource ( Addressable jimage,  Addressable module_name,  Addressable version,  Addressable name,  Addressable size) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$1.JIMAGE_FindResource$MH, \"JIMAGE_FindResource\");\n+    public static long JIMAGE_FindResource ( MemorySegment jimage,  MemorySegment module_name,  MemorySegment version,  MemorySegment name,  MemorySegment size) {\n+        var mh$ = JIMAGE_FindResource$MH();\n@@ -74,2 +74,2 @@\n-    public static long JIMAGE_GetResource ( Addressable jimage,  long location,  Addressable buffer,  long size) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$2.JIMAGE_GetResource$MH, \"JIMAGE_GetResource\");\n+    public static long JIMAGE_GetResource ( MemorySegment jimage,  long location,  MemorySegment buffer,  long size) {\n+        var mh$ = JIMAGE_GetResource$MH();\n@@ -85,2 +85,2 @@\n-    public static void JIMAGE_ResourceIterator ( Addressable jimage,  Addressable visitor,  Addressable arg) {\n-        var mh$ = RuntimeHelper.requireNonNull(constants$2.JIMAGE_ResourceIterator$MH, \"JIMAGE_ResourceIterator\");\n+    public static void JIMAGE_ResourceIterator ( MemorySegment jimage,  MemorySegment visitor,  MemorySegment arg) {\n+        var mh$ = JIMAGE_ResourceIterator$MH();\n","filename":"samples\/libjimage\/org\/openjdk\/jimage_h.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   --enable-preview --source=19 \\\n+   --enable-preview --source=20 \\\n","filename":"samples\/libjimage\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/libproc\/LibprocMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-javac --enable-preview --source=19 org\/unix\/*.java\n+javac --enable-preview --source=20 org\/unix\/*.java\n","filename":"samples\/libproc\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   --enable-preview --source=19 \\\n+   --enable-preview --source=20 \\\n","filename":"samples\/libproc\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/lp_solve\/LpSolveDemo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-javac --enable-preview --source=19 net\/sourceforge\/lpsolve\/*.java\n+javac --enable-preview --source=20 net\/sourceforge\/lpsolve\/*.java\n","filename":"samples\/lp_solve\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   --source=19 --enable-preview \\\n+   --source=20 --enable-preview \\\n","filename":"samples\/lp_solve\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-javac --enable-preview --source=19 opengl\/*.java\n+javac --enable-preview --source=20 opengl\/*.java\n","filename":"samples\/opengl\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/opengl\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"samples\/python3\/PythonMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-javac --enable-preview --source=19 org\/python\/*.java\n+javac --enable-preview --source=20 org\/python\/*.java\n","filename":"samples\/python3\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/python3\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-javac --enable-preview --source=19 org\/unix\/*.java\n+javac --enable-preview --source=20 org\/unix\/*.java\n","filename":"samples\/readline\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/readline\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -37,1 +36,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n@@ -99,2 +98,2 @@\n-                var argv_seg = MemorySegment.ofAddress(argv, C_POINTER.byteSize() * argc, session);\n-                var columnNames_seg = MemorySegment.ofAddress(columnNames, C_POINTER.byteSize() * argc, session);\n+                var argv_seg = MemorySegment.ofAddress(argv.address(), C_POINTER.byteSize() * argc, session);\n+                var columnNames_seg = MemorySegment.ofAddress(columnNames.address(), C_POINTER.byteSize() * argc, session);\n","filename":"samples\/sqlite\/SqliteMain.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-javac --enable-preview --source=19 org\/sqlite\/*.java\n+javac --enable-preview --source=20 org\/sqlite\/*.java\n","filename":"samples\/sqlite\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   --enable-preview --source=19 \\\n+   --enable-preview --source=20 \\\n","filename":"samples\/sqlite\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-javac --enable-preview --source=19 org\/tcl\/*.java\n+javac --enable-preview --source=20 org\/tcl\/*.java\n","filename":"samples\/tcl\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/tcl\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import static java.lang.foreign.MemoryAddress.*;\n+import static java.lang.foreign.MemorySegment.*;\n","filename":"samples\/tensorflow\/TensorflowLoadSavedModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-javac --enable-preview --source=19 org\/tensorflow\/*.java\n+javac --enable-preview --source=20 org\/tensorflow\/*.java\n","filename":"samples\/tensorflow\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   --enable-preview --source=19 \\\n+   --enable-preview --source=20 \\\n","filename":"samples\/tensorflow\/loadsavedmodel.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-javac --enable-preview --source=19 org\/unix\/*.java\n+javac --enable-preview --source=20 org\/unix\/*.java\n","filename":"samples\/time\/compilesource.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-    --enable-preview --source=19 \\\n+    --enable-preview --source=20 \\\n","filename":"samples\/time\/run.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -45,1 +44,1 @@\n-    public ClangDisposable(MemoryAddress ptr, long size, Runnable cleanup) {\n+    public ClangDisposable(MemorySegment ptr, long size, Runnable cleanup) {\n@@ -47,1 +46,1 @@\n-        this.ptr = MemorySegment.ofAddress(ptr, size, session).asReadOnly();\n+        this.ptr = MemorySegment.ofAddress(ptr.address(), size, session).asReadOnly();\n@@ -52,1 +51,1 @@\n-    public ClangDisposable(MemoryAddress ptr, Runnable cleanup) {\n+    public ClangDisposable(MemorySegment ptr, Runnable cleanup) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/ClangDisposable.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -236,1 +235,1 @@\n-        }, MemorySession.openImplicit());\n+        }, MemorySession.global());\n@@ -243,1 +242,1 @@\n-                Index_h.clang_visitChildren(c.segment, callback, MemoryAddress.NULL);\n+                Index_h.clang_visitChildren(c.segment, callback, MemorySegment.NULL);\n@@ -255,1 +254,1 @@\n-    private MemoryAddress eval0() {\n+    private MemorySegment eval0() {\n@@ -260,2 +259,2 @@\n-        MemoryAddress ptr = eval0();\n-        return ptr == MemoryAddress.NULL ? EvalResult.erroneous : new EvalResult(ptr);\n+        MemorySegment ptr = eval0();\n+        return ptr == MemorySegment.NULL ? EvalResult.erroneous : new EvalResult(ptr);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Cursor.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -67,1 +67,1 @@\n-    Diagnostic(MemoryAddress ptr) {\n+    Diagnostic(MemorySegment ptr) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Diagnostic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -34,1 +34,1 @@\n-    private MemoryAddress ptr;\n+    private MemorySegment ptr;\n@@ -36,1 +36,1 @@\n-    public EvalResult(MemoryAddress ptr) {\n+    public EvalResult(MemorySegment ptr) {\n@@ -93,1 +93,1 @@\n-        MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);\n+        MemorySegment value = Index_h.clang_EvalResult_getAsStr(ptr);\n@@ -109,1 +109,1 @@\n-        if (ptr != MemoryAddress.NULL) {\n+        if (ptr != MemorySegment.NULL) {\n@@ -111,1 +111,1 @@\n-            ptr = MemoryAddress.NULL;\n+            ptr = MemorySegment.NULL;\n@@ -115,1 +115,1 @@\n-    final static EvalResult erroneous = new EvalResult(MemoryAddress.NULL) {\n+    final static EvalResult erroneous = new EvalResult(MemorySegment.NULL) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/EvalResult.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +30,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -33,0 +31,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -42,1 +41,1 @@\n-    Index(MemoryAddress addr) {\n+    Index(MemorySegment addr) {\n@@ -85,2 +84,2 @@\n-                    cargs == null ? MemoryAddress.NULL : cargs,\n-                    args.length, MemoryAddress.NULL,\n+                    cargs == null ? MemorySegment.NULL : cargs,\n+                    args.length, MemorySegment.NULL,\n@@ -91,1 +90,1 @@\n-            MemoryAddress tu = outAddress.get(C_POINTER, 0);\n+            MemorySegment tu = outAddress.get(C_POINTER, 0);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Index.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryAddress;\n@@ -34,0 +30,2 @@\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.FunctionDescriptor;\n@@ -49,0 +47,2 @@\n+    private static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+\n@@ -50,2 +50,1 @@\n-            SegmentAllocator.implicitAllocator()\n-                            .allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n+            IMPLICIT_ALLOCATOR.allocateUtf8String(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n@@ -62,1 +61,1 @@\n-                int res = (int) PUT_ENV.invokeExact((Addressable)disableCrashRecovery);\n+                int res = (int) PUT_ENV.invokeExact((MemorySegment)disableCrashRecovery);\n@@ -78,1 +77,1 @@\n-        MemoryAddress buf = Index_h.clang_getCString(cxstr);\n+        MemorySegment buf = Index_h.clang_getCString(cxstr);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/LibClang.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -33,1 +33,1 @@\n-    private MemoryAddress policy;\n+    private MemorySegment policy;\n@@ -35,1 +35,1 @@\n-    PrintingPolicy(MemoryAddress policy) {\n+    PrintingPolicy(MemorySegment policy) {\n@@ -39,1 +39,1 @@\n-    MemoryAddress ptr() {\n+    MemorySegment ptr() {\n@@ -49,1 +49,1 @@\n-        if (policy != MemoryAddress.NULL) {\n+        if (policy != MemorySegment.NULL) {\n@@ -51,1 +51,1 @@\n-            policy = MemoryAddress.NULL;\n+            policy = MemorySegment.NULL;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/PrintingPolicy.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +29,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -34,0 +31,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -53,2 +51,2 @@\n-        void get(MemorySegment loc, Addressable file,\n-                 Addressable line, Addressable column, Addressable offset);\n+        void get(MemorySegment loc, MemorySegment file,\n+                 MemorySegment line, MemorySegment column, MemorySegment offset);\n@@ -60,4 +58,4 @@\n-             MemorySegment file = MemorySegment.allocateNative(C_POINTER, session);\n-             MemorySegment line = MemorySegment.allocateNative(C_INT, session);\n-             MemorySegment col = MemorySegment.allocateNative(C_INT, session);\n-             MemorySegment offset = MemorySegment.allocateNative(C_INT, session);\n+             MemorySegment file = session.allocate(C_POINTER);\n+             MemorySegment line = session.allocate(C_INT);\n+             MemorySegment col = session.allocate(C_INT);\n+             MemorySegment offset = session.allocate(C_INT);\n@@ -66,2 +64,2 @@\n-            MemoryAddress fname = file.get(C_POINTER, 0);\n-            String str = fname == MemoryAddress.NULL ?  null : getFileName(fname);\n+            MemorySegment fname = file.get(C_POINTER, 0);\n+            String str = fname.equals(MemorySegment.NULL) ?  null : getFileName(fname);\n@@ -74,1 +72,1 @@\n-    private static String getFileName(MemoryAddress fname) {\n+    private static String getFileName(MemorySegment fname) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/SourceLocation.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n@@ -32,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -50,1 +49,1 @@\n-    TranslationUnit(MemoryAddress addr) {\n+    TranslationUnit(MemorySegment addr) {\n@@ -74,1 +73,1 @@\n-            MemoryAddress diag = Index_h.clang_getDiagnostic(ptr, i);\n+            MemorySegment diag = Index_h.clang_getDiagnostic(ptr, i);\n@@ -101,1 +100,1 @@\n-                        files == null ? MemoryAddress.NULL : files,\n+                        files == null ? MemorySegment.NULL : files,\n@@ -128,2 +127,2 @@\n-            MemorySegment p = MemorySegment.allocateNative(C_POINTER, session);\n-            MemorySegment pCnt = MemorySegment.allocateNative(C_INT, session);\n+            MemorySegment p = session.allocate(C_POINTER);\n+            MemorySegment pCnt = session.allocate(C_INT);\n@@ -139,1 +138,1 @@\n-        Tokens(MemoryAddress addr, int size) {\n+        Tokens(MemorySegment addr, int size) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/TranslationUnit.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -108,2 +109,1 @@\n-            var allocator = session;\n-            MemorySegment cfname = allocator.allocateUtf8String(fieldName);\n+            MemorySegment cfname = session.allocateUtf8String(fieldName);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    int apply(java.lang.foreign.MemorySegment cursor, java.lang.foreign.MemorySegment parent, java.lang.foreign.MemoryAddress client_data);\n+    int apply(java.lang.foreign.MemorySegment cursor, java.lang.foreign.MemorySegment parent, java.lang.foreign.MemorySegment client_data);\n@@ -41,3 +41,3 @@\n-    static CXCursorVisitor ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);\n-        return (java.lang.foreign.MemorySegment _cursor, java.lang.foreign.MemorySegment _parent, java.lang.foreign.MemoryAddress _client_data) -> {\n+    static CXCursorVisitor ofAddress(MemorySegment addr, MemorySession session) {\n+        MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, session);\n+        return (java.lang.foreign.MemorySegment _cursor, java.lang.foreign.MemorySegment _parent, java.lang.foreign.MemorySegment _client_data) -> {\n@@ -45,1 +45,1 @@\n-                return (int)constants$13.CXCursorVisitor$MH.invokeExact((Addressable)symbol, _cursor, _parent, (java.lang.foreign.Addressable)_client_data);\n+                return (int)constants$13.CXCursorVisitor$MH.invokeExact((MemorySegment)symbol, _cursor, _parent, (java.lang.foreign.MemorySegment)_client_data);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXCursorVisitor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-    public static MemoryAddress data$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemoryAddress)CXString.data$VH.get(seg);\n+    public static MemorySegment data$get(MemorySegment seg) {\n+        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg);\n@@ -52,1 +52,1 @@\n-    public static void data$set( MemorySegment seg, MemoryAddress x) {\n+    public static void data$set( MemorySegment seg, MemorySegment x) {\n@@ -55,2 +55,2 @@\n-    public static MemoryAddress data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemoryAddress)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n+    public static MemorySegment data$get(MemorySegment seg, long index) {\n+        return (java.lang.foreign.MemorySegment)CXString.data$VH.get(seg.asSlice(index*sizeof()));\n@@ -58,1 +58,1 @@\n-    public static void data$set(MemorySegment seg, long index, MemoryAddress x) {\n+    public static void data$set(MemorySegment seg, long index, MemorySegment x) {\n@@ -82,1 +82,1 @@\n-    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n+    public static MemorySegment ofAddress(MemorySegment addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXString.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-    public static MemoryAddress ptr_data$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg);\n+    public static MemorySegment ptr_data$get(MemorySegment seg) {\n+        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg);\n@@ -54,1 +54,1 @@\n-    public static void ptr_data$set( MemorySegment seg, MemoryAddress x) {\n+    public static void ptr_data$set( MemorySegment seg, MemorySegment x) {\n@@ -57,2 +57,2 @@\n-    public static MemoryAddress ptr_data$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+    public static MemorySegment ptr_data$get(MemorySegment seg, long index) {\n+        return (java.lang.foreign.MemorySegment)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n@@ -60,1 +60,1 @@\n-    public static void ptr_data$set(MemorySegment seg, long index, MemoryAddress x) {\n+    public static void ptr_data$set(MemorySegment seg, long index, MemorySegment x) {\n@@ -68,1 +68,1 @@\n-    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n+    public static MemorySegment ofAddress(MemorySegment addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXToken.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n+    public static MemorySegment ofAddress(MemorySegment addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-    public static MemoryAddress Filename$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg);\n+    public static MemorySegment Filename$get(MemorySegment seg) {\n+        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg);\n@@ -52,1 +52,1 @@\n-    public static void Filename$set( MemorySegment seg, MemoryAddress x) {\n+    public static void Filename$set( MemorySegment seg, MemorySegment x) {\n@@ -55,2 +55,2 @@\n-    public static MemoryAddress Filename$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n+    public static MemorySegment Filename$get(MemorySegment seg, long index) {\n+        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n@@ -58,1 +58,1 @@\n-    public static void Filename$set(MemorySegment seg, long index, MemoryAddress x) {\n+    public static void Filename$set(MemorySegment seg, long index, MemorySegment x) {\n@@ -65,2 +65,2 @@\n-    public static MemoryAddress Contents$get(MemorySegment seg) {\n-        return (java.lang.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg);\n+    public static MemorySegment Contents$get(MemorySegment seg) {\n+        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg);\n@@ -68,1 +68,1 @@\n-    public static void Contents$set( MemorySegment seg, MemoryAddress x) {\n+    public static void Contents$set( MemorySegment seg, MemorySegment x) {\n@@ -71,2 +71,2 @@\n-    public static MemoryAddress Contents$get(MemorySegment seg, long index) {\n-        return (java.lang.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+    public static MemorySegment Contents$get(MemorySegment seg, long index) {\n+        return (java.lang.foreign.MemorySegment)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n@@ -74,1 +74,1 @@\n-    public static void Contents$set(MemorySegment seg, long index, MemoryAddress x) {\n+    public static void Contents$set(MemorySegment seg, long index, MemorySegment x) {\n@@ -98,1 +98,1 @@\n-    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n+    public static MemorySegment ofAddress(MemorySegment addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/CXUnsavedFile.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64);\n+    static final  OfAddress C_POINTER$LAYOUT = ADDRESS.withBitAlignment(64).asUnbounded();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Constants$root.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public static MemoryAddress clang_getCString ( MemorySegment string) {\n+    public static MemorySegment clang_getCString ( MemorySegment string) {\n@@ -67,1 +67,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(string);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(string);\n@@ -118,1 +118,1 @@\n-    public static MemoryAddress clang_createIndex ( int excludeDeclarationsFromPCH,  int displayDiagnostics) {\n+    public static MemorySegment clang_createIndex ( int excludeDeclarationsFromPCH,  int displayDiagnostics) {\n@@ -121,1 +121,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n@@ -129,1 +129,1 @@\n-    public static void clang_disposeIndex ( Addressable index) {\n+    public static void clang_disposeIndex ( MemorySegment index) {\n@@ -140,1 +140,1 @@\n-    public static MemorySegment clang_getFileName ( SegmentAllocator allocator,  Addressable SFile) {\n+    public static MemorySegment clang_getFileName ( SegmentAllocator allocator,  MemorySegment SFile) {\n@@ -173,1 +173,1 @@\n-    public static MemorySegment clang_getLocation ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int line,  int column) {\n+    public static MemorySegment clang_getLocation ( SegmentAllocator allocator,  MemorySegment tu,  MemorySegment file,  int line,  int column) {\n@@ -184,1 +184,1 @@\n-    public static MemorySegment clang_getLocationForOffset ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int offset) {\n+    public static MemorySegment clang_getLocationForOffset ( SegmentAllocator allocator,  MemorySegment tu,  MemorySegment file,  int offset) {\n@@ -228,1 +228,1 @@\n-    public static void clang_getExpansionLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+    public static void clang_getExpansionLocation ( MemorySegment location,  MemorySegment file,  MemorySegment line,  MemorySegment column,  MemorySegment offset) {\n@@ -239,1 +239,1 @@\n-    public static void clang_getSpellingLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+    public static void clang_getSpellingLocation ( MemorySegment location,  MemorySegment file,  MemorySegment line,  MemorySegment column,  MemorySegment offset) {\n@@ -250,1 +250,1 @@\n-    public static void clang_getFileLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+    public static void clang_getFileLocation ( MemorySegment location,  MemorySegment file,  MemorySegment line,  MemorySegment column,  MemorySegment offset) {\n@@ -298,1 +298,1 @@\n-    public static MemoryAddress clang_getChildDiagnostics ( Addressable D) {\n+    public static MemorySegment clang_getChildDiagnostics ( MemorySegment D) {\n@@ -301,1 +301,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(D);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(D);\n@@ -309,1 +309,1 @@\n-    public static int clang_getNumDiagnostics ( Addressable Unit) {\n+    public static int clang_getNumDiagnostics ( MemorySegment Unit) {\n@@ -320,1 +320,1 @@\n-    public static MemoryAddress clang_getDiagnostic ( Addressable Unit,  int Index) {\n+    public static MemorySegment clang_getDiagnostic ( MemorySegment Unit,  int Index) {\n@@ -323,1 +323,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(Unit, Index);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(Unit, Index);\n@@ -331,1 +331,1 @@\n-    public static void clang_disposeDiagnostic ( Addressable Diagnostic) {\n+    public static void clang_disposeDiagnostic ( MemorySegment Diagnostic) {\n@@ -360,1 +360,1 @@\n-    public static MemorySegment clang_formatDiagnostic ( SegmentAllocator allocator,  Addressable Diagnostic,  int Options) {\n+    public static MemorySegment clang_formatDiagnostic ( SegmentAllocator allocator,  MemorySegment Diagnostic,  int Options) {\n@@ -382,1 +382,1 @@\n-    public static int clang_getDiagnosticSeverity ( Addressable x0) {\n+    public static int clang_getDiagnosticSeverity ( MemorySegment x0) {\n@@ -393,1 +393,1 @@\n-    public static MemorySegment clang_getDiagnosticLocation ( SegmentAllocator allocator,  Addressable x1) {\n+    public static MemorySegment clang_getDiagnosticLocation ( SegmentAllocator allocator,  MemorySegment x1) {\n@@ -404,1 +404,1 @@\n-    public static MemorySegment clang_getDiagnosticSpelling ( SegmentAllocator allocator,  Addressable x1) {\n+    public static MemorySegment clang_getDiagnosticSpelling ( SegmentAllocator allocator,  MemorySegment x1) {\n@@ -466,1 +466,1 @@\n-    public static MemoryAddress clang_parseTranslationUnit ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options) {\n+    public static MemorySegment clang_parseTranslationUnit ( MemorySegment CIdx,  MemorySegment source_filename,  MemorySegment command_line_args,  int num_command_line_args,  MemorySegment unsaved_files,  int num_unsaved_files,  int options) {\n@@ -469,1 +469,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);\n@@ -477,1 +477,1 @@\n-    public static int clang_parseTranslationUnit2 ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options,  Addressable out_TU) {\n+    public static int clang_parseTranslationUnit2 ( MemorySegment CIdx,  MemorySegment source_filename,  MemorySegment command_line_args,  int num_command_line_args,  MemorySegment unsaved_files,  int num_unsaved_files,  int options,  MemorySegment out_TU) {\n@@ -503,1 +503,1 @@\n-    public static int clang_saveTranslationUnit ( Addressable TU,  Addressable FileName,  int options) {\n+    public static int clang_saveTranslationUnit ( MemorySegment TU,  MemorySegment FileName,  int options) {\n@@ -514,1 +514,1 @@\n-    public static void clang_disposeTranslationUnit ( Addressable x0) {\n+    public static void clang_disposeTranslationUnit ( MemorySegment x0) {\n@@ -528,1 +528,1 @@\n-    public static int clang_defaultReparseOptions ( Addressable TU) {\n+    public static int clang_defaultReparseOptions ( MemorySegment TU) {\n@@ -539,1 +539,1 @@\n-    public static int clang_reparseTranslationUnit ( Addressable TU,  int num_unsaved_files,  Addressable unsaved_files,  int options) {\n+    public static int clang_reparseTranslationUnit ( MemorySegment TU,  int num_unsaved_files,  MemorySegment unsaved_files,  int options) {\n@@ -1338,1 +1338,1 @@\n-    public static MemorySegment clang_getTranslationUnitCursor ( SegmentAllocator allocator,  Addressable x1) {\n+    public static MemorySegment clang_getTranslationUnitCursor ( SegmentAllocator allocator,  MemorySegment x1) {\n@@ -1449,1 +1449,1 @@\n-    public static MemoryAddress clang_Cursor_getTranslationUnit ( MemorySegment x0) {\n+    public static MemorySegment clang_Cursor_getTranslationUnit ( MemorySegment x0) {\n@@ -1452,1 +1452,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(x0);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n@@ -2245,1 +2245,1 @@\n-    public static long clang_Type_getOffsetOf ( MemorySegment T,  Addressable S) {\n+    public static long clang_Type_getOffsetOf ( MemorySegment T,  MemorySegment S) {\n@@ -2298,1 +2298,1 @@\n-    public static int clang_visitChildren ( MemorySegment parent,  Addressable visitor,  Addressable client_data) {\n+    public static int clang_visitChildren ( MemorySegment parent,  MemorySegment visitor,  MemorySegment client_data) {\n@@ -2412,1 +2412,1 @@\n-    public static int clang_PrintingPolicy_getProperty ( Addressable Policy,  int Property) {\n+    public static int clang_PrintingPolicy_getProperty ( MemorySegment Policy,  int Property) {\n@@ -2423,1 +2423,1 @@\n-    public static void clang_PrintingPolicy_setProperty ( Addressable Policy,  int Property,  int Value) {\n+    public static void clang_PrintingPolicy_setProperty ( MemorySegment Policy,  int Property,  int Value) {\n@@ -2434,1 +2434,1 @@\n-    public static MemoryAddress clang_getCursorPrintingPolicy ( MemorySegment x0) {\n+    public static MemorySegment clang_getCursorPrintingPolicy ( MemorySegment x0) {\n@@ -2437,1 +2437,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(x0);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(x0);\n@@ -2445,1 +2445,1 @@\n-    public static void clang_PrintingPolicy_dispose ( Addressable Policy) {\n+    public static void clang_PrintingPolicy_dispose ( MemorySegment Policy) {\n@@ -2456,1 +2456,1 @@\n-    public static MemorySegment clang_getCursorPrettyPrinted ( SegmentAllocator allocator,  MemorySegment Cursor,  Addressable Policy) {\n+    public static MemorySegment clang_getCursorPrettyPrinted ( SegmentAllocator allocator,  MemorySegment Cursor,  MemorySegment Policy) {\n@@ -2559,1 +2559,1 @@\n-    public static MemorySegment clang_getTokenSpelling ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+    public static MemorySegment clang_getTokenSpelling ( SegmentAllocator allocator,  MemorySegment x1,  MemorySegment x2) {\n@@ -2570,1 +2570,1 @@\n-    public static MemorySegment clang_getTokenLocation ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+    public static MemorySegment clang_getTokenLocation ( SegmentAllocator allocator,  MemorySegment x1,  MemorySegment x2) {\n@@ -2581,1 +2581,1 @@\n-    public static MemorySegment clang_getTokenExtent ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+    public static MemorySegment clang_getTokenExtent ( SegmentAllocator allocator,  MemorySegment x1,  MemorySegment x2) {\n@@ -2592,1 +2592,1 @@\n-    public static void clang_tokenize ( Addressable TU,  MemorySegment Range,  Addressable Tokens,  Addressable NumTokens) {\n+    public static void clang_tokenize ( MemorySegment TU,  MemorySegment Range,  MemorySegment Tokens,  MemorySegment NumTokens) {\n@@ -2603,1 +2603,1 @@\n-    public static void clang_disposeTokens ( Addressable TU,  Addressable Tokens,  int NumTokens) {\n+    public static void clang_disposeTokens ( MemorySegment TU,  MemorySegment Tokens,  int NumTokens) {\n@@ -2647,1 +2647,1 @@\n-    public static MemoryAddress clang_Cursor_Evaluate ( MemorySegment C) {\n+    public static MemorySegment clang_Cursor_Evaluate ( MemorySegment C) {\n@@ -2650,1 +2650,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(C);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(C);\n@@ -2658,1 +2658,1 @@\n-    public static int clang_EvalResult_getKind ( Addressable E) {\n+    public static int clang_EvalResult_getKind ( MemorySegment E) {\n@@ -2669,1 +2669,1 @@\n-    public static int clang_EvalResult_getAsInt ( Addressable E) {\n+    public static int clang_EvalResult_getAsInt ( MemorySegment E) {\n@@ -2680,1 +2680,1 @@\n-    public static long clang_EvalResult_getAsLongLong ( Addressable E) {\n+    public static long clang_EvalResult_getAsLongLong ( MemorySegment E) {\n@@ -2691,1 +2691,1 @@\n-    public static int clang_EvalResult_isUnsignedInt ( Addressable E) {\n+    public static int clang_EvalResult_isUnsignedInt ( MemorySegment E) {\n@@ -2702,1 +2702,1 @@\n-    public static long clang_EvalResult_getAsUnsigned ( Addressable E) {\n+    public static long clang_EvalResult_getAsUnsigned ( MemorySegment E) {\n@@ -2713,1 +2713,1 @@\n-    public static double clang_EvalResult_getAsDouble ( Addressable E) {\n+    public static double clang_EvalResult_getAsDouble ( MemorySegment E) {\n@@ -2724,1 +2724,1 @@\n-    public static MemoryAddress clang_EvalResult_getAsStr ( Addressable E) {\n+    public static MemorySegment clang_EvalResult_getAsStr ( MemorySegment E) {\n@@ -2727,1 +2727,1 @@\n-            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(E);\n+            return (java.lang.foreign.MemorySegment)mh$.invokeExact(E);\n@@ -2735,1 +2735,1 @@\n-    public static void clang_EvalResult_dispose ( Addressable E) {\n+    public static void clang_EvalResult_dispose ( MemorySegment E) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -34,1 +34,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -62,1 +62,1 @@\n-            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.global());\n@@ -83,1 +83,1 @@\n-        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.openShared())).orElse(null);\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.global())).orElse(null);\n@@ -104,1 +104,1 @@\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", Linker.upcallType(fdesc));\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", Linker.methodType(fdesc));\n@@ -112,2 +112,2 @@\n-    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, MemorySession session) {\n-         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), session);\n+    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, MemorySession session) {\n+         return MemorySegment.ofAddress(addr.address(), numElements * layout.byteSize(), session);\n@@ -154,2 +154,2 @@\n-                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n-                        valueLayout.carrier() : Addressable.class;\n+                return (ret || valueLayout.carrier() != MemorySegment.class) ?\n+                        valueLayout.carrier() : MemorySegment.class;\n@@ -240,2 +240,2 @@\n-            if (MemoryAddress.class.isAssignableFrom(c)) {\n-                return MemoryAddress.class;\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n@@ -254,1 +254,1 @@\n-            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+            } else if (MemorySegment.class.isAssignableFrom(c)) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/RuntimeHelper.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -99,1 +99,1 @@\n-        if (type == MemorySegment.class) {\n+        if (value instanceof String) {\n@@ -102,1 +102,1 @@\n-        } else if (type == MemoryAddress.class) {\n+        } else if (type == MemorySegment.class) {\n@@ -117,1 +117,1 @@\n-            ADDRESS(MemoryAddress.class, \"$ADDR\"),\n+            ADDRESS(MemorySegment.class, \"$ADDR\"),\n@@ -360,1 +360,1 @@\n-        append(\"MemoryAddress \");\n+        append(\"MemorySegment \");\n@@ -362,1 +362,1 @@\n-        append(\" = MemoryAddress.ofLong(\");\n+        append(\" = MemorySegment.ofAddress(\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ConstantBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-        this.fiType = Linker.upcallType(descriptor);\n-        this.downcallType = Linker.downcallType(descriptor);\n+        this.fiType = Linker.methodType(descriptor);\n+        this.downcallType = Linker.methodType(descriptor);\n@@ -113,1 +113,1 @@\n-            append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemoryAddress addr, MemorySession session) {\\n\");\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemorySegment addr, MemorySession session) {\\n\");\n@@ -117,1 +117,1 @@\n-            append(\"addr, 0, session);\\n\");\n+            append(\"addr.address(), 0, session);\\n\");\n@@ -140,1 +140,1 @@\n-            append(mhConstant.accessExpression() + \".invokeExact((Addressable)symbol\");\n+            append(mhConstant.accessExpression() + \".invokeExact((MemorySegment)symbol\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n@@ -33,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemoryLayout;\n@@ -99,2 +97,4 @@\n-            MethodType downcallType = Linker.downcallType(descriptor);\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, isVarargs, parameterNames);\n+            MethodType downcallType = Linker.methodType(descriptor);\n+            boolean needsAllocator = descriptor.returnLayout().isPresent() &&\n+                    descriptor.returnLayout().get() instanceof GroupLayout;\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, downcallType, needsAllocator, isVarargs, parameterNames);\n@@ -106,1 +106,1 @@\n-        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+        if (type.equals(MemorySegment.class)) {\n@@ -118,1 +118,2 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType declType, boolean isVarargs, List<String> parameterNames) {\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType declType,\n+                                     boolean needsAllocator, boolean isVarargs, List<String> parameterNames) {\n@@ -122,1 +123,1 @@\n-        if (declType.returnType().equals(MemorySegment.class)) {\n+        if (needsAllocator) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/HeaderFileBuilder.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-        append(\" MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\\n\");\n+        append(\" MemorySegment ofAddress(MemorySegment addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }\\n\");\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -257,2 +257,2 @@\n-            } else if (vl.carrier() == MemoryAddress.class) {\n-                return \"ADDRESS.withBitAlignment(\" + vl.bitAlignment() + \")\";\n+            } else if (vl.carrier() == MemorySegment.class) {\n+                return \"ADDRESS.withBitAlignment(\" + vl.bitAlignment() + \").asUnbounded()\";\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/ToplevelBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        public static final ValueLayout.OfAddress POINTER_LAYOUT = ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress POINTER_LAYOUT = ADDRESS.withBitAlignment(64).asUnbounded();\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                \"MemoryAddress\", \"MemoryLayout\",\n+                \"MemoryLayout\", \"MemorySession\",\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                \"--source\", \"19\",\n+                \"--source\", \"20\",\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/Writer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-import java.lang.foreign.Addressable;\n@@ -8,1 +7,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -36,1 +34,1 @@\n-            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n+            (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.global());\n@@ -54,1 +52,1 @@\n-        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.openShared())).orElse(null);\n+        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddress(symbol.address(), layout.byteSize(), MemorySession.global())).orElse(null);\n@@ -75,1 +73,1 @@\n-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", Linker.upcallType(fdesc));\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\", Linker.methodType(fdesc));\n@@ -83,2 +81,2 @@\n-    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, MemorySession session) {\n-         return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), session);\n+    static MemorySegment asArray(MemorySegment addr, MemoryLayout layout, int numElements, MemorySession session) {\n+         return MemorySegment.ofAddress(addr.address(), numElements * layout.byteSize(), session);\n@@ -115,1 +113,3 @@\n-            if (mtype.returnType().equals(MemorySegment.class)) {\n+            boolean needsAllocator = function.returnLayout().isPresent() &&\n+                                function.returnLayout().get() instanceof GroupLayout;\n+            if (needsAllocator) {\n@@ -125,2 +125,1 @@\n-                return (ret || valueLayout.carrier() != MemoryAddress.class) ?\n-                        valueLayout.carrier() : Addressable.class;\n+                return valueLayout.carrier();\n@@ -161,1 +160,3 @@\n-            if (mh.type().returnType() == MemorySegment.class) {\n+            boolean needsAllocator = function.returnLayout().isPresent() &&\n+                                            function.returnLayout().get() instanceof GroupLayout;\n+            if (needsAllocator) {\n@@ -211,4 +212,1 @@\n-            if (MemoryAddress.class.isAssignableFrom(c)) {\n-                return MemoryAddress.class;\n-            }\n-            if (MemorySegment.class.isAssignableFrom(c)) {\n+            if (c == MemorySegment.class) {\n@@ -225,1 +223,1 @@\n-            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+            } else if (c == MemorySegment.class) {\n","filename":"src\/main\/resources\/org\/openjdk\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -54,1 +54,1 @@\n-            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), session).address());\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), session));\n@@ -65,1 +65,1 @@\n-            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), session).address());\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), session));\n@@ -75,1 +75,1 @@\n-            f$set(Foo.allocate((i) -> val.set(i), session).address());\n+            f$set(Foo.allocate((i) -> val.set(i), session));\n@@ -85,1 +85,1 @@\n-            f$set(Foo.allocate((i) -> val.set(i), session).address());\n+            f$set(Foo.allocate((i) -> val.set(i), session));\n@@ -96,1 +96,1 @@\n-            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), session).address());\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), session));\n@@ -107,1 +107,1 @@\n-            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), session).address());\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), session));\n@@ -117,1 +117,1 @@\n-            fp$set(fp.allocate((i) -> val.set(i), session).address());\n+            fp$set(fp.allocate((i) -> val.set(i), session));\n@@ -127,1 +127,1 @@\n-            fp$set(fp.allocate((i) -> val.set(i), session).address());\n+            fp$set(fp.allocate((i) -> val.set(i), session));\n@@ -136,2 +136,2 @@\n-            fp_addr$set(fp_addr.allocate((addr) -> MemoryAddress.ofLong(addr.toRawLongValue() + 1), session).address());\n-            assertEquals(fp_addr.ofAddress(fp_addr$get(), session).apply(MemoryAddress.ofLong(42)), MemoryAddress.ofLong(43));\n+            fp_addr$set(fp_addr.allocate((addr) -> MemorySegment.ofAddress(addr.address() + 1), session));\n+            assertEquals(fp_addr.ofAddress(fp_addr$get(), session).apply(MemorySegment.ofAddress(42)).address(), MemorySegment.ofAddress(43).address());\n","filename":"test\/jtreg\/generator\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n","filename":"test\/jtreg\/generator\/test8244412\/LibTest8244412Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -57,1 +57,0 @@\n-                var addr = MemorySegment.ofAddress(argv, C_POINTER.byteSize() * argc, session);\n@@ -59,4 +58,4 @@\n-                assertEquals(addr.get(C_POINTER, 0).getUtf8String(0), \"java\");\n-                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 1).getUtf8String(0), \"python\");\n-                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 2).getUtf8String(0), \"javascript\");\n-                assertEquals(addr.get(C_POINTER, C_POINTER.byteSize() * 3).getUtf8String(0), \"c++\");\n+                assertEquals(argv.get(C_POINTER, 0).getUtf8String(0), \"java\");\n+                assertEquals(argv.get(C_POINTER, C_POINTER.byteSize() * 1).getUtf8String(0), \"python\");\n+                assertEquals(argv.get(C_POINTER, C_POINTER.byteSize() * 2).getUtf8String(0), \"javascript\");\n+                assertEquals(argv.get(C_POINTER, C_POINTER.byteSize() * 3).getUtf8String(0), \"c++\");\n@@ -72,3 +71,2 @@\n-            var allocator = SegmentAllocator.newNativeArena(C_POINTER.byteSize(), session);\n-            var addr = allocator.allocate(C_POINTER);\n-            addr.set(C_POINTER, 0, MemoryAddress.NULL);\n+            var addr = session.allocate(C_POINTER);\n+            addr.set(C_POINTER, 0, MemorySegment.NULL);\n","filename":"test\/jtreg\/generator\/test8246341\/LibTest8246341Test.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -68,1 +66,1 @@\n-            Addressable callback = cosine_similarity$dot.allocate((a, b) -> {\n+            MemorySegment callback = cosine_similarity$dot.allocate((a, b) -> {\n","filename":"test\/jtreg\/generator\/test8246400\/LibTest8246400Test.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            my_vsprintf(s, session.allocateUtf8String(\"%hhd %.2f %lld %lld\"), vaList);\n+            my_vsprintf(s, session.allocateUtf8String(\"%hhd %.2f %lld %lld\"), vaList.segment());\n","filename":"test\/jtreg\/generator\/test8252016\/Test8252016.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -53,1 +53,1 @@\n-            MemoryAddress addr = make(14, 99);\n+            MemorySegment addr = make(14, 99);\n","filename":"test\/jtreg\/generator\/test8253102\/LibTest8253102Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            var seg = MemorySegment.ofAddress(getFoo(), Foo.sizeof(), session);\n+            var seg = MemorySegment.ofAddress(getFoo().address(), Foo.sizeof(), session);\n","filename":"test\/jtreg\/generator\/test8257892\/LibUnsupportedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static java.lang.foreign.MemoryAddress.NULL;\n+import static java.lang.foreign.MemorySegment.NULL;\n","filename":"test\/jtreg\/generator\/test8258605\/LibTest8258605Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n","filename":"test\/jtreg\/generator\/test8259473\/LibTest8259473Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            commands.add(\"--source=19\");\n+            commands.add(\"--source=20\");\n","filename":"test\/lib\/JtregJextractSources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize()).asUnbounded();\n","filename":"test\/lib\/testlib\/JextractToolRunner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -99,2 +99,2 @@\n-                { \"ZERO_PTR\", MemoryAddress.class, equalsPtrContents(0) },\n-                { \"F_PTR\", MemoryAddress.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },\n+                { \"ZERO_PTR\", MemorySegment.class, equalsPtrContents(0) },\n+                { \"F_PTR\", MemorySegment.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },\n@@ -112,2 +112,2 @@\n-    static Consumer<MemoryAddress> equalsPtrContents(long expected) {\n-        return actual -> assertEquals(actual.toRawLongValue(), expected);\n+    static Consumer<MemorySegment> equalsPtrContents(long expected) {\n+        return actual -> assertEquals(actual.address(), expected);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/ConstantsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -115,2 +115,2 @@\n-            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n@@ -145,2 +145,2 @@\n-            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n@@ -172,2 +172,2 @@\n-            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n-            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+            \/\/ check a method for \"int printf(MemorySegment, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", MemorySegment.class, Object[].class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/JextractToolProviderTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -54,1 +54,1 @@\n-            assertNotNull(findMethod(cls, \"func3\", Addressable.class));\n+            assertNotNull(findMethod(cls, \"func3\", MemorySegment.class));\n@@ -57,1 +57,1 @@\n-            assertNotNull(findMethod(cls, \"func4\", Addressable.class));\n+            assertNotNull(findMethod(cls, \"func4\", MemorySegment.class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/RepeatedDeclsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -44,2 +44,2 @@\n-            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class);\n-            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+            checkMethod(nodeClass, \"next$get\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next$get\", MemorySegment.class, MemorySegment.class, long.class);\n@@ -48,2 +48,2 @@\n-            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemoryAddress.class);\n-            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemorySegment.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8248415.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -41,1 +41,1 @@\n-            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            checkMethod(headerClass, \"func\", void.class, MemorySegment.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249290.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -41,1 +41,1 @@\n-            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            checkMethod(headerClass, \"func\", void.class, MemorySegment.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8249300.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8251943.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260705.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -46,4 +46,4 @@\n-            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class);\n-            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class, long.class);\n-            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemoryAddress.class);\n-            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+            checkMethod(FooClass, \"ptr$get\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr$get\", MemorySegment.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemorySegment.class);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8260717.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            assertNotNull(loader.loadClass(\"MemoryAddress_\"));\n+            assertNotNull(loader.loadClass(\"MemorySegment_\"));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/Test8262825.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -33,0 +33,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -62,2 +63,2 @@\n-            { \"macro_address_NULL\", MemoryAddress.class, MemoryAddress.NULL        },\n-            { \"macro_address_123\",  MemoryAddress.class, MemoryAddress.ofLong(123) },\n+            { \"macro_address_NULL\", MemorySegment.class, MemorySegment.NULL        },\n+            { \"macro_address_123\",  MemorySegment.class, MemorySegment.ofAddress(123) },\n@@ -131,1 +132,5 @@\n-        assertEquals(getter.invoke(null), expectedValue);\n+        if (expectedType == MemorySegment.class) {\n+            assertEquals(((MemorySegment)getter.invoke(null)).address(), ((MemorySegment)expectedValue).address());\n+        } else {\n+            assertEquals(getter.invoke(null), expectedValue);\n+        }\n@@ -184,1 +189,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(structLayout, session);\n+            MemorySegment struct = session.allocate(structLayout);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestClassGeneration.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -33,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -159,1 +159,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(layout, session);\n+                    MemorySegment struct = session.allocate(layout);\n@@ -171,1 +171,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(layout, session);\n+                    MemorySegment struct = session.allocate(layout);\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/TestNested.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -45,1 +45,1 @@\n-            assertNotNull(findMethod(cls, \"func\", Addressable.class));\n+            assertNotNull(findMethod(cls, \"func\", MemorySegment.class));\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/toolprovider\/UniondeclTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}