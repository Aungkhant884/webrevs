{"files":[{"patch":"@@ -167,0 +167,4 @@\n+    private long align0() {\n+        return Index_h.clang_Type_getAlignOf(segment);\n+    }\n+\n@@ -175,0 +179,8 @@\n+    public long align() {\n+        long res = align0();\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"segment: %s\", this));\n+        }\n+        return res;\n+    }\n+\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/Type.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4993,0 +4993,16 @@\n+    public static MethodHandle clang_Type_getAlignOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getAlignOf$MH,\"clang_Type_getAlignOf\");\n+    }\n+    \/**\n+     * {@snippet :\n+     * long long clang_Type_getAlignOf(CXType T);\n+     * }\n+     *\/\n+    public static long clang_Type_getAlignOf(MemorySegment T) {\n+        var mh$ = clang_Type_getAlignOf$MH();\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/Index_h.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -87,0 +87,11 @@\n+    static final FunctionDescriptor clang_Type_getAlignOf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,\n+            MemoryLayout.structLayout(\n+                    Constants$root.C_INT$LAYOUT.withName(\"kind\"),\n+                    MemoryLayout.paddingLayout(4),\n+                    MemoryLayout.sequenceLayout(2, Constants$root.C_POINTER$LAYOUT).withName(\"data\")\n+            )\n+    );\n+    static final MethodHandle clang_Type_getAlignOf$MH = RuntimeHelper.downcallHandle(\n+            \"clang_Type_getAlignOf\",\n+            constants$12.clang_Type_getAlignOf$FUNC\n+    );\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/clang\/libclang\/constants$12.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -133,4 +134,0 @@\n-            if ((offset % (layout.byteAlignment() * 8) != 0)) {\n-                long maxAlign = Long.lowestOneBit(offset) \/ 8;\n-                layout = forceAlign(layout, maxAlign);\n-            }\n@@ -196,13 +193,39 @@\n-    MemoryLayout forceAlign(MemoryLayout layout, long maxAlign) {\n-        if (layout instanceof GroupLayout groupLayout) {\n-            MemoryLayout[] newMembers = groupLayout.memberLayouts()\n-                    .stream().map(l -> forceAlign(l, maxAlign)).toArray(MemoryLayout[]::new);\n-            return groupLayout instanceof StructLayout ?\n-                    MemoryLayout.structLayout(newMembers) :\n-                    MemoryLayout.unionLayout(newMembers);\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            return MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n-                    forceAlign(sequenceLayout.elementLayout(), maxAlign));\n-        } else {\n-            return layout.byteAlignment() > maxAlign ?\n-                    layout.withByteAlignment(maxAlign) : layout;\n+    void checkSize(GroupLayout layout) {\n+        \/\/ sanity check\n+        if (cursor.type().size() != layout.byteSize()) {\n+            throw new AssertionError(\n+                    String.format(\"Unexpected size for layout %s. Found %d ; expected %d\",\n+                            layout, layout.byteSize(), cursor.type().size()));\n+        }\n+    }\n+\n+    MemoryLayout[] alignFields() {\n+        long align = cursor.type().align();\n+        return fieldLayouts.stream()\n+                .map(l -> forceAlign(l, align))\n+                .toArray(MemoryLayout[]::new);\n+    }\n+\n+    private static MemoryLayout forceAlign(MemoryLayout layout, long align) {\n+        if (align >= layout.byteAlignment()) {\n+            return layout; \/\/ fast-path\n+        }\n+        MemoryLayout res = switch (layout) {\n+            case GroupLayout groupLayout -> {\n+                MemoryLayout[] newMembers = groupLayout.memberLayouts()\n+                        .stream().map(l -> forceAlign(l, align)).toArray(MemoryLayout[]::new);\n+                yield groupLayout instanceof StructLayout ?\n+                        MemoryLayout.structLayout(newMembers) :\n+                        MemoryLayout.unionLayout(newMembers);\n+            }\n+            case SequenceLayout sequenceLayout ->\n+                MemoryLayout.sequenceLayout(sequenceLayout.elementCount(),\n+                        forceAlign(sequenceLayout.elementLayout(), align));\n+            default -> layout.withByteAlignment(align);\n+        };\n+        \/\/ copy name and target layout, if present\n+        if (layout.name().isPresent()) {\n+            res = res.withName(layout.name().get());\n+        }\n+        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n+            ((AddressLayout)res).withTargetLayout(addressLayout.targetLayout().get());\n@@ -210,0 +233,1 @@\n+        return res;\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/RecordLayoutComputer.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -136,2 +136,2 @@\n-        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n-        GroupLayout g = MemoryLayout.structLayout(fields);\n+        GroupLayout g = MemoryLayout.structLayout(alignFields());\n+        checkSize(g);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/StructLayoutComputer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-        } catch (Throwable ex) {\n+        } catch (UnsupportedOperationException ex) {\n@@ -392,1 +392,1 @@\n-        } catch (Throwable ex) {\n+        } catch (UnsupportedOperationException ex) {\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/TypeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,2 +94,0 @@\n-        } else if (actualSize > expectedSize) {\n-            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n@@ -98,2 +96,2 @@\n-        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n-        GroupLayout g = MemoryLayout.unionLayout(fields);\n+        GroupLayout g = MemoryLayout.unionLayout(alignFields());\n+        checkSize(g);\n","filename":"src\/main\/java\/org\/openjdk\/jextract\/impl\/UnionLayoutComputer.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\"\n+            \"S1\", \"S2\", \"S3\", \"S4\", \"S5\", \"S6\", \"S7\", \"S8\"\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/TestPackedStructs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,12 @@\n+\n+#pragma pack(1)\n+struct S7 {\n+   long long first;\n+   int second;\n+};\n+\n+#pragma pack(1)\n+struct S8 {\n+   struct S7 first[1];\n+   struct S7 second[1];\n+};\n","filename":"test\/testng\/org\/openjdk\/jextract\/test\/api\/packedstructs.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}