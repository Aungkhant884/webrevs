{"files":[{"patch":"@@ -116,1 +116,2 @@\n-\n+            String testQuery = System.getProperty(\"test.query\");\n+            \/\/ if test.query is set, treat it as a method name to be executed\n@@ -118,1 +119,3 @@\n-                .selectors(DiscoverySelectors.selectClass(mainClass))\n+                .selectors(testQuery == null\n+                        ? DiscoverySelectors.selectClass(mainClass)\n+                        : DiscoverySelectors.selectMethod(mainClass, testQuery))\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/JUnitRunner.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -632,0 +632,1 @@\n+    private static final String TEST_QUERIES = \".testQueries\";\n@@ -725,0 +726,5 @@\n+            v = data.get(prefix + TEST_QUERIES);\n+            if (v != null) {\n+                setTestQueries(List.of(StringUtils.splitSeparator(\"\\n\", v)));\n+            }\n+\n@@ -804,0 +810,4 @@\n+\n+        if (testQueries != null) {\n+            data.put(prefix + TEST_QUERIES, join(testQueries, \"\\n\"));\n+        }\n@@ -1280,0 +1290,35 @@\n+    public void setTestQueries(List<String> testQueries) {\n+        this.testQueries = testQueries;\n+    }\n+\n+    public List<String> getTestQueries() {\n+        return testQueries;\n+    }\n+\n+    \/**\n+     * Returns the query component for a given test, if one was specified,\n+     * or null if there is no query component for this test.\n+     *\n+     * @param test the name of the test\n+     * @return the query component associated with this test, or null\n+     *\/\n+    public String getTestQuery(String test) {\n+        \/\/ There are two common cases:\n+        \/\/ 1. any number of tests are being run, none of which have queries, or\n+        \/\/ 2. a single test is being run, which has query.\n+        \/\/ As such, it is probably not worth parsing testQueries into a map.\n+        if (testQueries != null) {\n+            for (String tq : testQueries) {\n+                int sep = tq.indexOf(\"?\");\n+                if (test.equals(tq.substring(0, sep))) {\n+                    return tq.substring(sep + 1);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<String> testQueries;\n+\n+    \/\/---------------------------------------------------------------------\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/config\/RegressionParameters.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.List;\n@@ -42,0 +43,1 @@\n+import java.util.Objects;\n@@ -45,0 +47,3 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n@@ -46,1 +51,0 @@\n-import com.sun.javatest.TestFilter;\n@@ -79,0 +83,165 @@\n+    \/**\n+     * A GroupSpec embodies an argument of the form  [path]:name  where path is\n+     * a file path to the root of a test suite and name is the name of a group\n+     * of tests defined in the files given in the \"groups\" entry in TEST.ROOT.\n+     *\/\n+    public static class GroupSpec {\n+        \/** The test suite containing the group, or null for the default test suite. *\/\n+        final Path dir;\n+        \/** The name for the group. *\/\n+        final String groupName;\n+\n+        \/* A \"group\" argument is of the form  [path]:id  where the path is a file path\n+         * to the root of the test suite. On Windows, we have to be careful about\n+         * the ambiguity between an absolute path beginning with a drive letter\n+         * and a relative path that is a single letter. Therefore, on Windows,\n+         * we accept the following for a path:\n+         * - (empty)\n+         * - a single non-alphabetic character followed by :id\n+         * - two or more characters followed by :id\n+         * Thus, letter:id is not accepted as a group spec, and so will be treated\n+         * elsewhere as a plain absolute file path instead.\n+         *\/\n+        static final Pattern groupPtn = System.getProperty(\"os.name\").matches(\"(?i)windows.*\")\n+                ? Pattern.compile(\"(?<dir>|[^A-Za-z]|.{2,}):(?<group>[A-Za-z0-9_,]+)\")\n+                : Pattern.compile(\"(?<dir>.*):(?<group>[A-Za-z0-9_,]+)\");\n+\n+        \/**\n+         * Returns true if a string may represent a named group of tests.\n+         *\n+         * @param s the string\n+         * @return true if the string may represent a named group of tests, and false otherwise\n+         *\/\n+        public static boolean isGroupSpec(String s) {\n+            return groupPtn.matcher(s).matches();\n+        }\n+\n+        \/**\n+         * Returns an object indicating a named group of tests in a specific test suite.\n+         *\n+         * @param s a string identifying the named group of tests\n+         * @return an object indicating a named group of tests in a specific test suite\n+         *\/\n+        public static GroupSpec of(String s) {\n+            Matcher m = groupPtn.matcher(s);\n+            if (!m.matches()) {\n+                throw new IllegalArgumentException(s);\n+            }\n+\n+            String d = m.group(\"dir\");\n+            Path dir = d.isEmpty() ? null : Path.of(d);\n+            String groupName = m.group(\"group\");\n+            return new GroupSpec(dir, groupName);\n+        }\n+\n+        private GroupSpec(Path dir, String groupName) {\n+            this.dir = dir;\n+            this.groupName = Objects.requireNonNull(groupName);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            GroupSpec groupSpec = (GroupSpec) o;\n+            return Objects.equals(dir, groupSpec.dir) && groupName.equals(groupSpec.groupName);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(dir, groupName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return (dir == null ? \"\" : dir) + \":\" + groupName;\n+        }\n+    }\n+\n+    \/**\n+     * A TestSpec embodies an argument of the form path[#id][?query] where\n+     * path is the path for a file in a test suite, id may indicate the name\n+     * of a test within that file, and query may indicate the part of that\n+     * test to be executed.\n+     *\n+     * Note the pattern is similar to but intentionally different from that\n+     * of a URL, where the query component precedes the fragment component.\n+     * As given, path, id and query are hierarchically related.\n+     *\n+     * The path may be a directory to indicate all the tests in the files\n+     * in and under that directory.\n+     *\/\n+    public static class TestSpec {\n+        private final Path file;\n+        private final String id;\n+        private final String query;\n+\n+        \/**\n+         * Returns true if a string may represent one or more tests.\n+         *\n+         * @param s the string\n+         * @return true if the string may represent one or more tests, and false otherwise\n+         *\/\n+        public static boolean isTestSpec(String s) {\n+            return fileIdQueryPtn.matcher(s).matches();\n+        }\n+\n+        \/**\n+         * Returns an object indicating one or more tests.\n+         *\n+         * @param s a string identifying one or more tests\n+         * @return an object indicating one or more tests in a specific test suite\n+         *\/\n+        public static TestSpec of(String s) {\n+            Matcher m = fileIdQueryPtn.matcher(s);\n+            if (!m.matches()) {\n+                throw new IllegalArgumentException(s);\n+            }\n+\n+            Path file = Path.of(m.group(\"file\"));\n+            String id = m.group(\"id\"); \/\/ may be null\n+            String query = m.group(\"query\"); \/\/ may be null\n+            return new TestSpec(file, id, query);\n+        }\n+\n+        static Pattern fileIdQueryPtn = Pattern.compile(\"(?<file>.+?)(#(?<id>[A-Za-z0-9-_]+))?(\\\\?(?<query>.*))?\");\n+\n+        private TestSpec(Path file, String id, String query) {\n+            this.file = Objects.requireNonNull(file);\n+            this.id = id;\n+            this.query = query;\n+        }\n+\n+        \/**\n+         * Returns the path for a test, as required by JavaTest.\n+         * The form contains the file and id as a relative URL.\n+         * It does not include the query.\n+         *\n+         * @return the path for a test\n+         *\/\n+        String getTestPath() {\n+            return id == null ? pathToString(file) : pathToString(file) + \"#\" + id;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            TestSpec testSpec = (TestSpec) o;\n+            return file.equals(testSpec.file) && Objects.equals(id, testSpec.id) && Objects.equals(query, testSpec.query);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(file, id, query);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return file + (id == null ? \"\" : \"#\" + id) + (query == null ? \"\" : \"?\" + query);\n+        }\n+    }\n+\n+    \/**\n+     * An object to encapsulate the details for the tests to be run in a single test suite.\n+     *\/\n@@ -80,0 +249,3 @@\n+        \/**\n+         * The root directory for the test specs and group specs in this entry.\n+         *\/\n@@ -81,0 +253,5 @@\n+\n+        \/**\n+         * Whether all tests in the test suite are to be included.\n+         * When true, the test specs and group specs are ignored.\n+         *\/\n@@ -82,2 +259,0 @@\n-        Set<String> files = new LinkedHashSet<>();\n-        Set<String> groups = new LinkedHashSet<>();\n@@ -85,0 +260,14 @@\n+        \/**\n+         * The test specs for the tests to be run.\n+         * In these specs, the file is relative to the rootDir.\n+         *\/\n+        final Set<TestSpec> tests = new LinkedHashSet<>();\n+\n+        \/**\n+         * The names of the groups to be run.\n+         *\/\n+        final Set<String> groups = new LinkedHashSet<>();\n+\n+        \/**\n+         * The test suite containing the test specs and group specs for this entry.\n+         *\/\n@@ -86,0 +275,5 @@\n+\n+        \/**\n+         * The subdirectory to use for the work directory and report directory,\n+         * when tests are to be run from multiple test suites.\n+         *\/\n@@ -87,0 +281,4 @@\n+\n+        \/**\n+         * The work directory to use when running the tests in this entry.\n+         *\/\n@@ -88,0 +286,4 @@\n+\n+        \/**\n+         * The report directory to use when running the tests in this entry.\n+         *\/\n@@ -95,10 +297,0 @@\n-    public static class FileId {\n-        final Path file;\n-        final String id;\n-\n-        public FileId(Path file, String id) {\n-            this.file = file;\n-            this.id = id;\n-        }\n-    }\n-\n@@ -111,1 +303,1 @@\n-    public void addTestFiles(Collection<Path> testFiles) throws Fault {\n+    public void addTestSpecs(Collection<TestSpec> tests) throws Fault {\n@@ -113,4 +305,7 @@\n-        for (Path tf: testFiles) {\n-            addTest(rootDirCache, tf, null);\n-        }\n-    }\n+        for (TestSpec t : tests) {\n+            Path f = canon(t.file);\n+            if (!Files.exists(f))\n+                throw new Fault(i18n, \"tm.cantFindFile\", t.file);\n+            Path rootDir = getRootDir(rootDirCache, f);\n+            if (rootDir == null)\n+                throw new Fault(i18n, \"tm.cantDetermineTestSuite\", t.file);\n@@ -118,21 +313,7 @@\n-    public void addTestFileIds(Collection<FileId> testFiles) throws Fault {\n-        Map<Path, Path> rootDirCache = new HashMap<>();\n-        for (FileId tf: testFiles) {\n-            addTest(rootDirCache, tf.file, tf.id);\n-        }\n-    }\n-\n-    private void addTest(Map<Path, Path> rootDirCache, Path tf, String id) throws Fault {\n-        Path f = canon(tf.toFile()).toPath();\n-        if (!Files.exists(f))\n-            throw new Fault(i18n, \"tm.cantFindFile\", tf);\n-        Path rootDir = getRootDir(rootDirCache, f);\n-        if (rootDir == null)\n-            throw new Fault(i18n, \"tm.cantDetermineTestSuite\", tf);\n-\n-        Entry e = getEntry(rootDir);\n-        if (f.equals(rootDir)) {\n-            e.all = true;\n-            e.files.clear();\n-        } else if (!e.all) {\n-            e.files.add(getRelativePath(rootDir, f, id));\n+            Entry e = getEntry(rootDir);\n+            if (f.equals(rootDir)) {\n+                e.all = true;\n+                e.tests.clear();\n+            } else if (!e.all) {\n+                e.tests.add(new TestSpec(rootDir.relativize(f), t.id, t.query));\n+            }\n@@ -142,6 +323,3 @@\n-    public void addGroups(Collection<String> groups) throws Fault {\n-        for (String g: groups) {\n-            int sep = g.lastIndexOf(\":\");\n-            if (sep == -1)\n-                throw new Fault(i18n, \"tm.badGroupSpec\", g);\n-            Path rootDir = canon((sep == 0) ? baseDir : Path.of(g.substring(0, sep)));\n+    public void addGroupSpecs(Collection<GroupSpec> groups) throws Fault {\n+        for (GroupSpec g: groups) {\n+            Path rootDir = canon((g.dir == null) ? baseDir : g.dir);\n@@ -151,1 +329,1 @@\n-            e.groups.add(g.substring(sep + 1));\n+            e.groups.add(g.groupName);\n@@ -155,0 +333,5 @@\n+    \/**\n+     * Returns whether the test manager is empty or not.\n+     *\n+     * @return true if the test manager does not contain any tests specs or group specs.\n+     *\/\n@@ -159,0 +342,7 @@\n+    \/**\n+     * Returns whether the test manager contains test specs or group specs\n+     * from different test suites.\n+     *\n+     * @return true if the test manager contains test specs or group specs\n+     * from different test suites\n+     *\/\n@@ -163,0 +353,7 @@\n+    \/**\n+     * Returns the set of test suites that contain the test specs or group specs\n+     * that have been added.\n+     *\n+     * @return the test suites\n+     * @throws Fault if there is an error accessing any of the test suites\n+     *\/\n@@ -184,0 +381,8 @@\n+    \/**\n+     * Sets the path for the work directory to be used for this run.\n+     * When running tests in multiple test suites, separate work\n+     * directories for each test suite will be created as subdirectories\n+     * of this directory.\n+     *\n+     * @param wd the path for the work directory\n+     *\/\n@@ -192,0 +397,5 @@\n+    \/**\n+     * Returns the path for the work directory to be used for this run.\n+     *\n+     * @return the path for the work directory\n+     *\/\n@@ -198,0 +408,7 @@\n+    \/**\n+     * Returns the work directory to be used when running tests in a given test suite.\n+     *\n+     * @param ts the test suite\n+     * @return the work directory\n+     * @throws Fault if there is a problem accessing the work directory\n+     *\/\n@@ -222,0 +439,8 @@\n+    \/**\n+     * Sets the path for the report directory to be used for this run.\n+     * When running tests in multiple test suites, separate report\n+     * directories for each test suite will be created as subdirectories\n+     * of this directory.\n+     *\n+     * @param rd the path\n+     *\/\n@@ -230,0 +455,5 @@\n+    \/**\n+     * Returns the path for the report directory to be used for this run.\n+     *\n+     * @return the path\n+     *\/\n@@ -236,0 +466,7 @@\n+    \/**\n+     * Returns the report directory to be used when running tests in a given test suite.\n+     *\n+     * @param ts the test suite\n+     * @return the report directory\n+     * @throws Fault if there is a problem accessing the report directory\n+     *\/\n@@ -248,0 +485,8 @@\n+    \/**\n+     * Returns the name of the subdirectory to use when running tests from\n+     * multiple test suites.\n+     *\n+     * @param ts the test suite\n+     * @return the name of the subdirectory\n+     * @throws Fault if there is a problem accessing the test suite\n+     *\/\n@@ -260,0 +505,11 @@\n+    \/**\n+     * Returns the set of tests to be run in a given test suite.\n+     * The tests are identified in \"URL form\", containing the\n+     * path of the test relative to the test suite root, and\n+     * with an id if given. The query part of a test spec is\n+     * not included.\n+     *\n+     * @param ts the test suite\n+     * @return the list of tests\n+     * @throws Fault if there is a problem with the tests to be run\n+     *\/\n@@ -268,3 +524,4 @@\n-        for (String test: e.files) {\n-            if (validatePath(wd, test)) {\n-                tests.add(test);\n+        for (TestSpec test: e.tests) {\n+            String t = test.getTestPath();\n+            if (validatePath(wd, t)) {\n+                tests.add(t);\n@@ -276,1 +533,1 @@\n-            String test = getRelativePath(e.rootDir, f, null);\n+            String test = pathToString(e.rootDir.relativize(f));\n@@ -285,0 +542,38 @@\n+    \/**\n+     * Returns the list of tests to be run in a given test suite that\n+     * contain a non-null query in the test spec.\n+     * If there are multiple test specs for the same test path, then\n+     * the last one wins. This applies regardless of whether the test spec\n+     * contains a query or not.\n+     * The tests are identified in \"modified URL form\",  containing the\n+     * path of the test relative to the test suite root, an id if given,\n+     * and the query part of the test spec.\n+     *\n+     * @param ts the test suite\n+     * @return the list of tests\n+     * @throws Fault if there is a problem with the tests to be run\n+     *\/\n+    public List<String> getTestQueries(RegressionTestSuite ts) throws Fault {\n+        Entry e = map.get(ts.getRootDir().toPath());\n+        if (e == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (e.all) {\n+            return List.of();\n+        }\n+\n+        \/\/ Eliminate any duplicates for each test path with \"last one wins\"\n+        Map<String, TestSpec> map = new LinkedHashMap<>();\n+        for (TestSpec t : e.tests) {\n+            if (t.query != null && Files.isDirectory(e.rootDir.resolve(t.file))) {\n+                throw new Fault(i18n, \"tm.invalidQuery\", t);\n+            }\n+            map.put(t.getTestPath(), t);\n+        }\n+        \/\/ Return the remaining test specs that contain a query component\n+        return map.values().stream()\n+                .filter(t -> t.query != null)\n+                .map(t -> t.getTestPath() + \"?\" + t.query)\n+                .collect(Collectors.toList());\n+    }\n+\n@@ -293,1 +588,0 @@\n-    @SuppressWarnings(\"cast\") \/\/ temporary: to cover transition for generifying TreeIterator\n@@ -319,0 +613,8 @@\n+    \/**\n+     * Returns the names of the groups containing tests to be run in\n+     * the given test suite.\n+     *\n+     * @param ts the test suite\n+     * @return the names of the groups to be run\n+     * @throws Fault if there is a problem accessing the groups\n+     *\/\n@@ -447,10 +749,1 @@\n-    File canon(File file) {\n-        File f = file.isAbsolute() ? file : new File(baseDir.toFile(), file.getPath());\n-        try {\n-            return f.getCanonicalFile();\n-        } catch (IOException e) {\n-            return getNormalizedFile(f);\n-        }\n-    }\n-\n-    Path canon(Path file) {\n+    private Path canon(Path file) {\n@@ -465,5 +758,1 @@\n-    static File getNormalizedFile(File f) {\n-        return new File(f.getAbsoluteFile().toURI().normalize());\n-    }\n-\n-    static Path getNormalizedFile(Path f) {\n+    private static Path getNormalizedFile(Path f) {\n@@ -473,14 +762,2 @@\n-    static String getRelativePath(Path base, Path f, String id) {\n-        \/\/ maybe use base.relativize(f) ?\n-        StringBuilder sb = new StringBuilder();\n-        for ( ; f != null; f = f.getParent()) {\n-            if (f.equals(base)) {\n-                if (id != null)\n-                    sb.append(\"#\").append(id);\n-                return sb.toString();\n-            }\n-            if (sb.length() > 0)\n-                sb.insert(0, '\/');\n-            sb.insert(0, f.getFileName().toString());\n-        }\n-        return null;\n+    private static String pathToString(Path p) {\n+        return p.toString().replace(File.separatorChar, '\/');\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/config\/TestManager.java","additions":357,"deletions":80,"binary":false,"changes":437,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-tm.badGroupSpec=Bad group spec: {0}\n@@ -55,0 +54,1 @@\n+tm.invalidQuery=Invalid use of query component: {0}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/config\/i18n.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -738,0 +738,5 @@\n+    String getTestQuery() {\n+        String testName = testResult.getTestName();\n+        return params.getTestQuery(testName);\n+    }\n+\n@@ -1170,1 +1175,6 @@\n-        p.put(\"test.name\", testResult.getTestName());\n+        String testName = testResult.getTestName();\n+        p.put(\"test.name\", testName);\n+        String testQuery = params.getTestQuery(testName);\n+        if (testQuery != null) {\n+            p.put(\"test.query\", testQuery);\n+        }\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/RegressionScript.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -235,0 +235,4 @@\n+            String testQuery = script.getTestQuery();\n+            if (testQuery != null) {\n+                env.put(\"TESTQUERY\", testQuery);\n+            }\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/ShellAction.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import java.lang.reflect.Method;\n@@ -69,1 +68,0 @@\n-import java.util.regex.Pattern;\n@@ -117,1 +115,0 @@\n-import com.sun.javatest.regtest.tool.Help.VersionHelper;\n@@ -119,1 +116,0 @@\n-import com.sun.javatest.regtest.util.StringUtils;\n@@ -1005,8 +1001,5 @@\n-            public void process(String opt, String arg) {\n-                if (groupPtn.matcher(arg).matches()) {\n-                    testGroupArgs.add(arg);\n-                } else if (fileIdPtn.matcher(arg).matches()) {\n-                    int sep = arg.lastIndexOf(\"#\");\n-                    Path file = Path.of(arg.substring(0, sep));\n-                    String id = arg.substring(sep + 1);\n-                    testFileIdArgs.add(new TestManager.FileId(file, id));\n+            public void process(String opt, String arg) throws BadArgs {\n+                if (TestManager.GroupSpec.isGroupSpec(arg)) {\n+                    testGroupSpecArgs.add(TestManager.GroupSpec.of(arg));\n+                } else if (TestManager.TestSpec.isTestSpec(arg)) {\n+                    testSpecArgs.add(TestManager.TestSpec.of(arg));\n@@ -1014,1 +1007,1 @@\n-                    testFileArgs.add(Path.of(arg));\n+                    throw new BadArgs(i18n, \"main.badTestOrGroup\", arg);\n@@ -1017,17 +1010,0 @@\n-\n-            \/* A \"group\" argument is of the form  [path]:id  where the path is a file path\n-             * to the root of the test suite. On Windows, we have to be careful about\n-             * the ambiguity between an absolute path beginning with a drive letter\n-             * and a relative path that is a single letter. Therefore, on Windows,\n-             * we accept the following for a path:\n-             * - (empty)\n-             * - a single non-alphabetic character followed by :id\n-             * - two or more characters followed by :id\n-             * Thus, letter:id is not accepted as a group spec, and so will be treated\n-             * elsewhere as a plain absolute file path instead.\n-             *\/\n-            Pattern groupPtn = System.getProperty(\"os.name\").matches(\"(?i)windows.*\")\n-                    ? Pattern.compile(\"(|[^A-Za-z]|.{2,}):[A-Za-z0-9_,]+\")\n-                    : Pattern.compile(\".*:[A-Za-z0-9_,]+\");\n-\n-            Pattern fileIdPtn = Pattern.compile(\".*#[A-Za-z0-9-_]+\");\n@@ -1128,3 +1104,2 @@\n-        testManager.addTestFiles(testFileArgs);\n-        testManager.addTestFileIds(testFileIdArgs);\n-        testManager.addGroups(testGroupArgs);\n+        testManager.addTestSpecs(testSpecArgs);\n+        testManager.addGroupSpecs(testGroupSpecArgs);\n@@ -1400,1 +1375,1 @@\n-     * No filters (like keywords, status, etc) are taken into account.\n+     * No filters (like keywords, status, etc.) are taken into account.\n@@ -1665,0 +1640,2 @@\n+            \/\/ the tests are the tests to be executed by the harness, and do not\n+            \/\/ include the \"query\" component\n@@ -1667,0 +1644,7 @@\n+            \/\/ the tests that have an associated query component, included in\n+            \/\/ the string\n+            List<String> testQueries = testManager.getTestQueries(testSuite);\n+            if (!testQueries.isEmpty()) {\n+                rp.setTestQueries(testQueries);\n+            }\n+\n@@ -2137,1 +2121,1 @@\n-        \/\/ HttpdServer.isActive() and decide whether or not to\n+        \/\/ HttpdServer.isActive() and decide whether to\n@@ -2233,3 +2217,2 @@\n-     * Returns whether or not Windows Subsystem for Linux may be\n-     * available, by examining to see whether wsl.exe can be found on\n-     * the path.\n+     * Returns whether Windows Subsystem for Linux may be available,\n+     * by examining whether wsl.exe can be found on the path.\n@@ -2291,3 +2274,0 @@\n-    public List<String> testGroupArgs = new ArrayList<>();\n-    public List<Path> testFileArgs = new ArrayList<>();\n-    public List<TestManager.FileId> testFileIdArgs = new ArrayList<>();\n@@ -2296,0 +2276,2 @@\n+    public List<TestManager.GroupSpec> testGroupSpecArgs = new ArrayList<>();\n+    public List<TestManager.TestSpec> testSpecArgs = new ArrayList<>();\n@@ -2303,1 +2285,1 @@\n-    public enum ReportMode { NONE, EXECUTED, ALL_EXECUTED, ALL };\n+    public enum ReportMode { NONE, EXECUTED, ALL_EXECUTED, ALL }\n@@ -2357,2 +2339,0 @@\n-    private static final String JAVATEST_ANT_FILE_LIST = \"javatest.ant.file.list\";\n-\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/tool\/Tool.java","additions":24,"deletions":44,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-help.tests.summary.file.name=file[#id]\n+help.tests.summary.file.name=file[#id][?string]\n@@ -376,1 +376,6 @@\n-    multiple test descriptions, in separate comment blocks.\n+    multiple test descriptions, in separate comment blocks.\\n\\\n+    If '?string' is specified, the string will be passed to the test \\\n+    so that it may filter the parts of the test to be executed. \\\n+    The string will typically be the name of a method to be executed.\\n\\\n+    If conflicting values for the string are given for a specific test, \\\n+    the last one given will be used.\n@@ -444,0 +449,1 @@\n+main.badTestOrGroup=bad test or group specification: {0}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/tool\/i18n.properties","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -437,0 +437,1 @@\n+\n@@ -443,0 +444,7 @@\n+If you specify `?`_string_ after the name of a test, the _string_ will be\n+passed down to the test, for the test to filter the parts of the test to be\n+executed. For any tests executed by JUnit Platform, the string is interpreted\n+as the name of a single method in the test to be executed.  If you give\n+conflicting values for the string, including not setting any value, the last\n+one specified will be used.\n+\n@@ -453,2 +461,2 @@\n-| Argument                | Description                                         |\n-|-------------------------|-----------------------------------------------------|\n+| Argument                | Description                                        |\n+|-------------------------|----------------------------------------------------|\n@@ -456,3 +464,4 @@\n-| _file[#id]_             | All tests in a file, or a specific test in a file   |\n-| _[directory]_`:`_group_ | All tests in a group defined for a testsuite        |   \n-| `@`_file_               | Expand arguments in a file                          |\n+| _file[#id]_             | All tests in a file, or a specific test in a file  |\n+| _file[#id]?string_      | Parts of a test in a file                          |\n+| _[directory]_`:`_group_ | All tests in a group defined for a testsuite       |   \n+| `@`_file_               | Expand arguments in a file                         |\n@@ -485,0 +494,8 @@\n+### How do I run a single test method in a JUnit test?\n+\n+Specify the test and method name on the command-line with the `?` syntax:\n+\n+    path-to-test?method-name\n+\n+See [How do I specify which tests to run?](#how-do-i-specify-which-tests-to-run).\n+\n","filename":"src\/share\/doc\/javatest\/regtest\/faq.md","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1329,0 +1329,9 @@\n+<tr>\n+<td><code>test.query<\/code>\n+<td><code>TESTQUERY<\/code>\n+<td>Set to the string specified on the command-line for this test,\n+or not set if no value was specified. If set, a test may use\n+the value to filter the parts of the test to be executed.\n+For example, JUnit tests executed by the JUnit Platform, will interpret\n+the value as the name of a single method to be executed.\n+\n","filename":"src\/share\/doc\/javatest\/regtest\/tag-spec.html","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute all (6) test methods in the test suite\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.all.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/ \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m11 Test1.m12 Test1.m13 Test2.m21 Test2.m22 Test2.m23\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 6, .* started: 6, succeeded: 6\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.all.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute a single specific method (Test1.m12) using the query syntax  Test1.java?m12\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.m12.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m12 \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m12\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 3, .* started: 1, succeeded: 1\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.m12.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute a mixture of 4 tests:\n+# - a single specific method (Test1.m12) using the query syntax  Test1.java?m12\n+# - all (3) test methods in Test2.java\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.m12.Test2.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m12 \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test2.java \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m12 Test2.m21 Test2.m22 Test2.m23\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 6, .* started: 4, succeeded: 4\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.m12.Test2.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute tests when duplicates are given: last one wins (m13, m12)\n+# See related test for the reverse order\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.m13.m12.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m13 \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m12 \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m12\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 3, .* started: 1, succeeded: 1\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.m13.m12.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute tests when duplicates are given: last one wins (m12, m13)\n+# See related test for the reverse order\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.m12.m13.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m12 \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m13 \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m13\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 3, .* started: 1, succeeded: 1\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.m12.m13.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute tests when duplicates are given: last one wins (m13, all)\n+# See related test for the reverse order\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.m13.all.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m13 \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m11 Test1.m12 Test1.m13\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 3, .* started: 3, succeeded: 3\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.m13.all.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Execute tests when duplicates are given: last one wins (all, m13)\n+# See related test for the reverse order\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.all.m13.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m13 \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.m13\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ containers: 3, .* started: 1, succeeded: 1\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.all.m13.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Invalid use of query\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.invalidQuery.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c?m13 \\\n+\t\t\t> $(@:%.ok=%)\/jt.log 2>&1 || \\\n+\t\ttrue \"non-zero exit code from jtreg intentionally ignored\"\n+\t$(GREP) -s \"Error: Invalid use of query component: a\/b\/c?m13\" $(@:%.ok=%)\/jt.log\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.invalidQuery.ok\n+\n+\n+#----------------------------------------------------------------------\n+#\n+# Invalid method name\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.invalidMethod.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?m14 \\\n+\t\t\t> $(@:%.ok=%)\/jt.log 2>&1 || \\\n+\t\ttrue \"non-zero exit code from jtreg intentionally ignored\"\n+\t$(GREP) -s 'Could not find method with name \\[m14] in class \\[Test1]' $(@:%.ok=%)\/jt.log\n+\t$(GREP) -s \"TEST RESULT: Failed. Execution failed: .*JUnitException: .* failed to discover tests\" $(@:%.ok=%)\/jt.log\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.invalidMethod.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# Convenience target\n+\n+junit-query-tests: \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.all.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.m12.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.m12.Test2.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.m13.m12.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.m12.m13.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.m13.all.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.all.m13.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.invalidQuery.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.invalidMethod.ok\n\\ No newline at end of file\n","filename":"test\/junitQueryTest\/JUnitQueryTest.gmk","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"","filename":"test\/junitQueryTest\/TEST.ROOT","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/4499340\/test\/TEST.ROOT","status":"copied"},{"patch":"@@ -1,2 +0,0 @@\n-#!\/bin\/sh\n-\n@@ -4,1 +2,1 @@\n-# Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +24,1 @@\n-# @test\n-\n-env\n+JUnit.dirs = .\n\\ No newline at end of file\n","filename":"test\/junitQueryTest\/a\/b\/c\/TEST.properties","additions":2,"deletions":6,"binary":false,"changes":8,"previous_filename":"test\/6622433\/TestShell.sh","status":"copied"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/**\n+ * A collection of test methods, to help exercise the query mechanism.\n+ * Each method just prints its name.\n+ *\/\n+public class Test1 {\n+    @Test\n+    public void m11() {\n+        System.out.println(\"Test1.m11\");\n+    }\n+\n+    @Test\n+    public void m12() {\n+        System.out.println(\"Test1.m12\");\n+    }\n+\n+    @Test\n+    public void m13() {\n+        System.out.println(\"Test1.m13\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/junitQueryTest\/a\/b\/c\/Test1.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/**\n+ * A collection of test methods, to help exercise the query mechanism.\n+ * Each method just prints its name.\n+ *\/\n+public class Test2 {\n+    @Test\n+    public void m21() {\n+        System.out.println(\"Test2.m21\");\n+    }\n+\n+    @Test\n+    public void m22() {\n+        System.out.println(\"Test2.m22\");\n+    }\n+\n+    @Test\n+    public void m23() {\n+        System.out.println(\"Test2.m23\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/junitQueryTest\/a\/b\/c\/Test2.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}